61. In programming, as in everything else, to be in error is to be reborn.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
96. Computers don't introduce order anywhere as much as they expose opportunities.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
41. Some programming languages manage to absorb change, but withstand progress.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
38. Structured Programming supports the law of the excluded middle.
57. It is easier to change the specification to fit the program than vice versa.
40. There are two ways to write error-free programs; only the third one works.
119. Programming is an unnatural act.
38. Structured Programming supports the law of the excluded middle.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
22. A good system can't have a weak command language.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
102. One can't proceed from the informal to the formal by formal means.
40. There are two ways to write error-free programs; only the third one works.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
31. Simplicity does not precede complexity, but follows it.
11. If you have a procedure with ten parameters, you probably missed some.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
47. As Will Rogers would have said, "There is no such thing as a free variable."
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
103. Purely applicative languages are poorly applicable.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
76. It is the user who should parameterize procedures, not their creators.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
114. Within a computer natural language is unnatural.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
103. Purely applicative languages are poorly applicable.
76. It is the user who should parameterize procedures, not their creators.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
110. Editing is a rewording activity.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
79. A year spent in artificial intelligence is enough to make one believe in God.
102. One can't proceed from the informal to the formal by formal means.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
57. It is easier to change the specification to fit the program than vice versa.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
38. Structured Programming supports the law of the excluded middle.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
21. Optimization hinders evolution.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
41. Some programming languages manage to absorb change, but withstand progress.
110. Editing is a rewording activity.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
112. Computer Science is embarrassed by the computer.
108. Whenever two programmers meet to criticize their programs, both are silent.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
104. The proof of a system's value is its existence.
14. In the long run every program becomes rococo - then rubble.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
23. To understand a program you must become both the machine and the program.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
95. Don't have good ideas if you aren't willing to be responsible for them.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
22. A good system can't have a weak command language.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
38. Structured Programming supports the law of the excluded middle.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
40. There are two ways to write error-free programs; only the third one works.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
112. Computer Science is embarrassed by the computer.
112. Computer Science is embarrassed by the computer.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
63. When we write programs that "learn", it turns out that we do and they don't.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
38. Structured Programming supports the law of the excluded middle.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
1. One man's constant is another man's variable.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
104. The proof of a system's value is its existence.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
66. Making something variable is easy. Controlling duration of constancy is the trick.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
43. In software systems, it is often the early bird that makes the worm.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
107. The debate rages on: is PL/I Bachtrian or Dromedary?
96. Computers don't introduce order anywhere as much as they expose opportunities.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
15. Everything should be built top-down, except the first time.
38. Structured Programming supports the law of the excluded middle.
57. It is easier to change the specification to fit the program than vice versa.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
115. Most people find the concept of programming obvious, but the doing impossible.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
100. We will never run out of things to program as long as there is a single program around.
110. Editing is a rewording activity.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
3. Syntactic sugar causes cancer of the semicolon.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
41. Some programming languages manage to absorb change, but withstand progress.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
4. Every program is a part of some other program and rarely fits.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
103. Purely applicative languages are poorly applicable.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
18. A program without a loop and a structured variable isn't worth writing.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
79. A year spent in artificial intelligence is enough to make one believe in God.
7. It is easier to write an incorrect program than understand a correct one.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
78. If your computer speaks English, it was probably made in Japan.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
11. If you have a procedure with ten parameters, you probably missed some.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
115. Most people find the concept of programming obvious, but the doing impossible.
110. Editing is a rewording activity.
8. A programming language is low level when its programs require attention to the irrelevant.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
27. Once you understand how to write a program get someone else to write it.
27. Once you understand how to write a program get someone else to write it.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
40. There are two ways to write error-free programs; only the third one works.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
72. An adequate bootstrap is a contradiction in terms.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
98. In computing, the mean time to failure keeps getting shorter.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
63. When we write programs that "learn", it turns out that we do and they don't.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
4. Every program is a part of some other program and rarely fits.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
7. It is easier to write an incorrect program than understand a correct one.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
102. One can't proceed from the informal to the formal by formal means.
108. Whenever two programmers meet to criticize their programs, both are silent.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
12. Recursion is the root of computation since it trades description for time.
105. You can't communicate complexity, only an awareness of it.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
57. It is easier to change the specification to fit the program than vice versa.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
40. There are two ways to write error-free programs; only the third one works.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
100. We will never run out of things to program as long as there is a single program around.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
102. One can't proceed from the informal to the formal by formal means.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
40. There are two ways to write error-free programs; only the third one works.
79. A year spent in artificial intelligence is enough to make one believe in God.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
18. A program without a loop and a structured variable isn't worth writing.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
96. Computers don't introduce order anywhere as much as they expose opportunities.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
107. The debate rages on: is PL/I Bachtrian or Dromedary?
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
114. Within a computer natural language is unnatural.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
27. Once you understand how to write a program get someone else to write it.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
19. A language that doesn't affect the way you think about programming, is not worth knowing.
112. Computer Science is embarrassed by the computer.
110. Editing is a rewording activity.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
40. There are two ways to write error-free programs; only the third one works.
103. Purely applicative languages are poorly applicable.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
18. A program without a loop and a structured variable isn't worth writing.
110. Editing is a rewording activity.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
96. Computers don't introduce order anywhere as much as they expose opportunities.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
108. Whenever two programmers meet to criticize their programs, both are silent.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
46. Like punning, programming is a play on words.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
14. In the long run every program becomes rococo - then rubble.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
115. Most people find the concept of programming obvious, but the doing impossible.
15. Everything should be built top-down, except the first time.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
17. If a listener nods his head when you're explaining your program, wake him up.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
108. Whenever two programmers meet to criticize their programs, both are silent.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
100. We will never run out of things to program as long as there is a single program around.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
27. Once you understand how to write a program get someone else to write it.
66. Making something variable is easy. Controlling duration of constancy is the trick.
31. Simplicity does not precede complexity, but follows it.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
41. Some programming languages manage to absorb change, but withstand progress.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
62. In computing, invariants are ephemeral.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
96. Computers don't introduce order anywhere as much as they expose opportunities.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
38. Structured Programming supports the law of the excluded middle.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
23. To understand a program you must become both the machine and the program.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
11. If you have a procedure with ten parameters, you probably missed some.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
12. Recursion is the root of computation since it trades description for time.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
96. Computers don't introduce order anywhere as much as they expose opportunities.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
59. In English every word can be verbed. Would that it were so in our programming languages.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
27. Once you understand how to write a program get someone else to write it.
119. Programming is an unnatural act.
7. It is easier to write an incorrect program than understand a correct one.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
105. You can't communicate complexity, only an awareness of it.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
79. A year spent in artificial intelligence is enough to make one believe in God.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
7. It is easier to write an incorrect program than understand a correct one.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
11. If you have a procedure with ten parameters, you probably missed some.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
41. Some programming languages manage to absorb change, but withstand progress.
4. Every program is a part of some other program and rarely fits.
47. As Will Rogers would have said, "There is no such thing as a free variable."
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
103. Purely applicative languages are poorly applicable.
41. Some programming languages manage to absorb change, but withstand progress.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
62. In computing, invariants are ephemeral.
17. If a listener nods his head when you're explaining your program, wake him up.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
60. In seeking the unattainable, simplicity only gets in the way.
76. It is the user who should parameterize procedures, not their creators.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
76. It is the user who should parameterize procedures, not their creators.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
4. Every program is a part of some other program and rarely fits.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
21. Optimization hinders evolution.
14. In the long run every program becomes rococo - then rubble.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
79. A year spent in artificial intelligence is enough to make one believe in God.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
12. Recursion is the root of computation since it trades description for time.
31. Simplicity does not precede complexity, but follows it.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
115. Most people find the concept of programming obvious, but the doing impossible.
66. Making something variable is easy. Controlling duration of constancy is the trick.
4. Every program is a part of some other program and rarely fits.
63. When we write programs that "learn", it turns out that we do and they don't.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
12. Recursion is the root of computation since it trades description for time.
1. One man's constant is another man's variable.
90. Computation has made the tree flower.
17. If a listener nods his head when you're explaining your program, wake him up.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
63. When we write programs that "learn", it turns out that we do and they don't.
63. When we write programs that "learn", it turns out that we do and they don't.
63. When we write programs that "learn", it turns out that we do and they don't.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
23. To understand a program you must become both the machine and the program.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
41. Some programming languages manage to absorb change, but withstand progress.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
22. A good system can't have a weak command language.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
23. To understand a program you must become both the machine and the program.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
7. It is easier to write an incorrect program than understand a correct one.
98. In computing, the mean time to failure keeps getting shorter.
27. Once you understand how to write a program get someone else to write it.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
111. Why did the Roman Empire collapse? What is Latin for office automation?
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
11. If you have a procedure with ten parameters, you probably missed some.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
43. In software systems, it is often the early bird that makes the worm.
43. In software systems, it is often the early bird that makes the worm.
90. Computation has made the tree flower.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
22. A good system can't have a weak command language.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
95. Don't have good ideas if you aren't willing to be responsible for them.
111. Why did the Roman Empire collapse? What is Latin for office automation?
100. We will never run out of things to program as long as there is a single program around.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
12. Recursion is the root of computation since it trades description for time.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
59. In English every word can be verbed. Would that it were so in our programming languages.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
15. Everything should be built top-down, except the first time.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
108. Whenever two programmers meet to criticize their programs, both are silent.
1. One man's constant is another man's variable.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
96. Computers don't introduce order anywhere as much as they expose opportunities.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
59. In English every word can be verbed. Would that it were so in our programming languages.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
76. It is the user who should parameterize procedures, not their creators.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
47. As Will Rogers would have said, "There is no such thing as a free variable."
108. Whenever two programmers meet to criticize their programs, both are silent.
12. Recursion is the root of computation since it trades description for time.
115. Most people find the concept of programming obvious, but the doing impossible.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
66. Making something variable is easy. Controlling duration of constancy is the trick.
72. An adequate bootstrap is a contradiction in terms.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
1. One man's constant is another man's variable.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
61. In programming, as in everything else, to be in error is to be reborn.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
95. Don't have good ideas if you aren't willing to be responsible for them.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
7. It is easier to write an incorrect program than understand a correct one.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
11. If you have a procedure with ten parameters, you probably missed some.
43. In software systems, it is often the early bird that makes the worm.
8. A programming language is low level when its programs require attention to the irrelevant.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
55. A LISP programmer knows the value of everything, but the cost of nothing.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
100. We will never run out of things to program as long as there is a single program around.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
72. An adequate bootstrap is a contradiction in terms.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
111. Why did the Roman Empire collapse? What is Latin for office automation?
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
62. In computing, invariants are ephemeral.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
57. It is easier to change the specification to fit the program than vice versa.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
38. Structured Programming supports the law of the excluded middle.
72. An adequate bootstrap is a contradiction in terms.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
12. Recursion is the root of computation since it trades description for time.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
96. Computers don't introduce order anywhere as much as they expose opportunities.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
47. As Will Rogers would have said, "There is no such thing as a free variable."
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
21. Optimization hinders evolution.
119. Programming is an unnatural act.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
43. In software systems, it is often the early bird that makes the worm.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
72. An adequate bootstrap is a contradiction in terms.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
15. Everything should be built top-down, except the first time.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
41. Some programming languages manage to absorb change, but withstand progress.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
66. Making something variable is easy. Controlling duration of constancy is the trick.
72. An adequate bootstrap is a contradiction in terms.
38. Structured Programming supports the law of the excluded middle.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
14. In the long run every program becomes rococo - then rubble.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
47. As Will Rogers would have said, "There is no such thing as a free variable."
18. A program without a loop and a structured variable isn't worth writing.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
111. Why did the Roman Empire collapse? What is Latin for office automation?
100. We will never run out of things to program as long as there is a single program around.
17. If a listener nods his head when you're explaining your program, wake him up.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
41. Some programming languages manage to absorb change, but withstand progress.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
23. To understand a program you must become both the machine and the program.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
19. A language that doesn't affect the way you think about programming, is not worth knowing.
110. Editing is a rewording activity.
17. If a listener nods his head when you're explaining your program, wake him up.
17. If a listener nods his head when you're explaining your program, wake him up.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
12. Recursion is the root of computation since it trades description for time.
114. Within a computer natural language is unnatural.
3. Syntactic sugar causes cancer of the semicolon.
46. Like punning, programming is a play on words.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
103. Purely applicative languages are poorly applicable.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
59. In English every word can be verbed. Would that it were so in our programming languages.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
100. We will never run out of things to program as long as there is a single program around.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
110. Editing is a rewording activity.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
21. Optimization hinders evolution.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
110. Editing is a rewording activity.
7. It is easier to write an incorrect program than understand a correct one.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
115. Most people find the concept of programming obvious, but the doing impossible.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
115. Most people find the concept of programming obvious, but the doing impossible.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
3. Syntactic sugar causes cancer of the semicolon.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
90. Computation has made the tree flower.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
66. Making something variable is easy. Controlling duration of constancy is the trick.
60. In seeking the unattainable, simplicity only gets in the way.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
108. Whenever two programmers meet to criticize their programs, both are silent.
23. To understand a program you must become both the machine and the program.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
31. Simplicity does not precede complexity, but follows it.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
62. In computing, invariants are ephemeral.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
95. Don't have good ideas if you aren't willing to be responsible for them.
96. Computers don't introduce order anywhere as much as they expose opportunities.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
1. One man's constant is another man's variable.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
22. A good system can't have a weak command language.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
78. If your computer speaks English, it was probably made in Japan.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
111. Why did the Roman Empire collapse? What is Latin for office automation?
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
27. Once you understand how to write a program get someone else to write it.
3. Syntactic sugar causes cancer of the semicolon.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
40. There are two ways to write error-free programs; only the third one works.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
22. A good system can't have a weak command language.
110. Editing is a rewording activity.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
112. Computer Science is embarrassed by the computer.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
41. Some programming languages manage to absorb change, but withstand progress.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
112. Computer Science is embarrassed by the computer.
76. It is the user who should parameterize procedures, not their creators.
66. Making something variable is easy. Controlling duration of constancy is the trick.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
110. Editing is a rewording activity.
3. Syntactic sugar causes cancer of the semicolon.
4. Every program is a part of some other program and rarely fits.
60. In seeking the unattainable, simplicity only gets in the way.
76. It is the user who should parameterize procedures, not their creators.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
119. Programming is an unnatural act.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
31. Simplicity does not precede complexity, but follows it.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
114. Within a computer natural language is unnatural.
55. A LISP programmer knows the value of everything, but the cost of nothing.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
103. Purely applicative languages are poorly applicable.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
95. Don't have good ideas if you aren't willing to be responsible for them.
62. In computing, invariants are ephemeral.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
78. If your computer speaks English, it was probably made in Japan.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
38. Structured Programming supports the law of the excluded middle.
12. Recursion is the root of computation since it trades description for time.
119. Programming is an unnatural act.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
104. The proof of a system's value is its existence.
41. Some programming languages manage to absorb change, but withstand progress.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
60. In seeking the unattainable, simplicity only gets in the way.
38. Structured Programming supports the law of the excluded middle.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
22. A good system can't have a weak command language.
27. Once you understand how to write a program get someone else to write it.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
103. Purely applicative languages are poorly applicable.
1. One man's constant is another man's variable.
110. Editing is a rewording activity.
78. If your computer speaks English, it was probably made in Japan.
105. You can't communicate complexity, only an awareness of it.
103. Purely applicative languages are poorly applicable.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
55. A LISP programmer knows the value of everything, but the cost of nothing.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
31. Simplicity does not precede complexity, but follows it.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
23. To understand a program you must become both the machine and the program.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
1. One man's constant is another man's variable.
90. Computation has made the tree flower.
79. A year spent in artificial intelligence is enough to make one believe in God.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
57. It is easier to change the specification to fit the program than vice versa.
102. One can't proceed from the informal to the formal by formal means.
102. One can't proceed from the informal to the formal by formal means.
18. A program without a loop and a structured variable isn't worth writing.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
11. If you have a procedure with ten parameters, you probably missed some.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
90. Computation has made the tree flower.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
66. Making something variable is easy. Controlling duration of constancy is the trick.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
98. In computing, the mean time to failure keeps getting shorter.
57. It is easier to change the specification to fit the program than vice versa.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
40. There are two ways to write error-free programs; only the third one works.
95. Don't have good ideas if you aren't willing to be responsible for them.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
22. A good system can't have a weak command language.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
78. If your computer speaks English, it was probably made in Japan.
46. Like punning, programming is a play on words.
11. If you have a procedure with ten parameters, you probably missed some.
21. Optimization hinders evolution.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
119. Programming is an unnatural act.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
61. In programming, as in everything else, to be in error is to be reborn.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
12. Recursion is the root of computation since it trades description for time.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
62. In computing, invariants are ephemeral.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
115. Most people find the concept of programming obvious, but the doing impossible.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
100. We will never run out of things to program as long as there is a single program around.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
43. In software systems, it is often the early bird that makes the worm.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
11. If you have a procedure with ten parameters, you probably missed some.
4. Every program is a part of some other program and rarely fits.
55. A LISP programmer knows the value of everything, but the cost of nothing.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
78. If your computer speaks English, it was probably made in Japan.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
43. In software systems, it is often the early bird that makes the worm.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
78. If your computer speaks English, it was probably made in Japan.
22. A good system can't have a weak command language.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
47. As Will Rogers would have said, "There is no such thing as a free variable."
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
110. Editing is a rewording activity.
1. One man's constant is another man's variable.
102. One can't proceed from the informal to the formal by formal means.
40. There are two ways to write error-free programs; only the third one works.
40. There are two ways to write error-free programs; only the third one works.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
22. A good system can't have a weak command language.
21. Optimization hinders evolution.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
3. Syntactic sugar causes cancer of the semicolon.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
105. You can't communicate complexity, only an awareness of it.
41. Some programming languages manage to absorb change, but withstand progress.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
17. If a listener nods his head when you're explaining your program, wake him up.
12. Recursion is the root of computation since it trades description for time.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
23. To understand a program you must become both the machine and the program.
14. In the long run every program becomes rococo - then rubble.
1. One man's constant is another man's variable.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
43. In software systems, it is often the early bird that makes the worm.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
115. Most people find the concept of programming obvious, but the doing impossible.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
43. In software systems, it is often the early bird that makes the worm.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
12. Recursion is the root of computation since it trades description for time.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
7. It is easier to write an incorrect program than understand a correct one.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
22. A good system can't have a weak command language.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
12. Recursion is the root of computation since it trades description for time.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
43. In software systems, it is often the early bird that makes the worm.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
115. Most people find the concept of programming obvious, but the doing impossible.
4. Every program is a part of some other program and rarely fits.
78. If your computer speaks English, it was probably made in Japan.
105. You can't communicate complexity, only an awareness of it.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
1. One man's constant is another man's variable.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
112. Computer Science is embarrassed by the computer.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
27. Once you understand how to write a program get someone else to write it.
105. You can't communicate complexity, only an awareness of it.
59. In English every word can be verbed. Would that it were so in our programming languages.
22. A good system can't have a weak command language.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
110. Editing is a rewording activity.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
11. If you have a procedure with ten parameters, you probably missed some.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
76. It is the user who should parameterize procedures, not their creators.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
1. One man's constant is another man's variable.
3. Syntactic sugar causes cancer of the semicolon.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
96. Computers don't introduce order anywhere as much as they expose opportunities.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
43. In software systems, it is often the early bird that makes the worm.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
60. In seeking the unattainable, simplicity only gets in the way.
57. It is easier to change the specification to fit the program than vice versa.
79. A year spent in artificial intelligence is enough to make one believe in God.
76. It is the user who should parameterize procedures, not their creators.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
90. Computation has made the tree flower.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
63. When we write programs that "learn", it turns out that we do and they don't.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
96. Computers don't introduce order anywhere as much as they expose opportunities.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
115. Most people find the concept of programming obvious, but the doing impossible.
43. In software systems, it is often the early bird that makes the worm.
41. Some programming languages manage to absorb change, but withstand progress.
8. A programming language is low level when its programs require attention to the irrelevant.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
76. It is the user who should parameterize procedures, not their creators.
76. It is the user who should parameterize procedures, not their creators.
108. Whenever two programmers meet to criticize their programs, both are silent.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
12. Recursion is the root of computation since it trades description for time.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
27. Once you understand how to write a program get someone else to write it.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
104. The proof of a system's value is its existence.
102. One can't proceed from the informal to the formal by formal means.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
43. In software systems, it is often the early bird that makes the worm.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
43. In software systems, it is often the early bird that makes the worm.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
41. Some programming languages manage to absorb change, but withstand progress.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
78. If your computer speaks English, it was probably made in Japan.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
31. Simplicity does not precede complexity, but follows it.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
11. If you have a procedure with ten parameters, you probably missed some.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
61. In programming, as in everything else, to be in error is to be reborn.
112. Computer Science is embarrassed by the computer.
7. It is easier to write an incorrect program than understand a correct one.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
105. You can't communicate complexity, only an awareness of it.
47. As Will Rogers would have said, "There is no such thing as a free variable."
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
114. Within a computer natural language is unnatural.
76. It is the user who should parameterize procedures, not their creators.
17. If a listener nods his head when you're explaining your program, wake him up.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
40. There are two ways to write error-free programs; only the third one works.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
23. To understand a program you must become both the machine and the program.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
115. Most people find the concept of programming obvious, but the doing impossible.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
112. Computer Science is embarrassed by the computer.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
78. If your computer speaks English, it was probably made in Japan.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
41. Some programming languages manage to absorb change, but withstand progress.
21. Optimization hinders evolution.
102. One can't proceed from the informal to the formal by formal means.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
46. Like punning, programming is a play on words.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
11. If you have a procedure with ten parameters, you probably missed some.
79. A year spent in artificial intelligence is enough to make one believe in God.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
8. A programming language is low level when its programs require attention to the irrelevant.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
114. Within a computer natural language is unnatural.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
46. Like punning, programming is a play on words.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
105. You can't communicate complexity, only an awareness of it.
55. A LISP programmer knows the value of everything, but the cost of nothing.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
14. In the long run every program becomes rococo - then rubble.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
38. Structured Programming supports the law of the excluded middle.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
4. Every program is a part of some other program and rarely fits.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
115. Most people find the concept of programming obvious, but the doing impossible.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
17. If a listener nods his head when you're explaining your program, wake him up.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
17. If a listener nods his head when you're explaining your program, wake him up.
72. An adequate bootstrap is a contradiction in terms.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
17. If a listener nods his head when you're explaining your program, wake him up.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
104. The proof of a system's value is its existence.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
21. Optimization hinders evolution.
43. In software systems, it is often the early bird that makes the worm.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
63. When we write programs that "learn", it turns out that we do and they don't.
11. If you have a procedure with ten parameters, you probably missed some.
59. In English every word can be verbed. Would that it were so in our programming languages.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
102. One can't proceed from the informal to the formal by formal means.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
98. In computing, the mean time to failure keeps getting shorter.
76. It is the user who should parameterize procedures, not their creators.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
76. It is the user who should parameterize procedures, not their creators.
23. To understand a program you must become both the machine and the program.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
108. Whenever two programmers meet to criticize their programs, both are silent.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
57. It is easier to change the specification to fit the program than vice versa.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
38. Structured Programming supports the law of the excluded middle.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
114. Within a computer natural language is unnatural.
103. Purely applicative languages are poorly applicable.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
61. In programming, as in everything else, to be in error is to be reborn.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
62. In computing, invariants are ephemeral.
41. Some programming languages manage to absorb change, but withstand progress.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
11. If you have a procedure with ten parameters, you probably missed some.
104. The proof of a system's value is its existence.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
11. If you have a procedure with ten parameters, you probably missed some.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
63. When we write programs that "learn", it turns out that we do and they don't.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
72. An adequate bootstrap is a contradiction in terms.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
72. An adequate bootstrap is a contradiction in terms.
47. As Will Rogers would have said, "There is no such thing as a free variable."
66. Making something variable is easy. Controlling duration of constancy is the trick.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
27. Once you understand how to write a program get someone else to write it.
47. As Will Rogers would have said, "There is no such thing as a free variable."
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
61. In programming, as in everything else, to be in error is to be reborn.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
15. Everything should be built top-down, except the first time.
60. In seeking the unattainable, simplicity only gets in the way.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
103. Purely applicative languages are poorly applicable.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
31. Simplicity does not precede complexity, but follows it.
18. A program without a loop and a structured variable isn't worth writing.
95. Don't have good ideas if you aren't willing to be responsible for them.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
5. If a program manipulates a large amount of data, it does so in a small number of ways.
103. Purely applicative languages are poorly applicable.
1. One man's constant is another man's variable.
62. In computing, invariants are ephemeral.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
23. To understand a program you must become both the machine and the program.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
12. Recursion is the root of computation since it trades description for time.
96. Computers don't introduce order anywhere as much as they expose opportunities.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
7. It is easier to write an incorrect program than understand a correct one.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
102. One can't proceed from the informal to the formal by formal means.
72. An adequate bootstrap is a contradiction in terms.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
72. An adequate bootstrap is a contradiction in terms.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
79. A year spent in artificial intelligence is enough to make one believe in God.
46. Like punning, programming is a play on words.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
119. Programming is an unnatural act.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
3. Syntactic sugar causes cancer of the semicolon.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
102. One can't proceed from the informal to the formal by formal means.
111. Why did the Roman Empire collapse? What is Latin for office automation?
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
46. Like punning, programming is a play on words.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
78. If your computer speaks English, it was probably made in Japan.
55. A LISP programmer knows the value of everything, but the cost of nothing.
66. Making something variable is easy. Controlling duration of constancy is the trick.
72. An adequate bootstrap is a contradiction in terms.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
27. Once you understand how to write a program get someone else to write it.
47. As Will Rogers would have said, "There is no such thing as a free variable."
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
38. Structured Programming supports the law of the excluded middle.
55. A LISP programmer knows the value of everything, but the cost of nothing.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
95. Don't have good ideas if you aren't willing to be responsible for them.
22. A good system can't have a weak command language.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
79. A year spent in artificial intelligence is enough to make one believe in God.
17. If a listener nods his head when you're explaining your program, wake him up.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
59. In English every word can be verbed. Would that it were so in our programming languages.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
61. In programming, as in everything else, to be in error is to be reborn.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
79. A year spent in artificial intelligence is enough to make one believe in God.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
47. As Will Rogers would have said, "There is no such thing as a free variable."
59. In English every word can be verbed. Would that it were so in our programming languages.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
21. Optimization hinders evolution.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
102. One can't proceed from the informal to the formal by formal means.
1. One man's constant is another man's variable.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
61. In programming, as in everything else, to be in error is to be reborn.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
96. Computers don't introduce order anywhere as much as they expose opportunities.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
61. In programming, as in everything else, to be in error is to be reborn.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
31. Simplicity does not precede complexity, but follows it.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
102. One can't proceed from the informal to the formal by formal means.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
63. When we write programs that "learn", it turns out that we do and they don't.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
110. Editing is a rewording activity.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
108. Whenever two programmers meet to criticize their programs, both are silent.
27. Once you understand how to write a program get someone else to write it.
3. Syntactic sugar causes cancer of the semicolon.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
78. If your computer speaks English, it was probably made in Japan.
61. In programming, as in everything else, to be in error is to be reborn.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
95. Don't have good ideas if you aren't willing to be responsible for them.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
11. If you have a procedure with ten parameters, you probably missed some.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
95. Don't have good ideas if you aren't willing to be responsible for them.
31. Simplicity does not precede complexity, but follows it.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
57. It is easier to change the specification to fit the program than vice versa.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
47. As Will Rogers would have said, "There is no such thing as a free variable."
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
108. Whenever two programmers meet to criticize their programs, both are silent.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
105. You can't communicate complexity, only an awareness of it.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
46. Like punning, programming is a play on words.
12. Recursion is the root of computation since it trades description for time.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
108. Whenever two programmers meet to criticize their programs, both are silent.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
40. There are two ways to write error-free programs; only the third one works.
57. It is easier to change the specification to fit the program than vice versa.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
119. Programming is an unnatural act.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
23. To understand a program you must become both the machine and the program.
100. We will never run out of things to program as long as there is a single program around.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
23. To understand a program you must become both the machine and the program.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
47. As Will Rogers would have said, "There is no such thing as a free variable."
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
111. Why did the Roman Empire collapse? What is Latin for office automation?
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
72. An adequate bootstrap is a contradiction in terms.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
15. Everything should be built top-down, except the first time.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
72. An adequate bootstrap is a contradiction in terms.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
103. Purely applicative languages are poorly applicable.
57. It is easier to change the specification to fit the program than vice versa.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
112. Computer Science is embarrassed by the computer.
27. Once you understand how to write a program get someone else to write it.
55. A LISP programmer knows the value of everything, but the cost of nothing.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
55. A LISP programmer knows the value of everything, but the cost of nothing.
12. Recursion is the root of computation since it trades description for time.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
61. In programming, as in everything else, to be in error is to be reborn.
103. Purely applicative languages are poorly applicable.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
12. Recursion is the root of computation since it trades description for time.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
43. In software systems, it is often the early bird that makes the worm.
12. Recursion is the root of computation since it trades description for time.
21. Optimization hinders evolution.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
40. There are two ways to write error-free programs; only the third one works.
78. If your computer speaks English, it was probably made in Japan.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
104. The proof of a system's value is its existence.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
14. In the long run every program becomes rococo - then rubble.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
46. Like punning, programming is a play on words.
11. If you have a procedure with ten parameters, you probably missed some.
90. Computation has made the tree flower.
115. Most people find the concept of programming obvious, but the doing impossible.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
104. The proof of a system's value is its existence.
31. Simplicity does not precede complexity, but follows it.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
12. Recursion is the root of computation since it trades description for time.
119. Programming is an unnatural act.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
23. To understand a program you must become both the machine and the program.
102. One can't proceed from the informal to the formal by formal means.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
46. Like punning, programming is a play on words.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
78. If your computer speaks English, it was probably made in Japan.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
110. Editing is a rewording activity.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
12. Recursion is the root of computation since it trades description for time.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
7. It is easier to write an incorrect program than understand a correct one.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
115. Most people find the concept of programming obvious, but the doing impossible.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
31. Simplicity does not precede complexity, but follows it.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
57. It is easier to change the specification to fit the program than vice versa.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
18. A program without a loop and a structured variable isn't worth writing.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
23. To understand a program you must become both the machine and the program.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
31. Simplicity does not precede complexity, but follows it.
41. Some programming languages manage to absorb change, but withstand progress.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
4. Every program is a part of some other program and rarely fits.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
15. Everything should be built top-down, except the first time.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
12. Recursion is the root of computation since it trades description for time.
61. In programming, as in everything else, to be in error is to be reborn.
100. We will never run out of things to program as long as there is a single program around.
47. As Will Rogers would have said, "There is no such thing as a free variable."
108. Whenever two programmers meet to criticize their programs, both are silent.
98. In computing, the mean time to failure keeps getting shorter.
79. A year spent in artificial intelligence is enough to make one believe in God.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
57. It is easier to change the specification to fit the program than vice versa.
4. Every program is a part of some other program and rarely fits.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
3. Syntactic sugar causes cancer of the semicolon.
38. Structured Programming supports the law of the excluded middle.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
22. A good system can't have a weak command language.
115. Most people find the concept of programming obvious, but the doing impossible.
63. When we write programs that "learn", it turns out that we do and they don't.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
41. Some programming languages manage to absorb change, but withstand progress.
1. One man's constant is another man's variable.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
31. Simplicity does not precede complexity, but follows it.
62. In computing, invariants are ephemeral.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
103. Purely applicative languages are poorly applicable.
110. Editing is a rewording activity.
22. A good system can't have a weak command language.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
23. To understand a program you must become both the machine and the program.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
15. Everything should be built top-down, except the first time.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
90. Computation has made the tree flower.
1. One man's constant is another man's variable.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
55. A LISP programmer knows the value of everything, but the cost of nothing.
57. It is easier to change the specification to fit the program than vice versa.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
11. If you have a procedure with ten parameters, you probably missed some.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
61. In programming, as in everything else, to be in error is to be reborn.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
90. Computation has made the tree flower.
115. Most people find the concept of programming obvious, but the doing impossible.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
110. Editing is a rewording activity.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
95. Don't have good ideas if you aren't willing to be responsible for them.
55. A LISP programmer knows the value of everything, but the cost of nothing.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
31. Simplicity does not precede complexity, but follows it.
72. An adequate bootstrap is a contradiction in terms.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
103. Purely applicative languages are poorly applicable.
114. Within a computer natural language is unnatural.
7. It is easier to write an incorrect program than understand a correct one.
61. In programming, as in everything else, to be in error is to be reborn.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
38. Structured Programming supports the law of the excluded middle.
105. You can't communicate complexity, only an awareness of it.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
21. Optimization hinders evolution.
23. To understand a program you must become both the machine and the program.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
102. One can't proceed from the informal to the formal by formal means.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
27. Once you understand how to write a program get someone else to write it.
23. To understand a program you must become both the machine and the program.
119. Programming is an unnatural act.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
23. To understand a program you must become both the machine and the program.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
78. If your computer speaks English, it was probably made in Japan.
115. Most people find the concept of programming obvious, but the doing impossible.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
115. Most people find the concept of programming obvious, but the doing impossible.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
27. Once you understand how to write a program get someone else to write it.
98. In computing, the mean time to failure keeps getting shorter.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
1. One man's constant is another man's variable.
4. Every program is a part of some other program and rarely fits.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
21. Optimization hinders evolution.
95. Don't have good ideas if you aren't willing to be responsible for them.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
1. One man's constant is another man's variable.
14. In the long run every program becomes rococo - then rubble.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
1. One man's constant is another man's variable.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
115. Most people find the concept of programming obvious, but the doing impossible.
90. Computation has made the tree flower.
111. Why did the Roman Empire collapse? What is Latin for office automation?
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
22. A good system can't have a weak command language.
76. It is the user who should parameterize procedures, not their creators.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
112. Computer Science is embarrassed by the computer.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
60. In seeking the unattainable, simplicity only gets in the way.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
3. Syntactic sugar causes cancer of the semicolon.
21. Optimization hinders evolution.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
103. Purely applicative languages are poorly applicable.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
59. In English every word can be verbed. Would that it were so in our programming languages.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
46. Like punning, programming is a play on words.
110. Editing is a rewording activity.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
47. As Will Rogers would have said, "There is no such thing as a free variable."
17. If a listener nods his head when you're explaining your program, wake him up.
59. In English every word can be verbed. Would that it were so in our programming languages.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
38. Structured Programming supports the law of the excluded middle.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
90. Computation has made the tree flower.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
78. If your computer speaks English, it was probably made in Japan.
38. Structured Programming supports the law of the excluded middle.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
76. It is the user who should parameterize procedures, not their creators.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
57. It is easier to change the specification to fit the program than vice versa.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
18. A program without a loop and a structured variable isn't worth writing.
114. Within a computer natural language is unnatural.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
110. Editing is a rewording activity.
112. Computer Science is embarrassed by the computer.
40. There are two ways to write error-free programs; only the third one works.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
15. Everything should be built top-down, except the first time.
114. Within a computer natural language is unnatural.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
3. Syntactic sugar causes cancer of the semicolon.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
18. A program without a loop and a structured variable isn't worth writing.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
41. Some programming languages manage to absorb change, but withstand progress.
104. The proof of a system's value is its existence.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
59. In English every word can be verbed. Would that it were so in our programming languages.
103. Purely applicative languages are poorly applicable.
90. Computation has made the tree flower.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
55. A LISP programmer knows the value of everything, but the cost of nothing.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
110. Editing is a rewording activity.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
103. Purely applicative languages are poorly applicable.
12. Recursion is the root of computation since it trades description for time.
23. To understand a program you must become both the machine and the program.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
115. Most people find the concept of programming obvious, but the doing impossible.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
38. Structured Programming supports the law of the excluded middle.
31. Simplicity does not precede complexity, but follows it.
115. Most people find the concept of programming obvious, but the doing impossible.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
95. Don't have good ideas if you aren't willing to be responsible for them.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
104. The proof of a system's value is its existence.
11. If you have a procedure with ten parameters, you probably missed some.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
112. Computer Science is embarrassed by the computer.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
17. If a listener nods his head when you're explaining your program, wake him up.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
17. If a listener nods his head when you're explaining your program, wake him up.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
102. One can't proceed from the informal to the formal by formal means.
115. Most people find the concept of programming obvious, but the doing impossible.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
62. In computing, invariants are ephemeral.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
98. In computing, the mean time to failure keeps getting shorter.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
61. In programming, as in everything else, to be in error is to be reborn.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
46. Like punning, programming is a play on words.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
12. Recursion is the root of computation since it trades description for time.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
23. To understand a program you must become both the machine and the program.
12. Recursion is the root of computation since it trades description for time.
57. It is easier to change the specification to fit the program than vice versa.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
95. Don't have good ideas if you aren't willing to be responsible for them.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
112. Computer Science is embarrassed by the computer.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
14. In the long run every program becomes rococo - then rubble.
40. There are two ways to write error-free programs; only the third one works.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
8. A programming language is low level when its programs require attention to the irrelevant.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
18. A program without a loop and a structured variable isn't worth writing.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
18. A program without a loop and a structured variable isn't worth writing.
95. Don't have good ideas if you aren't willing to be responsible for them.
27. Once you understand how to write a program get someone else to write it.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
3. Syntactic sugar causes cancer of the semicolon.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
31. Simplicity does not precede complexity, but follows it.
100. We will never run out of things to program as long as there is a single program around.
111. Why did the Roman Empire collapse? What is Latin for office automation?
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
31. Simplicity does not precede complexity, but follows it.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
78. If your computer speaks English, it was probably made in Japan.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
115. Most people find the concept of programming obvious, but the doing impossible.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
62. In computing, invariants are ephemeral.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
104. The proof of a system's value is its existence.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
22. A good system can't have a weak command language.
98. In computing, the mean time to failure keeps getting shorter.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
17. If a listener nods his head when you're explaining your program, wake him up.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
43. In software systems, it is often the early bird that makes the worm.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
4. Every program is a part of some other program and rarely fits.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
95. Don't have good ideas if you aren't willing to be responsible for them.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
7. It is easier to write an incorrect program than understand a correct one.
105. You can't communicate complexity, only an awareness of it.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
4. Every program is a part of some other program and rarely fits.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
119. Programming is an unnatural act.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
17. If a listener nods his head when you're explaining your program, wake him up.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
21. Optimization hinders evolution.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
14. In the long run every program becomes rococo - then rubble.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
11. If you have a procedure with ten parameters, you probably missed some.
27. Once you understand how to write a program get someone else to write it.
38. Structured Programming supports the law of the excluded middle.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
17. If a listener nods his head when you're explaining your program, wake him up.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
17. If a listener nods his head when you're explaining your program, wake him up.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
98. In computing, the mean time to failure keeps getting shorter.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
8. A programming language is low level when its programs require attention to the irrelevant.
60. In seeking the unattainable, simplicity only gets in the way.
21. Optimization hinders evolution.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
90. Computation has made the tree flower.
21. Optimization hinders evolution.
95. Don't have good ideas if you aren't willing to be responsible for them.
12. Recursion is the root of computation since it trades description for time.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
23. To understand a program you must become both the machine and the program.
90. Computation has made the tree flower.
110. Editing is a rewording activity.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
17. If a listener nods his head when you're explaining your program, wake him up.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
11. If you have a procedure with ten parameters, you probably missed some.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
55. A LISP programmer knows the value of everything, but the cost of nothing.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
103. Purely applicative languages are poorly applicable.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
14. In the long run every program becomes rococo - then rubble.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
95. Don't have good ideas if you aren't willing to be responsible for them.
21. Optimization hinders evolution.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
103. Purely applicative languages are poorly applicable.
63. When we write programs that "learn", it turns out that we do and they don't.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
96. Computers don't introduce order anywhere as much as they expose opportunities.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
43. In software systems, it is often the early bird that makes the worm.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
22. A good system can't have a weak command language.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
112. Computer Science is embarrassed by the computer.
1. One man's constant is another man's variable.
3. Syntactic sugar causes cancer of the semicolon.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
22. A good system can't have a weak command language.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
1. One man's constant is another man's variable.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
66. Making something variable is easy. Controlling duration of constancy is the trick.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
102. One can't proceed from the informal to the formal by formal means.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
18. A program without a loop and a structured variable isn't worth writing.
62. In computing, invariants are ephemeral.
111. Why did the Roman Empire collapse? What is Latin for office automation?
66. Making something variable is easy. Controlling duration of constancy is the trick.
105. You can't communicate complexity, only an awareness of it.
66. Making something variable is easy. Controlling duration of constancy is the trick.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
95. Don't have good ideas if you aren't willing to be responsible for them.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
41. Some programming languages manage to absorb change, but withstand progress.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
66. Making something variable is easy. Controlling duration of constancy is the trick.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
46. Like punning, programming is a play on words.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
8. A programming language is low level when its programs require attention to the irrelevant.
31. Simplicity does not precede complexity, but follows it.
63. When we write programs that "learn", it turns out that we do and they don't.
78. If your computer speaks English, it was probably made in Japan.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
57. It is easier to change the specification to fit the program than vice versa.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
102. One can't proceed from the informal to the formal by formal means.
100. We will never run out of things to program as long as there is a single program around.
98. In computing, the mean time to failure keeps getting shorter.
57. It is easier to change the specification to fit the program than vice versa.
14. In the long run every program becomes rococo - then rubble.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
105. You can't communicate complexity, only an awareness of it.
78. If your computer speaks English, it was probably made in Japan.
4. Every program is a part of some other program and rarely fits.
79. A year spent in artificial intelligence is enough to make one believe in God.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
22. A good system can't have a weak command language.
59. In English every word can be verbed. Would that it were so in our programming languages.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
72. An adequate bootstrap is a contradiction in terms.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
79. A year spent in artificial intelligence is enough to make one believe in God.
66. Making something variable is easy. Controlling duration of constancy is the trick.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
1. One man's constant is another man's variable.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
78. If your computer speaks English, it was probably made in Japan.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
57. It is easier to change the specification to fit the program than vice versa.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
38. Structured Programming supports the law of the excluded middle.
4. Every program is a part of some other program and rarely fits.
76. It is the user who should parameterize procedures, not their creators.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
112. Computer Science is embarrassed by the computer.
31. Simplicity does not precede complexity, but follows it.
79. A year spent in artificial intelligence is enough to make one believe in God.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
63. When we write programs that "learn", it turns out that we do and they don't.
61. In programming, as in everything else, to be in error is to be reborn.
78. If your computer speaks English, it was probably made in Japan.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
119. Programming is an unnatural act.
111. Why did the Roman Empire collapse? What is Latin for office automation?
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
105. You can't communicate complexity, only an awareness of it.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
14. In the long run every program becomes rococo - then rubble.
90. Computation has made the tree flower.
95. Don't have good ideas if you aren't willing to be responsible for them.
103. Purely applicative languages are poorly applicable.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
40. There are two ways to write error-free programs; only the third one works.
1. One man's constant is another man's variable.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
12. Recursion is the root of computation since it trades description for time.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
105. You can't communicate complexity, only an awareness of it.
17. If a listener nods his head when you're explaining your program, wake him up.
95. Don't have good ideas if you aren't willing to be responsible for them.
79. A year spent in artificial intelligence is enough to make one believe in God.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
100. We will never run out of things to program as long as there is a single program around.
105. You can't communicate complexity, only an awareness of it.
15. Everything should be built top-down, except the first time.
115. Most people find the concept of programming obvious, but the doing impossible.
95. Don't have good ideas if you aren't willing to be responsible for them.
98. In computing, the mean time to failure keeps getting shorter.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
18. A program without a loop and a structured variable isn't worth writing.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
21. Optimization hinders evolution.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
110. Editing is a rewording activity.
76. It is the user who should parameterize procedures, not their creators.
46. Like punning, programming is a play on words.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
14. In the long run every program becomes rococo - then rubble.
12. Recursion is the root of computation since it trades description for time.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
40. There are two ways to write error-free programs; only the third one works.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
72. An adequate bootstrap is a contradiction in terms.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
11. If you have a procedure with ten parameters, you probably missed some.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
100. We will never run out of things to program as long as there is a single program around.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
22. A good system can't have a weak command language.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
66. Making something variable is easy. Controlling duration of constancy is the trick.
17. If a listener nods his head when you're explaining your program, wake him up.
3. Syntactic sugar causes cancer of the semicolon.
76. It is the user who should parameterize procedures, not their creators.
72. An adequate bootstrap is a contradiction in terms.
66. Making something variable is easy. Controlling duration of constancy is the trick.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
63. When we write programs that "learn", it turns out that we do and they don't.
111. Why did the Roman Empire collapse? What is Latin for office automation?
104. The proof of a system's value is its existence.
38. Structured Programming supports the law of the excluded middle.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
111. Why did the Roman Empire collapse? What is Latin for office automation?
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
1. One man's constant is another man's variable.
46. Like punning, programming is a play on words.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
27. Once you understand how to write a program get someone else to write it.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
18. A program without a loop and a structured variable isn't worth writing.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
46. Like punning, programming is a play on words.
1. One man's constant is another man's variable.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
115. Most people find the concept of programming obvious, but the doing impossible.
95. Don't have good ideas if you aren't willing to be responsible for them.
98. In computing, the mean time to failure keeps getting shorter.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
95. Don't have good ideas if you aren't willing to be responsible for them.
100. We will never run out of things to program as long as there is a single program around.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
78. If your computer speaks English, it was probably made in Japan.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
43. In software systems, it is often the early bird that makes the worm.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
95. Don't have good ideas if you aren't willing to be responsible for them.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
27. Once you understand how to write a program get someone else to write it.
22. A good system can't have a weak command language.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
60. In seeking the unattainable, simplicity only gets in the way.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
90. Computation has made the tree flower.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
18. A program without a loop and a structured variable isn't worth writing.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
14. In the long run every program becomes rococo - then rubble.
95. Don't have good ideas if you aren't willing to be responsible for them.
105. You can't communicate complexity, only an awareness of it.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
22. A good system can't have a weak command language.
100. We will never run out of things to program as long as there is a single program around.
60. In seeking the unattainable, simplicity only gets in the way.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
5. If a program manipulates a large amount of data, it does so in a small number of ways.
119. Programming is an unnatural act.
110. Editing is a rewording activity.
27. Once you understand how to write a program get someone else to write it.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
38. Structured Programming supports the law of the excluded middle.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
17. If a listener nods his head when you're explaining your program, wake him up.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
59. In English every word can be verbed. Would that it were so in our programming languages.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
59. In English every word can be verbed. Would that it were so in our programming languages.
62. In computing, invariants are ephemeral.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
41. Some programming languages manage to absorb change, but withstand progress.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
96. Computers don't introduce order anywhere as much as they expose opportunities.
111. Why did the Roman Empire collapse? What is Latin for office automation?
108. Whenever two programmers meet to criticize their programs, both are silent.
47. As Will Rogers would have said, "There is no such thing as a free variable."
40. There are two ways to write error-free programs; only the third one works.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
95. Don't have good ideas if you aren't willing to be responsible for them.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
76. It is the user who should parameterize procedures, not their creators.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
103. Purely applicative languages are poorly applicable.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
14. In the long run every program becomes rococo - then rubble.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
110. Editing is a rewording activity.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
104. The proof of a system's value is its existence.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
7. It is easier to write an incorrect program than understand a correct one.
110. Editing is a rewording activity.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
31. Simplicity does not precede complexity, but follows it.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
47. As Will Rogers would have said, "There is no such thing as a free variable."
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
61. In programming, as in everything else, to be in error is to be reborn.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
90. Computation has made the tree flower.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
23. To understand a program you must become both the machine and the program.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
112. Computer Science is embarrassed by the computer.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
66. Making something variable is easy. Controlling duration of constancy is the trick.
8. A programming language is low level when its programs require attention to the irrelevant.
11. If you have a procedure with ten parameters, you probably missed some.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
3. Syntactic sugar causes cancer of the semicolon.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
15. Everything should be built top-down, except the first time.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
72. An adequate bootstrap is a contradiction in terms.
1. One man's constant is another man's variable.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
62. In computing, invariants are ephemeral.
76. It is the user who should parameterize procedures, not their creators.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
59. In English every word can be verbed. Would that it were so in our programming languages.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
72. An adequate bootstrap is a contradiction in terms.
55. A LISP programmer knows the value of everything, but the cost of nothing.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
4. Every program is a part of some other program and rarely fits.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
43. In software systems, it is often the early bird that makes the worm.
41. Some programming languages manage to absorb change, but withstand progress.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
103. Purely applicative languages are poorly applicable.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
59. In English every word can be verbed. Would that it were so in our programming languages.
11. If you have a procedure with ten parameters, you probably missed some.
17. If a listener nods his head when you're explaining your program, wake him up.
8. A programming language is low level when its programs require attention to the irrelevant.
7. It is easier to write an incorrect program than understand a correct one.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
119. Programming is an unnatural act.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
111. Why did the Roman Empire collapse? What is Latin for office automation?
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
27. Once you understand how to write a program get someone else to write it.
90. Computation has made the tree flower.
111. Why did the Roman Empire collapse? What is Latin for office automation?
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
76. It is the user who should parameterize procedures, not their creators.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
59. In English every word can be verbed. Would that it were so in our programming languages.
61. In programming, as in everything else, to be in error is to be reborn.
8. A programming language is low level when its programs require attention to the irrelevant.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
1. One man's constant is another man's variable.
47. As Will Rogers would have said, "There is no such thing as a free variable."
55. A LISP programmer knows the value of everything, but the cost of nothing.
95. Don't have good ideas if you aren't willing to be responsible for them.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
15. Everything should be built top-down, except the first time.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
21. Optimization hinders evolution.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
31. Simplicity does not precede complexity, but follows it.
115. Most people find the concept of programming obvious, but the doing impossible.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
112. Computer Science is embarrassed by the computer.
61. In programming, as in everything else, to be in error is to be reborn.
27. Once you understand how to write a program get someone else to write it.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
103. Purely applicative languages are poorly applicable.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
14. In the long run every program becomes rococo - then rubble.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
41. Some programming languages manage to absorb change, but withstand progress.
40. There are two ways to write error-free programs; only the third one works.
31. Simplicity does not precede complexity, but follows it.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
103. Purely applicative languages are poorly applicable.
66. Making something variable is easy. Controlling duration of constancy is the trick.
14. In the long run every program becomes rococo - then rubble.
4. Every program is a part of some other program and rarely fits.
98. In computing, the mean time to failure keeps getting shorter.
1. One man's constant is another man's variable.
41. Some programming languages manage to absorb change, but withstand progress.
38. Structured Programming supports the law of the excluded middle.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
59. In English every word can be verbed. Would that it were so in our programming languages.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
105. You can't communicate complexity, only an awareness of it.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
47. As Will Rogers would have said, "There is no such thing as a free variable."
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
60. In seeking the unattainable, simplicity only gets in the way.
62. In computing, invariants are ephemeral.
11. If you have a procedure with ten parameters, you probably missed some.
12. Recursion is the root of computation since it trades description for time.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
90. Computation has made the tree flower.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
78. If your computer speaks English, it was probably made in Japan.
21. Optimization hinders evolution.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
98. In computing, the mean time to failure keeps getting shorter.
21. Optimization hinders evolution.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
78. If your computer speaks English, it was probably made in Japan.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
79. A year spent in artificial intelligence is enough to make one believe in God.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
41. Some programming languages manage to absorb change, but withstand progress.
40. There are two ways to write error-free programs; only the third one works.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
78. If your computer speaks English, it was probably made in Japan.
22. A good system can't have a weak command language.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
72. An adequate bootstrap is a contradiction in terms.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
96. Computers don't introduce order anywhere as much as they expose opportunities.
4. Every program is a part of some other program and rarely fits.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
90. Computation has made the tree flower.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
59. In English every word can be verbed. Would that it were so in our programming languages.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
61. In programming, as in everything else, to be in error is to be reborn.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
104. The proof of a system's value is its existence.
38. Structured Programming supports the law of the excluded middle.
12. Recursion is the root of computation since it trades description for time.
59. In English every word can be verbed. Would that it were so in our programming languages.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
59. In English every word can be verbed. Would that it were so in our programming languages.
66. Making something variable is easy. Controlling duration of constancy is the trick.
1. One man's constant is another man's variable.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
18. A program without a loop and a structured variable isn't worth writing.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
90. Computation has made the tree flower.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
15. Everything should be built top-down, except the first time.
4. Every program is a part of some other program and rarely fits.
11. If you have a procedure with ten parameters, you probably missed some.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
27. Once you understand how to write a program get someone else to write it.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
1. One man's constant is another man's variable.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
115. Most people find the concept of programming obvious, but the doing impossible.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
8. A programming language is low level when its programs require attention to the irrelevant.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
38. Structured Programming supports the law of the excluded middle.
114. Within a computer natural language is unnatural.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
102. One can't proceed from the informal to the formal by formal means.
66. Making something variable is easy. Controlling duration of constancy is the trick.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
57. It is easier to change the specification to fit the program than vice versa.
76. It is the user who should parameterize procedures, not their creators.
95. Don't have good ideas if you aren't willing to be responsible for them.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
112. Computer Science is embarrassed by the computer.
66. Making something variable is easy. Controlling duration of constancy is the trick.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
119. Programming is an unnatural act.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
12. Recursion is the root of computation since it trades description for time.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
27. Once you understand how to write a program get someone else to write it.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
114. Within a computer natural language is unnatural.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
14. In the long run every program becomes rococo - then rubble.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
119. Programming is an unnatural act.
78. If your computer speaks English, it was probably made in Japan.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
14. In the long run every program becomes rococo - then rubble.
105. You can't communicate complexity, only an awareness of it.
43. In software systems, it is often the early bird that makes the worm.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
90. Computation has made the tree flower.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
95. Don't have good ideas if you aren't willing to be responsible for them.
112. Computer Science is embarrassed by the computer.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
38. Structured Programming supports the law of the excluded middle.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
100. We will never run out of things to program as long as there is a single program around.
60. In seeking the unattainable, simplicity only gets in the way.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
8. A programming language is low level when its programs require attention to the irrelevant.
100. We will never run out of things to program as long as there is a single program around.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
47. As Will Rogers would have said, "There is no such thing as a free variable."
12. Recursion is the root of computation since it trades description for time.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
95. Don't have good ideas if you aren't willing to be responsible for them.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
76. It is the user who should parameterize procedures, not their creators.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
3. Syntactic sugar causes cancer of the semicolon.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
72. An adequate bootstrap is a contradiction in terms.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
18. A program without a loop and a structured variable isn't worth writing.
14. In the long run every program becomes rococo - then rubble.
102. One can't proceed from the informal to the formal by formal means.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
31. Simplicity does not precede complexity, but follows it.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
43. In software systems, it is often the early bird that makes the worm.
105. You can't communicate complexity, only an awareness of it.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
105. You can't communicate complexity, only an awareness of it.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
11. If you have a procedure with ten parameters, you probably missed some.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
38. Structured Programming supports the law of the excluded middle.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
12. Recursion is the root of computation since it trades description for time.
8. A programming language is low level when its programs require attention to the irrelevant.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
46. Like punning, programming is a play on words.
12. Recursion is the root of computation since it trades description for time.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
110. Editing is a rewording activity.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
1. One man's constant is another man's variable.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
62. In computing, invariants are ephemeral.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
95. Don't have good ideas if you aren't willing to be responsible for them.
47. As Will Rogers would have said, "There is no such thing as a free variable."
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
63. When we write programs that "learn", it turns out that we do and they don't.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
3. Syntactic sugar causes cancer of the semicolon.
61. In programming, as in everything else, to be in error is to be reborn.
57. It is easier to change the specification to fit the program than vice versa.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
47. As Will Rogers would have said, "There is no such thing as a free variable."
38. Structured Programming supports the law of the excluded middle.
38. Structured Programming supports the law of the excluded middle.
76. It is the user who should parameterize procedures, not their creators.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
12. Recursion is the root of computation since it trades description for time.
17. If a listener nods his head when you're explaining your program, wake him up.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
4. Every program is a part of some other program and rarely fits.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
12. Recursion is the root of computation since it trades description for time.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
105. You can't communicate complexity, only an awareness of it.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
98. In computing, the mean time to failure keeps getting shorter.
43. In software systems, it is often the early bird that makes the worm.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
47. As Will Rogers would have said, "There is no such thing as a free variable."
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
96. Computers don't introduce order anywhere as much as they expose opportunities.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
78. If your computer speaks English, it was probably made in Japan.
61. In programming, as in everything else, to be in error is to be reborn.
57. It is easier to change the specification to fit the program than vice versa.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
57. It is easier to change the specification to fit the program than vice versa.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
115. Most people find the concept of programming obvious, but the doing impossible.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
41. Some programming languages manage to absorb change, but withstand progress.
104. The proof of a system's value is its existence.
76. It is the user who should parameterize procedures, not their creators.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
112. Computer Science is embarrassed by the computer.
41. Some programming languages manage to absorb change, but withstand progress.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
108. Whenever two programmers meet to criticize their programs, both are silent.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
76. It is the user who should parameterize procedures, not their creators.
23. To understand a program you must become both the machine and the program.
18. A program without a loop and a structured variable isn't worth writing.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
14. In the long run every program becomes rococo - then rubble.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
18. A program without a loop and a structured variable isn't worth writing.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
17. If a listener nods his head when you're explaining your program, wake him up.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
103. Purely applicative languages are poorly applicable.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
66. Making something variable is easy. Controlling duration of constancy is the trick.
31. Simplicity does not precede complexity, but follows it.
12. Recursion is the root of computation since it trades description for time.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
98. In computing, the mean time to failure keeps getting shorter.
78. If your computer speaks English, it was probably made in Japan.
55. A LISP programmer knows the value of everything, but the cost of nothing.
57. It is easier to change the specification to fit the program than vice versa.
100. We will never run out of things to program as long as there is a single program around.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
18. A program without a loop and a structured variable isn't worth writing.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
18. A program without a loop and a structured variable isn't worth writing.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
61. In programming, as in everything else, to be in error is to be reborn.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
3. Syntactic sugar causes cancer of the semicolon.
112. Computer Science is embarrassed by the computer.
23. To understand a program you must become both the machine and the program.
57. It is easier to change the specification to fit the program than vice versa.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
119. Programming is an unnatural act.
61. In programming, as in everything else, to be in error is to be reborn.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
1. One man's constant is another man's variable.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
4. Every program is a part of some other program and rarely fits.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
31. Simplicity does not precede complexity, but follows it.
90. Computation has made the tree flower.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
31. Simplicity does not precede complexity, but follows it.
78. If your computer speaks English, it was probably made in Japan.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
110. Editing is a rewording activity.
76. It is the user who should parameterize procedures, not their creators.
90. Computation has made the tree flower.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
90. Computation has made the tree flower.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
15. Everything should be built top-down, except the first time.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
111. Why did the Roman Empire collapse? What is Latin for office automation?
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
115. Most people find the concept of programming obvious, but the doing impossible.
40. There are two ways to write error-free programs; only the third one works.
23. To understand a program you must become both the machine and the program.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
1. One man's constant is another man's variable.
59. In English every word can be verbed. Would that it were so in our programming languages.
63. When we write programs that "learn", it turns out that we do and they don't.
12. Recursion is the root of computation since it trades description for time.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
63. When we write programs that "learn", it turns out that we do and they don't.
12. Recursion is the root of computation since it trades description for time.
76. It is the user who should parameterize procedures, not their creators.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
11. If you have a procedure with ten parameters, you probably missed some.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
57. It is easier to change the specification to fit the program than vice versa.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
110. Editing is a rewording activity.
63. When we write programs that "learn", it turns out that we do and they don't.
3. Syntactic sugar causes cancer of the semicolon.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
27. Once you understand how to write a program get someone else to write it.
62. In computing, invariants are ephemeral.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
31. Simplicity does not precede complexity, but follows it.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
40. There are two ways to write error-free programs; only the third one works.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
46. Like punning, programming is a play on words.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
103. Purely applicative languages are poorly applicable.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
3. Syntactic sugar causes cancer of the semicolon.
111. Why did the Roman Empire collapse? What is Latin for office automation?
31. Simplicity does not precede complexity, but follows it.
115. Most people find the concept of programming obvious, but the doing impossible.
60. In seeking the unattainable, simplicity only gets in the way.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
40. There are two ways to write error-free programs; only the third one works.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
22. A good system can't have a weak command language.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
27. Once you understand how to write a program get someone else to write it.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
76. It is the user who should parameterize procedures, not their creators.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
11. If you have a procedure with ten parameters, you probably missed some.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
105. You can't communicate complexity, only an awareness of it.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
12. Recursion is the root of computation since it trades description for time.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
111. Why did the Roman Empire collapse? What is Latin for office automation?
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
76. It is the user who should parameterize procedures, not their creators.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
12. Recursion is the root of computation since it trades description for time.
14. In the long run every program becomes rococo - then rubble.
21. Optimization hinders evolution.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
1. One man's constant is another man's variable.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
15. Everything should be built top-down, except the first time.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
60. In seeking the unattainable, simplicity only gets in the way.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
96. Computers don't introduce order anywhere as much as they expose opportunities.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
105. You can't communicate complexity, only an awareness of it.
21. Optimization hinders evolution.
96. Computers don't introduce order anywhere as much as they expose opportunities.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
102. One can't proceed from the informal to the formal by formal means.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
41. Some programming languages manage to absorb change, but withstand progress.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
110. Editing is a rewording activity.
102. One can't proceed from the informal to the formal by formal means.
63. When we write programs that "learn", it turns out that we do and they don't.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
100. We will never run out of things to program as long as there is a single program around.
60. In seeking the unattainable, simplicity only gets in the way.
12. Recursion is the root of computation since it trades description for time.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
38. Structured Programming supports the law of the excluded middle.
15. Everything should be built top-down, except the first time.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
115. Most people find the concept of programming obvious, but the doing impossible.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
108. Whenever two programmers meet to criticize their programs, both are silent.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
119. Programming is an unnatural act.
21. Optimization hinders evolution.
22. A good system can't have a weak command language.
31. Simplicity does not precede complexity, but follows it.
60. In seeking the unattainable, simplicity only gets in the way.
15. Everything should be built top-down, except the first time.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
17. If a listener nods his head when you're explaining your program, wake him up.
62. In computing, invariants are ephemeral.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
60. In seeking the unattainable, simplicity only gets in the way.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
38. Structured Programming supports the law of the excluded middle.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
61. In programming, as in everything else, to be in error is to be reborn.
22. A good system can't have a weak command language.
114. Within a computer natural language is unnatural.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
21. Optimization hinders evolution.
8. A programming language is low level when its programs require attention to the irrelevant.
102. One can't proceed from the informal to the formal by formal means.
96. Computers don't introduce order anywhere as much as they expose opportunities.
72. An adequate bootstrap is a contradiction in terms.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
95. Don't have good ideas if you aren't willing to be responsible for them.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
90. Computation has made the tree flower.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
95. Don't have good ideas if you aren't willing to be responsible for them.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
23. To understand a program you must become both the machine and the program.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
47. As Will Rogers would have said, "There is no such thing as a free variable."
8. A programming language is low level when its programs require attention to the irrelevant.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
90. Computation has made the tree flower.
41. Some programming languages manage to absorb change, but withstand progress.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
8. A programming language is low level when its programs require attention to the irrelevant.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
21. Optimization hinders evolution.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
110. Editing is a rewording activity.
12. Recursion is the root of computation since it trades description for time.
79. A year spent in artificial intelligence is enough to make one believe in God.
98. In computing, the mean time to failure keeps getting shorter.
111. Why did the Roman Empire collapse? What is Latin for office automation?
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
66. Making something variable is easy. Controlling duration of constancy is the trick.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
103. Purely applicative languages are poorly applicable.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
100. We will never run out of things to program as long as there is a single program around.
46. Like punning, programming is a play on words.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
103. Purely applicative languages are poorly applicable.
23. To understand a program you must become both the machine and the program.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
79. A year spent in artificial intelligence is enough to make one believe in God.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
31. Simplicity does not precede complexity, but follows it.
63. When we write programs that "learn", it turns out that we do and they don't.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
102. One can't proceed from the informal to the formal by formal means.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
3. Syntactic sugar causes cancer of the semicolon.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
57. It is easier to change the specification to fit the program than vice versa.
79. A year spent in artificial intelligence is enough to make one believe in God.
22. A good system can't have a weak command language.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
57. It is easier to change the specification to fit the program than vice versa.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
27. Once you understand how to write a program get someone else to write it.
57. It is easier to change the specification to fit the program than vice versa.
96. Computers don't introduce order anywhere as much as they expose opportunities.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
27. Once you understand how to write a program get someone else to write it.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
66. Making something variable is easy. Controlling duration of constancy is the trick.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
47. As Will Rogers would have said, "There is no such thing as a free variable."
3. Syntactic sugar causes cancer of the semicolon.
55. A LISP programmer knows the value of everything, but the cost of nothing.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
112. Computer Science is embarrassed by the computer.
79. A year spent in artificial intelligence is enough to make one believe in God.
61. In programming, as in everything else, to be in error is to be reborn.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
107. The debate rages on: is PL/I Bachtrian or Dromedary?
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
46. Like punning, programming is a play on words.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
27. Once you understand how to write a program get someone else to write it.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
15. Everything should be built top-down, except the first time.
103. Purely applicative languages are poorly applicable.
17. If a listener nods his head when you're explaining your program, wake him up.
76. It is the user who should parameterize procedures, not their creators.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
59. In English every word can be verbed. Would that it were so in our programming languages.
111. Why did the Roman Empire collapse? What is Latin for office automation?
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
4. Every program is a part of some other program and rarely fits.
38. Structured Programming supports the law of the excluded middle.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
12. Recursion is the root of computation since it trades description for time.
14. In the long run every program becomes rococo - then rubble.
40. There are two ways to write error-free programs; only the third one works.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
14. In the long run every program becomes rococo - then rubble.
57. It is easier to change the specification to fit the program than vice versa.
1. One man's constant is another man's variable.
79. A year spent in artificial intelligence is enough to make one believe in God.
47. As Will Rogers would have said, "There is no such thing as a free variable."
3. Syntactic sugar causes cancer of the semicolon.
114. Within a computer natural language is unnatural.
79. A year spent in artificial intelligence is enough to make one believe in God.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
22. A good system can't have a weak command language.
115. Most people find the concept of programming obvious, but the doing impossible.
96. Computers don't introduce order anywhere as much as they expose opportunities.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
66. Making something variable is easy. Controlling duration of constancy is the trick.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
103. Purely applicative languages are poorly applicable.
46. Like punning, programming is a play on words.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
15. Everything should be built top-down, except the first time.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
57. It is easier to change the specification to fit the program than vice versa.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
111. Why did the Roman Empire collapse? What is Latin for office automation?
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
40. There are two ways to write error-free programs; only the third one works.
11. If you have a procedure with ten parameters, you probably missed some.
38. Structured Programming supports the law of the excluded middle.
76. It is the user who should parameterize procedures, not their creators.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
43. In software systems, it is often the early bird that makes the worm.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
102. One can't proceed from the informal to the formal by formal means.
108. Whenever two programmers meet to criticize their programs, both are silent.
115. Most people find the concept of programming obvious, but the doing impossible.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
79. A year spent in artificial intelligence is enough to make one believe in God.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
100. We will never run out of things to program as long as there is a single program around.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
66. Making something variable is easy. Controlling duration of constancy is the trick.
114. Within a computer natural language is unnatural.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
18. A program without a loop and a structured variable isn't worth writing.
38. Structured Programming supports the law of the excluded middle.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
114. Within a computer natural language is unnatural.
104. The proof of a system's value is its existence.
104. The proof of a system's value is its existence.
47. As Will Rogers would have said, "There is no such thing as a free variable."
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
12. Recursion is the root of computation since it trades description for time.
66. Making something variable is easy. Controlling duration of constancy is the trick.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
62. In computing, invariants are ephemeral.
63. When we write programs that "learn", it turns out that we do and they don't.
27. Once you understand how to write a program get someone else to write it.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
15. Everything should be built top-down, except the first time.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
55. A LISP programmer knows the value of everything, but the cost of nothing.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
110. Editing is a rewording activity.
108. Whenever two programmers meet to criticize their programs, both are silent.
40. There are two ways to write error-free programs; only the third one works.
47. As Will Rogers would have said, "There is no such thing as a free variable."
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
21. Optimization hinders evolution.
96. Computers don't introduce order anywhere as much as they expose opportunities.
40. There are two ways to write error-free programs; only the third one works.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
114. Within a computer natural language is unnatural.
11. If you have a procedure with ten parameters, you probably missed some.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
98. In computing, the mean time to failure keeps getting shorter.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
108. Whenever two programmers meet to criticize their programs, both are silent.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
47. As Will Rogers would have said, "There is no such thing as a free variable."
66. Making something variable is easy. Controlling duration of constancy is the trick.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
17. If a listener nods his head when you're explaining your program, wake him up.
60. In seeking the unattainable, simplicity only gets in the way.
60. In seeking the unattainable, simplicity only gets in the way.
61. In programming, as in everything else, to be in error is to be reborn.
98. In computing, the mean time to failure keeps getting shorter.
1. One man's constant is another man's variable.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
41. Some programming languages manage to absorb change, but withstand progress.
4. Every program is a part of some other program and rarely fits.
23. To understand a program you must become both the machine and the program.
40. There are two ways to write error-free programs; only the third one works.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
8. A programming language is low level when its programs require attention to the irrelevant.
40. There are two ways to write error-free programs; only the third one works.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
115. Most people find the concept of programming obvious, but the doing impossible.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
31. Simplicity does not precede complexity, but follows it.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
41. Some programming languages manage to absorb change, but withstand progress.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
103. Purely applicative languages are poorly applicable.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
98. In computing, the mean time to failure keeps getting shorter.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
115. Most people find the concept of programming obvious, but the doing impossible.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
12. Recursion is the root of computation since it trades description for time.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
96. Computers don't introduce order anywhere as much as they expose opportunities.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
115. Most people find the concept of programming obvious, but the doing impossible.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
3. Syntactic sugar causes cancer of the semicolon.
108. Whenever two programmers meet to criticize their programs, both are silent.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
61. In programming, as in everything else, to be in error is to be reborn.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
31. Simplicity does not precede complexity, but follows it.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
46. Like punning, programming is a play on words.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
3. Syntactic sugar causes cancer of the semicolon.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
62. In computing, invariants are ephemeral.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
15. Everything should be built top-down, except the first time.
57. It is easier to change the specification to fit the program than vice versa.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
108. Whenever two programmers meet to criticize their programs, both are silent.
103. Purely applicative languages are poorly applicable.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
90. Computation has made the tree flower.
22. A good system can't have a weak command language.
15. Everything should be built top-down, except the first time.
4. Every program is a part of some other program and rarely fits.
8. A programming language is low level when its programs require attention to the irrelevant.
76. It is the user who should parameterize procedures, not their creators.
22. A good system can't have a weak command language.
100. We will never run out of things to program as long as there is a single program around.
104. The proof of a system's value is its existence.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
38. Structured Programming supports the law of the excluded middle.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
104. The proof of a system's value is its existence.
41. Some programming languages manage to absorb change, but withstand progress.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
15. Everything should be built top-down, except the first time.
63. When we write programs that "learn", it turns out that we do and they don't.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
119. Programming is an unnatural act.
18. A program without a loop and a structured variable isn't worth writing.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
8. A programming language is low level when its programs require attention to the irrelevant.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
95. Don't have good ideas if you aren't willing to be responsible for them.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
108. Whenever two programmers meet to criticize their programs, both are silent.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
22. A good system can't have a weak command language.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
7. It is easier to write an incorrect program than understand a correct one.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
1. One man's constant is another man's variable.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
7. It is easier to write an incorrect program than understand a correct one.
62. In computing, invariants are ephemeral.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
31. Simplicity does not precede complexity, but follows it.
76. It is the user who should parameterize procedures, not their creators.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
60. In seeking the unattainable, simplicity only gets in the way.
4. Every program is a part of some other program and rarely fits.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
15. Everything should be built top-down, except the first time.
63. When we write programs that "learn", it turns out that we do and they don't.
59. In English every word can be verbed. Would that it were so in our programming languages.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
63. When we write programs that "learn", it turns out that we do and they don't.
108. Whenever two programmers meet to criticize their programs, both are silent.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
3. Syntactic sugar causes cancer of the semicolon.
14. In the long run every program becomes rococo - then rubble.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
100. We will never run out of things to program as long as there is a single program around.
63. When we write programs that "learn", it turns out that we do and they don't.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
27. Once you understand how to write a program get someone else to write it.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
7. It is easier to write an incorrect program than understand a correct one.
41. Some programming languages manage to absorb change, but withstand progress.
59. In English every word can be verbed. Would that it were so in our programming languages.
90. Computation has made the tree flower.
96. Computers don't introduce order anywhere as much as they expose opportunities.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
61. In programming, as in everything else, to be in error is to be reborn.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
105. You can't communicate complexity, only an awareness of it.
66. Making something variable is easy. Controlling duration of constancy is the trick.
62. In computing, invariants are ephemeral.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
8. A programming language is low level when its programs require attention to the irrelevant.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
98. In computing, the mean time to failure keeps getting shorter.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
12. Recursion is the root of computation since it trades description for time.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
115. Most people find the concept of programming obvious, but the doing impossible.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
72. An adequate bootstrap is a contradiction in terms.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
108. Whenever two programmers meet to criticize their programs, both are silent.
104. The proof of a system's value is its existence.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
59. In English every word can be verbed. Would that it were so in our programming languages.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
76. It is the user who should parameterize procedures, not their creators.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
27. Once you understand how to write a program get someone else to write it.
62. In computing, invariants are ephemeral.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
100. We will never run out of things to program as long as there is a single program around.
96. Computers don't introduce order anywhere as much as they expose opportunities.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
96. Computers don't introduce order anywhere as much as they expose opportunities.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
31. Simplicity does not precede complexity, but follows it.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
63. When we write programs that "learn", it turns out that we do and they don't.
11. If you have a procedure with ten parameters, you probably missed some.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
43. In software systems, it is often the early bird that makes the worm.
72. An adequate bootstrap is a contradiction in terms.
78. If your computer speaks English, it was probably made in Japan.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
15. Everything should be built top-down, except the first time.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
102. One can't proceed from the informal to the formal by formal means.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
21. Optimization hinders evolution.
63. When we write programs that "learn", it turns out that we do and they don't.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
17. If a listener nods his head when you're explaining your program, wake him up.
3. Syntactic sugar causes cancer of the semicolon.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
27. Once you understand how to write a program get someone else to write it.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
27. Once you understand how to write a program get someone else to write it.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
12. Recursion is the root of computation since it trades description for time.
110. Editing is a rewording activity.
108. Whenever two programmers meet to criticize their programs, both are silent.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
8. A programming language is low level when its programs require attention to the irrelevant.
100. We will never run out of things to program as long as there is a single program around.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
96. Computers don't introduce order anywhere as much as they expose opportunities.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
63. When we write programs that "learn", it turns out that we do and they don't.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
12. Recursion is the root of computation since it trades description for time.
112. Computer Science is embarrassed by the computer.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
7. It is easier to write an incorrect program than understand a correct one.
17. If a listener nods his head when you're explaining your program, wake him up.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
105. You can't communicate complexity, only an awareness of it.
18. A program without a loop and a structured variable isn't worth writing.
104. The proof of a system's value is its existence.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
41. Some programming languages manage to absorb change, but withstand progress.
4. Every program is a part of some other program and rarely fits.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
95. Don't have good ideas if you aren't willing to be responsible for them.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
72. An adequate bootstrap is a contradiction in terms.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
100. We will never run out of things to program as long as there is a single program around.
7. It is easier to write an incorrect program than understand a correct one.
108. Whenever two programmers meet to criticize their programs, both are silent.
46. Like punning, programming is a play on words.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
15. Everything should be built top-down, except the first time.
46. Like punning, programming is a play on words.
22. A good system can't have a weak command language.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
115. Most people find the concept of programming obvious, but the doing impossible.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
3. Syntactic sugar causes cancer of the semicolon.
78. If your computer speaks English, it was probably made in Japan.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
100. We will never run out of things to program as long as there is a single program around.
78. If your computer speaks English, it was probably made in Japan.
105. You can't communicate complexity, only an awareness of it.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
90. Computation has made the tree flower.
79. A year spent in artificial intelligence is enough to make one believe in God.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
60. In seeking the unattainable, simplicity only gets in the way.
98. In computing, the mean time to failure keeps getting shorter.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
22. A good system can't have a weak command language.
119. Programming is an unnatural act.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
63. When we write programs that "learn", it turns out that we do and they don't.
60. In seeking the unattainable, simplicity only gets in the way.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
17. If a listener nods his head when you're explaining your program, wake him up.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
8. A programming language is low level when its programs require attention to the irrelevant.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
78. If your computer speaks English, it was probably made in Japan.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
90. Computation has made the tree flower.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
31. Simplicity does not precede complexity, but follows it.
15. Everything should be built top-down, except the first time.
59. In English every word can be verbed. Would that it were so in our programming languages.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
72. An adequate bootstrap is a contradiction in terms.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
57. It is easier to change the specification to fit the program than vice versa.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
59. In English every word can be verbed. Would that it were so in our programming languages.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
119. Programming is an unnatural act.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
98. In computing, the mean time to failure keeps getting shorter.
60. In seeking the unattainable, simplicity only gets in the way.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
103. Purely applicative languages are poorly applicable.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
3. Syntactic sugar causes cancer of the semicolon.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
7. It is easier to write an incorrect program than understand a correct one.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
119. Programming is an unnatural act.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
57. It is easier to change the specification to fit the program than vice versa.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
79. A year spent in artificial intelligence is enough to make one believe in God.
27. Once you understand how to write a program get someone else to write it.
46. Like punning, programming is a play on words.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
111. Why did the Roman Empire collapse? What is Latin for office automation?
79. A year spent in artificial intelligence is enough to make one believe in God.
21. Optimization hinders evolution.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
15. Everything should be built top-down, except the first time.
61. In programming, as in everything else, to be in error is to be reborn.
40. There are two ways to write error-free programs; only the third one works.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
38. Structured Programming supports the law of the excluded middle.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
21. Optimization hinders evolution.
23. To understand a program you must become both the machine and the program.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
4. Every program is a part of some other program and rarely fits.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
72. An adequate bootstrap is a contradiction in terms.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
38. Structured Programming supports the law of the excluded middle.
72. An adequate bootstrap is a contradiction in terms.
1. One man's constant is another man's variable.
96. Computers don't introduce order anywhere as much as they expose opportunities.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
105. You can't communicate complexity, only an awareness of it.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
55. A LISP programmer knows the value of everything, but the cost of nothing.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
46. Like punning, programming is a play on words.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
22. A good system can't have a weak command language.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
41. Some programming languages manage to absorb change, but withstand progress.
23. To understand a program you must become both the machine and the program.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
40. There are two ways to write error-free programs; only the third one works.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
98. In computing, the mean time to failure keeps getting shorter.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
108. Whenever two programmers meet to criticize their programs, both are silent.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
17. If a listener nods his head when you're explaining your program, wake him up.
96. Computers don't introduce order anywhere as much as they expose opportunities.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
102. One can't proceed from the informal to the formal by formal means.
112. Computer Science is embarrassed by the computer.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
115. Most people find the concept of programming obvious, but the doing impossible.
90. Computation has made the tree flower.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
38. Structured Programming supports the law of the excluded middle.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
7. It is easier to write an incorrect program than understand a correct one.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
96. Computers don't introduce order anywhere as much as they expose opportunities.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
17. If a listener nods his head when you're explaining your program, wake him up.
40. There are two ways to write error-free programs; only the third one works.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
62. In computing, invariants are ephemeral.
21. Optimization hinders evolution.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
61. In programming, as in everything else, to be in error is to be reborn.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
46. Like punning, programming is a play on words.
21. Optimization hinders evolution.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
110. Editing is a rewording activity.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
12. Recursion is the root of computation since it trades description for time.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
105. You can't communicate complexity, only an awareness of it.
12. Recursion is the root of computation since it trades description for time.
41. Some programming languages manage to absorb change, but withstand progress.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
22. A good system can't have a weak command language.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
103. Purely applicative languages are poorly applicable.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
98. In computing, the mean time to failure keeps getting shorter.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
114. Within a computer natural language is unnatural.
76. It is the user who should parameterize procedures, not their creators.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
100. We will never run out of things to program as long as there is a single program around.
78. If your computer speaks English, it was probably made in Japan.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
41. Some programming languages manage to absorb change, but withstand progress.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
98. In computing, the mean time to failure keeps getting shorter.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
105. You can't communicate complexity, only an awareness of it.
55. A LISP programmer knows the value of everything, but the cost of nothing.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
111. Why did the Roman Empire collapse? What is Latin for office automation?
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
46. Like punning, programming is a play on words.
111. Why did the Roman Empire collapse? What is Latin for office automation?
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
90. Computation has made the tree flower.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
90. Computation has made the tree flower.
21. Optimization hinders evolution.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
110. Editing is a rewording activity.
63. When we write programs that "learn", it turns out that we do and they don't.
11. If you have a procedure with ten parameters, you probably missed some.
61. In programming, as in everything else, to be in error is to be reborn.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
18. A program without a loop and a structured variable isn't worth writing.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
115. Most people find the concept of programming obvious, but the doing impossible.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
7. It is easier to write an incorrect program than understand a correct one.
11. If you have a procedure with ten parameters, you probably missed some.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
119. Programming is an unnatural act.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
72. An adequate bootstrap is a contradiction in terms.
79. A year spent in artificial intelligence is enough to make one believe in God.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
98. In computing, the mean time to failure keeps getting shorter.
57. It is easier to change the specification to fit the program than vice versa.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
21. Optimization hinders evolution.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
119. Programming is an unnatural act.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
76. It is the user who should parameterize procedures, not their creators.
78. If your computer speaks English, it was probably made in Japan.
15. Everything should be built top-down, except the first time.
105. You can't communicate complexity, only an awareness of it.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
23. To understand a program you must become both the machine and the program.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
119. Programming is an unnatural act.
112. Computer Science is embarrassed by the computer.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
96. Computers don't introduce order anywhere as much as they expose opportunities.
14. In the long run every program becomes rococo - then rubble.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
115. Most people find the concept of programming obvious, but the doing impossible.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
111. Why did the Roman Empire collapse? What is Latin for office automation?
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
18. A program without a loop and a structured variable isn't worth writing.
55. A LISP programmer knows the value of everything, but the cost of nothing.
1. One man's constant is another man's variable.
8. A programming language is low level when its programs require attention to the irrelevant.
72. An adequate bootstrap is a contradiction in terms.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
12. Recursion is the root of computation since it trades description for time.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
22. A good system can't have a weak command language.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
79. A year spent in artificial intelligence is enough to make one believe in God.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
63. When we write programs that "learn", it turns out that we do and they don't.
108. Whenever two programmers meet to criticize their programs, both are silent.
76. It is the user who should parameterize procedures, not their creators.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
115. Most people find the concept of programming obvious, but the doing impossible.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
112. Computer Science is embarrassed by the computer.
72. An adequate bootstrap is a contradiction in terms.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
55. A LISP programmer knows the value of everything, but the cost of nothing.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
1. One man's constant is another man's variable.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
90. Computation has made the tree flower.
27. Once you understand how to write a program get someone else to write it.
40. There are two ways to write error-free programs; only the third one works.
112. Computer Science is embarrassed by the computer.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
11. If you have a procedure with ten parameters, you probably missed some.
27. Once you understand how to write a program get someone else to write it.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
15. Everything should be built top-down, except the first time.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
17. If a listener nods his head when you're explaining your program, wake him up.
60. In seeking the unattainable, simplicity only gets in the way.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
63. When we write programs that "learn", it turns out that we do and they don't.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
40. There are two ways to write error-free programs; only the third one works.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
17. If a listener nods his head when you're explaining your program, wake him up.
66. Making something variable is easy. Controlling duration of constancy is the trick.
57. It is easier to change the specification to fit the program than vice versa.
8. A programming language is low level when its programs require attention to the irrelevant.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
103. Purely applicative languages are poorly applicable.
102. One can't proceed from the informal to the formal by formal means.
18. A program without a loop and a structured variable isn't worth writing.
62. In computing, invariants are ephemeral.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
115. Most people find the concept of programming obvious, but the doing impossible.
63. When we write programs that "learn", it turns out that we do and they don't.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
43. In software systems, it is often the early bird that makes the worm.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
66. Making something variable is easy. Controlling duration of constancy is the trick.
7. It is easier to write an incorrect program than understand a correct one.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
7. It is easier to write an incorrect program than understand a correct one.
22. A good system can't have a weak command language.
78. If your computer speaks English, it was probably made in Japan.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
72. An adequate bootstrap is a contradiction in terms.
59. In English every word can be verbed. Would that it were so in our programming languages.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
46. Like punning, programming is a play on words.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
62. In computing, invariants are ephemeral.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
62. In computing, invariants are ephemeral.
108. Whenever two programmers meet to criticize their programs, both are silent.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
78. If your computer speaks English, it was probably made in Japan.
15. Everything should be built top-down, except the first time.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
18. A program without a loop and a structured variable isn't worth writing.
46. Like punning, programming is a play on words.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
57. It is easier to change the specification to fit the program than vice versa.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
55. A LISP programmer knows the value of everything, but the cost of nothing.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
47. As Will Rogers would have said, "There is no such thing as a free variable."
3. Syntactic sugar causes cancer of the semicolon.
103. Purely applicative languages are poorly applicable.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
23. To understand a program you must become both the machine and the program.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
46. Like punning, programming is a play on words.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
105. You can't communicate complexity, only an awareness of it.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
110. Editing is a rewording activity.
43. In software systems, it is often the early bird that makes the worm.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
76. It is the user who should parameterize procedures, not their creators.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
72. An adequate bootstrap is a contradiction in terms.
40. There are two ways to write error-free programs; only the third one works.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
63. When we write programs that "learn", it turns out that we do and they don't.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
108. Whenever two programmers meet to criticize their programs, both are silent.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
15. Everything should be built top-down, except the first time.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
59. In English every word can be verbed. Would that it were so in our programming languages.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
100. We will never run out of things to program as long as there is a single program around.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
23. To understand a program you must become both the machine and the program.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
76. It is the user who should parameterize procedures, not their creators.
72. An adequate bootstrap is a contradiction in terms.
22. A good system can't have a weak command language.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
59. In English every word can be verbed. Would that it were so in our programming languages.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
12. Recursion is the root of computation since it trades description for time.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
47. As Will Rogers would have said, "There is no such thing as a free variable."
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
105. You can't communicate complexity, only an awareness of it.
63. When we write programs that "learn", it turns out that we do and they don't.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
4. Every program is a part of some other program and rarely fits.
11. If you have a procedure with ten parameters, you probably missed some.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
72. An adequate bootstrap is a contradiction in terms.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
17. If a listener nods his head when you're explaining your program, wake him up.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
17. If a listener nods his head when you're explaining your program, wake him up.
47. As Will Rogers would have said, "There is no such thing as a free variable."
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
17. If a listener nods his head when you're explaining your program, wake him up.
11. If you have a procedure with ten parameters, you probably missed some.
41. Some programming languages manage to absorb change, but withstand progress.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
115. Most people find the concept of programming obvious, but the doing impossible.
110. Editing is a rewording activity.
23. To understand a program you must become both the machine and the program.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
31. Simplicity does not precede complexity, but follows it.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
59. In English every word can be verbed. Would that it were so in our programming languages.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
12. Recursion is the root of computation since it trades description for time.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
40. There are two ways to write error-free programs; only the third one works.
66. Making something variable is easy. Controlling duration of constancy is the trick.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
119. Programming is an unnatural act.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
110. Editing is a rewording activity.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
115. Most people find the concept of programming obvious, but the doing impossible.
60. In seeking the unattainable, simplicity only gets in the way.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
60. In seeking the unattainable, simplicity only gets in the way.
108. Whenever two programmers meet to criticize their programs, both are silent.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
14. In the long run every program becomes rococo - then rubble.
72. An adequate bootstrap is a contradiction in terms.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
98. In computing, the mean time to failure keeps getting shorter.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
38. Structured Programming supports the law of the excluded middle.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
60. In seeking the unattainable, simplicity only gets in the way.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
8. A programming language is low level when its programs require attention to the irrelevant.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
110. Editing is a rewording activity.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
27. Once you understand how to write a program get someone else to write it.
115. Most people find the concept of programming obvious, but the doing impossible.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
59. In English every word can be verbed. Would that it were so in our programming languages.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
61. In programming, as in everything else, to be in error is to be reborn.
104. The proof of a system's value is its existence.
57. It is easier to change the specification to fit the program than vice versa.
78. If your computer speaks English, it was probably made in Japan.
17. If a listener nods his head when you're explaining your program, wake him up.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
100. We will never run out of things to program as long as there is a single program around.
18. A program without a loop and a structured variable isn't worth writing.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
96. Computers don't introduce order anywhere as much as they expose opportunities.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
3. Syntactic sugar causes cancer of the semicolon.
11. If you have a procedure with ten parameters, you probably missed some.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
17. If a listener nods his head when you're explaining your program, wake him up.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
105. You can't communicate complexity, only an awareness of it.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
57. It is easier to change the specification to fit the program than vice versa.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
17. If a listener nods his head when you're explaining your program, wake him up.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
112. Computer Science is embarrassed by the computer.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
14. In the long run every program becomes rococo - then rubble.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
22. A good system can't have a weak command language.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
95. Don't have good ideas if you aren't willing to be responsible for them.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
18. A program without a loop and a structured variable isn't worth writing.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
102. One can't proceed from the informal to the formal by formal means.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
8. A programming language is low level when its programs require attention to the irrelevant.
43. In software systems, it is often the early bird that makes the worm.
31. Simplicity does not precede complexity, but follows it.
112. Computer Science is embarrassed by the computer.
119. Programming is an unnatural act.
15. Everything should be built top-down, except the first time.
115. Most people find the concept of programming obvious, but the doing impossible.
22. A good system can't have a weak command language.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
61. In programming, as in everything else, to be in error is to be reborn.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
3. Syntactic sugar causes cancer of the semicolon.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
59. In English every word can be verbed. Would that it were so in our programming languages.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
31. Simplicity does not precede complexity, but follows it.
21. Optimization hinders evolution.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
3. Syntactic sugar causes cancer of the semicolon.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
11. If you have a procedure with ten parameters, you probably missed some.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
21. Optimization hinders evolution.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
57. It is easier to change the specification to fit the program than vice versa.
105. You can't communicate complexity, only an awareness of it.
18. A program without a loop and a structured variable isn't worth writing.
96. Computers don't introduce order anywhere as much as they expose opportunities.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
112. Computer Science is embarrassed by the computer.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
76. It is the user who should parameterize procedures, not their creators.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
105. You can't communicate complexity, only an awareness of it.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
55. A LISP programmer knows the value of everything, but the cost of nothing.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
115. Most people find the concept of programming obvious, but the doing impossible.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
111. Why did the Roman Empire collapse? What is Latin for office automation?
66. Making something variable is easy. Controlling duration of constancy is the trick.
62. In computing, invariants are ephemeral.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
1. One man's constant is another man's variable.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
15. Everything should be built top-down, except the first time.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
119. Programming is an unnatural act.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
115. Most people find the concept of programming obvious, but the doing impossible.
12. Recursion is the root of computation since it trades description for time.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
76. It is the user who should parameterize procedures, not their creators.
61. In programming, as in everything else, to be in error is to be reborn.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
79. A year spent in artificial intelligence is enough to make one believe in God.
57. It is easier to change the specification to fit the program than vice versa.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
76. It is the user who should parameterize procedures, not their creators.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
115. Most people find the concept of programming obvious, but the doing impossible.
110. Editing is a rewording activity.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
12. Recursion is the root of computation since it trades description for time.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
119. Programming is an unnatural act.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
66. Making something variable is easy. Controlling duration of constancy is the trick.
23. To understand a program you must become both the machine and the program.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
79. A year spent in artificial intelligence is enough to make one believe in God.
7. It is easier to write an incorrect program than understand a correct one.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
3. Syntactic sugar causes cancer of the semicolon.
31. Simplicity does not precede complexity, but follows it.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
60. In seeking the unattainable, simplicity only gets in the way.
55. A LISP programmer knows the value of everything, but the cost of nothing.
59. In English every word can be verbed. Would that it were so in our programming languages.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
43. In software systems, it is often the early bird that makes the worm.
95. Don't have good ideas if you aren't willing to be responsible for them.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
111. Why did the Roman Empire collapse? What is Latin for office automation?
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
55. A LISP programmer knows the value of everything, but the cost of nothing.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
21. Optimization hinders evolution.
40. There are two ways to write error-free programs; only the third one works.
72. An adequate bootstrap is a contradiction in terms.
18. A program without a loop and a structured variable isn't worth writing.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
17. If a listener nods his head when you're explaining your program, wake him up.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
21. Optimization hinders evolution.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
17. If a listener nods his head when you're explaining your program, wake him up.
115. Most people find the concept of programming obvious, but the doing impossible.
63. When we write programs that "learn", it turns out that we do and they don't.
72. An adequate bootstrap is a contradiction in terms.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
59. In English every word can be verbed. Would that it were so in our programming languages.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
98. In computing, the mean time to failure keeps getting shorter.
55. A LISP programmer knows the value of everything, but the cost of nothing.
22. A good system can't have a weak command language.
23. To understand a program you must become both the machine and the program.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
112. Computer Science is embarrassed by the computer.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
61. In programming, as in everything else, to be in error is to be reborn.
78. If your computer speaks English, it was probably made in Japan.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
115. Most people find the concept of programming obvious, but the doing impossible.
12. Recursion is the root of computation since it trades description for time.
55. A LISP programmer knows the value of everything, but the cost of nothing.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
57. It is easier to change the specification to fit the program than vice versa.
8. A programming language is low level when its programs require attention to the irrelevant.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
14. In the long run every program becomes rococo - then rubble.
103. Purely applicative languages are poorly applicable.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
115. Most people find the concept of programming obvious, but the doing impossible.
105. You can't communicate complexity, only an awareness of it.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
78. If your computer speaks English, it was probably made in Japan.
104. The proof of a system's value is its existence.
100. We will never run out of things to program as long as there is a single program around.
78. If your computer speaks English, it was probably made in Japan.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
15. Everything should be built top-down, except the first time.
55. A LISP programmer knows the value of everything, but the cost of nothing.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
115. Most people find the concept of programming obvious, but the doing impossible.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
19. A language that doesn't affect the way you think about programming, is not worth knowing.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
107. The debate rages on: is PL/I Bachtrian or Dromedary?
57. It is easier to change the specification to fit the program than vice versa.
115. Most people find the concept of programming obvious, but the doing impossible.
62. In computing, invariants are ephemeral.
38. Structured Programming supports the law of the excluded middle.
27. Once you understand how to write a program get someone else to write it.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
66. Making something variable is easy. Controlling duration of constancy is the trick.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
8. A programming language is low level when its programs require attention to the irrelevant.
3. Syntactic sugar causes cancer of the semicolon.
43. In software systems, it is often the early bird that makes the worm.
46. Like punning, programming is a play on words.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
62. In computing, invariants are ephemeral.
40. There are two ways to write error-free programs; only the third one works.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
63. When we write programs that "learn", it turns out that we do and they don't.
27. Once you understand how to write a program get someone else to write it.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
110. Editing is a rewording activity.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
17. If a listener nods his head when you're explaining your program, wake him up.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
96. Computers don't introduce order anywhere as much as they expose opportunities.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
38. Structured Programming supports the law of the excluded middle.
27. Once you understand how to write a program get someone else to write it.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
21. Optimization hinders evolution.
90. Computation has made the tree flower.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
17. If a listener nods his head when you're explaining your program, wake him up.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
57. It is easier to change the specification to fit the program than vice versa.
114. Within a computer natural language is unnatural.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
59. In English every word can be verbed. Would that it were so in our programming languages.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
43. In software systems, it is often the early bird that makes the worm.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
66. Making something variable is easy. Controlling duration of constancy is the trick.
111. Why did the Roman Empire collapse? What is Latin for office automation?
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
23. To understand a program you must become both the machine and the program.
76. It is the user who should parameterize procedures, not their creators.
72. An adequate bootstrap is a contradiction in terms.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
21. Optimization hinders evolution.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
17. If a listener nods his head when you're explaining your program, wake him up.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
66. Making something variable is easy. Controlling duration of constancy is the trick.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
40. There are two ways to write error-free programs; only the third one works.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
38. Structured Programming supports the law of the excluded middle.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
22. A good system can't have a weak command language.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
1. One man's constant is another man's variable.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
72. An adequate bootstrap is a contradiction in terms.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
21. Optimization hinders evolution.
95. Don't have good ideas if you aren't willing to be responsible for them.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
38. Structured Programming supports the law of the excluded middle.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
108. Whenever two programmers meet to criticize their programs, both are silent.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
12. Recursion is the root of computation since it trades description for time.
7. It is easier to write an incorrect program than understand a correct one.
63. When we write programs that "learn", it turns out that we do and they don't.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
18. A program without a loop and a structured variable isn't worth writing.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
12. Recursion is the root of computation since it trades description for time.
112. Computer Science is embarrassed by the computer.
119. Programming is an unnatural act.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
102. One can't proceed from the informal to the formal by formal means.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
100. We will never run out of things to program as long as there is a single program around.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
40. There are two ways to write error-free programs; only the third one works.
79. A year spent in artificial intelligence is enough to make one believe in God.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
96. Computers don't introduce order anywhere as much as they expose opportunities.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
5. If a program manipulates a large amount of data, it does so in a small number of ways.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
41. Some programming languages manage to absorb change, but withstand progress.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
57. It is easier to change the specification to fit the program than vice versa.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
111. Why did the Roman Empire collapse? What is Latin for office automation?
1. One man's constant is another man's variable.
18. A program without a loop and a structured variable isn't worth writing.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
108. Whenever two programmers meet to criticize their programs, both are silent.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
40. There are two ways to write error-free programs; only the third one works.
38. Structured Programming supports the law of the excluded middle.
27. Once you understand how to write a program get someone else to write it.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
76. It is the user who should parameterize procedures, not their creators.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
96. Computers don't introduce order anywhere as much as they expose opportunities.
59. In English every word can be verbed. Would that it were so in our programming languages.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
111. Why did the Roman Empire collapse? What is Latin for office automation?
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
40. There are two ways to write error-free programs; only the third one works.
90. Computation has made the tree flower.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
63. When we write programs that "learn", it turns out that we do and they don't.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
57. It is easier to change the specification to fit the program than vice versa.
100. We will never run out of things to program as long as there is a single program around.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
4. Every program is a part of some other program and rarely fits.
27. Once you understand how to write a program get someone else to write it.
98. In computing, the mean time to failure keeps getting shorter.
96. Computers don't introduce order anywhere as much as they expose opportunities.
31. Simplicity does not precede complexity, but follows it.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
1. One man's constant is another man's variable.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
7. It is easier to write an incorrect program than understand a correct one.
115. Most people find the concept of programming obvious, but the doing impossible.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
7. It is easier to write an incorrect program than understand a correct one.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
90. Computation has made the tree flower.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
90. Computation has made the tree flower.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
1. One man's constant is another man's variable.
59. In English every word can be verbed. Would that it were so in our programming languages.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
79. A year spent in artificial intelligence is enough to make one believe in God.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
115. Most people find the concept of programming obvious, but the doing impossible.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
43. In software systems, it is often the early bird that makes the worm.
115. Most people find the concept of programming obvious, but the doing impossible.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
100. We will never run out of things to program as long as there is a single program around.
76. It is the user who should parameterize procedures, not their creators.
102. One can't proceed from the informal to the formal by formal means.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
1. One man's constant is another man's variable.
78. If your computer speaks English, it was probably made in Japan.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
108. Whenever two programmers meet to criticize their programs, both are silent.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
114. Within a computer natural language is unnatural.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
104. The proof of a system's value is its existence.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
102. One can't proceed from the informal to the formal by formal means.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
61. In programming, as in everything else, to be in error is to be reborn.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
72. An adequate bootstrap is a contradiction in terms.
62. In computing, invariants are ephemeral.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
103. Purely applicative languages are poorly applicable.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
110. Editing is a rewording activity.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
103. Purely applicative languages are poorly applicable.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
112. Computer Science is embarrassed by the computer.
17. If a listener nods his head when you're explaining your program, wake him up.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
61. In programming, as in everything else, to be in error is to be reborn.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
12. Recursion is the root of computation since it trades description for time.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
17. If a listener nods his head when you're explaining your program, wake him up.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
22. A good system can't have a weak command language.
43. In software systems, it is often the early bird that makes the worm.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
11. If you have a procedure with ten parameters, you probably missed some.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
60. In seeking the unattainable, simplicity only gets in the way.
14. In the long run every program becomes rococo - then rubble.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
21. Optimization hinders evolution.
18. A program without a loop and a structured variable isn't worth writing.
4. Every program is a part of some other program and rarely fits.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
27. Once you understand how to write a program get someone else to write it.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
41. Some programming languages manage to absorb change, but withstand progress.
114. Within a computer natural language is unnatural.
11. If you have a procedure with ten parameters, you probably missed some.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
63. When we write programs that "learn", it turns out that we do and they don't.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
78. If your computer speaks English, it was probably made in Japan.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
60. In seeking the unattainable, simplicity only gets in the way.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
105. You can't communicate complexity, only an awareness of it.
4. Every program is a part of some other program and rarely fits.
22. A good system can't have a weak command language.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
8. A programming language is low level when its programs require attention to the irrelevant.
115. Most people find the concept of programming obvious, but the doing impossible.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
79. A year spent in artificial intelligence is enough to make one believe in God.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
38. Structured Programming supports the law of the excluded middle.
46. Like punning, programming is a play on words.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
57. It is easier to change the specification to fit the program than vice versa.
79. A year spent in artificial intelligence is enough to make one believe in God.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
38. Structured Programming supports the law of the excluded middle.
4. Every program is a part of some other program and rarely fits.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
40. There are two ways to write error-free programs; only the third one works.
57. It is easier to change the specification to fit the program than vice versa.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
62. In computing, invariants are ephemeral.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
60. In seeking the unattainable, simplicity only gets in the way.
104. The proof of a system's value is its existence.
47. As Will Rogers would have said, "There is no such thing as a free variable."
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
23. To understand a program you must become both the machine and the program.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
31. Simplicity does not precede complexity, but follows it.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
15. Everything should be built top-down, except the first time.
1. One man's constant is another man's variable.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
108. Whenever two programmers meet to criticize their programs, both are silent.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
27. Once you understand how to write a program get someone else to write it.
76. It is the user who should parameterize procedures, not their creators.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
66. Making something variable is easy. Controlling duration of constancy is the trick.
72. An adequate bootstrap is a contradiction in terms.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
11. If you have a procedure with ten parameters, you probably missed some.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
21. Optimization hinders evolution.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
76. It is the user who should parameterize procedures, not their creators.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
4. Every program is a part of some other program and rarely fits.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
38. Structured Programming supports the law of the excluded middle.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
31. Simplicity does not precede complexity, but follows it.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
76. It is the user who should parameterize procedures, not their creators.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
22. A good system can't have a weak command language.
31. Simplicity does not precede complexity, but follows it.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
76. It is the user who should parameterize procedures, not their creators.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
15. Everything should be built top-down, except the first time.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
18. A program without a loop and a structured variable isn't worth writing.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
61. In programming, as in everything else, to be in error is to be reborn.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
108. Whenever two programmers meet to criticize their programs, both are silent.
12. Recursion is the root of computation since it trades description for time.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
11. If you have a procedure with ten parameters, you probably missed some.
63. When we write programs that "learn", it turns out that we do and they don't.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
38. Structured Programming supports the law of the excluded middle.
112. Computer Science is embarrassed by the computer.
21. Optimization hinders evolution.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
72. An adequate bootstrap is a contradiction in terms.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
23. To understand a program you must become both the machine and the program.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
103. Purely applicative languages are poorly applicable.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
66. Making something variable is easy. Controlling duration of constancy is the trick.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
115. Most people find the concept of programming obvious, but the doing impossible.
60. In seeking the unattainable, simplicity only gets in the way.
103. Purely applicative languages are poorly applicable.
61. In programming, as in everything else, to be in error is to be reborn.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
43. In software systems, it is often the early bird that makes the worm.
38. Structured Programming supports the law of the excluded middle.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
95. Don't have good ideas if you aren't willing to be responsible for them.
79. A year spent in artificial intelligence is enough to make one believe in God.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
41. Some programming languages manage to absorb change, but withstand progress.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
3. Syntactic sugar causes cancer of the semicolon.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
59. In English every word can be verbed. Would that it were so in our programming languages.
61. In programming, as in everything else, to be in error is to be reborn.
79. A year spent in artificial intelligence is enough to make one believe in God.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
46. Like punning, programming is a play on words.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
12. Recursion is the root of computation since it trades description for time.
78. If your computer speaks English, it was probably made in Japan.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
110. Editing is a rewording activity.
14. In the long run every program becomes rococo - then rubble.
60. In seeking the unattainable, simplicity only gets in the way.
40. There are two ways to write error-free programs; only the third one works.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
102. One can't proceed from the informal to the formal by formal means.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
95. Don't have good ideas if you aren't willing to be responsible for them.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
4. Every program is a part of some other program and rarely fits.
14. In the long run every program becomes rococo - then rubble.
90. Computation has made the tree flower.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
62. In computing, invariants are ephemeral.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
100. We will never run out of things to program as long as there is a single program around.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
19. A language that doesn't affect the way you think about programming, is not worth knowing.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
15. Everything should be built top-down, except the first time.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
7. It is easier to write an incorrect program than understand a correct one.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
100. We will never run out of things to program as long as there is a single program around.
14. In the long run every program becomes rococo - then rubble.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
18. A program without a loop and a structured variable isn't worth writing.
62. In computing, invariants are ephemeral.
11. If you have a procedure with ten parameters, you probably missed some.
46. Like punning, programming is a play on words.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
8. A programming language is low level when its programs require attention to the irrelevant.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
79. A year spent in artificial intelligence is enough to make one believe in God.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
115. Most people find the concept of programming obvious, but the doing impossible.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
41. Some programming languages manage to absorb change, but withstand progress.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
40. There are two ways to write error-free programs; only the third one works.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
110. Editing is a rewording activity.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
115. Most people find the concept of programming obvious, but the doing impossible.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
41. Some programming languages manage to absorb change, but withstand progress.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
102. One can't proceed from the informal to the formal by formal means.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
119. Programming is an unnatural act.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
112. Computer Science is embarrassed by the computer.
78. If your computer speaks English, it was probably made in Japan.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
3. Syntactic sugar causes cancer of the semicolon.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
104. The proof of a system's value is its existence.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
38. Structured Programming supports the law of the excluded middle.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
59. In English every word can be verbed. Would that it were so in our programming languages.
17. If a listener nods his head when you're explaining your program, wake him up.
15. Everything should be built top-down, except the first time.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
104. The proof of a system's value is its existence.
111. Why did the Roman Empire collapse? What is Latin for office automation?
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
66. Making something variable is easy. Controlling duration of constancy is the trick.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
63. When we write programs that "learn", it turns out that we do and they don't.
14. In the long run every program becomes rococo - then rubble.
12. Recursion is the root of computation since it trades description for time.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
100. We will never run out of things to program as long as there is a single program around.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
41. Some programming languages manage to absorb change, but withstand progress.
3. Syntactic sugar causes cancer of the semicolon.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
4. Every program is a part of some other program and rarely fits.
60. In seeking the unattainable, simplicity only gets in the way.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
41. Some programming languages manage to absorb change, but withstand progress.
59. In English every word can be verbed. Would that it were so in our programming languages.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
62. In computing, invariants are ephemeral.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
11. If you have a procedure with ten parameters, you probably missed some.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
105. You can't communicate complexity, only an awareness of it.
98. In computing, the mean time to failure keeps getting shorter.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
7. It is easier to write an incorrect program than understand a correct one.
18. A program without a loop and a structured variable isn't worth writing.
66. Making something variable is easy. Controlling duration of constancy is the trick.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
46. Like punning, programming is a play on words.
40. There are two ways to write error-free programs; only the third one works.
43. In software systems, it is often the early bird that makes the worm.
108. Whenever two programmers meet to criticize their programs, both are silent.
108. Whenever two programmers meet to criticize their programs, both are silent.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
27. Once you understand how to write a program get someone else to write it.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
40. There are two ways to write error-free programs; only the third one works.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
60. In seeking the unattainable, simplicity only gets in the way.
57. It is easier to change the specification to fit the program than vice versa.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
57. It is easier to change the specification to fit the program than vice versa.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
100. We will never run out of things to program as long as there is a single program around.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
18. A program without a loop and a structured variable isn't worth writing.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
1. One man's constant is another man's variable.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
59. In English every word can be verbed. Would that it were so in our programming languages.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
96. Computers don't introduce order anywhere as much as they expose opportunities.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
31. Simplicity does not precede complexity, but follows it.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
40. There are two ways to write error-free programs; only the third one works.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
4. Every program is a part of some other program and rarely fits.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
1. One man's constant is another man's variable.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
112. Computer Science is embarrassed by the computer.
3. Syntactic sugar causes cancer of the semicolon.
47. As Will Rogers would have said, "There is no such thing as a free variable."
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
100. We will never run out of things to program as long as there is a single program around.
57. It is easier to change the specification to fit the program than vice versa.
115. Most people find the concept of programming obvious, but the doing impossible.
3. Syntactic sugar causes cancer of the semicolon.
27. Once you understand how to write a program get someone else to write it.
114. Within a computer natural language is unnatural.
1. One man's constant is another man's variable.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
102. One can't proceed from the informal to the formal by formal means.
31. Simplicity does not precede complexity, but follows it.
96. Computers don't introduce order anywhere as much as they expose opportunities.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
4. Every program is a part of some other program and rarely fits.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
59. In English every word can be verbed. Would that it were so in our programming languages.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
102. One can't proceed from the informal to the formal by formal means.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
43. In software systems, it is often the early bird that makes the worm.
79. A year spent in artificial intelligence is enough to make one believe in God.
22. A good system can't have a weak command language.
104. The proof of a system's value is its existence.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
57. It is easier to change the specification to fit the program than vice versa.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
17. If a listener nods his head when you're explaining your program, wake him up.
7. It is easier to write an incorrect program than understand a correct one.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
1. One man's constant is another man's variable.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
115. Most people find the concept of programming obvious, but the doing impossible.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
38. Structured Programming supports the law of the excluded middle.
31. Simplicity does not precede complexity, but follows it.
105. You can't communicate complexity, only an awareness of it.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
60. In seeking the unattainable, simplicity only gets in the way.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
23. To understand a program you must become both the machine and the program.
11. If you have a procedure with ten parameters, you probably missed some.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
108. Whenever two programmers meet to criticize their programs, both are silent.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
63. When we write programs that "learn", it turns out that we do and they don't.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
22. A good system can't have a weak command language.
22. A good system can't have a weak command language.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
23. To understand a program you must become both the machine and the program.
15. Everything should be built top-down, except the first time.
76. It is the user who should parameterize procedures, not their creators.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
40. There are two ways to write error-free programs; only the third one works.
115. Most people find the concept of programming obvious, but the doing impossible.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
105. You can't communicate complexity, only an awareness of it.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
90. Computation has made the tree flower.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
115. Most people find the concept of programming obvious, but the doing impossible.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
17. If a listener nods his head when you're explaining your program, wake him up.
46. Like punning, programming is a play on words.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
40. There are two ways to write error-free programs; only the third one works.
41. Some programming languages manage to absorb change, but withstand progress.
18. A program without a loop and a structured variable isn't worth writing.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
47. As Will Rogers would have said, "There is no such thing as a free variable."
31. Simplicity does not precede complexity, but follows it.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
76. It is the user who should parameterize procedures, not their creators.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
12. Recursion is the root of computation since it trades description for time.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
111. Why did the Roman Empire collapse? What is Latin for office automation?
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
11. If you have a procedure with ten parameters, you probably missed some.
102. One can't proceed from the informal to the formal by formal means.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
60. In seeking the unattainable, simplicity only gets in the way.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
66. Making something variable is easy. Controlling duration of constancy is the trick.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
43. In software systems, it is often the early bird that makes the worm.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
59. In English every word can be verbed. Would that it were so in our programming languages.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
62. In computing, invariants are ephemeral.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
110. Editing is a rewording activity.
15. Everything should be built top-down, except the first time.
41. Some programming languages manage to absorb change, but withstand progress.
79. A year spent in artificial intelligence is enough to make one believe in God.
115. Most people find the concept of programming obvious, but the doing impossible.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
31. Simplicity does not precede complexity, but follows it.
66. Making something variable is easy. Controlling duration of constancy is the trick.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
102. One can't proceed from the informal to the formal by formal means.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
119. Programming is an unnatural act.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
57. It is easier to change the specification to fit the program than vice versa.
14. In the long run every program becomes rococo - then rubble.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
60. In seeking the unattainable, simplicity only gets in the way.
98. In computing, the mean time to failure keeps getting shorter.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
55. A LISP programmer knows the value of everything, but the cost of nothing.
18. A program without a loop and a structured variable isn't worth writing.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
98. In computing, the mean time to failure keeps getting shorter.
27. Once you understand how to write a program get someone else to write it.
112. Computer Science is embarrassed by the computer.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
104. The proof of a system's value is its existence.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
63. When we write programs that "learn", it turns out that we do and they don't.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
27. Once you understand how to write a program get someone else to write it.
60. In seeking the unattainable, simplicity only gets in the way.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
114. Within a computer natural language is unnatural.
112. Computer Science is embarrassed by the computer.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
98. In computing, the mean time to failure keeps getting shorter.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
38. Structured Programming supports the law of the excluded middle.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
119. Programming is an unnatural act.
59. In English every word can be verbed. Would that it were so in our programming languages.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
17. If a listener nods his head when you're explaining your program, wake him up.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
79. A year spent in artificial intelligence is enough to make one believe in God.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
18. A program without a loop and a structured variable isn't worth writing.
1. One man's constant is another man's variable.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
17. If a listener nods his head when you're explaining your program, wake him up.
96. Computers don't introduce order anywhere as much as they expose opportunities.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
96. Computers don't introduce order anywhere as much as they expose opportunities.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
103. Purely applicative languages are poorly applicable.
72. An adequate bootstrap is a contradiction in terms.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
60. In seeking the unattainable, simplicity only gets in the way.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
110. Editing is a rewording activity.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
76. It is the user who should parameterize procedures, not their creators.
111. Why did the Roman Empire collapse? What is Latin for office automation?
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
7. It is easier to write an incorrect program than understand a correct one.
100. We will never run out of things to program as long as there is a single program around.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
57. It is easier to change the specification to fit the program than vice versa.
22. A good system can't have a weak command language.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
105. You can't communicate complexity, only an awareness of it.
14. In the long run every program becomes rococo - then rubble.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
103. Purely applicative languages are poorly applicable.
111. Why did the Roman Empire collapse? What is Latin for office automation?
1. One man's constant is another man's variable.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
103. Purely applicative languages are poorly applicable.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
79. A year spent in artificial intelligence is enough to make one believe in God.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
96. Computers don't introduce order anywhere as much as they expose opportunities.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
43. In software systems, it is often the early bird that makes the worm.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
55. A LISP programmer knows the value of everything, but the cost of nothing.
100. We will never run out of things to program as long as there is a single program around.
55. A LISP programmer knows the value of everything, but the cost of nothing.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
111. Why did the Roman Empire collapse? What is Latin for office automation?
5. If a program manipulates a large amount of data, it does so in a small number of ways.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
79. A year spent in artificial intelligence is enough to make one believe in God.
98. In computing, the mean time to failure keeps getting shorter.
3. Syntactic sugar causes cancer of the semicolon.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
1. One man's constant is another man's variable.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
55. A LISP programmer knows the value of everything, but the cost of nothing.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
76. It is the user who should parameterize procedures, not their creators.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
17. If a listener nods his head when you're explaining your program, wake him up.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
110. Editing is a rewording activity.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
22. A good system can't have a weak command language.
27. Once you understand how to write a program get someone else to write it.
119. Programming is an unnatural act.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
79. A year spent in artificial intelligence is enough to make one believe in God.
22. A good system can't have a weak command language.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
78. If your computer speaks English, it was probably made in Japan.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
7. It is easier to write an incorrect program than understand a correct one.
105. You can't communicate complexity, only an awareness of it.
12. Recursion is the root of computation since it trades description for time.
46. Like punning, programming is a play on words.
102. One can't proceed from the informal to the formal by formal means.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
115. Most people find the concept of programming obvious, but the doing impossible.
108. Whenever two programmers meet to criticize their programs, both are silent.
114. Within a computer natural language is unnatural.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
18. A program without a loop and a structured variable isn't worth writing.
60. In seeking the unattainable, simplicity only gets in the way.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
62. In computing, invariants are ephemeral.
40. There are two ways to write error-free programs; only the third one works.
104. The proof of a system's value is its existence.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
59. In English every word can be verbed. Would that it were so in our programming languages.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
100. We will never run out of things to program as long as there is a single program around.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
1. One man's constant is another man's variable.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
17. If a listener nods his head when you're explaining your program, wake him up.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
115. Most people find the concept of programming obvious, but the doing impossible.
61. In programming, as in everything else, to be in error is to be reborn.
3. Syntactic sugar causes cancer of the semicolon.
96. Computers don't introduce order anywhere as much as they expose opportunities.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
100. We will never run out of things to program as long as there is a single program around.
27. Once you understand how to write a program get someone else to write it.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
1. One man's constant is another man's variable.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
115. Most people find the concept of programming obvious, but the doing impossible.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
61. In programming, as in everything else, to be in error is to be reborn.
46. Like punning, programming is a play on words.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
110. Editing is a rewording activity.
43. In software systems, it is often the early bird that makes the worm.
100. We will never run out of things to program as long as there is a single program around.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
21. Optimization hinders evolution.
104. The proof of a system's value is its existence.
98. In computing, the mean time to failure keeps getting shorter.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
100. We will never run out of things to program as long as there is a single program around.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
31. Simplicity does not precede complexity, but follows it.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
105. You can't communicate complexity, only an awareness of it.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
27. Once you understand how to write a program get someone else to write it.
11. If you have a procedure with ten parameters, you probably missed some.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
21. Optimization hinders evolution.
18. A program without a loop and a structured variable isn't worth writing.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
38. Structured Programming supports the law of the excluded middle.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
59. In English every word can be verbed. Would that it were so in our programming languages.
4. Every program is a part of some other program and rarely fits.
57. It is easier to change the specification to fit the program than vice versa.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
12. Recursion is the root of computation since it trades description for time.
61. In programming, as in everything else, to be in error is to be reborn.
55. A LISP programmer knows the value of everything, but the cost of nothing.
14. In the long run every program becomes rococo - then rubble.
98. In computing, the mean time to failure keeps getting shorter.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
43. In software systems, it is often the early bird that makes the worm.
11. If you have a procedure with ten parameters, you probably missed some.
15. Everything should be built top-down, except the first time.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
11. If you have a procedure with ten parameters, you probably missed some.
4. Every program is a part of some other program and rarely fits.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
14. In the long run every program becomes rococo - then rubble.
17. If a listener nods his head when you're explaining your program, wake him up.
3. Syntactic sugar causes cancer of the semicolon.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
4. Every program is a part of some other program and rarely fits.
14. In the long run every program becomes rococo - then rubble.
47. As Will Rogers would have said, "There is no such thing as a free variable."
76. It is the user who should parameterize procedures, not their creators.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
4. Every program is a part of some other program and rarely fits.
96. Computers don't introduce order anywhere as much as they expose opportunities.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
111. Why did the Roman Empire collapse? What is Latin for office automation?
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
14. In the long run every program becomes rococo - then rubble.
47. As Will Rogers would have said, "There is no such thing as a free variable."
119. Programming is an unnatural act.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
14. In the long run every program becomes rococo - then rubble.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
12. Recursion is the root of computation since it trades description for time.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
111. Why did the Roman Empire collapse? What is Latin for office automation?
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
76. It is the user who should parameterize procedures, not their creators.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
38. Structured Programming supports the law of the excluded middle.
3. Syntactic sugar causes cancer of the semicolon.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
103. Purely applicative languages are poorly applicable.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
43. In software systems, it is often the early bird that makes the worm.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
90. Computation has made the tree flower.
63. When we write programs that "learn", it turns out that we do and they don't.
59. In English every word can be verbed. Would that it were so in our programming languages.
102. One can't proceed from the informal to the formal by formal means.
46. Like punning, programming is a play on words.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
14. In the long run every program becomes rococo - then rubble.
17. If a listener nods his head when you're explaining your program, wake him up.
7. It is easier to write an incorrect program than understand a correct one.
115. Most people find the concept of programming obvious, but the doing impossible.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
100. We will never run out of things to program as long as there is a single program around.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
22. A good system can't have a weak command language.
66. Making something variable is easy. Controlling duration of constancy is the trick.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
112. Computer Science is embarrassed by the computer.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
103. Purely applicative languages are poorly applicable.
111. Why did the Roman Empire collapse? What is Latin for office automation?
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
114. Within a computer natural language is unnatural.
119. Programming is an unnatural act.
43. In software systems, it is often the early bird that makes the worm.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
61. In programming, as in everything else, to be in error is to be reborn.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
66. Making something variable is easy. Controlling duration of constancy is the trick.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
110. Editing is a rewording activity.
41. Some programming languages manage to absorb change, but withstand progress.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
104. The proof of a system's value is its existence.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
22. A good system can't have a weak command language.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
27. Once you understand how to write a program get someone else to write it.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
40. There are two ways to write error-free programs; only the third one works.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
76. It is the user who should parameterize procedures, not their creators.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
40. There are two ways to write error-free programs; only the third one works.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
114. Within a computer natural language is unnatural.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
38. Structured Programming supports the law of the excluded middle.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
104. The proof of a system's value is its existence.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
3. Syntactic sugar causes cancer of the semicolon.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
40. There are two ways to write error-free programs; only the third one works.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
119. Programming is an unnatural act.
72. An adequate bootstrap is a contradiction in terms.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
107. The debate rages on: is PL/I Bachtrian or Dromedary?
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
31. Simplicity does not precede complexity, but follows it.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
105. You can't communicate complexity, only an awareness of it.
7. It is easier to write an incorrect program than understand a correct one.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
21. Optimization hinders evolution.
47. As Will Rogers would have said, "There is no such thing as a free variable."
41. Some programming languages manage to absorb change, but withstand progress.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
57. It is easier to change the specification to fit the program than vice versa.
57. It is easier to change the specification to fit the program than vice versa.
41. Some programming languages manage to absorb change, but withstand progress.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
27. Once you understand how to write a program get someone else to write it.
115. Most people find the concept of programming obvious, but the doing impossible.
72. An adequate bootstrap is a contradiction in terms.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
18. A program without a loop and a structured variable isn't worth writing.
111. Why did the Roman Empire collapse? What is Latin for office automation?
14. In the long run every program becomes rococo - then rubble.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
21. Optimization hinders evolution.
98. In computing, the mean time to failure keeps getting shorter.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
79. A year spent in artificial intelligence is enough to make one believe in God.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
111. Why did the Roman Empire collapse? What is Latin for office automation?
61. In programming, as in everything else, to be in error is to be reborn.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
43. In software systems, it is often the early bird that makes the worm.
61. In programming, as in everything else, to be in error is to be reborn.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
40. There are two ways to write error-free programs; only the third one works.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
27. Once you understand how to write a program get someone else to write it.
112. Computer Science is embarrassed by the computer.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
38. Structured Programming supports the law of the excluded middle.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
66. Making something variable is easy. Controlling duration of constancy is the trick.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
43. In software systems, it is often the early bird that makes the worm.
59. In English every word can be verbed. Would that it were so in our programming languages.
43. In software systems, it is often the early bird that makes the worm.
22. A good system can't have a weak command language.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
11. If you have a procedure with ten parameters, you probably missed some.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
104. The proof of a system's value is its existence.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
17. If a listener nods his head when you're explaining your program, wake him up.
3. Syntactic sugar causes cancer of the semicolon.
100. We will never run out of things to program as long as there is a single program around.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
72. An adequate bootstrap is a contradiction in terms.
90. Computation has made the tree flower.
17. If a listener nods his head when you're explaining your program, wake him up.
47. As Will Rogers would have said, "There is no such thing as a free variable."
7. It is easier to write an incorrect program than understand a correct one.
41. Some programming languages manage to absorb change, but withstand progress.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
1. One man's constant is another man's variable.
14. In the long run every program becomes rococo - then rubble.
59. In English every word can be verbed. Would that it were so in our programming languages.
15. Everything should be built top-down, except the first time.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
95. Don't have good ideas if you aren't willing to be responsible for them.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
3. Syntactic sugar causes cancer of the semicolon.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
18. A program without a loop and a structured variable isn't worth writing.
119. Programming is an unnatural act.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
62. In computing, invariants are ephemeral.
47. As Will Rogers would have said, "There is no such thing as a free variable."
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
66. Making something variable is easy. Controlling duration of constancy is the trick.
111. Why did the Roman Empire collapse? What is Latin for office automation?
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
108. Whenever two programmers meet to criticize their programs, both are silent.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
15. Everything should be built top-down, except the first time.
112. Computer Science is embarrassed by the computer.
119. Programming is an unnatural act.
112. Computer Science is embarrassed by the computer.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
79. A year spent in artificial intelligence is enough to make one believe in God.
12. Recursion is the root of computation since it trades description for time.
17. If a listener nods his head when you're explaining your program, wake him up.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
47. As Will Rogers would have said, "There is no such thing as a free variable."
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
17. If a listener nods his head when you're explaining your program, wake him up.
105. You can't communicate complexity, only an awareness of it.
18. A program without a loop and a structured variable isn't worth writing.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
78. If your computer speaks English, it was probably made in Japan.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
79. A year spent in artificial intelligence is enough to make one believe in God.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
62. In computing, invariants are ephemeral.
111. Why did the Roman Empire collapse? What is Latin for office automation?
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
103. Purely applicative languages are poorly applicable.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
78. If your computer speaks English, it was probably made in Japan.
90. Computation has made the tree flower.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
18. A program without a loop and a structured variable isn't worth writing.
66. Making something variable is easy. Controlling duration of constancy is the trick.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
15. Everything should be built top-down, except the first time.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
15. Everything should be built top-down, except the first time.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
104. The proof of a system's value is its existence.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
119. Programming is an unnatural act.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
46. Like punning, programming is a play on words.
31. Simplicity does not precede complexity, but follows it.
76. It is the user who should parameterize procedures, not their creators.
104. The proof of a system's value is its existence.
103. Purely applicative languages are poorly applicable.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
47. As Will Rogers would have said, "There is no such thing as a free variable."
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
62. In computing, invariants are ephemeral.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
95. Don't have good ideas if you aren't willing to be responsible for them.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
96. Computers don't introduce order anywhere as much as they expose opportunities.
108. Whenever two programmers meet to criticize their programs, both are silent.
115. Most people find the concept of programming obvious, but the doing impossible.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
12. Recursion is the root of computation since it trades description for time.
79. A year spent in artificial intelligence is enough to make one believe in God.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
18. A program without a loop and a structured variable isn't worth writing.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
47. As Will Rogers would have said, "There is no such thing as a free variable."
115. Most people find the concept of programming obvious, but the doing impossible.
57. It is easier to change the specification to fit the program than vice versa.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
12. Recursion is the root of computation since it trades description for time.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
57. It is easier to change the specification to fit the program than vice versa.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
62. In computing, invariants are ephemeral.
110. Editing is a rewording activity.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
104. The proof of a system's value is its existence.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
21. Optimization hinders evolution.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
119. Programming is an unnatural act.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
1. One man's constant is another man's variable.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
40. There are two ways to write error-free programs; only the third one works.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
115. Most people find the concept of programming obvious, but the doing impossible.
40. There are two ways to write error-free programs; only the third one works.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
7. It is easier to write an incorrect program than understand a correct one.
104. The proof of a system's value is its existence.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
61. In programming, as in everything else, to be in error is to be reborn.
59. In English every word can be verbed. Would that it were so in our programming languages.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
103. Purely applicative languages are poorly applicable.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
38. Structured Programming supports the law of the excluded middle.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
21. Optimization hinders evolution.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
76. It is the user who should parameterize procedures, not their creators.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
43. In software systems, it is often the early bird that makes the worm.
79. A year spent in artificial intelligence is enough to make one believe in God.
96. Computers don't introduce order anywhere as much as they expose opportunities.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
15. Everything should be built top-down, except the first time.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
47. As Will Rogers would have said, "There is no such thing as a free variable."
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
100. We will never run out of things to program as long as there is a single program around.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
104. The proof of a system's value is its existence.
102. One can't proceed from the informal to the formal by formal means.
38. Structured Programming supports the law of the excluded middle.
63. When we write programs that "learn", it turns out that we do and they don't.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
110. Editing is a rewording activity.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
41. Some programming languages manage to absorb change, but withstand progress.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
96. Computers don't introduce order anywhere as much as they expose opportunities.
31. Simplicity does not precede complexity, but follows it.
40. There are two ways to write error-free programs; only the third one works.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
17. If a listener nods his head when you're explaining your program, wake him up.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
12. Recursion is the root of computation since it trades description for time.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
76. It is the user who should parameterize procedures, not their creators.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
76. It is the user who should parameterize procedures, not their creators.
41. Some programming languages manage to absorb change, but withstand progress.
1. One man's constant is another man's variable.
90. Computation has made the tree flower.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
18. A program without a loop and a structured variable isn't worth writing.
102. One can't proceed from the informal to the formal by formal means.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
115. Most people find the concept of programming obvious, but the doing impossible.
41. Some programming languages manage to absorb change, but withstand progress.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
31. Simplicity does not precede complexity, but follows it.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
17. If a listener nods his head when you're explaining your program, wake him up.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
105. You can't communicate complexity, only an awareness of it.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
98. In computing, the mean time to failure keeps getting shorter.
114. Within a computer natural language is unnatural.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
46. Like punning, programming is a play on words.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
79. A year spent in artificial intelligence is enough to make one believe in God.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
12. Recursion is the root of computation since it trades description for time.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
11. If you have a procedure with ten parameters, you probably missed some.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
112. Computer Science is embarrassed by the computer.
17. If a listener nods his head when you're explaining your program, wake him up.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
43. In software systems, it is often the early bird that makes the worm.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
3. Syntactic sugar causes cancer of the semicolon.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
15. Everything should be built top-down, except the first time.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
119. Programming is an unnatural act.
3. Syntactic sugar causes cancer of the semicolon.
66. Making something variable is easy. Controlling duration of constancy is the trick.
17. If a listener nods his head when you're explaining your program, wake him up.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
12. Recursion is the root of computation since it trades description for time.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
22. A good system can't have a weak command language.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
104. The proof of a system's value is its existence.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
21. Optimization hinders evolution.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
60. In seeking the unattainable, simplicity only gets in the way.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
103. Purely applicative languages are poorly applicable.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
1. One man's constant is another man's variable.
59. In English every word can be verbed. Would that it were so in our programming languages.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
46. Like punning, programming is a play on words.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
41. Some programming languages manage to absorb change, but withstand progress.
96. Computers don't introduce order anywhere as much as they expose opportunities.
102. One can't proceed from the informal to the formal by formal means.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
12. Recursion is the root of computation since it trades description for time.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
23. To understand a program you must become both the machine and the program.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
90. Computation has made the tree flower.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
12. Recursion is the root of computation since it trades description for time.
47. As Will Rogers would have said, "There is no such thing as a free variable."
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
108. Whenever two programmers meet to criticize their programs, both are silent.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
31. Simplicity does not precede complexity, but follows it.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
18. A program without a loop and a structured variable isn't worth writing.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
55. A LISP programmer knows the value of everything, but the cost of nothing.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
96. Computers don't introduce order anywhere as much as they expose opportunities.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
15. Everything should be built top-down, except the first time.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
15. Everything should be built top-down, except the first time.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
27. Once you understand how to write a program get someone else to write it.
11. If you have a procedure with ten parameters, you probably missed some.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
95. Don't have good ideas if you aren't willing to be responsible for them.
114. Within a computer natural language is unnatural.
115. Most people find the concept of programming obvious, but the doing impossible.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
11. If you have a procedure with ten parameters, you probably missed some.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
72. An adequate bootstrap is a contradiction in terms.
59. In English every word can be verbed. Would that it were so in our programming languages.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
31. Simplicity does not precede complexity, but follows it.
43. In software systems, it is often the early bird that makes the worm.
57. It is easier to change the specification to fit the program than vice versa.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
119. Programming is an unnatural act.
115. Most people find the concept of programming obvious, but the doing impossible.
104. The proof of a system's value is its existence.
41. Some programming languages manage to absorb change, but withstand progress.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
38. Structured Programming supports the law of the excluded middle.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
1. One man's constant is another man's variable.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
104. The proof of a system's value is its existence.
59. In English every word can be verbed. Would that it were so in our programming languages.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
103. Purely applicative languages are poorly applicable.
17. If a listener nods his head when you're explaining your program, wake him up.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
47. As Will Rogers would have said, "There is no such thing as a free variable."
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
59. In English every word can be verbed. Would that it were so in our programming languages.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
102. One can't proceed from the informal to the formal by formal means.
66. Making something variable is easy. Controlling duration of constancy is the trick.
15. Everything should be built top-down, except the first time.
102. One can't proceed from the informal to the formal by formal means.
112. Computer Science is embarrassed by the computer.
23. To understand a program you must become both the machine and the program.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
105. You can't communicate complexity, only an awareness of it.
62. In computing, invariants are ephemeral.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
76. It is the user who should parameterize procedures, not their creators.
57. It is easier to change the specification to fit the program than vice versa.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
55. A LISP programmer knows the value of everything, but the cost of nothing.
95. Don't have good ideas if you aren't willing to be responsible for them.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
47. As Will Rogers would have said, "There is no such thing as a free variable."
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
15. Everything should be built top-down, except the first time.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
38. Structured Programming supports the law of the excluded middle.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
63. When we write programs that "learn", it turns out that we do and they don't.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
23. To understand a program you must become both the machine and the program.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
7. It is easier to write an incorrect program than understand a correct one.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
1. One man's constant is another man's variable.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
47. As Will Rogers would have said, "There is no such thing as a free variable."
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
98. In computing, the mean time to failure keeps getting shorter.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
55. A LISP programmer knows the value of everything, but the cost of nothing.
112. Computer Science is embarrassed by the computer.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
55. A LISP programmer knows the value of everything, but the cost of nothing.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
72. An adequate bootstrap is a contradiction in terms.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
21. Optimization hinders evolution.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
110. Editing is a rewording activity.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
17. If a listener nods his head when you're explaining your program, wake him up.
21. Optimization hinders evolution.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
4. Every program is a part of some other program and rarely fits.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
62. In computing, invariants are ephemeral.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
21. Optimization hinders evolution.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
12. Recursion is the root of computation since it trades description for time.
1. One man's constant is another man's variable.
96. Computers don't introduce order anywhere as much as they expose opportunities.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
110. Editing is a rewording activity.
11. If you have a procedure with ten parameters, you probably missed some.
78. If your computer speaks English, it was probably made in Japan.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
43. In software systems, it is often the early bird that makes the worm.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
79. A year spent in artificial intelligence is enough to make one believe in God.
102. One can't proceed from the informal to the formal by formal means.
62. In computing, invariants are ephemeral.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
119. Programming is an unnatural act.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
62. In computing, invariants are ephemeral.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
114. Within a computer natural language is unnatural.
21. Optimization hinders evolution.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
23. To understand a program you must become both the machine and the program.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
111. Why did the Roman Empire collapse? What is Latin for office automation?
27. Once you understand how to write a program get someone else to write it.
102. One can't proceed from the informal to the formal by formal means.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
1. One man's constant is another man's variable.
115. Most people find the concept of programming obvious, but the doing impossible.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
40. There are two ways to write error-free programs; only the third one works.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
8. A programming language is low level when its programs require attention to the irrelevant.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
18. A program without a loop and a structured variable isn't worth writing.
41. Some programming languages manage to absorb change, but withstand progress.
110. Editing is a rewording activity.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
57. It is easier to change the specification to fit the program than vice versa.
55. A LISP programmer knows the value of everything, but the cost of nothing.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
105. You can't communicate complexity, only an awareness of it.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
102. One can't proceed from the informal to the formal by formal means.
76. It is the user who should parameterize procedures, not their creators.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
4. Every program is a part of some other program and rarely fits.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
102. One can't proceed from the informal to the formal by formal means.
110. Editing is a rewording activity.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
3. Syntactic sugar causes cancer of the semicolon.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
96. Computers don't introduce order anywhere as much as they expose opportunities.
104. The proof of a system's value is its existence.
76. It is the user who should parameterize procedures, not their creators.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
31. Simplicity does not precede complexity, but follows it.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
7. It is easier to write an incorrect program than understand a correct one.
31. Simplicity does not precede complexity, but follows it.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
4. Every program is a part of some other program and rarely fits.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
55. A LISP programmer knows the value of everything, but the cost of nothing.
72. An adequate bootstrap is a contradiction in terms.
104. The proof of a system's value is its existence.
1. One man's constant is another man's variable.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
14. In the long run every program becomes rococo - then rubble.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
4. Every program is a part of some other program and rarely fits.
8. A programming language is low level when its programs require attention to the irrelevant.
105. You can't communicate complexity, only an awareness of it.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
95. Don't have good ideas if you aren't willing to be responsible for them.
23. To understand a program you must become both the machine and the program.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
115. Most people find the concept of programming obvious, but the doing impossible.
60. In seeking the unattainable, simplicity only gets in the way.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
103. Purely applicative languages are poorly applicable.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
78. If your computer speaks English, it was probably made in Japan.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
18. A program without a loop and a structured variable isn't worth writing.
95. Don't have good ideas if you aren't willing to be responsible for them.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
18. A program without a loop and a structured variable isn't worth writing.
59. In English every word can be verbed. Would that it were so in our programming languages.
55. A LISP programmer knows the value of everything, but the cost of nothing.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
7. It is easier to write an incorrect program than understand a correct one.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
8. A programming language is low level when its programs require attention to the irrelevant.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
5. If a program manipulates a large amount of data, it does so in a small number of ways.
98. In computing, the mean time to failure keeps getting shorter.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
1. One man's constant is another man's variable.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
104. The proof of a system's value is its existence.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
15. Everything should be built top-down, except the first time.
12. Recursion is the root of computation since it trades description for time.
40. There are two ways to write error-free programs; only the third one works.
119. Programming is an unnatural act.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
104. The proof of a system's value is its existence.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
7. It is easier to write an incorrect program than understand a correct one.
22. A good system can't have a weak command language.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
23. To understand a program you must become both the machine and the program.
17. If a listener nods his head when you're explaining your program, wake him up.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
119. Programming is an unnatural act.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
60. In seeking the unattainable, simplicity only gets in the way.
21. Optimization hinders evolution.
4. Every program is a part of some other program and rarely fits.
95. Don't have good ideas if you aren't willing to be responsible for them.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
22. A good system can't have a weak command language.
108. Whenever two programmers meet to criticize their programs, both are silent.
90. Computation has made the tree flower.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
111. Why did the Roman Empire collapse? What is Latin for office automation?
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
18. A program without a loop and a structured variable isn't worth writing.
79. A year spent in artificial intelligence is enough to make one believe in God.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
112. Computer Science is embarrassed by the computer.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
112. Computer Science is embarrassed by the computer.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
11. If you have a procedure with ten parameters, you probably missed some.
119. Programming is an unnatural act.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
102. One can't proceed from the informal to the formal by formal means.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
110. Editing is a rewording activity.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
63. When we write programs that "learn", it turns out that we do and they don't.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
11. If you have a procedure with ten parameters, you probably missed some.
72. An adequate bootstrap is a contradiction in terms.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
115. Most people find the concept of programming obvious, but the doing impossible.
18. A program without a loop and a structured variable isn't worth writing.
41. Some programming languages manage to absorb change, but withstand progress.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
119. Programming is an unnatural act.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
62. In computing, invariants are ephemeral.
79. A year spent in artificial intelligence is enough to make one believe in God.
18. A program without a loop and a structured variable isn't worth writing.
90. Computation has made the tree flower.
115. Most people find the concept of programming obvious, but the doing impossible.
78. If your computer speaks English, it was probably made in Japan.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
11. If you have a procedure with ten parameters, you probably missed some.
104. The proof of a system's value is its existence.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
95. Don't have good ideas if you aren't willing to be responsible for them.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
27. Once you understand how to write a program get someone else to write it.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
61. In programming, as in everything else, to be in error is to be reborn.
31. Simplicity does not precede complexity, but follows it.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
72. An adequate bootstrap is a contradiction in terms.
66. Making something variable is easy. Controlling duration of constancy is the trick.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
11. If you have a procedure with ten parameters, you probably missed some.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
96. Computers don't introduce order anywhere as much as they expose opportunities.
100. We will never run out of things to program as long as there is a single program around.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
78. If your computer speaks English, it was probably made in Japan.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
110. Editing is a rewording activity.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
38. Structured Programming supports the law of the excluded middle.
62. In computing, invariants are ephemeral.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
41. Some programming languages manage to absorb change, but withstand progress.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
12. Recursion is the root of computation since it trades description for time.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
114. Within a computer natural language is unnatural.
60. In seeking the unattainable, simplicity only gets in the way.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
40. There are two ways to write error-free programs; only the third one works.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
18. A program without a loop and a structured variable isn't worth writing.
79. A year spent in artificial intelligence is enough to make one believe in God.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
96. Computers don't introduce order anywhere as much as they expose opportunities.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
14. In the long run every program becomes rococo - then rubble.
59. In English every word can be verbed. Would that it were so in our programming languages.
46. Like punning, programming is a play on words.
100. We will never run out of things to program as long as there is a single program around.
17. If a listener nods his head when you're explaining your program, wake him up.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
103. Purely applicative languages are poorly applicable.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
21. Optimization hinders evolution.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
3. Syntactic sugar causes cancer of the semicolon.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
105. You can't communicate complexity, only an awareness of it.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
19. A language that doesn't affect the way you think about programming, is not worth knowing.
14. In the long run every program becomes rococo - then rubble.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
119. Programming is an unnatural act.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
72. An adequate bootstrap is a contradiction in terms.
79. A year spent in artificial intelligence is enough to make one believe in God.
112. Computer Science is embarrassed by the computer.
104. The proof of a system's value is its existence.
3. Syntactic sugar causes cancer of the semicolon.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
100. We will never run out of things to program as long as there is a single program around.
8. A programming language is low level when its programs require attention to the irrelevant.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
60. In seeking the unattainable, simplicity only gets in the way.
90. Computation has made the tree flower.
112. Computer Science is embarrassed by the computer.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
63. When we write programs that "learn", it turns out that we do and they don't.
40. There are two ways to write error-free programs; only the third one works.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
31. Simplicity does not precede complexity, but follows it.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
23. To understand a program you must become both the machine and the program.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
18. A program without a loop and a structured variable isn't worth writing.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
4. Every program is a part of some other program and rarely fits.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
43. In software systems, it is often the early bird that makes the worm.
119. Programming is an unnatural act.
100. We will never run out of things to program as long as there is a single program around.
59. In English every word can be verbed. Would that it were so in our programming languages.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
63. When we write programs that "learn", it turns out that we do and they don't.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
17. If a listener nods his head when you're explaining your program, wake him up.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
57. It is easier to change the specification to fit the program than vice versa.
40. There are two ways to write error-free programs; only the third one works.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
40. There are two ways to write error-free programs; only the third one works.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
59. In English every word can be verbed. Would that it were so in our programming languages.
59. In English every word can be verbed. Would that it were so in our programming languages.
115. Most people find the concept of programming obvious, but the doing impossible.
62. In computing, invariants are ephemeral.
66. Making something variable is easy. Controlling duration of constancy is the trick.
95. Don't have good ideas if you aren't willing to be responsible for them.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
107. The debate rages on: is PL/I Bachtrian or Dromedary?
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
60. In seeking the unattainable, simplicity only gets in the way.
17. If a listener nods his head when you're explaining your program, wake him up.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
31. Simplicity does not precede complexity, but follows it.
59. In English every word can be verbed. Would that it were so in our programming languages.
62. In computing, invariants are ephemeral.
17. If a listener nods his head when you're explaining your program, wake him up.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
72. An adequate bootstrap is a contradiction in terms.
59. In English every word can be verbed. Would that it were so in our programming languages.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
79. A year spent in artificial intelligence is enough to make one believe in God.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
100. We will never run out of things to program as long as there is a single program around.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
78. If your computer speaks English, it was probably made in Japan.
46. Like punning, programming is a play on words.
104. The proof of a system's value is its existence.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
57. It is easier to change the specification to fit the program than vice versa.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
114. Within a computer natural language is unnatural.
11. If you have a procedure with ten parameters, you probably missed some.
61. In programming, as in everything else, to be in error is to be reborn.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
22. A good system can't have a weak command language.
41. Some programming languages manage to absorb change, but withstand progress.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
18. A program without a loop and a structured variable isn't worth writing.
98. In computing, the mean time to failure keeps getting shorter.
61. In programming, as in everything else, to be in error is to be reborn.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
112. Computer Science is embarrassed by the computer.
23. To understand a program you must become both the machine and the program.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
17. If a listener nods his head when you're explaining your program, wake him up.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
111. Why did the Roman Empire collapse? What is Latin for office automation?
61. In programming, as in everything else, to be in error is to be reborn.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
119. Programming is an unnatural act.
103. Purely applicative languages are poorly applicable.
18. A program without a loop and a structured variable isn't worth writing.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
119. Programming is an unnatural act.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
3. Syntactic sugar causes cancer of the semicolon.
47. As Will Rogers would have said, "There is no such thing as a free variable."
38. Structured Programming supports the law of the excluded middle.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
59. In English every word can be verbed. Would that it were so in our programming languages.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
11. If you have a procedure with ten parameters, you probably missed some.
22. A good system can't have a weak command language.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
114. Within a computer natural language is unnatural.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
38. Structured Programming supports the law of the excluded middle.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
1. One man's constant is another man's variable.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
61. In programming, as in everything else, to be in error is to be reborn.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
38. Structured Programming supports the law of the excluded middle.
43. In software systems, it is often the early bird that makes the worm.
27. Once you understand how to write a program get someone else to write it.
95. Don't have good ideas if you aren't willing to be responsible for them.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
98. In computing, the mean time to failure keeps getting shorter.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
63. When we write programs that "learn", it turns out that we do and they don't.
111. Why did the Roman Empire collapse? What is Latin for office automation?
3. Syntactic sugar causes cancer of the semicolon.
15. Everything should be built top-down, except the first time.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
8. A programming language is low level when its programs require attention to the irrelevant.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
96. Computers don't introduce order anywhere as much as they expose opportunities.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
60. In seeking the unattainable, simplicity only gets in the way.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
47. As Will Rogers would have said, "There is no such thing as a free variable."
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
18. A program without a loop and a structured variable isn't worth writing.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
111. Why did the Roman Empire collapse? What is Latin for office automation?
22. A good system can't have a weak command language.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
100. We will never run out of things to program as long as there is a single program around.
22. A good system can't have a weak command language.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
90. Computation has made the tree flower.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
114. Within a computer natural language is unnatural.
104. The proof of a system's value is its existence.
40. There are two ways to write error-free programs; only the third one works.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
60. In seeking the unattainable, simplicity only gets in the way.
78. If your computer speaks English, it was probably made in Japan.
18. A program without a loop and a structured variable isn't worth writing.
23. To understand a program you must become both the machine and the program.
61. In programming, as in everything else, to be in error is to be reborn.
21. Optimization hinders evolution.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
102. One can't proceed from the informal to the formal by formal means.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
23. To understand a program you must become both the machine and the program.
66. Making something variable is easy. Controlling duration of constancy is the trick.
111. Why did the Roman Empire collapse? What is Latin for office automation?
19. A language that doesn't affect the way you think about programming, is not worth knowing.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
38. Structured Programming supports the law of the excluded middle.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
119. Programming is an unnatural act.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
100. We will never run out of things to program as long as there is a single program around.
79. A year spent in artificial intelligence is enough to make one believe in God.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
102. One can't proceed from the informal to the formal by formal means.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
60. In seeking the unattainable, simplicity only gets in the way.
105. You can't communicate complexity, only an awareness of it.
114. Within a computer natural language is unnatural.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
115. Most people find the concept of programming obvious, but the doing impossible.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
8. A programming language is low level when its programs require attention to the irrelevant.
59. In English every word can be verbed. Would that it were so in our programming languages.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
105. You can't communicate complexity, only an awareness of it.
1. One man's constant is another man's variable.
12. Recursion is the root of computation since it trades description for time.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
40. There are two ways to write error-free programs; only the third one works.
108. Whenever two programmers meet to criticize their programs, both are silent.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
114. Within a computer natural language is unnatural.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
21. Optimization hinders evolution.
78. If your computer speaks English, it was probably made in Japan.
1. One man's constant is another man's variable.
38. Structured Programming supports the law of the excluded middle.
23. To understand a program you must become both the machine and the program.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
100. We will never run out of things to program as long as there is a single program around.
110. Editing is a rewording activity.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
14. In the long run every program becomes rococo - then rubble.
60. In seeking the unattainable, simplicity only gets in the way.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
60. In seeking the unattainable, simplicity only gets in the way.
98. In computing, the mean time to failure keeps getting shorter.
47. As Will Rogers would have said, "There is no such thing as a free variable."
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
17. If a listener nods his head when you're explaining your program, wake him up.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
112. Computer Science is embarrassed by the computer.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
103. Purely applicative languages are poorly applicable.
21. Optimization hinders evolution.
55. A LISP programmer knows the value of everything, but the cost of nothing.
72. An adequate bootstrap is a contradiction in terms.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
105. You can't communicate complexity, only an awareness of it.
23. To understand a program you must become both the machine and the program.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
61. In programming, as in everything else, to be in error is to be reborn.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
27. Once you understand how to write a program get someone else to write it.
47. As Will Rogers would have said, "There is no such thing as a free variable."
3. Syntactic sugar causes cancer of the semicolon.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
47. As Will Rogers would have said, "There is no such thing as a free variable."
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
18. A program without a loop and a structured variable isn't worth writing.
8. A programming language is low level when its programs require attention to the irrelevant.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
18. A program without a loop and a structured variable isn't worth writing.
40. There are two ways to write error-free programs; only the third one works.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
60. In seeking the unattainable, simplicity only gets in the way.
76. It is the user who should parameterize procedures, not their creators.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
21. Optimization hinders evolution.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
22. A good system can't have a weak command language.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
55. A LISP programmer knows the value of everything, but the cost of nothing.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
46. Like punning, programming is a play on words.
111. Why did the Roman Empire collapse? What is Latin for office automation?
38. Structured Programming supports the law of the excluded middle.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
15. Everything should be built top-down, except the first time.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
14. In the long run every program becomes rococo - then rubble.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
18. A program without a loop and a structured variable isn't worth writing.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
63. When we write programs that "learn", it turns out that we do and they don't.
95. Don't have good ideas if you aren't willing to be responsible for them.
108. Whenever two programmers meet to criticize their programs, both are silent.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
43. In software systems, it is often the early bird that makes the worm.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
1. One man's constant is another man's variable.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
8. A programming language is low level when its programs require attention to the irrelevant.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
41. Some programming languages manage to absorb change, but withstand progress.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
96. Computers don't introduce order anywhere as much as they expose opportunities.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
14. In the long run every program becomes rococo - then rubble.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
3. Syntactic sugar causes cancer of the semicolon.
102. One can't proceed from the informal to the formal by formal means.
105. You can't communicate complexity, only an awareness of it.
31. Simplicity does not precede complexity, but follows it.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
90. Computation has made the tree flower.
108. Whenever two programmers meet to criticize their programs, both are silent.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
23. To understand a program you must become both the machine and the program.
23. To understand a program you must become both the machine and the program.
18. A program without a loop and a structured variable isn't worth writing.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
72. An adequate bootstrap is a contradiction in terms.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
72. An adequate bootstrap is a contradiction in terms.
119. Programming is an unnatural act.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
61. In programming, as in everything else, to be in error is to be reborn.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
103. Purely applicative languages are poorly applicable.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
57. It is easier to change the specification to fit the program than vice versa.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
23. To understand a program you must become both the machine and the program.
21. Optimization hinders evolution.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
119. Programming is an unnatural act.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
4. Every program is a part of some other program and rarely fits.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
31. Simplicity does not precede complexity, but follows it.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
31. Simplicity does not precede complexity, but follows it.
47. As Will Rogers would have said, "There is no such thing as a free variable."
110. Editing is a rewording activity.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
31. Simplicity does not precede complexity, but follows it.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
46. Like punning, programming is a play on words.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
96. Computers don't introduce order anywhere as much as they expose opportunities.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
72. An adequate bootstrap is a contradiction in terms.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
46. Like punning, programming is a play on words.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
76. It is the user who should parameterize procedures, not their creators.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
15. Everything should be built top-down, except the first time.
31. Simplicity does not precede complexity, but follows it.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
104. The proof of a system's value is its existence.
108. Whenever two programmers meet to criticize their programs, both are silent.
60. In seeking the unattainable, simplicity only gets in the way.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
11. If you have a procedure with ten parameters, you probably missed some.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
23. To understand a program you must become both the machine and the program.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
112. Computer Science is embarrassed by the computer.
63. When we write programs that "learn", it turns out that we do and they don't.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
103. Purely applicative languages are poorly applicable.
110. Editing is a rewording activity.
41. Some programming languages manage to absorb change, but withstand progress.
112. Computer Science is embarrassed by the computer.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
104. The proof of a system's value is its existence.
100. We will never run out of things to program as long as there is a single program around.
110. Editing is a rewording activity.
12. Recursion is the root of computation since it trades description for time.
115. Most people find the concept of programming obvious, but the doing impossible.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
105. You can't communicate complexity, only an awareness of it.
115. Most people find the concept of programming obvious, but the doing impossible.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
38. Structured Programming supports the law of the excluded middle.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
27. Once you understand how to write a program get someone else to write it.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
61. In programming, as in everything else, to be in error is to be reborn.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
119. Programming is an unnatural act.
114. Within a computer natural language is unnatural.
23. To understand a program you must become both the machine and the program.
60. In seeking the unattainable, simplicity only gets in the way.
66. Making something variable is easy. Controlling duration of constancy is the trick.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
40. There are two ways to write error-free programs; only the third one works.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
57. It is easier to change the specification to fit the program than vice versa.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
114. Within a computer natural language is unnatural.
103. Purely applicative languages are poorly applicable.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
60. In seeking the unattainable, simplicity only gets in the way.
111. Why did the Roman Empire collapse? What is Latin for office automation?
100. We will never run out of things to program as long as there is a single program around.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
114. Within a computer natural language is unnatural.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
79. A year spent in artificial intelligence is enough to make one believe in God.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
38. Structured Programming supports the law of the excluded middle.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
66. Making something variable is easy. Controlling duration of constancy is the trick.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
66. Making something variable is easy. Controlling duration of constancy is the trick.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
115. Most people find the concept of programming obvious, but the doing impossible.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
72. An adequate bootstrap is a contradiction in terms.
46. Like punning, programming is a play on words.
11. If you have a procedure with ten parameters, you probably missed some.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
119. Programming is an unnatural act.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
4. Every program is a part of some other program and rarely fits.
79. A year spent in artificial intelligence is enough to make one believe in God.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
103. Purely applicative languages are poorly applicable.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
15. Everything should be built top-down, except the first time.
17. If a listener nods his head when you're explaining your program, wake him up.
112. Computer Science is embarrassed by the computer.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
78. If your computer speaks English, it was probably made in Japan.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
60. In seeking the unattainable, simplicity only gets in the way.
95. Don't have good ideas if you aren't willing to be responsible for them.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
114. Within a computer natural language is unnatural.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
47. As Will Rogers would have said, "There is no such thing as a free variable."
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
17. If a listener nods his head when you're explaining your program, wake him up.
40. There are two ways to write error-free programs; only the third one works.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
100. We will never run out of things to program as long as there is a single program around.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
27. Once you understand how to write a program get someone else to write it.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
31. Simplicity does not precede complexity, but follows it.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
12. Recursion is the root of computation since it trades description for time.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
4. Every program is a part of some other program and rarely fits.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
76. It is the user who should parameterize procedures, not their creators.
114. Within a computer natural language is unnatural.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
43. In software systems, it is often the early bird that makes the worm.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
3. Syntactic sugar causes cancer of the semicolon.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
41. Some programming languages manage to absorb change, but withstand progress.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
110. Editing is a rewording activity.
22. A good system can't have a weak command language.
46. Like punning, programming is a play on words.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
78. If your computer speaks English, it was probably made in Japan.
112. Computer Science is embarrassed by the computer.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
102. One can't proceed from the informal to the formal by formal means.
60. In seeking the unattainable, simplicity only gets in the way.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
3. Syntactic sugar causes cancer of the semicolon.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
60. In seeking the unattainable, simplicity only gets in the way.
79. A year spent in artificial intelligence is enough to make one believe in God.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
95. Don't have good ideas if you aren't willing to be responsible for them.
102. One can't proceed from the informal to the formal by formal means.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
22. A good system can't have a weak command language.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
66. Making something variable is easy. Controlling duration of constancy is the trick.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
4. Every program is a part of some other program and rarely fits.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
21. Optimization hinders evolution.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
15. Everything should be built top-down, except the first time.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
100. We will never run out of things to program as long as there is a single program around.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
17. If a listener nods his head when you're explaining your program, wake him up.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
4. Every program is a part of some other program and rarely fits.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
55. A LISP programmer knows the value of everything, but the cost of nothing.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
76. It is the user who should parameterize procedures, not their creators.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
4. Every program is a part of some other program and rarely fits.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
46. Like punning, programming is a play on words.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
119. Programming is an unnatural act.
108. Whenever two programmers meet to criticize their programs, both are silent.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
63. When we write programs that "learn", it turns out that we do and they don't.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
22. A good system can't have a weak command language.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
78. If your computer speaks English, it was probably made in Japan.
102. One can't proceed from the informal to the formal by formal means.
23. To understand a program you must become both the machine and the program.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
38. Structured Programming supports the law of the excluded middle.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
63. When we write programs that "learn", it turns out that we do and they don't.
105. You can't communicate complexity, only an awareness of it.
110. Editing is a rewording activity.
108. Whenever two programmers meet to criticize their programs, both are silent.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
47. As Will Rogers would have said, "There is no such thing as a free variable."
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
63. When we write programs that "learn", it turns out that we do and they don't.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
31. Simplicity does not precede complexity, but follows it.
27. Once you understand how to write a program get someone else to write it.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
110. Editing is a rewording activity.
115. Most people find the concept of programming obvious, but the doing impossible.
22. A good system can't have a weak command language.
119. Programming is an unnatural act.
104. The proof of a system's value is its existence.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
43. In software systems, it is often the early bird that makes the worm.
31. Simplicity does not precede complexity, but follows it.
72. An adequate bootstrap is a contradiction in terms.
8. A programming language is low level when its programs require attention to the irrelevant.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
7. It is easier to write an incorrect program than understand a correct one.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
43. In software systems, it is often the early bird that makes the worm.
78. If your computer speaks English, it was probably made in Japan.
105. You can't communicate complexity, only an awareness of it.
7. It is easier to write an incorrect program than understand a correct one.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
115. Most people find the concept of programming obvious, but the doing impossible.
4. Every program is a part of some other program and rarely fits.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
90. Computation has made the tree flower.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
63. When we write programs that "learn", it turns out that we do and they don't.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
60. In seeking the unattainable, simplicity only gets in the way.
55. A LISP programmer knows the value of everything, but the cost of nothing.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
103. Purely applicative languages are poorly applicable.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
18. A program without a loop and a structured variable isn't worth writing.
22. A good system can't have a weak command language.
79. A year spent in artificial intelligence is enough to make one believe in God.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
43. In software systems, it is often the early bird that makes the worm.
55. A LISP programmer knows the value of everything, but the cost of nothing.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
7. It is easier to write an incorrect program than understand a correct one.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
17. If a listener nods his head when you're explaining your program, wake him up.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
1. One man's constant is another man's variable.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
61. In programming, as in everything else, to be in error is to be reborn.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
72. An adequate bootstrap is a contradiction in terms.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
17. If a listener nods his head when you're explaining your program, wake him up.
7. It is easier to write an incorrect program than understand a correct one.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
98. In computing, the mean time to failure keeps getting shorter.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
23. To understand a program you must become both the machine and the program.
95. Don't have good ideas if you aren't willing to be responsible for them.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
103. Purely applicative languages are poorly applicable.
110. Editing is a rewording activity.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
72. An adequate bootstrap is a contradiction in terms.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
105. You can't communicate complexity, only an awareness of it.
57. It is easier to change the specification to fit the program than vice versa.
47. As Will Rogers would have said, "There is no such thing as a free variable."
76. It is the user who should parameterize procedures, not their creators.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
55. A LISP programmer knows the value of everything, but the cost of nothing.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
95. Don't have good ideas if you aren't willing to be responsible for them.
14. In the long run every program becomes rococo - then rubble.
72. An adequate bootstrap is a contradiction in terms.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
100. We will never run out of things to program as long as there is a single program around.
23. To understand a program you must become both the machine and the program.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
3. Syntactic sugar causes cancer of the semicolon.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
110. Editing is a rewording activity.
119. Programming is an unnatural act.
104. The proof of a system's value is its existence.
43. In software systems, it is often the early bird that makes the worm.
115. Most people find the concept of programming obvious, but the doing impossible.
111. Why did the Roman Empire collapse? What is Latin for office automation?
40. There are two ways to write error-free programs; only the third one works.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
60. In seeking the unattainable, simplicity only gets in the way.
102. One can't proceed from the informal to the formal by formal means.
102. One can't proceed from the informal to the formal by formal means.
102. One can't proceed from the informal to the formal by formal means.
8. A programming language is low level when its programs require attention to the irrelevant.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
27. Once you understand how to write a program get someone else to write it.
112. Computer Science is embarrassed by the computer.
59. In English every word can be verbed. Would that it were so in our programming languages.
40. There are two ways to write error-free programs; only the third one works.
22. A good system can't have a weak command language.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
111. Why did the Roman Empire collapse? What is Latin for office automation?
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
60. In seeking the unattainable, simplicity only gets in the way.
12. Recursion is the root of computation since it trades description for time.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
46. Like punning, programming is a play on words.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
15. Everything should be built top-down, except the first time.
57. It is easier to change the specification to fit the program than vice versa.
11. If you have a procedure with ten parameters, you probably missed some.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
111. Why did the Roman Empire collapse? What is Latin for office automation?
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
66. Making something variable is easy. Controlling duration of constancy is the trick.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
90. Computation has made the tree flower.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
8. A programming language is low level when its programs require attention to the irrelevant.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
3. Syntactic sugar causes cancer of the semicolon.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
72. An adequate bootstrap is a contradiction in terms.
104. The proof of a system's value is its existence.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
47. As Will Rogers would have said, "There is no such thing as a free variable."
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
4. Every program is a part of some other program and rarely fits.
90. Computation has made the tree flower.
96. Computers don't introduce order anywhere as much as they expose opportunities.
38. Structured Programming supports the law of the excluded middle.
47. As Will Rogers would have said, "There is no such thing as a free variable."
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
23. To understand a program you must become both the machine and the program.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
102. One can't proceed from the informal to the formal by formal means.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
110. Editing is a rewording activity.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
119. Programming is an unnatural act.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
95. Don't have good ideas if you aren't willing to be responsible for them.
21. Optimization hinders evolution.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
76. It is the user who should parameterize procedures, not their creators.
98. In computing, the mean time to failure keeps getting shorter.
41. Some programming languages manage to absorb change, but withstand progress.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
100. We will never run out of things to program as long as there is a single program around.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
11. If you have a procedure with ten parameters, you probably missed some.
43. In software systems, it is often the early bird that makes the worm.
3. Syntactic sugar causes cancer of the semicolon.
43. In software systems, it is often the early bird that makes the worm.
104. The proof of a system's value is its existence.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
41. Some programming languages manage to absorb change, but withstand progress.
7. It is easier to write an incorrect program than understand a correct one.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
104. The proof of a system's value is its existence.
78. If your computer speaks English, it was probably made in Japan.
22. A good system can't have a weak command language.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
90. Computation has made the tree flower.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
18. A program without a loop and a structured variable isn't worth writing.
111. Why did the Roman Empire collapse? What is Latin for office automation?
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
100. We will never run out of things to program as long as there is a single program around.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
57. It is easier to change the specification to fit the program than vice versa.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
23. To understand a program you must become both the machine and the program.
98. In computing, the mean time to failure keeps getting shorter.
47. As Will Rogers would have said, "There is no such thing as a free variable."
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
22. A good system can't have a weak command language.
95. Don't have good ideas if you aren't willing to be responsible for them.
14. In the long run every program becomes rococo - then rubble.
66. Making something variable is easy. Controlling duration of constancy is the trick.
111. Why did the Roman Empire collapse? What is Latin for office automation?
76. It is the user who should parameterize procedures, not their creators.
18. A program without a loop and a structured variable isn't worth writing.
105. You can't communicate complexity, only an awareness of it.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
7. It is easier to write an incorrect program than understand a correct one.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
1. One man's constant is another man's variable.
60. In seeking the unattainable, simplicity only gets in the way.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
11. If you have a procedure with ten parameters, you probably missed some.
63. When we write programs that "learn", it turns out that we do and they don't.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
98. In computing, the mean time to failure keeps getting shorter.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
17. If a listener nods his head when you're explaining your program, wake him up.
96. Computers don't introduce order anywhere as much as they expose opportunities.
103. Purely applicative languages are poorly applicable.
8. A programming language is low level when its programs require attention to the irrelevant.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
22. A good system can't have a weak command language.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
66. Making something variable is easy. Controlling duration of constancy is the trick.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
63. When we write programs that "learn", it turns out that we do and they don't.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
112. Computer Science is embarrassed by the computer.
79. A year spent in artificial intelligence is enough to make one believe in God.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
115. Most people find the concept of programming obvious, but the doing impossible.
72. An adequate bootstrap is a contradiction in terms.
115. Most people find the concept of programming obvious, but the doing impossible.
115. Most people find the concept of programming obvious, but the doing impossible.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
105. You can't communicate complexity, only an awareness of it.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
8. A programming language is low level when its programs require attention to the irrelevant.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
62. In computing, invariants are ephemeral.
98. In computing, the mean time to failure keeps getting shorter.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
72. An adequate bootstrap is a contradiction in terms.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
15. Everything should be built top-down, except the first time.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
55. A LISP programmer knows the value of everything, but the cost of nothing.
46. Like punning, programming is a play on words.
95. Don't have good ideas if you aren't willing to be responsible for them.
3. Syntactic sugar causes cancer of the semicolon.
59. In English every word can be verbed. Would that it were so in our programming languages.
61. In programming, as in everything else, to be in error is to be reborn.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
8. A programming language is low level when its programs require attention to the irrelevant.
76. It is the user who should parameterize procedures, not their creators.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
8. A programming language is low level when its programs require attention to the irrelevant.
62. In computing, invariants are ephemeral.
112. Computer Science is embarrassed by the computer.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
60. In seeking the unattainable, simplicity only gets in the way.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
115. Most people find the concept of programming obvious, but the doing impossible.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
21. Optimization hinders evolution.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
95. Don't have good ideas if you aren't willing to be responsible for them.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
108. Whenever two programmers meet to criticize their programs, both are silent.
62. In computing, invariants are ephemeral.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
61. In programming, as in everything else, to be in error is to be reborn.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
27. Once you understand how to write a program get someone else to write it.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
60. In seeking the unattainable, simplicity only gets in the way.
103. Purely applicative languages are poorly applicable.
119. Programming is an unnatural act.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
63. When we write programs that "learn", it turns out that we do and they don't.
59. In English every word can be verbed. Would that it were so in our programming languages.
12. Recursion is the root of computation since it trades description for time.
11. If you have a procedure with ten parameters, you probably missed some.
40. There are two ways to write error-free programs; only the third one works.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
63. When we write programs that "learn", it turns out that we do and they don't.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
15. Everything should be built top-down, except the first time.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
5. If a program manipulates a large amount of data, it does so in a small number of ways.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
7. It is easier to write an incorrect program than understand a correct one.
112. Computer Science is embarrassed by the computer.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
57. It is easier to change the specification to fit the program than vice versa.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
46. Like punning, programming is a play on words.
76. It is the user who should parameterize procedures, not their creators.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
1. One man's constant is another man's variable.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
15. Everything should be built top-down, except the first time.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
105. You can't communicate complexity, only an awareness of it.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
43. In software systems, it is often the early bird that makes the worm.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
100. We will never run out of things to program as long as there is a single program around.
38. Structured Programming supports the law of the excluded middle.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
111. Why did the Roman Empire collapse? What is Latin for office automation?
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
55. A LISP programmer knows the value of everything, but the cost of nothing.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
22. A good system can't have a weak command language.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
61. In programming, as in everything else, to be in error is to be reborn.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
60. In seeking the unattainable, simplicity only gets in the way.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
59. In English every word can be verbed. Would that it were so in our programming languages.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
66. Making something variable is easy. Controlling duration of constancy is the trick.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
57. It is easier to change the specification to fit the program than vice versa.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
96. Computers don't introduce order anywhere as much as they expose opportunities.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
31. Simplicity does not precede complexity, but follows it.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
96. Computers don't introduce order anywhere as much as they expose opportunities.
114. Within a computer natural language is unnatural.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
78. If your computer speaks English, it was probably made in Japan.
63. When we write programs that "learn", it turns out that we do and they don't.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
100. We will never run out of things to program as long as there is a single program around.
103. Purely applicative languages are poorly applicable.
114. Within a computer natural language is unnatural.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
61. In programming, as in everything else, to be in error is to be reborn.
115. Most people find the concept of programming obvious, but the doing impossible.
15. Everything should be built top-down, except the first time.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
102. One can't proceed from the informal to the formal by formal means.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
66. Making something variable is easy. Controlling duration of constancy is the trick.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
14. In the long run every program becomes rococo - then rubble.
8. A programming language is low level when its programs require attention to the irrelevant.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
103. Purely applicative languages are poorly applicable.
3. Syntactic sugar causes cancer of the semicolon.
72. An adequate bootstrap is a contradiction in terms.
14. In the long run every program becomes rococo - then rubble.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
110. Editing is a rewording activity.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
59. In English every word can be verbed. Would that it were so in our programming languages.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
66. Making something variable is easy. Controlling duration of constancy is the trick.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
108. Whenever two programmers meet to criticize their programs, both are silent.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
8. A programming language is low level when its programs require attention to the irrelevant.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
66. Making something variable is easy. Controlling duration of constancy is the trick.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
57. It is easier to change the specification to fit the program than vice versa.
119. Programming is an unnatural act.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
41. Some programming languages manage to absorb change, but withstand progress.
105. You can't communicate complexity, only an awareness of it.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
43. In software systems, it is often the early bird that makes the worm.
21. Optimization hinders evolution.
76. It is the user who should parameterize procedures, not their creators.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
55. A LISP programmer knows the value of everything, but the cost of nothing.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
21. Optimization hinders evolution.
115. Most people find the concept of programming obvious, but the doing impossible.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
62. In computing, invariants are ephemeral.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
21. Optimization hinders evolution.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
102. One can't proceed from the informal to the formal by formal means.
102. One can't proceed from the informal to the formal by formal means.
63. When we write programs that "learn", it turns out that we do and they don't.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
12. Recursion is the root of computation since it trades description for time.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
79. A year spent in artificial intelligence is enough to make one believe in God.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
23. To understand a program you must become both the machine and the program.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
79. A year spent in artificial intelligence is enough to make one believe in God.
40. There are two ways to write error-free programs; only the third one works.
14. In the long run every program becomes rococo - then rubble.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
104. The proof of a system's value is its existence.
76. It is the user who should parameterize procedures, not their creators.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
27. Once you understand how to write a program get someone else to write it.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
55. A LISP programmer knows the value of everything, but the cost of nothing.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
72. An adequate bootstrap is a contradiction in terms.
12. Recursion is the root of computation since it trades description for time.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
8. A programming language is low level when its programs require attention to the irrelevant.
4. Every program is a part of some other program and rarely fits.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
103. Purely applicative languages are poorly applicable.
100. We will never run out of things to program as long as there is a single program around.
12. Recursion is the root of computation since it trades description for time.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
114. Within a computer natural language is unnatural.
15. Everything should be built top-down, except the first time.
60. In seeking the unattainable, simplicity only gets in the way.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
7. It is easier to write an incorrect program than understand a correct one.
76. It is the user who should parameterize procedures, not their creators.
46. Like punning, programming is a play on words.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
114. Within a computer natural language is unnatural.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
112. Computer Science is embarrassed by the computer.
66. Making something variable is easy. Controlling duration of constancy is the trick.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
38. Structured Programming supports the law of the excluded middle.
95. Don't have good ideas if you aren't willing to be responsible for them.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
76. It is the user who should parameterize procedures, not their creators.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
104. The proof of a system's value is its existence.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
103. Purely applicative languages are poorly applicable.
12. Recursion is the root of computation since it trades description for time.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
14. In the long run every program becomes rococo - then rubble.
72. An adequate bootstrap is a contradiction in terms.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
72. An adequate bootstrap is a contradiction in terms.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
12. Recursion is the root of computation since it trades description for time.
104. The proof of a system's value is its existence.
72. An adequate bootstrap is a contradiction in terms.
72. An adequate bootstrap is a contradiction in terms.
108. Whenever two programmers meet to criticize their programs, both are silent.
12. Recursion is the root of computation since it trades description for time.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
27. Once you understand how to write a program get someone else to write it.
4. Every program is a part of some other program and rarely fits.
110. Editing is a rewording activity.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
110. Editing is a rewording activity.
95. Don't have good ideas if you aren't willing to be responsible for them.
119. Programming is an unnatural act.
119. Programming is an unnatural act.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
23. To understand a program you must become both the machine and the program.
21. Optimization hinders evolution.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
63. When we write programs that "learn", it turns out that we do and they don't.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
61. In programming, as in everything else, to be in error is to be reborn.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
41. Some programming languages manage to absorb change, but withstand progress.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
100. We will never run out of things to program as long as there is a single program around.
41. Some programming languages manage to absorb change, but withstand progress.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
38. Structured Programming supports the law of the excluded middle.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
76. It is the user who should parameterize procedures, not their creators.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
95. Don't have good ideas if you aren't willing to be responsible for them.
103. Purely applicative languages are poorly applicable.
7. It is easier to write an incorrect program than understand a correct one.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
40. There are two ways to write error-free programs; only the third one works.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
110. Editing is a rewording activity.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
111. Why did the Roman Empire collapse? What is Latin for office automation?
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
27. Once you understand how to write a program get someone else to write it.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
108. Whenever two programmers meet to criticize their programs, both are silent.
18. A program without a loop and a structured variable isn't worth writing.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
31. Simplicity does not precede complexity, but follows it.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
4. Every program is a part of some other program and rarely fits.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
115. Most people find the concept of programming obvious, but the doing impossible.
98. In computing, the mean time to failure keeps getting shorter.
105. You can't communicate complexity, only an awareness of it.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
78. If your computer speaks English, it was probably made in Japan.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
110. Editing is a rewording activity.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
38. Structured Programming supports the law of the excluded middle.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
61. In programming, as in everything else, to be in error is to be reborn.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
43. In software systems, it is often the early bird that makes the worm.
11. If you have a procedure with ten parameters, you probably missed some.
100. We will never run out of things to program as long as there is a single program around.
15. Everything should be built top-down, except the first time.
8. A programming language is low level when its programs require attention to the irrelevant.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
18. A program without a loop and a structured variable isn't worth writing.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
107. The debate rages on: is PL/I Bachtrian or Dromedary?
102. One can't proceed from the informal to the formal by formal means.
41. Some programming languages manage to absorb change, but withstand progress.
62. In computing, invariants are ephemeral.
66. Making something variable is easy. Controlling duration of constancy is the trick.
3. Syntactic sugar causes cancer of the semicolon.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
4. Every program is a part of some other program and rarely fits.
55. A LISP programmer knows the value of everything, but the cost of nothing.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
95. Don't have good ideas if you aren't willing to be responsible for them.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
15. Everything should be built top-down, except the first time.
4. Every program is a part of some other program and rarely fits.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
115. Most people find the concept of programming obvious, but the doing impossible.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
43. In software systems, it is often the early bird that makes the worm.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
14. In the long run every program becomes rococo - then rubble.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
59. In English every word can be verbed. Would that it were so in our programming languages.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
8. A programming language is low level when its programs require attention to the irrelevant.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
63. When we write programs that "learn", it turns out that we do and they don't.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
3. Syntactic sugar causes cancer of the semicolon.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
119. Programming is an unnatural act.
46. Like punning, programming is a play on words.
41. Some programming languages manage to absorb change, but withstand progress.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
104. The proof of a system's value is its existence.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
95. Don't have good ideas if you aren't willing to be responsible for them.
108. Whenever two programmers meet to criticize their programs, both are silent.
47. As Will Rogers would have said, "There is no such thing as a free variable."
23. To understand a program you must become both the machine and the program.
62. In computing, invariants are ephemeral.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
8. A programming language is low level when its programs require attention to the irrelevant.
4. Every program is a part of some other program and rarely fits.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
14. In the long run every program becomes rococo - then rubble.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
18. A program without a loop and a structured variable isn't worth writing.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
7. It is easier to write an incorrect program than understand a correct one.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
8. A programming language is low level when its programs require attention to the irrelevant.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
27. Once you understand how to write a program get someone else to write it.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
3. Syntactic sugar causes cancer of the semicolon.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
18. A program without a loop and a structured variable isn't worth writing.
27. Once you understand how to write a program get someone else to write it.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
72. An adequate bootstrap is a contradiction in terms.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
59. In English every word can be verbed. Would that it were so in our programming languages.
108. Whenever two programmers meet to criticize their programs, both are silent.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
60. In seeking the unattainable, simplicity only gets in the way.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
76. It is the user who should parameterize procedures, not their creators.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
3. Syntactic sugar causes cancer of the semicolon.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
95. Don't have good ideas if you aren't willing to be responsible for them.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
105. You can't communicate complexity, only an awareness of it.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
15. Everything should be built top-down, except the first time.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
61. In programming, as in everything else, to be in error is to be reborn.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
15. Everything should be built top-down, except the first time.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
60. In seeking the unattainable, simplicity only gets in the way.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
23. To understand a program you must become both the machine and the program.
111. Why did the Roman Empire collapse? What is Latin for office automation?
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
11. If you have a procedure with ten parameters, you probably missed some.
7. It is easier to write an incorrect program than understand a correct one.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
115. Most people find the concept of programming obvious, but the doing impossible.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
14. In the long run every program becomes rococo - then rubble.
18. A program without a loop and a structured variable isn't worth writing.
111. Why did the Roman Empire collapse? What is Latin for office automation?
12. Recursion is the root of computation since it trades description for time.
98. In computing, the mean time to failure keeps getting shorter.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
41. Some programming languages manage to absorb change, but withstand progress.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
22. A good system can't have a weak command language.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
108. Whenever two programmers meet to criticize their programs, both are silent.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
61. In programming, as in everything else, to be in error is to be reborn.
4. Every program is a part of some other program and rarely fits.
105. You can't communicate complexity, only an awareness of it.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
61. In programming, as in everything else, to be in error is to be reborn.
60. In seeking the unattainable, simplicity only gets in the way.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
41. Some programming languages manage to absorb change, but withstand progress.
104. The proof of a system's value is its existence.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
31. Simplicity does not precede complexity, but follows it.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
14. In the long run every program becomes rococo - then rubble.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
14. In the long run every program becomes rococo - then rubble.
59. In English every word can be verbed. Would that it were so in our programming languages.
59. In English every word can be verbed. Would that it were so in our programming languages.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
12. Recursion is the root of computation since it trades description for time.
55. A LISP programmer knows the value of everything, but the cost of nothing.
100. We will never run out of things to program as long as there is a single program around.
98. In computing, the mean time to failure keeps getting shorter.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
102. One can't proceed from the informal to the formal by formal means.
3. Syntactic sugar causes cancer of the semicolon.
62. In computing, invariants are ephemeral.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
60. In seeking the unattainable, simplicity only gets in the way.
114. Within a computer natural language is unnatural.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
98. In computing, the mean time to failure keeps getting shorter.
98. In computing, the mean time to failure keeps getting shorter.
63. When we write programs that "learn", it turns out that we do and they don't.
63. When we write programs that "learn", it turns out that we do and they don't.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
63. When we write programs that "learn", it turns out that we do and they don't.
55. A LISP programmer knows the value of everything, but the cost of nothing.
7. It is easier to write an incorrect program than understand a correct one.
79. A year spent in artificial intelligence is enough to make one believe in God.
21. Optimization hinders evolution.
103. Purely applicative languages are poorly applicable.
55. A LISP programmer knows the value of everything, but the cost of nothing.
41. Some programming languages manage to absorb change, but withstand progress.
110. Editing is a rewording activity.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
23. To understand a program you must become both the machine and the program.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
108. Whenever two programmers meet to criticize their programs, both are silent.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
76. It is the user who should parameterize procedures, not their creators.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
78. If your computer speaks English, it was probably made in Japan.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
19. A language that doesn't affect the way you think about programming, is not worth knowing.
21. Optimization hinders evolution.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
104. The proof of a system's value is its existence.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
59. In English every word can be verbed. Would that it were so in our programming languages.
17. If a listener nods his head when you're explaining your program, wake him up.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
46. Like punning, programming is a play on words.
22. A good system can't have a weak command language.
102. One can't proceed from the informal to the formal by formal means.
17. If a listener nods his head when you're explaining your program, wake him up.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
96. Computers don't introduce order anywhere as much as they expose opportunities.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
55. A LISP programmer knows the value of everything, but the cost of nothing.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
55. A LISP programmer knows the value of everything, but the cost of nothing.
105. You can't communicate complexity, only an awareness of it.
55. A LISP programmer knows the value of everything, but the cost of nothing.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
57. It is easier to change the specification to fit the program than vice versa.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
102. One can't proceed from the informal to the formal by formal means.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
15. Everything should be built top-down, except the first time.
11. If you have a procedure with ten parameters, you probably missed some.
62. In computing, invariants are ephemeral.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
1. One man's constant is another man's variable.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
17. If a listener nods his head when you're explaining your program, wake him up.
21. Optimization hinders evolution.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
119. Programming is an unnatural act.
63. When we write programs that "learn", it turns out that we do and they don't.
14. In the long run every program becomes rococo - then rubble.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
31. Simplicity does not precede complexity, but follows it.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
43. In software systems, it is often the early bird that makes the worm.
27. Once you understand how to write a program get someone else to write it.
55. A LISP programmer knows the value of everything, but the cost of nothing.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
17. If a listener nods his head when you're explaining your program, wake him up.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
63. When we write programs that "learn", it turns out that we do and they don't.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
63. When we write programs that "learn", it turns out that we do and they don't.
76. It is the user who should parameterize procedures, not their creators.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
55. A LISP programmer knows the value of everything, but the cost of nothing.
111. Why did the Roman Empire collapse? What is Latin for office automation?
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
46. Like punning, programming is a play on words.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
79. A year spent in artificial intelligence is enough to make one believe in God.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
115. Most people find the concept of programming obvious, but the doing impossible.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
14. In the long run every program becomes rococo - then rubble.
78. If your computer speaks English, it was probably made in Japan.
31. Simplicity does not precede complexity, but follows it.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
27. Once you understand how to write a program get someone else to write it.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
57. It is easier to change the specification to fit the program than vice versa.
17. If a listener nods his head when you're explaining your program, wake him up.
108. Whenever two programmers meet to criticize their programs, both are silent.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
111. Why did the Roman Empire collapse? What is Latin for office automation?
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
98. In computing, the mean time to failure keeps getting shorter.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
23. To understand a program you must become both the machine and the program.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
79. A year spent in artificial intelligence is enough to make one believe in God.
47. As Will Rogers would have said, "There is no such thing as a free variable."
8. A programming language is low level when its programs require attention to the irrelevant.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
17. If a listener nods his head when you're explaining your program, wake him up.
76. It is the user who should parameterize procedures, not their creators.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
62. In computing, invariants are ephemeral.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
96. Computers don't introduce order anywhere as much as they expose opportunities.
90. Computation has made the tree flower.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
112. Computer Science is embarrassed by the computer.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
3. Syntactic sugar causes cancer of the semicolon.
62. In computing, invariants are ephemeral.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
111. Why did the Roman Empire collapse? What is Latin for office automation?
18. A program without a loop and a structured variable isn't worth writing.
31. Simplicity does not precede complexity, but follows it.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
23. To understand a program you must become both the machine and the program.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
17. If a listener nods his head when you're explaining your program, wake him up.
46. Like punning, programming is a play on words.
18. A program without a loop and a structured variable isn't worth writing.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
4. Every program is a part of some other program and rarely fits.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
102. One can't proceed from the informal to the formal by formal means.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
40. There are two ways to write error-free programs; only the third one works.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
111. Why did the Roman Empire collapse? What is Latin for office automation?
61. In programming, as in everything else, to be in error is to be reborn.
27. Once you understand how to write a program get someone else to write it.
98. In computing, the mean time to failure keeps getting shorter.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
59. In English every word can be verbed. Would that it were so in our programming languages.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
100. We will never run out of things to program as long as there is a single program around.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
43. In software systems, it is often the early bird that makes the worm.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
98. In computing, the mean time to failure keeps getting shorter.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
110. Editing is a rewording activity.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
15. Everything should be built top-down, except the first time.
100. We will never run out of things to program as long as there is a single program around.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
38. Structured Programming supports the law of the excluded middle.
103. Purely applicative languages are poorly applicable.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
47. As Will Rogers would have said, "There is no such thing as a free variable."
11. If you have a procedure with ten parameters, you probably missed some.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
63. When we write programs that "learn", it turns out that we do and they don't.
46. Like punning, programming is a play on words.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
46. Like punning, programming is a play on words.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
90. Computation has made the tree flower.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
104. The proof of a system's value is its existence.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
79. A year spent in artificial intelligence is enough to make one believe in God.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
66. Making something variable is easy. Controlling duration of constancy is the trick.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
46. Like punning, programming is a play on words.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
1. One man's constant is another man's variable.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
4. Every program is a part of some other program and rarely fits.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
112. Computer Science is embarrassed by the computer.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
95. Don't have good ideas if you aren't willing to be responsible for them.
4. Every program is a part of some other program and rarely fits.
38. Structured Programming supports the law of the excluded middle.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
1. One man's constant is another man's variable.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
111. Why did the Roman Empire collapse? What is Latin for office automation?
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
23. To understand a program you must become both the machine and the program.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
12. Recursion is the root of computation since it trades description for time.
55. A LISP programmer knows the value of everything, but the cost of nothing.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
12. Recursion is the root of computation since it trades description for time.
15. Everything should be built top-down, except the first time.
15. Everything should be built top-down, except the first time.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
79. A year spent in artificial intelligence is enough to make one believe in God.
31. Simplicity does not precede complexity, but follows it.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
22. A good system can't have a weak command language.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
15. Everything should be built top-down, except the first time.
60. In seeking the unattainable, simplicity only gets in the way.
31. Simplicity does not precede complexity, but follows it.
76. It is the user who should parameterize procedures, not their creators.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
21. Optimization hinders evolution.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
61. In programming, as in everything else, to be in error is to be reborn.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
79. A year spent in artificial intelligence is enough to make one believe in God.
110. Editing is a rewording activity.
61. In programming, as in everything else, to be in error is to be reborn.
21. Optimization hinders evolution.
41. Some programming languages manage to absorb change, but withstand progress.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
100. We will never run out of things to program as long as there is a single program around.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
1. One man's constant is another man's variable.
22. A good system can't have a weak command language.
95. Don't have good ideas if you aren't willing to be responsible for them.
119. Programming is an unnatural act.
4. Every program is a part of some other program and rarely fits.
60. In seeking the unattainable, simplicity only gets in the way.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
110. Editing is a rewording activity.
79. A year spent in artificial intelligence is enough to make one believe in God.
41. Some programming languages manage to absorb change, but withstand progress.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
95. Don't have good ideas if you aren't willing to be responsible for them.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
105. You can't communicate complexity, only an awareness of it.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
12. Recursion is the root of computation since it trades description for time.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
102. One can't proceed from the informal to the formal by formal means.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
17. If a listener nods his head when you're explaining your program, wake him up.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
60. In seeking the unattainable, simplicity only gets in the way.
18. A program without a loop and a structured variable isn't worth writing.
66. Making something variable is easy. Controlling duration of constancy is the trick.
14. In the long run every program becomes rococo - then rubble.
115. Most people find the concept of programming obvious, but the doing impossible.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
17. If a listener nods his head when you're explaining your program, wake him up.
57. It is easier to change the specification to fit the program than vice versa.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
3. Syntactic sugar causes cancer of the semicolon.
11. If you have a procedure with ten parameters, you probably missed some.
27. Once you understand how to write a program get someone else to write it.
23. To understand a program you must become both the machine and the program.
110. Editing is a rewording activity.
17. If a listener nods his head when you're explaining your program, wake him up.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
108. Whenever two programmers meet to criticize their programs, both are silent.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
100. We will never run out of things to program as long as there is a single program around.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
110. Editing is a rewording activity.
59. In English every word can be verbed. Would that it were so in our programming languages.
15. Everything should be built top-down, except the first time.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
38. Structured Programming supports the law of the excluded middle.
12. Recursion is the root of computation since it trades description for time.
12. Recursion is the root of computation since it trades description for time.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
111. Why did the Roman Empire collapse? What is Latin for office automation?
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
78. If your computer speaks English, it was probably made in Japan.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
78. If your computer speaks English, it was probably made in Japan.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
7. It is easier to write an incorrect program than understand a correct one.
59. In English every word can be verbed. Would that it were so in our programming languages.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
100. We will never run out of things to program as long as there is a single program around.
105. You can't communicate complexity, only an awareness of it.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
111. Why did the Roman Empire collapse? What is Latin for office automation?
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
40. There are two ways to write error-free programs; only the third one works.
43. In software systems, it is often the early bird that makes the worm.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
23. To understand a program you must become both the machine and the program.
40. There are two ways to write error-free programs; only the third one works.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
79. A year spent in artificial intelligence is enough to make one believe in God.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
104. The proof of a system's value is its existence.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
108. Whenever two programmers meet to criticize their programs, both are silent.
79. A year spent in artificial intelligence is enough to make one believe in God.
95. Don't have good ideas if you aren't willing to be responsible for them.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
3. Syntactic sugar causes cancer of the semicolon.
46. Like punning, programming is a play on words.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
114. Within a computer natural language is unnatural.
4. Every program is a part of some other program and rarely fits.
66. Making something variable is easy. Controlling duration of constancy is the trick.
63. When we write programs that "learn", it turns out that we do and they don't.
105. You can't communicate complexity, only an awareness of it.
76. It is the user who should parameterize procedures, not their creators.
66. Making something variable is easy. Controlling duration of constancy is the trick.
14. In the long run every program becomes rococo - then rubble.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
96. Computers don't introduce order anywhere as much as they expose opportunities.
79. A year spent in artificial intelligence is enough to make one believe in God.
102. One can't proceed from the informal to the formal by formal means.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
66. Making something variable is easy. Controlling duration of constancy is the trick.
11. If you have a procedure with ten parameters, you probably missed some.
110. Editing is a rewording activity.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
112. Computer Science is embarrassed by the computer.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
15. Everything should be built top-down, except the first time.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
3. Syntactic sugar causes cancer of the semicolon.
108. Whenever two programmers meet to criticize their programs, both are silent.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
12. Recursion is the root of computation since it trades description for time.
1. One man's constant is another man's variable.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
21. Optimization hinders evolution.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
61. In programming, as in everything else, to be in error is to be reborn.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
46. Like punning, programming is a play on words.
95. Don't have good ideas if you aren't willing to be responsible for them.
98. In computing, the mean time to failure keeps getting shorter.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
38. Structured Programming supports the law of the excluded middle.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
12. Recursion is the root of computation since it trades description for time.
22. A good system can't have a weak command language.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
5. If a program manipulates a large amount of data, it does so in a small number of ways.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
115. Most people find the concept of programming obvious, but the doing impossible.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
98. In computing, the mean time to failure keeps getting shorter.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
95. Don't have good ideas if you aren't willing to be responsible for them.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
41. Some programming languages manage to absorb change, but withstand progress.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
21. Optimization hinders evolution.
110. Editing is a rewording activity.
108. Whenever two programmers meet to criticize their programs, both are silent.
72. An adequate bootstrap is a contradiction in terms.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
76. It is the user who should parameterize procedures, not their creators.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
27. Once you understand how to write a program get someone else to write it.
72. An adequate bootstrap is a contradiction in terms.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
57. It is easier to change the specification to fit the program than vice versa.
55. A LISP programmer knows the value of everything, but the cost of nothing.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
60. In seeking the unattainable, simplicity only gets in the way.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
66. Making something variable is easy. Controlling duration of constancy is the trick.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
40. There are two ways to write error-free programs; only the third one works.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
8. A programming language is low level when its programs require attention to the irrelevant.
41. Some programming languages manage to absorb change, but withstand progress.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
105. You can't communicate complexity, only an awareness of it.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
14. In the long run every program becomes rococo - then rubble.
27. Once you understand how to write a program get someone else to write it.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
90. Computation has made the tree flower.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
3. Syntactic sugar causes cancer of the semicolon.
38. Structured Programming supports the law of the excluded middle.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
104. The proof of a system's value is its existence.
105. You can't communicate complexity, only an awareness of it.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
59. In English every word can be verbed. Would that it were so in our programming languages.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
31. Simplicity does not precede complexity, but follows it.
3. Syntactic sugar causes cancer of the semicolon.
98. In computing, the mean time to failure keeps getting shorter.
90. Computation has made the tree flower.
41. Some programming languages manage to absorb change, but withstand progress.
98. In computing, the mean time to failure keeps getting shorter.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
12. Recursion is the root of computation since it trades description for time.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
103. Purely applicative languages are poorly applicable.
115. Most people find the concept of programming obvious, but the doing impossible.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
7. It is easier to write an incorrect program than understand a correct one.
47. As Will Rogers would have said, "There is no such thing as a free variable."
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
23. To understand a program you must become both the machine and the program.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
96. Computers don't introduce order anywhere as much as they expose opportunities.
43. In software systems, it is often the early bird that makes the worm.
12. Recursion is the root of computation since it trades description for time.
103. Purely applicative languages are poorly applicable.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
8. A programming language is low level when its programs require attention to the irrelevant.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
78. If your computer speaks English, it was probably made in Japan.
31. Simplicity does not precede complexity, but follows it.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
104. The proof of a system's value is its existence.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
60. In seeking the unattainable, simplicity only gets in the way.
59. In English every word can be verbed. Would that it were so in our programming languages.
47. As Will Rogers would have said, "There is no such thing as a free variable."
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
108. Whenever two programmers meet to criticize their programs, both are silent.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
40. There are two ways to write error-free programs; only the third one works.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
108. Whenever two programmers meet to criticize their programs, both are silent.
41. Some programming languages manage to absorb change, but withstand progress.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
72. An adequate bootstrap is a contradiction in terms.
100. We will never run out of things to program as long as there is a single program around.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
98. In computing, the mean time to failure keeps getting shorter.
102. One can't proceed from the informal to the formal by formal means.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
61. In programming, as in everything else, to be in error is to be reborn.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
110. Editing is a rewording activity.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
76. It is the user who should parameterize procedures, not their creators.
111. Why did the Roman Empire collapse? What is Latin for office automation?
12. Recursion is the root of computation since it trades description for time.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
8. A programming language is low level when its programs require attention to the irrelevant.
63. When we write programs that "learn", it turns out that we do and they don't.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
47. As Will Rogers would have said, "There is no such thing as a free variable."
17. If a listener nods his head when you're explaining your program, wake him up.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
41. Some programming languages manage to absorb change, but withstand progress.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
103. Purely applicative languages are poorly applicable.
111. Why did the Roman Empire collapse? What is Latin for office automation?
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
100. We will never run out of things to program as long as there is a single program around.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
17. If a listener nods his head when you're explaining your program, wake him up.
79. A year spent in artificial intelligence is enough to make one believe in God.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
112. Computer Science is embarrassed by the computer.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
114. Within a computer natural language is unnatural.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
7. It is easier to write an incorrect program than understand a correct one.
8. A programming language is low level when its programs require attention to the irrelevant.
17. If a listener nods his head when you're explaining your program, wake him up.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
1. One man's constant is another man's variable.
110. Editing is a rewording activity.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
23. To understand a program you must become both the machine and the program.
4. Every program is a part of some other program and rarely fits.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
21. Optimization hinders evolution.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
47. As Will Rogers would have said, "There is no such thing as a free variable."
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
23. To understand a program you must become both the machine and the program.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
4. Every program is a part of some other program and rarely fits.
18. A program without a loop and a structured variable isn't worth writing.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
18. A program without a loop and a structured variable isn't worth writing.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
119. Programming is an unnatural act.
15. Everything should be built top-down, except the first time.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
55. A LISP programmer knows the value of everything, but the cost of nothing.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
108. Whenever two programmers meet to criticize their programs, both are silent.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
90. Computation has made the tree flower.
8. A programming language is low level when its programs require attention to the irrelevant.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
57. It is easier to change the specification to fit the program than vice versa.
60. In seeking the unattainable, simplicity only gets in the way.
90. Computation has made the tree flower.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
111. Why did the Roman Empire collapse? What is Latin for office automation?
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
105. You can't communicate complexity, only an awareness of it.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
100. We will never run out of things to program as long as there is a single program around.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
78. If your computer speaks English, it was probably made in Japan.
40. There are two ways to write error-free programs; only the third one works.
98. In computing, the mean time to failure keeps getting shorter.
18. A program without a loop and a structured variable isn't worth writing.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
21. Optimization hinders evolution.
66. Making something variable is easy. Controlling duration of constancy is the trick.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
22. A good system can't have a weak command language.
102. One can't proceed from the informal to the formal by formal means.
27. Once you understand how to write a program get someone else to write it.
21. Optimization hinders evolution.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
112. Computer Science is embarrassed by the computer.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
90. Computation has made the tree flower.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
4. Every program is a part of some other program and rarely fits.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
21. Optimization hinders evolution.
100. We will never run out of things to program as long as there is a single program around.
1. One man's constant is another man's variable.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
104. The proof of a system's value is its existence.
63. When we write programs that "learn", it turns out that we do and they don't.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
61. In programming, as in everything else, to be in error is to be reborn.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
18. A program without a loop and a structured variable isn't worth writing.
23. To understand a program you must become both the machine and the program.
1. One man's constant is another man's variable.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
119. Programming is an unnatural act.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
11. If you have a procedure with ten parameters, you probably missed some.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
104. The proof of a system's value is its existence.
18. A program without a loop and a structured variable isn't worth writing.
78. If your computer speaks English, it was probably made in Japan.
3. Syntactic sugar causes cancer of the semicolon.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
40. There are two ways to write error-free programs; only the third one works.
115. Most people find the concept of programming obvious, but the doing impossible.
60. In seeking the unattainable, simplicity only gets in the way.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
12. Recursion is the root of computation since it trades description for time.
14. In the long run every program becomes rococo - then rubble.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
61. In programming, as in everything else, to be in error is to be reborn.
115. Most people find the concept of programming obvious, but the doing impossible.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
12. Recursion is the root of computation since it trades description for time.
18. A program without a loop and a structured variable isn't worth writing.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
72. An adequate bootstrap is a contradiction in terms.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
66. Making something variable is easy. Controlling duration of constancy is the trick.
11. If you have a procedure with ten parameters, you probably missed some.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
95. Don't have good ideas if you aren't willing to be responsible for them.
57. It is easier to change the specification to fit the program than vice versa.
41. Some programming languages manage to absorb change, but withstand progress.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
38. Structured Programming supports the law of the excluded middle.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
3. Syntactic sugar causes cancer of the semicolon.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
15. Everything should be built top-down, except the first time.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
100. We will never run out of things to program as long as there is a single program around.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
107. The debate rages on: is PL/I Bachtrian or Dromedary?
61. In programming, as in everything else, to be in error is to be reborn.
61. In programming, as in everything else, to be in error is to be reborn.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
40. There are two ways to write error-free programs; only the third one works.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
102. One can't proceed from the informal to the formal by formal means.
55. A LISP programmer knows the value of everything, but the cost of nothing.
31. Simplicity does not precede complexity, but follows it.
27. Once you understand how to write a program get someone else to write it.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
62. In computing, invariants are ephemeral.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
43. In software systems, it is often the early bird that makes the worm.
1. One man's constant is another man's variable.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
59. In English every word can be verbed. Would that it were so in our programming languages.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
79. A year spent in artificial intelligence is enough to make one believe in God.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
40. There are two ways to write error-free programs; only the third one works.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
98. In computing, the mean time to failure keeps getting shorter.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
119. Programming is an unnatural act.
110. Editing is a rewording activity.
76. It is the user who should parameterize procedures, not their creators.
7. It is easier to write an incorrect program than understand a correct one.
100. We will never run out of things to program as long as there is a single program around.
105. You can't communicate complexity, only an awareness of it.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
23. To understand a program you must become both the machine and the program.
17. If a listener nods his head when you're explaining your program, wake him up.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
1. One man's constant is another man's variable.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
46. Like punning, programming is a play on words.
102. One can't proceed from the informal to the formal by formal means.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
96. Computers don't introduce order anywhere as much as they expose opportunities.
66. Making something variable is easy. Controlling duration of constancy is the trick.
119. Programming is an unnatural act.
112. Computer Science is embarrassed by the computer.
110. Editing is a rewording activity.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
43. In software systems, it is often the early bird that makes the worm.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
3. Syntactic sugar causes cancer of the semicolon.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
3. Syntactic sugar causes cancer of the semicolon.
60. In seeking the unattainable, simplicity only gets in the way.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
46. Like punning, programming is a play on words.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
96. Computers don't introduce order anywhere as much as they expose opportunities.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
96. Computers don't introduce order anywhere as much as they expose opportunities.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
40. There are two ways to write error-free programs; only the third one works.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
55. A LISP programmer knows the value of everything, but the cost of nothing.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
114. Within a computer natural language is unnatural.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
105. You can't communicate complexity, only an awareness of it.
108. Whenever two programmers meet to criticize their programs, both are silent.
12. Recursion is the root of computation since it trades description for time.
21. Optimization hinders evolution.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
62. In computing, invariants are ephemeral.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
8. A programming language is low level when its programs require attention to the irrelevant.
14. In the long run every program becomes rococo - then rubble.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
43. In software systems, it is often the early bird that makes the worm.
105. You can't communicate complexity, only an awareness of it.
4. Every program is a part of some other program and rarely fits.
76. It is the user who should parameterize procedures, not their creators.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
11. If you have a procedure with ten parameters, you probably missed some.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
66. Making something variable is easy. Controlling duration of constancy is the trick.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
98. In computing, the mean time to failure keeps getting shorter.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
12. Recursion is the root of computation since it trades description for time.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
14. In the long run every program becomes rococo - then rubble.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
17. If a listener nods his head when you're explaining your program, wake him up.
31. Simplicity does not precede complexity, but follows it.
112. Computer Science is embarrassed by the computer.
103. Purely applicative languages are poorly applicable.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
95. Don't have good ideas if you aren't willing to be responsible for them.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
8. A programming language is low level when its programs require attention to the irrelevant.
96. Computers don't introduce order anywhere as much as they expose opportunities.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
100. We will never run out of things to program as long as there is a single program around.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
21. Optimization hinders evolution.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
72. An adequate bootstrap is a contradiction in terms.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
47. As Will Rogers would have said, "There is no such thing as a free variable."
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
60. In seeking the unattainable, simplicity only gets in the way.
17. If a listener nods his head when you're explaining your program, wake him up.
12. Recursion is the root of computation since it trades description for time.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
3. Syntactic sugar causes cancer of the semicolon.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
46. Like punning, programming is a play on words.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
66. Making something variable is easy. Controlling duration of constancy is the trick.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
11. If you have a procedure with ten parameters, you probably missed some.
21. Optimization hinders evolution.
66. Making something variable is easy. Controlling duration of constancy is the trick.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
55. A LISP programmer knows the value of everything, but the cost of nothing.
105. You can't communicate complexity, only an awareness of it.
8. A programming language is low level when its programs require attention to the irrelevant.
60. In seeking the unattainable, simplicity only gets in the way.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
60. In seeking the unattainable, simplicity only gets in the way.
46. Like punning, programming is a play on words.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
72. An adequate bootstrap is a contradiction in terms.
18. A program without a loop and a structured variable isn't worth writing.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
61. In programming, as in everything else, to be in error is to be reborn.
55. A LISP programmer knows the value of everything, but the cost of nothing.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
60. In seeking the unattainable, simplicity only gets in the way.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
90. Computation has made the tree flower.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
112. Computer Science is embarrassed by the computer.
63. When we write programs that "learn", it turns out that we do and they don't.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
111. Why did the Roman Empire collapse? What is Latin for office automation?
21. Optimization hinders evolution.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
17. If a listener nods his head when you're explaining your program, wake him up.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
46. Like punning, programming is a play on words.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
76. It is the user who should parameterize procedures, not their creators.
111. Why did the Roman Empire collapse? What is Latin for office automation?
14. In the long run every program becomes rococo - then rubble.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
100. We will never run out of things to program as long as there is a single program around.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
21. Optimization hinders evolution.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
108. Whenever two programmers meet to criticize their programs, both are silent.
17. If a listener nods his head when you're explaining your program, wake him up.
62. In computing, invariants are ephemeral.
3. Syntactic sugar causes cancer of the semicolon.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
100. We will never run out of things to program as long as there is a single program around.
114. Within a computer natural language is unnatural.
108. Whenever two programmers meet to criticize their programs, both are silent.
110. Editing is a rewording activity.
12. Recursion is the root of computation since it trades description for time.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
19. A language that doesn't affect the way you think about programming, is not worth knowing.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
102. One can't proceed from the informal to the formal by formal means.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
103. Purely applicative languages are poorly applicable.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
41. Some programming languages manage to absorb change, but withstand progress.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
110. Editing is a rewording activity.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
100. We will never run out of things to program as long as there is a single program around.
1. One man's constant is another man's variable.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
41. Some programming languages manage to absorb change, but withstand progress.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
19. A language that doesn't affect the way you think about programming, is not worth knowing.
31. Simplicity does not precede complexity, but follows it.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
95. Don't have good ideas if you aren't willing to be responsible for them.
59. In English every word can be verbed. Would that it were so in our programming languages.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
47. As Will Rogers would have said, "There is no such thing as a free variable."
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
12. Recursion is the root of computation since it trades description for time.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
115. Most people find the concept of programming obvious, but the doing impossible.
55. A LISP programmer knows the value of everything, but the cost of nothing.
66. Making something variable is easy. Controlling duration of constancy is the trick.
108. Whenever two programmers meet to criticize their programs, both are silent.
100. We will never run out of things to program as long as there is a single program around.
114. Within a computer natural language is unnatural.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
119. Programming is an unnatural act.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
104. The proof of a system's value is its existence.
119. Programming is an unnatural act.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
18. A program without a loop and a structured variable isn't worth writing.
31. Simplicity does not precede complexity, but follows it.
63. When we write programs that "learn", it turns out that we do and they don't.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
61. In programming, as in everything else, to be in error is to be reborn.
103. Purely applicative languages are poorly applicable.
47. As Will Rogers would have said, "There is no such thing as a free variable."
103. Purely applicative languages are poorly applicable.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
72. An adequate bootstrap is a contradiction in terms.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
15. Everything should be built top-down, except the first time.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
111. Why did the Roman Empire collapse? What is Latin for office automation?
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
63. When we write programs that "learn", it turns out that we do and they don't.
79. A year spent in artificial intelligence is enough to make one believe in God.
31. Simplicity does not precede complexity, but follows it.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
114. Within a computer natural language is unnatural.
23. To understand a program you must become both the machine and the program.
105. You can't communicate complexity, only an awareness of it.
72. An adequate bootstrap is a contradiction in terms.
114. Within a computer natural language is unnatural.
41. Some programming languages manage to absorb change, but withstand progress.
27. Once you understand how to write a program get someone else to write it.
63. When we write programs that "learn", it turns out that we do and they don't.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
119. Programming is an unnatural act.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
21. Optimization hinders evolution.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
27. Once you understand how to write a program get someone else to write it.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
19. A language that doesn't affect the way you think about programming, is not worth knowing.
3. Syntactic sugar causes cancer of the semicolon.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
43. In software systems, it is often the early bird that makes the worm.
111. Why did the Roman Empire collapse? What is Latin for office automation?
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
14. In the long run every program becomes rococo - then rubble.
27. Once you understand how to write a program get someone else to write it.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
15. Everything should be built top-down, except the first time.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
4. Every program is a part of some other program and rarely fits.
27. Once you understand how to write a program get someone else to write it.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
23. To understand a program you must become both the machine and the program.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
114. Within a computer natural language is unnatural.
38. Structured Programming supports the law of the excluded middle.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
110. Editing is a rewording activity.
115. Most people find the concept of programming obvious, but the doing impossible.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
96. Computers don't introduce order anywhere as much as they expose opportunities.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
119. Programming is an unnatural act.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
102. One can't proceed from the informal to the formal by formal means.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
8. A programming language is low level when its programs require attention to the irrelevant.
102. One can't proceed from the informal to the formal by formal means.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
96. Computers don't introduce order anywhere as much as they expose opportunities.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
41. Some programming languages manage to absorb change, but withstand progress.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
119. Programming is an unnatural act.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
98. In computing, the mean time to failure keeps getting shorter.
90. Computation has made the tree flower.
66. Making something variable is easy. Controlling duration of constancy is the trick.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
8. A programming language is low level when its programs require attention to the irrelevant.
63. When we write programs that "learn", it turns out that we do and they don't.
47. As Will Rogers would have said, "There is no such thing as a free variable."
105. You can't communicate complexity, only an awareness of it.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
90. Computation has made the tree flower.
79. A year spent in artificial intelligence is enough to make one believe in God.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
46. Like punning, programming is a play on words.
43. In software systems, it is often the early bird that makes the worm.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
78. If your computer speaks English, it was probably made in Japan.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
61. In programming, as in everything else, to be in error is to be reborn.
31. Simplicity does not precede complexity, but follows it.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
100. We will never run out of things to program as long as there is a single program around.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
47. As Will Rogers would have said, "There is no such thing as a free variable."
14. In the long run every program becomes rococo - then rubble.
96. Computers don't introduce order anywhere as much as they expose opportunities.
38. Structured Programming supports the law of the excluded middle.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
17. If a listener nods his head when you're explaining your program, wake him up.
21. Optimization hinders evolution.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
18. A program without a loop and a structured variable isn't worth writing.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
46. Like punning, programming is a play on words.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
61. In programming, as in everything else, to be in error is to be reborn.
55. A LISP programmer knows the value of everything, but the cost of nothing.
78. If your computer speaks English, it was probably made in Japan.
79. A year spent in artificial intelligence is enough to make one believe in God.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
79. A year spent in artificial intelligence is enough to make one believe in God.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
8. A programming language is low level when its programs require attention to the irrelevant.
38. Structured Programming supports the law of the excluded middle.
76. It is the user who should parameterize procedures, not their creators.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
62. In computing, invariants are ephemeral.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
12. Recursion is the root of computation since it trades description for time.
14. In the long run every program becomes rococo - then rubble.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
57. It is easier to change the specification to fit the program than vice versa.
108. Whenever two programmers meet to criticize their programs, both are silent.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
108. Whenever two programmers meet to criticize their programs, both are silent.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
8. A programming language is low level when its programs require attention to the irrelevant.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
115. Most people find the concept of programming obvious, but the doing impossible.
72. An adequate bootstrap is a contradiction in terms.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
22. A good system can't have a weak command language.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
95. Don't have good ideas if you aren't willing to be responsible for them.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
55. A LISP programmer knows the value of everything, but the cost of nothing.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
108. Whenever two programmers meet to criticize their programs, both are silent.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
7. It is easier to write an incorrect program than understand a correct one.
103. Purely applicative languages are poorly applicable.
57. It is easier to change the specification to fit the program than vice versa.
90. Computation has made the tree flower.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
12. Recursion is the root of computation since it trades description for time.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
31. Simplicity does not precede complexity, but follows it.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
23. To understand a program you must become both the machine and the program.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
63. When we write programs that "learn", it turns out that we do and they don't.
90. Computation has made the tree flower.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
79. A year spent in artificial intelligence is enough to make one believe in God.
60. In seeking the unattainable, simplicity only gets in the way.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
41. Some programming languages manage to absorb change, but withstand progress.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
95. Don't have good ideas if you aren't willing to be responsible for them.
105. You can't communicate complexity, only an awareness of it.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
104. The proof of a system's value is its existence.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
63. When we write programs that "learn", it turns out that we do and they don't.
41. Some programming languages manage to absorb change, but withstand progress.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
38. Structured Programming supports the law of the excluded middle.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
14. In the long run every program becomes rococo - then rubble.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
21. Optimization hinders evolution.
66. Making something variable is easy. Controlling duration of constancy is the trick.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
104. The proof of a system's value is its existence.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
55. A LISP programmer knows the value of everything, but the cost of nothing.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
62. In computing, invariants are ephemeral.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
23. To understand a program you must become both the machine and the program.
3. Syntactic sugar causes cancer of the semicolon.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
114. Within a computer natural language is unnatural.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
115. Most people find the concept of programming obvious, but the doing impossible.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
76. It is the user who should parameterize procedures, not their creators.
62. In computing, invariants are ephemeral.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
90. Computation has made the tree flower.
100. We will never run out of things to program as long as there is a single program around.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
78. If your computer speaks English, it was probably made in Japan.
8. A programming language is low level when its programs require attention to the irrelevant.
79. A year spent in artificial intelligence is enough to make one believe in God.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
22. A good system can't have a weak command language.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
12. Recursion is the root of computation since it trades description for time.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
15. Everything should be built top-down, except the first time.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
61. In programming, as in everything else, to be in error is to be reborn.
8. A programming language is low level when its programs require attention to the irrelevant.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
115. Most people find the concept of programming obvious, but the doing impossible.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
18. A program without a loop and a structured variable isn't worth writing.
40. There are two ways to write error-free programs; only the third one works.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
14. In the long run every program becomes rococo - then rubble.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
40. There are two ways to write error-free programs; only the third one works.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
63. When we write programs that "learn", it turns out that we do and they don't.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
66. Making something variable is easy. Controlling duration of constancy is the trick.
119. Programming is an unnatural act.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
98. In computing, the mean time to failure keeps getting shorter.
12. Recursion is the root of computation since it trades description for time.
100. We will never run out of things to program as long as there is a single program around.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
66. Making something variable is easy. Controlling duration of constancy is the trick.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
119. Programming is an unnatural act.
61. In programming, as in everything else, to be in error is to be reborn.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
41. Some programming languages manage to absorb change, but withstand progress.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
21. Optimization hinders evolution.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
79. A year spent in artificial intelligence is enough to make one believe in God.
4. Every program is a part of some other program and rarely fits.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
108. Whenever two programmers meet to criticize their programs, both are silent.
62. In computing, invariants are ephemeral.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
119. Programming is an unnatural act.
72. An adequate bootstrap is a contradiction in terms.
12. Recursion is the root of computation since it trades description for time.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
3. Syntactic sugar causes cancer of the semicolon.
72. An adequate bootstrap is a contradiction in terms.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
23. To understand a program you must become both the machine and the program.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
31. Simplicity does not precede complexity, but follows it.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
38. Structured Programming supports the law of the excluded middle.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
78. If your computer speaks English, it was probably made in Japan.
22. A good system can't have a weak command language.
66. Making something variable is easy. Controlling duration of constancy is the trick.
23. To understand a program you must become both the machine and the program.
57. It is easier to change the specification to fit the program than vice versa.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
78. If your computer speaks English, it was probably made in Japan.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
21. Optimization hinders evolution.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
114. Within a computer natural language is unnatural.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
27. Once you understand how to write a program get someone else to write it.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
41. Some programming languages manage to absorb change, but withstand progress.
12. Recursion is the root of computation since it trades description for time.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
55. A LISP programmer knows the value of everything, but the cost of nothing.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
111. Why did the Roman Empire collapse? What is Latin for office automation?
60. In seeking the unattainable, simplicity only gets in the way.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
61. In programming, as in everything else, to be in error is to be reborn.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
23. To understand a program you must become both the machine and the program.
112. Computer Science is embarrassed by the computer.
40. There are two ways to write error-free programs; only the third one works.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
1. One man's constant is another man's variable.
4. Every program is a part of some other program and rarely fits.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
108. Whenever two programmers meet to criticize their programs, both are silent.
98. In computing, the mean time to failure keeps getting shorter.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
5. If a program manipulates a large amount of data, it does so in a small number of ways.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
108. Whenever two programmers meet to criticize their programs, both are silent.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
17. If a listener nods his head when you're explaining your program, wake him up.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
90. Computation has made the tree flower.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
21. Optimization hinders evolution.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
78. If your computer speaks English, it was probably made in Japan.
103. Purely applicative languages are poorly applicable.
90. Computation has made the tree flower.
17. If a listener nods his head when you're explaining your program, wake him up.
102. One can't proceed from the informal to the formal by formal means.
72. An adequate bootstrap is a contradiction in terms.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
98. In computing, the mean time to failure keeps getting shorter.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
62. In computing, invariants are ephemeral.
79. A year spent in artificial intelligence is enough to make one believe in God.
15. Everything should be built top-down, except the first time.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
60. In seeking the unattainable, simplicity only gets in the way.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
27. Once you understand how to write a program get someone else to write it.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
108. Whenever two programmers meet to criticize their programs, both are silent.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
3. Syntactic sugar causes cancer of the semicolon.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
4. Every program is a part of some other program and rarely fits.
119. Programming is an unnatural act.
78. If your computer speaks English, it was probably made in Japan.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
14. In the long run every program becomes rococo - then rubble.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
14. In the long run every program becomes rococo - then rubble.
102. One can't proceed from the informal to the formal by formal means.
22. A good system can't have a weak command language.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
63. When we write programs that "learn", it turns out that we do and they don't.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
17. If a listener nods his head when you're explaining your program, wake him up.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
57. It is easier to change the specification to fit the program than vice versa.
103. Purely applicative languages are poorly applicable.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
23. To understand a program you must become both the machine and the program.
111. Why did the Roman Empire collapse? What is Latin for office automation?
21. Optimization hinders evolution.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
14. In the long run every program becomes rococo - then rubble.
61. In programming, as in everything else, to be in error is to be reborn.
95. Don't have good ideas if you aren't willing to be responsible for them.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
119. Programming is an unnatural act.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
21. Optimization hinders evolution.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
1. One man's constant is another man's variable.
27. Once you understand how to write a program get someone else to write it.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
103. Purely applicative languages are poorly applicable.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
18. A program without a loop and a structured variable isn't worth writing.
90. Computation has made the tree flower.
72. An adequate bootstrap is a contradiction in terms.
23. To understand a program you must become both the machine and the program.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
27. Once you understand how to write a program get someone else to write it.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
7. It is easier to write an incorrect program than understand a correct one.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
59. In English every word can be verbed. Would that it were so in our programming languages.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
59. In English every word can be verbed. Would that it were so in our programming languages.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
78. If your computer speaks English, it was probably made in Japan.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
96. Computers don't introduce order anywhere as much as they expose opportunities.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
14. In the long run every program becomes rococo - then rubble.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
62. In computing, invariants are ephemeral.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
15. Everything should be built top-down, except the first time.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
114. Within a computer natural language is unnatural.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
108. Whenever two programmers meet to criticize their programs, both are silent.
18. A program without a loop and a structured variable isn't worth writing.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
57. It is easier to change the specification to fit the program than vice versa.
8. A programming language is low level when its programs require attention to the irrelevant.
21. Optimization hinders evolution.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
21. Optimization hinders evolution.
103. Purely applicative languages are poorly applicable.
27. Once you understand how to write a program get someone else to write it.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
40. There are two ways to write error-free programs; only the third one works.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
114. Within a computer natural language is unnatural.
90. Computation has made the tree flower.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
17. If a listener nods his head when you're explaining your program, wake him up.
66. Making something variable is easy. Controlling duration of constancy is the trick.
95. Don't have good ideas if you aren't willing to be responsible for them.
23. To understand a program you must become both the machine and the program.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
98. In computing, the mean time to failure keeps getting shorter.
103. Purely applicative languages are poorly applicable.
104. The proof of a system's value is its existence.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
23. To understand a program you must become both the machine and the program.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
100. We will never run out of things to program as long as there is a single program around.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
46. Like punning, programming is a play on words.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
79. A year spent in artificial intelligence is enough to make one believe in God.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
47. As Will Rogers would have said, "There is no such thing as a free variable."
66. Making something variable is easy. Controlling duration of constancy is the trick.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
15. Everything should be built top-down, except the first time.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
114. Within a computer natural language is unnatural.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
57. It is easier to change the specification to fit the program than vice versa.
43. In software systems, it is often the early bird that makes the worm.
61. In programming, as in everything else, to be in error is to be reborn.
17. If a listener nods his head when you're explaining your program, wake him up.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
18. A program without a loop and a structured variable isn't worth writing.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
14. In the long run every program becomes rococo - then rubble.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
98. In computing, the mean time to failure keeps getting shorter.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
8. A programming language is low level when its programs require attention to the irrelevant.
112. Computer Science is embarrassed by the computer.
60. In seeking the unattainable, simplicity only gets in the way.
61. In programming, as in everything else, to be in error is to be reborn.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
98. In computing, the mean time to failure keeps getting shorter.
21. Optimization hinders evolution.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
62. In computing, invariants are ephemeral.
103. Purely applicative languages are poorly applicable.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
3. Syntactic sugar causes cancer of the semicolon.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
111. Why did the Roman Empire collapse? What is Latin for office automation?
