18. A program without a loop and a structured variable isn't worth writing.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
114. Within a computer natural language is unnatural.
104. The proof of a system's value is its existence.
104. The proof of a system's value is its existence.
11. If you have a procedure with ten parameters, you probably missed some.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
112. Computer Science is embarrassed by the computer.
4. Every program is a part of some other program and rarely fits.
100. We will never run out of things to program as long as there is a single program around.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
7. It is easier to write an incorrect program than understand a correct one.
100. We will never run out of things to program as long as there is a single program around.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
55. A LISP programmer knows the value of everything, but the cost of nothing.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
61. In programming, as in everything else, to be in error is to be reborn.
7. It is easier to write an incorrect program than understand a correct one.
41. Some programming languages manage to absorb change, but withstand progress.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
59. In English every word can be verbed. Would that it were so in our programming languages.
100. We will never run out of things to program as long as there is a single program around.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
72. An adequate bootstrap is a contradiction in terms.
104. The proof of a system's value is its existence.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
114. Within a computer natural language is unnatural.
102. One can't proceed from the informal to the formal by formal means.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
31. Simplicity does not precede complexity, but follows it.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
4. Every program is a part of some other program and rarely fits.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
7. It is easier to write an incorrect program than understand a correct one.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
115. Most people find the concept of programming obvious, but the doing impossible.
115. Most people find the concept of programming obvious, but the doing impossible.
3. Syntactic sugar causes cancer of the semicolon.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
114. Within a computer natural language is unnatural.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
17. If a listener nods his head when you're explaining your program, wake him up.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
41. Some programming languages manage to absorb change, but withstand progress.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
63. When we write programs that "learn", it turns out that we do and they don't.
27. Once you understand how to write a program get someone else to write it.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
104. The proof of a system's value is its existence.
1. One man's constant is another man's variable.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
41. Some programming languages manage to absorb change, but withstand progress.
46. Like punning, programming is a play on words.
62. In computing, invariants are ephemeral.
102. One can't proceed from the informal to the formal by formal means.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
96. Computers don't introduce order anywhere as much as they expose opportunities.
17. If a listener nods his head when you're explaining your program, wake him up.
55. A LISP programmer knows the value of everything, but the cost of nothing.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
23. To understand a program you must become both the machine and the program.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
41. Some programming languages manage to absorb change, but withstand progress.
79. A year spent in artificial intelligence is enough to make one believe in God.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
59. In English every word can be verbed. Would that it were so in our programming languages.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
46. Like punning, programming is a play on words.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
79. A year spent in artificial intelligence is enough to make one believe in God.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
63. When we write programs that "learn", it turns out that we do and they don't.
76. It is the user who should parameterize procedures, not their creators.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
62. In computing, invariants are ephemeral.
46. Like punning, programming is a play on words.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
31. Simplicity does not precede complexity, but follows it.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
27. Once you understand how to write a program get someone else to write it.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
41. Some programming languages manage to absorb change, but withstand progress.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
60. In seeking the unattainable, simplicity only gets in the way.
119. Programming is an unnatural act.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
46. Like punning, programming is a play on words.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
103. Purely applicative languages are poorly applicable.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
119. Programming is an unnatural act.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
78. If your computer speaks English, it was probably made in Japan.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
46. Like punning, programming is a play on words.
90. Computation has made the tree flower.
60. In seeking the unattainable, simplicity only gets in the way.
100. We will never run out of things to program as long as there is a single program around.
4. Every program is a part of some other program and rarely fits.
15. Everything should be built top-down, except the first time.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
96. Computers don't introduce order anywhere as much as they expose opportunities.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
90. Computation has made the tree flower.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
27. Once you understand how to write a program get someone else to write it.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
100. We will never run out of things to program as long as there is a single program around.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
18. A program without a loop and a structured variable isn't worth writing.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
79. A year spent in artificial intelligence is enough to make one believe in God.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
41. Some programming languages manage to absorb change, but withstand progress.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
103. Purely applicative languages are poorly applicable.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
100. We will never run out of things to program as long as there is a single program around.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
41. Some programming languages manage to absorb change, but withstand progress.
66. Making something variable is easy. Controlling duration of constancy is the trick.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
78. If your computer speaks English, it was probably made in Japan.
76. It is the user who should parameterize procedures, not their creators.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
111. Why did the Roman Empire collapse? What is Latin for office automation?
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
27. Once you understand how to write a program get someone else to write it.
23. To understand a program you must become both the machine and the program.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
90. Computation has made the tree flower.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
66. Making something variable is easy. Controlling duration of constancy is the trick.
7. It is easier to write an incorrect program than understand a correct one.
46. Like punning, programming is a play on words.
115. Most people find the concept of programming obvious, but the doing impossible.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
11. If you have a procedure with ten parameters, you probably missed some.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
79. A year spent in artificial intelligence is enough to make one believe in God.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
40. There are two ways to write error-free programs; only the third one works.
111. Why did the Roman Empire collapse? What is Latin for office automation?
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
22. A good system can't have a weak command language.
114. Within a computer natural language is unnatural.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
55. A LISP programmer knows the value of everything, but the cost of nothing.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
19. A language that doesn't affect the way you think about programming, is not worth knowing.
60. In seeking the unattainable, simplicity only gets in the way.
114. Within a computer natural language is unnatural.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
100. We will never run out of things to program as long as there is a single program around.
23. To understand a program you must become both the machine and the program.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
38. Structured Programming supports the law of the excluded middle.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
14. In the long run every program becomes rococo - then rubble.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
31. Simplicity does not precede complexity, but follows it.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
108. Whenever two programmers meet to criticize their programs, both are silent.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
11. If you have a procedure with ten parameters, you probably missed some.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
112. Computer Science is embarrassed by the computer.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
90. Computation has made the tree flower.
95. Don't have good ideas if you aren't willing to be responsible for them.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
38. Structured Programming supports the law of the excluded middle.
21. Optimization hinders evolution.
11. If you have a procedure with ten parameters, you probably missed some.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
47. As Will Rogers would have said, "There is no such thing as a free variable."
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
76. It is the user who should parameterize procedures, not their creators.
59. In English every word can be verbed. Would that it were so in our programming languages.
62. In computing, invariants are ephemeral.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
43. In software systems, it is often the early bird that makes the worm.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
66. Making something variable is easy. Controlling duration of constancy is the trick.
57. It is easier to change the specification to fit the program than vice versa.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
76. It is the user who should parameterize procedures, not their creators.
111. Why did the Roman Empire collapse? What is Latin for office automation?
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
8. A programming language is low level when its programs require attention to the irrelevant.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
7. It is easier to write an incorrect program than understand a correct one.
62. In computing, invariants are ephemeral.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
108. Whenever two programmers meet to criticize their programs, both are silent.
102. One can't proceed from the informal to the formal by formal means.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
111. Why did the Roman Empire collapse? What is Latin for office automation?
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
110. Editing is a rewording activity.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
12. Recursion is the root of computation since it trades description for time.
17. If a listener nods his head when you're explaining your program, wake him up.
110. Editing is a rewording activity.
57. It is easier to change the specification to fit the program than vice versa.
12. Recursion is the root of computation since it trades description for time.
95. Don't have good ideas if you aren't willing to be responsible for them.
61. In programming, as in everything else, to be in error is to be reborn.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
7. It is easier to write an incorrect program than understand a correct one.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
8. A programming language is low level when its programs require attention to the irrelevant.
40. There are two ways to write error-free programs; only the third one works.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
95. Don't have good ideas if you aren't willing to be responsible for them.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
11. If you have a procedure with ten parameters, you probably missed some.
62. In computing, invariants are ephemeral.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
105. You can't communicate complexity, only an awareness of it.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
21. Optimization hinders evolution.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
55. A LISP programmer knows the value of everything, but the cost of nothing.
111. Why did the Roman Empire collapse? What is Latin for office automation?
4. Every program is a part of some other program and rarely fits.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
105. You can't communicate complexity, only an awareness of it.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
112. Computer Science is embarrassed by the computer.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
95. Don't have good ideas if you aren't willing to be responsible for them.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
40. There are two ways to write error-free programs; only the third one works.
60. In seeking the unattainable, simplicity only gets in the way.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
43. In software systems, it is often the early bird that makes the worm.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
102. One can't proceed from the informal to the formal by formal means.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
43. In software systems, it is often the early bird that makes the worm.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
18. A program without a loop and a structured variable isn't worth writing.
31. Simplicity does not precede complexity, but follows it.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
14. In the long run every program becomes rococo - then rubble.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
114. Within a computer natural language is unnatural.
105. You can't communicate complexity, only an awareness of it.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
104. The proof of a system's value is its existence.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
98. In computing, the mean time to failure keeps getting shorter.
95. Don't have good ideas if you aren't willing to be responsible for them.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
111. Why did the Roman Empire collapse? What is Latin for office automation?
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
38. Structured Programming supports the law of the excluded middle.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
46. Like punning, programming is a play on words.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
105. You can't communicate complexity, only an awareness of it.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
14. In the long run every program becomes rococo - then rubble.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
61. In programming, as in everything else, to be in error is to be reborn.
15. Everything should be built top-down, except the first time.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
1. One man's constant is another man's variable.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
72. An adequate bootstrap is a contradiction in terms.
43. In software systems, it is often the early bird that makes the worm.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
90. Computation has made the tree flower.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
47. As Will Rogers would have said, "There is no such thing as a free variable."
18. A program without a loop and a structured variable isn't worth writing.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
4. Every program is a part of some other program and rarely fits.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
23. To understand a program you must become both the machine and the program.
40. There are two ways to write error-free programs; only the third one works.
100. We will never run out of things to program as long as there is a single program around.
78. If your computer speaks English, it was probably made in Japan.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
47. As Will Rogers would have said, "There is no such thing as a free variable."
27. Once you understand how to write a program get someone else to write it.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
31. Simplicity does not precede complexity, but follows it.
18. A program without a loop and a structured variable isn't worth writing.
95. Don't have good ideas if you aren't willing to be responsible for them.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
90. Computation has made the tree flower.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
105. You can't communicate complexity, only an awareness of it.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
100. We will never run out of things to program as long as there is a single program around.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
96. Computers don't introduce order anywhere as much as they expose opportunities.
22. A good system can't have a weak command language.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
78. If your computer speaks English, it was probably made in Japan.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
103. Purely applicative languages are poorly applicable.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
110. Editing is a rewording activity.
95. Don't have good ideas if you aren't willing to be responsible for them.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
98. In computing, the mean time to failure keeps getting shorter.
4. Every program is a part of some other program and rarely fits.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
7. It is easier to write an incorrect program than understand a correct one.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
15. Everything should be built top-down, except the first time.
114. Within a computer natural language is unnatural.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
111. Why did the Roman Empire collapse? What is Latin for office automation?
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
17. If a listener nods his head when you're explaining your program, wake him up.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
43. In software systems, it is often the early bird that makes the worm.
114. Within a computer natural language is unnatural.
72. An adequate bootstrap is a contradiction in terms.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
21. Optimization hinders evolution.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
57. It is easier to change the specification to fit the program than vice versa.
76. It is the user who should parameterize procedures, not their creators.
31. Simplicity does not precede complexity, but follows it.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
15. Everything should be built top-down, except the first time.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
8. A programming language is low level when its programs require attention to the irrelevant.
3. Syntactic sugar causes cancer of the semicolon.
43. In software systems, it is often the early bird that makes the worm.
31. Simplicity does not precede complexity, but follows it.
21. Optimization hinders evolution.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
57. It is easier to change the specification to fit the program than vice versa.
18. A program without a loop and a structured variable isn't worth writing.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
22. A good system can't have a weak command language.
17. If a listener nods his head when you're explaining your program, wake him up.
18. A program without a loop and a structured variable isn't worth writing.
1. One man's constant is another man's variable.
63. When we write programs that "learn", it turns out that we do and they don't.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
12. Recursion is the root of computation since it trades description for time.
90. Computation has made the tree flower.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
43. In software systems, it is often the early bird that makes the worm.
111. Why did the Roman Empire collapse? What is Latin for office automation?
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
66. Making something variable is easy. Controlling duration of constancy is the trick.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
100. We will never run out of things to program as long as there is a single program around.
95. Don't have good ideas if you aren't willing to be responsible for them.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
98. In computing, the mean time to failure keeps getting shorter.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
114. Within a computer natural language is unnatural.
47. As Will Rogers would have said, "There is no such thing as a free variable."
112. Computer Science is embarrassed by the computer.
66. Making something variable is easy. Controlling duration of constancy is the trick.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
61. In programming, as in everything else, to be in error is to be reborn.
61. In programming, as in everything else, to be in error is to be reborn.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
105. You can't communicate complexity, only an awareness of it.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
12. Recursion is the root of computation since it trades description for time.
11. If you have a procedure with ten parameters, you probably missed some.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
31. Simplicity does not precede complexity, but follows it.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
22. A good system can't have a weak command language.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
61. In programming, as in everything else, to be in error is to be reborn.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
61. In programming, as in everything else, to be in error is to be reborn.
7. It is easier to write an incorrect program than understand a correct one.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
96. Computers don't introduce order anywhere as much as they expose opportunities.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
46. Like punning, programming is a play on words.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
119. Programming is an unnatural act.
21. Optimization hinders evolution.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
108. Whenever two programmers meet to criticize their programs, both are silent.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
8. A programming language is low level when its programs require attention to the irrelevant.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
62. In computing, invariants are ephemeral.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
38. Structured Programming supports the law of the excluded middle.
27. Once you understand how to write a program get someone else to write it.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
110. Editing is a rewording activity.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
7. It is easier to write an incorrect program than understand a correct one.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
57. It is easier to change the specification to fit the program than vice versa.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
96. Computers don't introduce order anywhere as much as they expose opportunities.
63. When we write programs that "learn", it turns out that we do and they don't.
98. In computing, the mean time to failure keeps getting shorter.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
3. Syntactic sugar causes cancer of the semicolon.
14. In the long run every program becomes rococo - then rubble.
27. Once you understand how to write a program get someone else to write it.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
1. One man's constant is another man's variable.
60. In seeking the unattainable, simplicity only gets in the way.
78. If your computer speaks English, it was probably made in Japan.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
100. We will never run out of things to program as long as there is a single program around.
90. Computation has made the tree flower.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
90. Computation has made the tree flower.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
14. In the long run every program becomes rococo - then rubble.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
72. An adequate bootstrap is a contradiction in terms.
62. In computing, invariants are ephemeral.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
90. Computation has made the tree flower.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
18. A program without a loop and a structured variable isn't worth writing.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
47. As Will Rogers would have said, "There is no such thing as a free variable."
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
3. Syntactic sugar causes cancer of the semicolon.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
112. Computer Science is embarrassed by the computer.
111. Why did the Roman Empire collapse? What is Latin for office automation?
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
15. Everything should be built top-down, except the first time.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
61. In programming, as in everything else, to be in error is to be reborn.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
15. Everything should be built top-down, except the first time.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
14. In the long run every program becomes rococo - then rubble.
112. Computer Science is embarrassed by the computer.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
108. Whenever two programmers meet to criticize their programs, both are silent.
100. We will never run out of things to program as long as there is a single program around.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
103. Purely applicative languages are poorly applicable.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
22. A good system can't have a weak command language.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
27. Once you understand how to write a program get someone else to write it.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
111. Why did the Roman Empire collapse? What is Latin for office automation?
38. Structured Programming supports the law of the excluded middle.
11. If you have a procedure with ten parameters, you probably missed some.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
21. Optimization hinders evolution.
57. It is easier to change the specification to fit the program than vice versa.
8. A programming language is low level when its programs require attention to the irrelevant.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
98. In computing, the mean time to failure keeps getting shorter.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
46. Like punning, programming is a play on words.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
55. A LISP programmer knows the value of everything, but the cost of nothing.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
110. Editing is a rewording activity.
21. Optimization hinders evolution.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
111. Why did the Roman Empire collapse? What is Latin for office automation?
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
111. Why did the Roman Empire collapse? What is Latin for office automation?
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
102. One can't proceed from the informal to the formal by formal means.
55. A LISP programmer knows the value of everything, but the cost of nothing.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
7. It is easier to write an incorrect program than understand a correct one.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
102. One can't proceed from the informal to the formal by formal means.
22. A good system can't have a weak command language.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
15. Everything should be built top-down, except the first time.
43. In software systems, it is often the early bird that makes the worm.
8. A programming language is low level when its programs require attention to the irrelevant.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
60. In seeking the unattainable, simplicity only gets in the way.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
14. In the long run every program becomes rococo - then rubble.
111. Why did the Roman Empire collapse? What is Latin for office automation?
18. A program without a loop and a structured variable isn't worth writing.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
55. A LISP programmer knows the value of everything, but the cost of nothing.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
43. In software systems, it is often the early bird that makes the worm.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
78. If your computer speaks English, it was probably made in Japan.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
114. Within a computer natural language is unnatural.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
103. Purely applicative languages are poorly applicable.
114. Within a computer natural language is unnatural.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
43. In software systems, it is often the early bird that makes the worm.
47. As Will Rogers would have said, "There is no such thing as a free variable."
115. Most people find the concept of programming obvious, but the doing impossible.
40. There are two ways to write error-free programs; only the third one works.
59. In English every word can be verbed. Would that it were so in our programming languages.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
98. In computing, the mean time to failure keeps getting shorter.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
38. Structured Programming supports the law of the excluded middle.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
108. Whenever two programmers meet to criticize their programs, both are silent.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
38. Structured Programming supports the law of the excluded middle.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
119. Programming is an unnatural act.
76. It is the user who should parameterize procedures, not their creators.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
23. To understand a program you must become both the machine and the program.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
23. To understand a program you must become both the machine and the program.
102. One can't proceed from the informal to the formal by formal means.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
78. If your computer speaks English, it was probably made in Japan.
110. Editing is a rewording activity.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
111. Why did the Roman Empire collapse? What is Latin for office automation?
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
31. Simplicity does not precede complexity, but follows it.
78. If your computer speaks English, it was probably made in Japan.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
22. A good system can't have a weak command language.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
12. Recursion is the root of computation since it trades description for time.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
7. It is easier to write an incorrect program than understand a correct one.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
108. Whenever two programmers meet to criticize their programs, both are silent.
8. A programming language is low level when its programs require attention to the irrelevant.
31. Simplicity does not precede complexity, but follows it.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
31. Simplicity does not precede complexity, but follows it.
1. One man's constant is another man's variable.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
63. When we write programs that "learn", it turns out that we do and they don't.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
105. You can't communicate complexity, only an awareness of it.
12. Recursion is the root of computation since it trades description for time.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
7. It is easier to write an incorrect program than understand a correct one.
105. You can't communicate complexity, only an awareness of it.
66. Making something variable is easy. Controlling duration of constancy is the trick.
59. In English every word can be verbed. Would that it were so in our programming languages.
72. An adequate bootstrap is a contradiction in terms.
11. If you have a procedure with ten parameters, you probably missed some.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
110. Editing is a rewording activity.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
46. Like punning, programming is a play on words.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
23. To understand a program you must become both the machine and the program.
1. One man's constant is another man's variable.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
110. Editing is a rewording activity.
100. We will never run out of things to program as long as there is a single program around.
27. Once you understand how to write a program get someone else to write it.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
59. In English every word can be verbed. Would that it were so in our programming languages.
114. Within a computer natural language is unnatural.
79. A year spent in artificial intelligence is enough to make one believe in God.
95. Don't have good ideas if you aren't willing to be responsible for them.
38. Structured Programming supports the law of the excluded middle.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
104. The proof of a system's value is its existence.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
115. Most people find the concept of programming obvious, but the doing impossible.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
43. In software systems, it is often the early bird that makes the worm.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
11. If you have a procedure with ten parameters, you probably missed some.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
40. There are two ways to write error-free programs; only the third one works.
111. Why did the Roman Empire collapse? What is Latin for office automation?
21. Optimization hinders evolution.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
4. Every program is a part of some other program and rarely fits.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
72. An adequate bootstrap is a contradiction in terms.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
55. A LISP programmer knows the value of everything, but the cost of nothing.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
38. Structured Programming supports the law of the excluded middle.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
96. Computers don't introduce order anywhere as much as they expose opportunities.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
105. You can't communicate complexity, only an awareness of it.
23. To understand a program you must become both the machine and the program.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
79. A year spent in artificial intelligence is enough to make one believe in God.
60. In seeking the unattainable, simplicity only gets in the way.
3. Syntactic sugar causes cancer of the semicolon.
62. In computing, invariants are ephemeral.
31. Simplicity does not precede complexity, but follows it.
14. In the long run every program becomes rococo - then rubble.
102. One can't proceed from the informal to the formal by formal means.
23. To understand a program you must become both the machine and the program.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
76. It is the user who should parameterize procedures, not their creators.
23. To understand a program you must become both the machine and the program.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
102. One can't proceed from the informal to the formal by formal means.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
18. A program without a loop and a structured variable isn't worth writing.
18. A program without a loop and a structured variable isn't worth writing.
46. Like punning, programming is a play on words.
66. Making something variable is easy. Controlling duration of constancy is the trick.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
17. If a listener nods his head when you're explaining your program, wake him up.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
62. In computing, invariants are ephemeral.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
46. Like punning, programming is a play on words.
3. Syntactic sugar causes cancer of the semicolon.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
114. Within a computer natural language is unnatural.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
119. Programming is an unnatural act.
63. When we write programs that "learn", it turns out that we do and they don't.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
98. In computing, the mean time to failure keeps getting shorter.
103. Purely applicative languages are poorly applicable.
3. Syntactic sugar causes cancer of the semicolon.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
110. Editing is a rewording activity.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
17. If a listener nods his head when you're explaining your program, wake him up.
21. Optimization hinders evolution.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
43. In software systems, it is often the early bird that makes the worm.
72. An adequate bootstrap is a contradiction in terms.
17. If a listener nods his head when you're explaining your program, wake him up.
96. Computers don't introduce order anywhere as much as they expose opportunities.
8. A programming language is low level when its programs require attention to the irrelevant.
114. Within a computer natural language is unnatural.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
100. We will never run out of things to program as long as there is a single program around.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
90. Computation has made the tree flower.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
60. In seeking the unattainable, simplicity only gets in the way.
63. When we write programs that "learn", it turns out that we do and they don't.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
115. Most people find the concept of programming obvious, but the doing impossible.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
115. Most people find the concept of programming obvious, but the doing impossible.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
46. Like punning, programming is a play on words.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
4. Every program is a part of some other program and rarely fits.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
103. Purely applicative languages are poorly applicable.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
108. Whenever two programmers meet to criticize their programs, both are silent.
1. One man's constant is another man's variable.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
96. Computers don't introduce order anywhere as much as they expose opportunities.
114. Within a computer natural language is unnatural.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
60. In seeking the unattainable, simplicity only gets in the way.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
100. We will never run out of things to program as long as there is a single program around.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
72. An adequate bootstrap is a contradiction in terms.
22. A good system can't have a weak command language.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
38. Structured Programming supports the law of the excluded middle.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
103. Purely applicative languages are poorly applicable.
7. It is easier to write an incorrect program than understand a correct one.
95. Don't have good ideas if you aren't willing to be responsible for them.
17. If a listener nods his head when you're explaining your program, wake him up.
90. Computation has made the tree flower.
66. Making something variable is easy. Controlling duration of constancy is the trick.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
72. An adequate bootstrap is a contradiction in terms.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
27. Once you understand how to write a program get someone else to write it.
78. If your computer speaks English, it was probably made in Japan.
103. Purely applicative languages are poorly applicable.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
12. Recursion is the root of computation since it trades description for time.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
12. Recursion is the root of computation since it trades description for time.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
95. Don't have good ideas if you aren't willing to be responsible for them.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
3. Syntactic sugar causes cancer of the semicolon.
90. Computation has made the tree flower.
8. A programming language is low level when its programs require attention to the irrelevant.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
62. In computing, invariants are ephemeral.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
66. Making something variable is easy. Controlling duration of constancy is the trick.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
119. Programming is an unnatural act.
38. Structured Programming supports the law of the excluded middle.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
22. A good system can't have a weak command language.
11. If you have a procedure with ten parameters, you probably missed some.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
66. Making something variable is easy. Controlling duration of constancy is the trick.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
15. Everything should be built top-down, except the first time.
62. In computing, invariants are ephemeral.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
11. If you have a procedure with ten parameters, you probably missed some.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
8. A programming language is low level when its programs require attention to the irrelevant.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
57. It is easier to change the specification to fit the program than vice versa.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
4. Every program is a part of some other program and rarely fits.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
79. A year spent in artificial intelligence is enough to make one believe in God.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
104. The proof of a system's value is its existence.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
110. Editing is a rewording activity.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
60. In seeking the unattainable, simplicity only gets in the way.
46. Like punning, programming is a play on words.
104. The proof of a system's value is its existence.
41. Some programming languages manage to absorb change, but withstand progress.
63. When we write programs that "learn", it turns out that we do and they don't.
7. It is easier to write an incorrect program than understand a correct one.
15. Everything should be built top-down, except the first time.
100. We will never run out of things to program as long as there is a single program around.
90. Computation has made the tree flower.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
98. In computing, the mean time to failure keeps getting shorter.
11. If you have a procedure with ten parameters, you probably missed some.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
90. Computation has made the tree flower.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
31. Simplicity does not precede complexity, but follows it.
21. Optimization hinders evolution.
22. A good system can't have a weak command language.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
115. Most people find the concept of programming obvious, but the doing impossible.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
119. Programming is an unnatural act.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
38. Structured Programming supports the law of the excluded middle.
114. Within a computer natural language is unnatural.
62. In computing, invariants are ephemeral.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
63. When we write programs that "learn", it turns out that we do and they don't.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
1. One man's constant is another man's variable.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
76. It is the user who should parameterize procedures, not their creators.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
111. Why did the Roman Empire collapse? What is Latin for office automation?
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
18. A program without a loop and a structured variable isn't worth writing.
7. It is easier to write an incorrect program than understand a correct one.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
31. Simplicity does not precede complexity, but follows it.
31. Simplicity does not precede complexity, but follows it.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
105. You can't communicate complexity, only an awareness of it.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
66. Making something variable is easy. Controlling duration of constancy is the trick.
15. Everything should be built top-down, except the first time.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
114. Within a computer natural language is unnatural.
66. Making something variable is easy. Controlling duration of constancy is the trick.
98. In computing, the mean time to failure keeps getting shorter.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
110. Editing is a rewording activity.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
1. One man's constant is another man's variable.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
115. Most people find the concept of programming obvious, but the doing impossible.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
96. Computers don't introduce order anywhere as much as they expose opportunities.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
27. Once you understand how to write a program get someone else to write it.
7. It is easier to write an incorrect program than understand a correct one.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
72. An adequate bootstrap is a contradiction in terms.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
8. A programming language is low level when its programs require attention to the irrelevant.
115. Most people find the concept of programming obvious, but the doing impossible.
17. If a listener nods his head when you're explaining your program, wake him up.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
41. Some programming languages manage to absorb change, but withstand progress.
46. Like punning, programming is a play on words.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
18. A program without a loop and a structured variable isn't worth writing.
23. To understand a program you must become both the machine and the program.
90. Computation has made the tree flower.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
55. A LISP programmer knows the value of everything, but the cost of nothing.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
111. Why did the Roman Empire collapse? What is Latin for office automation?
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
115. Most people find the concept of programming obvious, but the doing impossible.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
8. A programming language is low level when its programs require attention to the irrelevant.
11. If you have a procedure with ten parameters, you probably missed some.
119. Programming is an unnatural act.
23. To understand a program you must become both the machine and the program.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
41. Some programming languages manage to absorb change, but withstand progress.
115. Most people find the concept of programming obvious, but the doing impossible.
79. A year spent in artificial intelligence is enough to make one believe in God.
62. In computing, invariants are ephemeral.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
111. Why did the Roman Empire collapse? What is Latin for office automation?
43. In software systems, it is often the early bird that makes the worm.
104. The proof of a system's value is its existence.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
102. One can't proceed from the informal to the formal by formal means.
60. In seeking the unattainable, simplicity only gets in the way.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
112. Computer Science is embarrassed by the computer.
104. The proof of a system's value is its existence.
31. Simplicity does not precede complexity, but follows it.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
79. A year spent in artificial intelligence is enough to make one believe in God.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
55. A LISP programmer knows the value of everything, but the cost of nothing.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
102. One can't proceed from the informal to the formal by formal means.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
57. It is easier to change the specification to fit the program than vice versa.
119. Programming is an unnatural act.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
66. Making something variable is easy. Controlling duration of constancy is the trick.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
115. Most people find the concept of programming obvious, but the doing impossible.
105. You can't communicate complexity, only an awareness of it.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
62. In computing, invariants are ephemeral.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
18. A program without a loop and a structured variable isn't worth writing.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
4. Every program is a part of some other program and rarely fits.
17. If a listener nods his head when you're explaining your program, wake him up.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
100. We will never run out of things to program as long as there is a single program around.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
23. To understand a program you must become both the machine and the program.
1. One man's constant is another man's variable.
78. If your computer speaks English, it was probably made in Japan.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
47. As Will Rogers would have said, "There is no such thing as a free variable."
114. Within a computer natural language is unnatural.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
112. Computer Science is embarrassed by the computer.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
105. You can't communicate complexity, only an awareness of it.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
104. The proof of a system's value is its existence.
59. In English every word can be verbed. Would that it were so in our programming languages.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
66. Making something variable is easy. Controlling duration of constancy is the trick.
62. In computing, invariants are ephemeral.
21. Optimization hinders evolution.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
7. It is easier to write an incorrect program than understand a correct one.
17. If a listener nods his head when you're explaining your program, wake him up.
8. A programming language is low level when its programs require attention to the irrelevant.
90. Computation has made the tree flower.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
47. As Will Rogers would have said, "There is no such thing as a free variable."
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
31. Simplicity does not precede complexity, but follows it.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
63. When we write programs that "learn", it turns out that we do and they don't.
76. It is the user who should parameterize procedures, not their creators.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
4. Every program is a part of some other program and rarely fits.
105. You can't communicate complexity, only an awareness of it.
79. A year spent in artificial intelligence is enough to make one believe in God.
102. One can't proceed from the informal to the formal by formal means.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
102. One can't proceed from the informal to the formal by formal means.
96. Computers don't introduce order anywhere as much as they expose opportunities.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
41. Some programming languages manage to absorb change, but withstand progress.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
61. In programming, as in everything else, to be in error is to be reborn.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
21. Optimization hinders evolution.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
60. In seeking the unattainable, simplicity only gets in the way.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
46. Like punning, programming is a play on words.
104. The proof of a system's value is its existence.
59. In English every word can be verbed. Would that it were so in our programming languages.
72. An adequate bootstrap is a contradiction in terms.
104. The proof of a system's value is its existence.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
78. If your computer speaks English, it was probably made in Japan.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
96. Computers don't introduce order anywhere as much as they expose opportunities.
115. Most people find the concept of programming obvious, but the doing impossible.
112. Computer Science is embarrassed by the computer.
11. If you have a procedure with ten parameters, you probably missed some.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
78. If your computer speaks English, it was probably made in Japan.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
57. It is easier to change the specification to fit the program than vice versa.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
102. One can't proceed from the informal to the formal by formal means.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
46. Like punning, programming is a play on words.
21. Optimization hinders evolution.
76. It is the user who should parameterize procedures, not their creators.
23. To understand a program you must become both the machine and the program.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
111. Why did the Roman Empire collapse? What is Latin for office automation?
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
1. One man's constant is another man's variable.
105. You can't communicate complexity, only an awareness of it.
46. Like punning, programming is a play on words.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
40. There are two ways to write error-free programs; only the third one works.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
95. Don't have good ideas if you aren't willing to be responsible for them.
31. Simplicity does not precede complexity, but follows it.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
114. Within a computer natural language is unnatural.
46. Like punning, programming is a play on words.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
18. A program without a loop and a structured variable isn't worth writing.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
59. In English every word can be verbed. Would that it were so in our programming languages.
108. Whenever two programmers meet to criticize their programs, both are silent.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
17. If a listener nods his head when you're explaining your program, wake him up.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
31. Simplicity does not precede complexity, but follows it.
115. Most people find the concept of programming obvious, but the doing impossible.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
115. Most people find the concept of programming obvious, but the doing impossible.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
23. To understand a program you must become both the machine and the program.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
8. A programming language is low level when its programs require attention to the irrelevant.
119. Programming is an unnatural act.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
31. Simplicity does not precede complexity, but follows it.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
38. Structured Programming supports the law of the excluded middle.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
41. Some programming languages manage to absorb change, but withstand progress.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
63. When we write programs that "learn", it turns out that we do and they don't.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
8. A programming language is low level when its programs require attention to the irrelevant.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
40. There are two ways to write error-free programs; only the third one works.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
110. Editing is a rewording activity.
27. Once you understand how to write a program get someone else to write it.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
115. Most people find the concept of programming obvious, but the doing impossible.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
66. Making something variable is easy. Controlling duration of constancy is the trick.
96. Computers don't introduce order anywhere as much as they expose opportunities.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
105. You can't communicate complexity, only an awareness of it.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
11. If you have a procedure with ten parameters, you probably missed some.
41. Some programming languages manage to absorb change, but withstand progress.
78. If your computer speaks English, it was probably made in Japan.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
31. Simplicity does not precede complexity, but follows it.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
21. Optimization hinders evolution.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
105. You can't communicate complexity, only an awareness of it.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
103. Purely applicative languages are poorly applicable.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
100. We will never run out of things to program as long as there is a single program around.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
79. A year spent in artificial intelligence is enough to make one believe in God.
11. If you have a procedure with ten parameters, you probably missed some.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
96. Computers don't introduce order anywhere as much as they expose opportunities.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
40. There are two ways to write error-free programs; only the third one works.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
15. Everything should be built top-down, except the first time.
103. Purely applicative languages are poorly applicable.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
17. If a listener nods his head when you're explaining your program, wake him up.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
55. A LISP programmer knows the value of everything, but the cost of nothing.
111. Why did the Roman Empire collapse? What is Latin for office automation?
22. A good system can't have a weak command language.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
4. Every program is a part of some other program and rarely fits.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
60. In seeking the unattainable, simplicity only gets in the way.
115. Most people find the concept of programming obvious, but the doing impossible.
41. Some programming languages manage to absorb change, but withstand progress.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
23. To understand a program you must become both the machine and the program.
110. Editing is a rewording activity.
41. Some programming languages manage to absorb change, but withstand progress.
41. Some programming languages manage to absorb change, but withstand progress.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
22. A good system can't have a weak command language.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
78. If your computer speaks English, it was probably made in Japan.
1. One man's constant is another man's variable.
61. In programming, as in everything else, to be in error is to be reborn.
103. Purely applicative languages are poorly applicable.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
11. If you have a procedure with ten parameters, you probably missed some.
47. As Will Rogers would have said, "There is no such thing as a free variable."
17. If a listener nods his head when you're explaining your program, wake him up.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
112. Computer Science is embarrassed by the computer.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
15. Everything should be built top-down, except the first time.
47. As Will Rogers would have said, "There is no such thing as a free variable."
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
55. A LISP programmer knows the value of everything, but the cost of nothing.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
78. If your computer speaks English, it was probably made in Japan.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
102. One can't proceed from the informal to the formal by formal means.
18. A program without a loop and a structured variable isn't worth writing.
95. Don't have good ideas if you aren't willing to be responsible for them.
62. In computing, invariants are ephemeral.
108. Whenever two programmers meet to criticize their programs, both are silent.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
43. In software systems, it is often the early bird that makes the worm.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
95. Don't have good ideas if you aren't willing to be responsible for them.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
41. Some programming languages manage to absorb change, but withstand progress.
27. Once you understand how to write a program get someone else to write it.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
103. Purely applicative languages are poorly applicable.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
60. In seeking the unattainable, simplicity only gets in the way.
11. If you have a procedure with ten parameters, you probably missed some.
46. Like punning, programming is a play on words.
27. Once you understand how to write a program get someone else to write it.
108. Whenever two programmers meet to criticize their programs, both are silent.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
79. A year spent in artificial intelligence is enough to make one believe in God.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
8. A programming language is low level when its programs require attention to the irrelevant.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
55. A LISP programmer knows the value of everything, but the cost of nothing.
38. Structured Programming supports the law of the excluded middle.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
61. In programming, as in everything else, to be in error is to be reborn.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
79. A year spent in artificial intelligence is enough to make one believe in God.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
23. To understand a program you must become both the machine and the program.
7. It is easier to write an incorrect program than understand a correct one.
46. Like punning, programming is a play on words.
66. Making something variable is easy. Controlling duration of constancy is the trick.
4. Every program is a part of some other program and rarely fits.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
114. Within a computer natural language is unnatural.
15. Everything should be built top-down, except the first time.
98. In computing, the mean time to failure keeps getting shorter.
66. Making something variable is easy. Controlling duration of constancy is the trick.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
4. Every program is a part of some other program and rarely fits.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
62. In computing, invariants are ephemeral.
21. Optimization hinders evolution.
103. Purely applicative languages are poorly applicable.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
61. In programming, as in everything else, to be in error is to be reborn.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
112. Computer Science is embarrassed by the computer.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
4. Every program is a part of some other program and rarely fits.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
95. Don't have good ideas if you aren't willing to be responsible for them.
17. If a listener nods his head when you're explaining your program, wake him up.
40. There are two ways to write error-free programs; only the third one works.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
14. In the long run every program becomes rococo - then rubble.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
78. If your computer speaks English, it was probably made in Japan.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
78. If your computer speaks English, it was probably made in Japan.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
62. In computing, invariants are ephemeral.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
47. As Will Rogers would have said, "There is no such thing as a free variable."
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
96. Computers don't introduce order anywhere as much as they expose opportunities.
96. Computers don't introduce order anywhere as much as they expose opportunities.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
55. A LISP programmer knows the value of everything, but the cost of nothing.
17. If a listener nods his head when you're explaining your program, wake him up.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
112. Computer Science is embarrassed by the computer.
98. In computing, the mean time to failure keeps getting shorter.
47. As Will Rogers would have said, "There is no such thing as a free variable."
22. A good system can't have a weak command language.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
90. Computation has made the tree flower.
108. Whenever two programmers meet to criticize their programs, both are silent.
14. In the long run every program becomes rococo - then rubble.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
90. Computation has made the tree flower.
103. Purely applicative languages are poorly applicable.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
3. Syntactic sugar causes cancer of the semicolon.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
112. Computer Science is embarrassed by the computer.
43. In software systems, it is often the early bird that makes the worm.
17. If a listener nods his head when you're explaining your program, wake him up.
108. Whenever two programmers meet to criticize their programs, both are silent.
78. If your computer speaks English, it was probably made in Japan.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
62. In computing, invariants are ephemeral.
21. Optimization hinders evolution.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
111. Why did the Roman Empire collapse? What is Latin for office automation?
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
55. A LISP programmer knows the value of everything, but the cost of nothing.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
96. Computers don't introduce order anywhere as much as they expose opportunities.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
23. To understand a program you must become both the machine and the program.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
55. A LISP programmer knows the value of everything, but the cost of nothing.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
12. Recursion is the root of computation since it trades description for time.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
17. If a listener nods his head when you're explaining your program, wake him up.
15. Everything should be built top-down, except the first time.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
79. A year spent in artificial intelligence is enough to make one believe in God.
61. In programming, as in everything else, to be in error is to be reborn.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
95. Don't have good ideas if you aren't willing to be responsible for them.
103. Purely applicative languages are poorly applicable.
76. It is the user who should parameterize procedures, not their creators.
12. Recursion is the root of computation since it trades description for time.
114. Within a computer natural language is unnatural.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
12. Recursion is the root of computation since it trades description for time.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
63. When we write programs that "learn", it turns out that we do and they don't.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
110. Editing is a rewording activity.
62. In computing, invariants are ephemeral.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
63. When we write programs that "learn", it turns out that we do and they don't.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
12. Recursion is the root of computation since it trades description for time.
14. In the long run every program becomes rococo - then rubble.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
21. Optimization hinders evolution.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
98. In computing, the mean time to failure keeps getting shorter.
105. You can't communicate complexity, only an awareness of it.
14. In the long run every program becomes rococo - then rubble.
112. Computer Science is embarrassed by the computer.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
90. Computation has made the tree flower.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
61. In programming, as in everything else, to be in error is to be reborn.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
105. You can't communicate complexity, only an awareness of it.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
27. Once you understand how to write a program get someone else to write it.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
111. Why did the Roman Empire collapse? What is Latin for office automation?
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
105. You can't communicate complexity, only an awareness of it.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
95. Don't have good ideas if you aren't willing to be responsible for them.
112. Computer Science is embarrassed by the computer.
59. In English every word can be verbed. Would that it were so in our programming languages.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
31. Simplicity does not precede complexity, but follows it.
59. In English every word can be verbed. Would that it were so in our programming languages.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
11. If you have a procedure with ten parameters, you probably missed some.
40. There are two ways to write error-free programs; only the third one works.
14. In the long run every program becomes rococo - then rubble.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
8. A programming language is low level when its programs require attention to the irrelevant.
100. We will never run out of things to program as long as there is a single program around.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
21. Optimization hinders evolution.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
61. In programming, as in everything else, to be in error is to be reborn.
15. Everything should be built top-down, except the first time.
40. There are two ways to write error-free programs; only the third one works.
38. Structured Programming supports the law of the excluded middle.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
59. In English every word can be verbed. Would that it were so in our programming languages.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
38. Structured Programming supports the law of the excluded middle.
7. It is easier to write an incorrect program than understand a correct one.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
8. A programming language is low level when its programs require attention to the irrelevant.
103. Purely applicative languages are poorly applicable.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
59. In English every word can be verbed. Would that it were so in our programming languages.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
31. Simplicity does not precede complexity, but follows it.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
12. Recursion is the root of computation since it trades description for time.
62. In computing, invariants are ephemeral.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
43. In software systems, it is often the early bird that makes the worm.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
12. Recursion is the root of computation since it trades description for time.
102. One can't proceed from the informal to the formal by formal means.
38. Structured Programming supports the law of the excluded middle.
17. If a listener nods his head when you're explaining your program, wake him up.
119. Programming is an unnatural act.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
78. If your computer speaks English, it was probably made in Japan.
1. One man's constant is another man's variable.
76. It is the user who should parameterize procedures, not their creators.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
57. It is easier to change the specification to fit the program than vice versa.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
105. You can't communicate complexity, only an awareness of it.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
7. It is easier to write an incorrect program than understand a correct one.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
79. A year spent in artificial intelligence is enough to make one believe in God.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
79. A year spent in artificial intelligence is enough to make one believe in God.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
14. In the long run every program becomes rococo - then rubble.
96. Computers don't introduce order anywhere as much as they expose opportunities.
111. Why did the Roman Empire collapse? What is Latin for office automation?
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
46. Like punning, programming is a play on words.
15. Everything should be built top-down, except the first time.
3. Syntactic sugar causes cancer of the semicolon.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
104. The proof of a system's value is its existence.
66. Making something variable is easy. Controlling duration of constancy is the trick.
7. It is easier to write an incorrect program than understand a correct one.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
43. In software systems, it is often the early bird that makes the worm.
14. In the long run every program becomes rococo - then rubble.
76. It is the user who should parameterize procedures, not their creators.
31. Simplicity does not precede complexity, but follows it.
15. Everything should be built top-down, except the first time.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
63. When we write programs that "learn", it turns out that we do and they don't.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
79. A year spent in artificial intelligence is enough to make one believe in God.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
111. Why did the Roman Empire collapse? What is Latin for office automation?
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
8. A programming language is low level when its programs require attention to the irrelevant.
115. Most people find the concept of programming obvious, but the doing impossible.
8. A programming language is low level when its programs require attention to the irrelevant.
111. Why did the Roman Empire collapse? What is Latin for office automation?
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
76. It is the user who should parameterize procedures, not their creators.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
40. There are two ways to write error-free programs; only the third one works.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
108. Whenever two programmers meet to criticize their programs, both are silent.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
40. There are two ways to write error-free programs; only the third one works.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
114. Within a computer natural language is unnatural.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
59. In English every word can be verbed. Would that it were so in our programming languages.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
7. It is easier to write an incorrect program than understand a correct one.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
61. In programming, as in everything else, to be in error is to be reborn.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
55. A LISP programmer knows the value of everything, but the cost of nothing.
22. A good system can't have a weak command language.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
31. Simplicity does not precede complexity, but follows it.
98. In computing, the mean time to failure keeps getting shorter.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
66. Making something variable is easy. Controlling duration of constancy is the trick.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
63. When we write programs that "learn", it turns out that we do and they don't.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
78. If your computer speaks English, it was probably made in Japan.
78. If your computer speaks English, it was probably made in Japan.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
78. If your computer speaks English, it was probably made in Japan.
43. In software systems, it is often the early bird that makes the worm.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
7. It is easier to write an incorrect program than understand a correct one.
41. Some programming languages manage to absorb change, but withstand progress.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
72. An adequate bootstrap is a contradiction in terms.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
98. In computing, the mean time to failure keeps getting shorter.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
66. Making something variable is easy. Controlling duration of constancy is the trick.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
95. Don't have good ideas if you aren't willing to be responsible for them.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
14. In the long run every program becomes rococo - then rubble.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
90. Computation has made the tree flower.
112. Computer Science is embarrassed by the computer.
22. A good system can't have a weak command language.
15. Everything should be built top-down, except the first time.
3. Syntactic sugar causes cancer of the semicolon.
59. In English every word can be verbed. Would that it were so in our programming languages.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
17. If a listener nods his head when you're explaining your program, wake him up.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
43. In software systems, it is often the early bird that makes the worm.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
115. Most people find the concept of programming obvious, but the doing impossible.
72. An adequate bootstrap is a contradiction in terms.
43. In software systems, it is often the early bird that makes the worm.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
43. In software systems, it is often the early bird that makes the worm.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
38. Structured Programming supports the law of the excluded middle.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
57. It is easier to change the specification to fit the program than vice versa.
8. A programming language is low level when its programs require attention to the irrelevant.
22. A good system can't have a weak command language.
115. Most people find the concept of programming obvious, but the doing impossible.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
61. In programming, as in everything else, to be in error is to be reborn.
66. Making something variable is easy. Controlling duration of constancy is the trick.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
111. Why did the Roman Empire collapse? What is Latin for office automation?
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
105. You can't communicate complexity, only an awareness of it.
110. Editing is a rewording activity.
43. In software systems, it is often the early bird that makes the worm.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
27. Once you understand how to write a program get someone else to write it.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
98. In computing, the mean time to failure keeps getting shorter.
15. Everything should be built top-down, except the first time.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
40. There are two ways to write error-free programs; only the third one works.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
95. Don't have good ideas if you aren't willing to be responsible for them.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
46. Like punning, programming is a play on words.
61. In programming, as in everything else, to be in error is to be reborn.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
40. There are two ways to write error-free programs; only the third one works.
115. Most people find the concept of programming obvious, but the doing impossible.
115. Most people find the concept of programming obvious, but the doing impossible.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
61. In programming, as in everything else, to be in error is to be reborn.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
18. A program without a loop and a structured variable isn't worth writing.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
102. One can't proceed from the informal to the formal by formal means.
27. Once you understand how to write a program get someone else to write it.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
72. An adequate bootstrap is a contradiction in terms.
17. If a listener nods his head when you're explaining your program, wake him up.
60. In seeking the unattainable, simplicity only gets in the way.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
79. A year spent in artificial intelligence is enough to make one believe in God.
38. Structured Programming supports the law of the excluded middle.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
1. One man's constant is another man's variable.
31. Simplicity does not precede complexity, but follows it.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
57. It is easier to change the specification to fit the program than vice versa.
31. Simplicity does not precede complexity, but follows it.
1. One man's constant is another man's variable.
72. An adequate bootstrap is a contradiction in terms.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
66. Making something variable is easy. Controlling duration of constancy is the trick.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
15. Everything should be built top-down, except the first time.
7. It is easier to write an incorrect program than understand a correct one.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
104. The proof of a system's value is its existence.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
23. To understand a program you must become both the machine and the program.
78. If your computer speaks English, it was probably made in Japan.
110. Editing is a rewording activity.
38. Structured Programming supports the law of the excluded middle.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
111. Why did the Roman Empire collapse? What is Latin for office automation?
31. Simplicity does not precede complexity, but follows it.
12. Recursion is the root of computation since it trades description for time.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
17. If a listener nods his head when you're explaining your program, wake him up.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
15. Everything should be built top-down, except the first time.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
1. One man's constant is another man's variable.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
31. Simplicity does not precede complexity, but follows it.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
66. Making something variable is easy. Controlling duration of constancy is the trick.
40. There are two ways to write error-free programs; only the third one works.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
79. A year spent in artificial intelligence is enough to make one believe in God.
43. In software systems, it is often the early bird that makes the worm.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
57. It is easier to change the specification to fit the program than vice versa.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
21. Optimization hinders evolution.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
110. Editing is a rewording activity.
11. If you have a procedure with ten parameters, you probably missed some.
8. A programming language is low level when its programs require attention to the irrelevant.
38. Structured Programming supports the law of the excluded middle.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
78. If your computer speaks English, it was probably made in Japan.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
72. An adequate bootstrap is a contradiction in terms.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
17. If a listener nods his head when you're explaining your program, wake him up.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
115. Most people find the concept of programming obvious, but the doing impossible.
110. Editing is a rewording activity.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
15. Everything should be built top-down, except the first time.
114. Within a computer natural language is unnatural.
31. Simplicity does not precede complexity, but follows it.
61. In programming, as in everything else, to be in error is to be reborn.
23. To understand a program you must become both the machine and the program.
66. Making something variable is easy. Controlling duration of constancy is the trick.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
4. Every program is a part of some other program and rarely fits.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
60. In seeking the unattainable, simplicity only gets in the way.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
108. Whenever two programmers meet to criticize their programs, both are silent.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
23. To understand a program you must become both the machine and the program.
63. When we write programs that "learn", it turns out that we do and they don't.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
107. The debate rages on: is PL/I Bachtrian or Dromedary?
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
62. In computing, invariants are ephemeral.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
55. A LISP programmer knows the value of everything, but the cost of nothing.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
47. As Will Rogers would have said, "There is no such thing as a free variable."
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
59. In English every word can be verbed. Would that it were so in our programming languages.
103. Purely applicative languages are poorly applicable.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
14. In the long run every program becomes rococo - then rubble.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
98. In computing, the mean time to failure keeps getting shorter.
108. Whenever two programmers meet to criticize their programs, both are silent.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
60. In seeking the unattainable, simplicity only gets in the way.
111. Why did the Roman Empire collapse? What is Latin for office automation?
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
112. Computer Science is embarrassed by the computer.
7. It is easier to write an incorrect program than understand a correct one.
8. A programming language is low level when its programs require attention to the irrelevant.
12. Recursion is the root of computation since it trades description for time.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
104. The proof of a system's value is its existence.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
1. One man's constant is another man's variable.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
100. We will never run out of things to program as long as there is a single program around.
38. Structured Programming supports the law of the excluded middle.
114. Within a computer natural language is unnatural.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
55. A LISP programmer knows the value of everything, but the cost of nothing.
3. Syntactic sugar causes cancer of the semicolon.
43. In software systems, it is often the early bird that makes the worm.
21. Optimization hinders evolution.
59. In English every word can be verbed. Would that it were so in our programming languages.
7. It is easier to write an incorrect program than understand a correct one.
7. It is easier to write an incorrect program than understand a correct one.
38. Structured Programming supports the law of the excluded middle.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
61. In programming, as in everything else, to be in error is to be reborn.
102. One can't proceed from the informal to the formal by formal means.
112. Computer Science is embarrassed by the computer.
76. It is the user who should parameterize procedures, not their creators.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
110. Editing is a rewording activity.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
27. Once you understand how to write a program get someone else to write it.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
72. An adequate bootstrap is a contradiction in terms.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
115. Most people find the concept of programming obvious, but the doing impossible.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
102. One can't proceed from the informal to the formal by formal means.
90. Computation has made the tree flower.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
7. It is easier to write an incorrect program than understand a correct one.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
119. Programming is an unnatural act.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
61. In programming, as in everything else, to be in error is to be reborn.
102. One can't proceed from the informal to the formal by formal means.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
90. Computation has made the tree flower.
66. Making something variable is easy. Controlling duration of constancy is the trick.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
55. A LISP programmer knows the value of everything, but the cost of nothing.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
110. Editing is a rewording activity.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
43. In software systems, it is often the early bird that makes the worm.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
66. Making something variable is easy. Controlling duration of constancy is the trick.
47. As Will Rogers would have said, "There is no such thing as a free variable."
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
21. Optimization hinders evolution.
38. Structured Programming supports the law of the excluded middle.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
104. The proof of a system's value is its existence.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
95. Don't have good ideas if you aren't willing to be responsible for them.
55. A LISP programmer knows the value of everything, but the cost of nothing.
96. Computers don't introduce order anywhere as much as they expose opportunities.
110. Editing is a rewording activity.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
3. Syntactic sugar causes cancer of the semicolon.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
1. One man's constant is another man's variable.
1. One man's constant is another man's variable.
4. Every program is a part of some other program and rarely fits.
3. Syntactic sugar causes cancer of the semicolon.
18. A program without a loop and a structured variable isn't worth writing.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
114. Within a computer natural language is unnatural.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
7. It is easier to write an incorrect program than understand a correct one.
17. If a listener nods his head when you're explaining your program, wake him up.
31. Simplicity does not precede complexity, but follows it.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
40. There are two ways to write error-free programs; only the third one works.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
11. If you have a procedure with ten parameters, you probably missed some.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
41. Some programming languages manage to absorb change, but withstand progress.
21. Optimization hinders evolution.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
40. There are two ways to write error-free programs; only the third one works.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
57. It is easier to change the specification to fit the program than vice versa.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
11. If you have a procedure with ten parameters, you probably missed some.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
55. A LISP programmer knows the value of everything, but the cost of nothing.
119. Programming is an unnatural act.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
90. Computation has made the tree flower.
17. If a listener nods his head when you're explaining your program, wake him up.
8. A programming language is low level when its programs require attention to the irrelevant.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
61. In programming, as in everything else, to be in error is to be reborn.
38. Structured Programming supports the law of the excluded middle.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
11. If you have a procedure with ten parameters, you probably missed some.
7. It is easier to write an incorrect program than understand a correct one.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
100. We will never run out of things to program as long as there is a single program around.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
38. Structured Programming supports the law of the excluded middle.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
104. The proof of a system's value is its existence.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
79. A year spent in artificial intelligence is enough to make one believe in God.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
46. Like punning, programming is a play on words.
79. A year spent in artificial intelligence is enough to make one believe in God.
112. Computer Science is embarrassed by the computer.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
96. Computers don't introduce order anywhere as much as they expose opportunities.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
7. It is easier to write an incorrect program than understand a correct one.
78. If your computer speaks English, it was probably made in Japan.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
95. Don't have good ideas if you aren't willing to be responsible for them.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
110. Editing is a rewording activity.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
18. A program without a loop and a structured variable isn't worth writing.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
12. Recursion is the root of computation since it trades description for time.
114. Within a computer natural language is unnatural.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
41. Some programming languages manage to absorb change, but withstand progress.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
18. A program without a loop and a structured variable isn't worth writing.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
43. In software systems, it is often the early bird that makes the worm.
27. Once you understand how to write a program get someone else to write it.
41. Some programming languages manage to absorb change, but withstand progress.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
61. In programming, as in everything else, to be in error is to be reborn.
11. If you have a procedure with ten parameters, you probably missed some.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
21. Optimization hinders evolution.
108. Whenever two programmers meet to criticize their programs, both are silent.
23. To understand a program you must become both the machine and the program.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
104. The proof of a system's value is its existence.
111. Why did the Roman Empire collapse? What is Latin for office automation?
115. Most people find the concept of programming obvious, but the doing impossible.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
114. Within a computer natural language is unnatural.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
114. Within a computer natural language is unnatural.
22. A good system can't have a weak command language.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
96. Computers don't introduce order anywhere as much as they expose opportunities.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
22. A good system can't have a weak command language.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
114. Within a computer natural language is unnatural.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
7. It is easier to write an incorrect program than understand a correct one.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
119. Programming is an unnatural act.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
78. If your computer speaks English, it was probably made in Japan.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
105. You can't communicate complexity, only an awareness of it.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
18. A program without a loop and a structured variable isn't worth writing.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
95. Don't have good ideas if you aren't willing to be responsible for them.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
62. In computing, invariants are ephemeral.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
102. One can't proceed from the informal to the formal by formal means.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
78. If your computer speaks English, it was probably made in Japan.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
63. When we write programs that "learn", it turns out that we do and they don't.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
14. In the long run every program becomes rococo - then rubble.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
96. Computers don't introduce order anywhere as much as they expose opportunities.
41. Some programming languages manage to absorb change, but withstand progress.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
11. If you have a procedure with ten parameters, you probably missed some.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
31. Simplicity does not precede complexity, but follows it.
17. If a listener nods his head when you're explaining your program, wake him up.
112. Computer Science is embarrassed by the computer.
57. It is easier to change the specification to fit the program than vice versa.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
119. Programming is an unnatural act.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
8. A programming language is low level when its programs require attention to the irrelevant.
15. Everything should be built top-down, except the first time.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
104. The proof of a system's value is its existence.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
103. Purely applicative languages are poorly applicable.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
79. A year spent in artificial intelligence is enough to make one believe in God.
104. The proof of a system's value is its existence.
72. An adequate bootstrap is a contradiction in terms.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
76. It is the user who should parameterize procedures, not their creators.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
98. In computing, the mean time to failure keeps getting shorter.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
79. A year spent in artificial intelligence is enough to make one believe in God.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
98. In computing, the mean time to failure keeps getting shorter.
76. It is the user who should parameterize procedures, not their creators.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
8. A programming language is low level when its programs require attention to the irrelevant.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
14. In the long run every program becomes rococo - then rubble.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
5. If a program manipulates a large amount of data, it does so in a small number of ways.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
119. Programming is an unnatural act.
46. Like punning, programming is a play on words.
1. One man's constant is another man's variable.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
98. In computing, the mean time to failure keeps getting shorter.
96. Computers don't introduce order anywhere as much as they expose opportunities.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
95. Don't have good ideas if you aren't willing to be responsible for them.
47. As Will Rogers would have said, "There is no such thing as a free variable."
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
102. One can't proceed from the informal to the formal by formal means.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
22. A good system can't have a weak command language.
96. Computers don't introduce order anywhere as much as they expose opportunities.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
17. If a listener nods his head when you're explaining your program, wake him up.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
41. Some programming languages manage to absorb change, but withstand progress.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
62. In computing, invariants are ephemeral.
105. You can't communicate complexity, only an awareness of it.
72. An adequate bootstrap is a contradiction in terms.
61. In programming, as in everything else, to be in error is to be reborn.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
14. In the long run every program becomes rococo - then rubble.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
79. A year spent in artificial intelligence is enough to make one believe in God.
103. Purely applicative languages are poorly applicable.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
11. If you have a procedure with ten parameters, you probably missed some.
79. A year spent in artificial intelligence is enough to make one believe in God.
27. Once you understand how to write a program get someone else to write it.
79. A year spent in artificial intelligence is enough to make one believe in God.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
100. We will never run out of things to program as long as there is a single program around.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
15. Everything should be built top-down, except the first time.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
21. Optimization hinders evolution.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
31. Simplicity does not precede complexity, but follows it.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
103. Purely applicative languages are poorly applicable.
27. Once you understand how to write a program get someone else to write it.
115. Most people find the concept of programming obvious, but the doing impossible.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
103. Purely applicative languages are poorly applicable.
3. Syntactic sugar causes cancer of the semicolon.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
103. Purely applicative languages are poorly applicable.
62. In computing, invariants are ephemeral.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
72. An adequate bootstrap is a contradiction in terms.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
115. Most people find the concept of programming obvious, but the doing impossible.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
102. One can't proceed from the informal to the formal by formal means.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
4. Every program is a part of some other program and rarely fits.
47. As Will Rogers would have said, "There is no such thing as a free variable."
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
38. Structured Programming supports the law of the excluded middle.
57. It is easier to change the specification to fit the program than vice versa.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
95. Don't have good ideas if you aren't willing to be responsible for them.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
7. It is easier to write an incorrect program than understand a correct one.
17. If a listener nods his head when you're explaining your program, wake him up.
111. Why did the Roman Empire collapse? What is Latin for office automation?
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
4. Every program is a part of some other program and rarely fits.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
76. It is the user who should parameterize procedures, not their creators.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
63. When we write programs that "learn", it turns out that we do and they don't.
119. Programming is an unnatural act.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
12. Recursion is the root of computation since it trades description for time.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
55. A LISP programmer knows the value of everything, but the cost of nothing.
27. Once you understand how to write a program get someone else to write it.
57. It is easier to change the specification to fit the program than vice versa.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
79. A year spent in artificial intelligence is enough to make one believe in God.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
104. The proof of a system's value is its existence.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
27. Once you understand how to write a program get someone else to write it.
38. Structured Programming supports the law of the excluded middle.
47. As Will Rogers would have said, "There is no such thing as a free variable."
14. In the long run every program becomes rococo - then rubble.
18. A program without a loop and a structured variable isn't worth writing.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
12. Recursion is the root of computation since it trades description for time.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
119. Programming is an unnatural act.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
90. Computation has made the tree flower.
60. In seeking the unattainable, simplicity only gets in the way.
105. You can't communicate complexity, only an awareness of it.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
21. Optimization hinders evolution.
18. A program without a loop and a structured variable isn't worth writing.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
1. One man's constant is another man's variable.
72. An adequate bootstrap is a contradiction in terms.
78. If your computer speaks English, it was probably made in Japan.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
96. Computers don't introduce order anywhere as much as they expose opportunities.
7. It is easier to write an incorrect program than understand a correct one.
79. A year spent in artificial intelligence is enough to make one believe in God.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
17. If a listener nods his head when you're explaining your program, wake him up.
4. Every program is a part of some other program and rarely fits.
62. In computing, invariants are ephemeral.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
17. If a listener nods his head when you're explaining your program, wake him up.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
41. Some programming languages manage to absorb change, but withstand progress.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
104. The proof of a system's value is its existence.
55. A LISP programmer knows the value of everything, but the cost of nothing.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
38. Structured Programming supports the law of the excluded middle.
11. If you have a procedure with ten parameters, you probably missed some.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
43. In software systems, it is often the early bird that makes the worm.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
115. Most people find the concept of programming obvious, but the doing impossible.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
100. We will never run out of things to program as long as there is a single program around.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
11. If you have a procedure with ten parameters, you probably missed some.
76. It is the user who should parameterize procedures, not their creators.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
66. Making something variable is easy. Controlling duration of constancy is the trick.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
1. One man's constant is another man's variable.
103. Purely applicative languages are poorly applicable.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
12. Recursion is the root of computation since it trades description for time.
62. In computing, invariants are ephemeral.
114. Within a computer natural language is unnatural.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
112. Computer Science is embarrassed by the computer.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
115. Most people find the concept of programming obvious, but the doing impossible.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
104. The proof of a system's value is its existence.
14. In the long run every program becomes rococo - then rubble.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
115. Most people find the concept of programming obvious, but the doing impossible.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
4. Every program is a part of some other program and rarely fits.
104. The proof of a system's value is its existence.
27. Once you understand how to write a program get someone else to write it.
7. It is easier to write an incorrect program than understand a correct one.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
17. If a listener nods his head when you're explaining your program, wake him up.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
59. In English every word can be verbed. Would that it were so in our programming languages.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
111. Why did the Roman Empire collapse? What is Latin for office automation?
47. As Will Rogers would have said, "There is no such thing as a free variable."
95. Don't have good ideas if you aren't willing to be responsible for them.
59. In English every word can be verbed. Would that it were so in our programming languages.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
102. One can't proceed from the informal to the formal by formal means.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
38. Structured Programming supports the law of the excluded middle.
63. When we write programs that "learn", it turns out that we do and they don't.
72. An adequate bootstrap is a contradiction in terms.
8. A programming language is low level when its programs require attention to the irrelevant.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
115. Most people find the concept of programming obvious, but the doing impossible.
79. A year spent in artificial intelligence is enough to make one believe in God.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
41. Some programming languages manage to absorb change, but withstand progress.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
111. Why did the Roman Empire collapse? What is Latin for office automation?
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
104. The proof of a system's value is its existence.
31. Simplicity does not precede complexity, but follows it.
111. Why did the Roman Empire collapse? What is Latin for office automation?
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
21. Optimization hinders evolution.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
21. Optimization hinders evolution.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
1. One man's constant is another man's variable.
27. Once you understand how to write a program get someone else to write it.
27. Once you understand how to write a program get someone else to write it.
7. It is easier to write an incorrect program than understand a correct one.
108. Whenever two programmers meet to criticize their programs, both are silent.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
23. To understand a program you must become both the machine and the program.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
27. Once you understand how to write a program get someone else to write it.
31. Simplicity does not precede complexity, but follows it.
8. A programming language is low level when its programs require attention to the irrelevant.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
111. Why did the Roman Empire collapse? What is Latin for office automation?
27. Once you understand how to write a program get someone else to write it.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
27. Once you understand how to write a program get someone else to write it.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
78. If your computer speaks English, it was probably made in Japan.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
57. It is easier to change the specification to fit the program than vice versa.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
11. If you have a procedure with ten parameters, you probably missed some.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
115. Most people find the concept of programming obvious, but the doing impossible.
41. Some programming languages manage to absorb change, but withstand progress.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
115. Most people find the concept of programming obvious, but the doing impossible.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
38. Structured Programming supports the law of the excluded middle.
98. In computing, the mean time to failure keeps getting shorter.
114. Within a computer natural language is unnatural.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
59. In English every word can be verbed. Would that it were so in our programming languages.
59. In English every word can be verbed. Would that it were so in our programming languages.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
1. One man's constant is another man's variable.
3. Syntactic sugar causes cancer of the semicolon.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
18. A program without a loop and a structured variable isn't worth writing.
96. Computers don't introduce order anywhere as much as they expose opportunities.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
66. Making something variable is easy. Controlling duration of constancy is the trick.
78. If your computer speaks English, it was probably made in Japan.
119. Programming is an unnatural act.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
15. Everything should be built top-down, except the first time.
60. In seeking the unattainable, simplicity only gets in the way.
108. Whenever two programmers meet to criticize their programs, both are silent.
103. Purely applicative languages are poorly applicable.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
43. In software systems, it is often the early bird that makes the worm.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
119. Programming is an unnatural act.
11. If you have a procedure with ten parameters, you probably missed some.
110. Editing is a rewording activity.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
1. One man's constant is another man's variable.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
59. In English every word can be verbed. Would that it were so in our programming languages.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
111. Why did the Roman Empire collapse? What is Latin for office automation?
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
63. When we write programs that "learn", it turns out that we do and they don't.
79. A year spent in artificial intelligence is enough to make one believe in God.
1. One man's constant is another man's variable.
55. A LISP programmer knows the value of everything, but the cost of nothing.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
27. Once you understand how to write a program get someone else to write it.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
46. Like punning, programming is a play on words.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
62. In computing, invariants are ephemeral.
112. Computer Science is embarrassed by the computer.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
43. In software systems, it is often the early bird that makes the worm.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
66. Making something variable is easy. Controlling duration of constancy is the trick.
4. Every program is a part of some other program and rarely fits.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
78. If your computer speaks English, it was probably made in Japan.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
41. Some programming languages manage to absorb change, but withstand progress.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
55. A LISP programmer knows the value of everything, but the cost of nothing.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
59. In English every word can be verbed. Would that it were so in our programming languages.
57. It is easier to change the specification to fit the program than vice versa.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
95. Don't have good ideas if you aren't willing to be responsible for them.
3. Syntactic sugar causes cancer of the semicolon.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
27. Once you understand how to write a program get someone else to write it.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
31. Simplicity does not precede complexity, but follows it.
63. When we write programs that "learn", it turns out that we do and they don't.
55. A LISP programmer knows the value of everything, but the cost of nothing.
112. Computer Science is embarrassed by the computer.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
18. A program without a loop and a structured variable isn't worth writing.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
1. One man's constant is another man's variable.
79. A year spent in artificial intelligence is enough to make one believe in God.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
78. If your computer speaks English, it was probably made in Japan.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
21. Optimization hinders evolution.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
4. Every program is a part of some other program and rarely fits.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
43. In software systems, it is often the early bird that makes the worm.
79. A year spent in artificial intelligence is enough to make one believe in God.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
110. Editing is a rewording activity.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
41. Some programming languages manage to absorb change, but withstand progress.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
62. In computing, invariants are ephemeral.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
41. Some programming languages manage to absorb change, but withstand progress.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
7. It is easier to write an incorrect program than understand a correct one.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
108. Whenever two programmers meet to criticize their programs, both are silent.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
72. An adequate bootstrap is a contradiction in terms.
104. The proof of a system's value is its existence.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
96. Computers don't introduce order anywhere as much as they expose opportunities.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
59. In English every word can be verbed. Would that it were so in our programming languages.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
100. We will never run out of things to program as long as there is a single program around.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
5. If a program manipulates a large amount of data, it does so in a small number of ways.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
31. Simplicity does not precede complexity, but follows it.
119. Programming is an unnatural act.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
62. In computing, invariants are ephemeral.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
31. Simplicity does not precede complexity, but follows it.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
60. In seeking the unattainable, simplicity only gets in the way.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
63. When we write programs that "learn", it turns out that we do and they don't.
61. In programming, as in everything else, to be in error is to be reborn.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
76. It is the user who should parameterize procedures, not their creators.
100. We will never run out of things to program as long as there is a single program around.
1. One man's constant is another man's variable.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
59. In English every word can be verbed. Would that it were so in our programming languages.
112. Computer Science is embarrassed by the computer.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
104. The proof of a system's value is its existence.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
59. In English every word can be verbed. Would that it were so in our programming languages.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
59. In English every word can be verbed. Would that it were so in our programming languages.
66. Making something variable is easy. Controlling duration of constancy is the trick.
63. When we write programs that "learn", it turns out that we do and they don't.
78. If your computer speaks English, it was probably made in Japan.
17. If a listener nods his head when you're explaining your program, wake him up.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
17. If a listener nods his head when you're explaining your program, wake him up.
59. In English every word can be verbed. Would that it were so in our programming languages.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
43. In software systems, it is often the early bird that makes the worm.
60. In seeking the unattainable, simplicity only gets in the way.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
108. Whenever two programmers meet to criticize their programs, both are silent.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
1. One man's constant is another man's variable.
90. Computation has made the tree flower.
105. You can't communicate complexity, only an awareness of it.
114. Within a computer natural language is unnatural.
59. In English every word can be verbed. Would that it were so in our programming languages.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
15. Everything should be built top-down, except the first time.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
23. To understand a program you must become both the machine and the program.
66. Making something variable is easy. Controlling duration of constancy is the trick.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
17. If a listener nods his head when you're explaining your program, wake him up.
110. Editing is a rewording activity.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
119. Programming is an unnatural act.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
95. Don't have good ideas if you aren't willing to be responsible for them.
95. Don't have good ideas if you aren't willing to be responsible for them.
8. A programming language is low level when its programs require attention to the irrelevant.
62. In computing, invariants are ephemeral.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
1. One man's constant is another man's variable.
8. A programming language is low level when its programs require attention to the irrelevant.
41. Some programming languages manage to absorb change, but withstand progress.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
112. Computer Science is embarrassed by the computer.
3. Syntactic sugar causes cancer of the semicolon.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
15. Everything should be built top-down, except the first time.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
27. Once you understand how to write a program get someone else to write it.
1. One man's constant is another man's variable.
31. Simplicity does not precede complexity, but follows it.
8. A programming language is low level when its programs require attention to the irrelevant.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
7. It is easier to write an incorrect program than understand a correct one.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
15. Everything should be built top-down, except the first time.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
27. Once you understand how to write a program get someone else to write it.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
21. Optimization hinders evolution.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
98. In computing, the mean time to failure keeps getting shorter.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
104. The proof of a system's value is its existence.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
72. An adequate bootstrap is a contradiction in terms.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
66. Making something variable is easy. Controlling duration of constancy is the trick.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
17. If a listener nods his head when you're explaining your program, wake him up.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
112. Computer Science is embarrassed by the computer.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
31. Simplicity does not precede complexity, but follows it.
31. Simplicity does not precede complexity, but follows it.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
27. Once you understand how to write a program get someone else to write it.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
100. We will never run out of things to program as long as there is a single program around.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
111. Why did the Roman Empire collapse? What is Latin for office automation?
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
55. A LISP programmer knows the value of everything, but the cost of nothing.
111. Why did the Roman Empire collapse? What is Latin for office automation?
90. Computation has made the tree flower.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
104. The proof of a system's value is its existence.
21. Optimization hinders evolution.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
12. Recursion is the root of computation since it trades description for time.
105. You can't communicate complexity, only an awareness of it.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
59. In English every word can be verbed. Would that it were so in our programming languages.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
12. Recursion is the root of computation since it trades description for time.
12. Recursion is the root of computation since it trades description for time.
62. In computing, invariants are ephemeral.
38. Structured Programming supports the law of the excluded middle.
114. Within a computer natural language is unnatural.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
41. Some programming languages manage to absorb change, but withstand progress.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
104. The proof of a system's value is its existence.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
43. In software systems, it is often the early bird that makes the worm.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
41. Some programming languages manage to absorb change, but withstand progress.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
78. If your computer speaks English, it was probably made in Japan.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
111. Why did the Roman Empire collapse? What is Latin for office automation?
47. As Will Rogers would have said, "There is no such thing as a free variable."
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
59. In English every word can be verbed. Would that it were so in our programming languages.
43. In software systems, it is often the early bird that makes the worm.
3. Syntactic sugar causes cancer of the semicolon.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
60. In seeking the unattainable, simplicity only gets in the way.
22. A good system can't have a weak command language.
59. In English every word can be verbed. Would that it were so in our programming languages.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
59. In English every word can be verbed. Would that it were so in our programming languages.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
90. Computation has made the tree flower.
12. Recursion is the root of computation since it trades description for time.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
72. An adequate bootstrap is a contradiction in terms.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
76. It is the user who should parameterize procedures, not their creators.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
43. In software systems, it is often the early bird that makes the worm.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
38. Structured Programming supports the law of the excluded middle.
62. In computing, invariants are ephemeral.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
111. Why did the Roman Empire collapse? What is Latin for office automation?
11. If you have a procedure with ten parameters, you probably missed some.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
47. As Will Rogers would have said, "There is no such thing as a free variable."
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
43. In software systems, it is often the early bird that makes the worm.
100. We will never run out of things to program as long as there is a single program around.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
1. One man's constant is another man's variable.
108. Whenever two programmers meet to criticize their programs, both are silent.
119. Programming is an unnatural act.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
18. A program without a loop and a structured variable isn't worth writing.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
47. As Will Rogers would have said, "There is no such thing as a free variable."
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
90. Computation has made the tree flower.
95. Don't have good ideas if you aren't willing to be responsible for them.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
115. Most people find the concept of programming obvious, but the doing impossible.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
63. When we write programs that "learn", it turns out that we do and they don't.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
14. In the long run every program becomes rococo - then rubble.
7. It is easier to write an incorrect program than understand a correct one.
23. To understand a program you must become both the machine and the program.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
102. One can't proceed from the informal to the formal by formal means.
23. To understand a program you must become both the machine and the program.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
11. If you have a procedure with ten parameters, you probably missed some.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
72. An adequate bootstrap is a contradiction in terms.
18. A program without a loop and a structured variable isn't worth writing.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
66. Making something variable is easy. Controlling duration of constancy is the trick.
22. A good system can't have a weak command language.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
43. In software systems, it is often the early bird that makes the worm.
57. It is easier to change the specification to fit the program than vice versa.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
112. Computer Science is embarrassed by the computer.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
23. To understand a program you must become both the machine and the program.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
8. A programming language is low level when its programs require attention to the irrelevant.
108. Whenever two programmers meet to criticize their programs, both are silent.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
8. A programming language is low level when its programs require attention to the irrelevant.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
38. Structured Programming supports the law of the excluded middle.
79. A year spent in artificial intelligence is enough to make one believe in God.
1. One man's constant is another man's variable.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
95. Don't have good ideas if you aren't willing to be responsible for them.
90. Computation has made the tree flower.
79. A year spent in artificial intelligence is enough to make one believe in God.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
1. One man's constant is another man's variable.
43. In software systems, it is often the early bird that makes the worm.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
78. If your computer speaks English, it was probably made in Japan.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
38. Structured Programming supports the law of the excluded middle.
102. One can't proceed from the informal to the formal by formal means.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
110. Editing is a rewording activity.
11. If you have a procedure with ten parameters, you probably missed some.
18. A program without a loop and a structured variable isn't worth writing.
7. It is easier to write an incorrect program than understand a correct one.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
62. In computing, invariants are ephemeral.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
102. One can't proceed from the informal to the formal by formal means.
57. It is easier to change the specification to fit the program than vice versa.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
3. Syntactic sugar causes cancer of the semicolon.
103. Purely applicative languages are poorly applicable.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
104. The proof of a system's value is its existence.
27. Once you understand how to write a program get someone else to write it.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
119. Programming is an unnatural act.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
72. An adequate bootstrap is a contradiction in terms.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
63. When we write programs that "learn", it turns out that we do and they don't.
79. A year spent in artificial intelligence is enough to make one believe in God.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
4. Every program is a part of some other program and rarely fits.
111. Why did the Roman Empire collapse? What is Latin for office automation?
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
43. In software systems, it is often the early bird that makes the worm.
119. Programming is an unnatural act.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
7. It is easier to write an incorrect program than understand a correct one.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
110. Editing is a rewording activity.
31. Simplicity does not precede complexity, but follows it.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
23. To understand a program you must become both the machine and the program.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
98. In computing, the mean time to failure keeps getting shorter.
115. Most people find the concept of programming obvious, but the doing impossible.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
47. As Will Rogers would have said, "There is no such thing as a free variable."
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
47. As Will Rogers would have said, "There is no such thing as a free variable."
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
62. In computing, invariants are ephemeral.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
22. A good system can't have a weak command language.
119. Programming is an unnatural act.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
12. Recursion is the root of computation since it trades description for time.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
98. In computing, the mean time to failure keeps getting shorter.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
111. Why did the Roman Empire collapse? What is Latin for office automation?
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
14. In the long run every program becomes rococo - then rubble.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
23. To understand a program you must become both the machine and the program.
110. Editing is a rewording activity.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
108. Whenever two programmers meet to criticize their programs, both are silent.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
98. In computing, the mean time to failure keeps getting shorter.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
46. Like punning, programming is a play on words.
111. Why did the Roman Empire collapse? What is Latin for office automation?
5. If a program manipulates a large amount of data, it does so in a small number of ways.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
14. In the long run every program becomes rococo - then rubble.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
17. If a listener nods his head when you're explaining your program, wake him up.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
103. Purely applicative languages are poorly applicable.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
90. Computation has made the tree flower.
62. In computing, invariants are ephemeral.
8. A programming language is low level when its programs require attention to the irrelevant.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
47. As Will Rogers would have said, "There is no such thing as a free variable."
8. A programming language is low level when its programs require attention to the irrelevant.
31. Simplicity does not precede complexity, but follows it.
114. Within a computer natural language is unnatural.
78. If your computer speaks English, it was probably made in Japan.
7. It is easier to write an incorrect program than understand a correct one.
98. In computing, the mean time to failure keeps getting shorter.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
96. Computers don't introduce order anywhere as much as they expose opportunities.
63. When we write programs that "learn", it turns out that we do and they don't.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
55. A LISP programmer knows the value of everything, but the cost of nothing.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
95. Don't have good ideas if you aren't willing to be responsible for them.
8. A programming language is low level when its programs require attention to the irrelevant.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
59. In English every word can be verbed. Would that it were so in our programming languages.
17. If a listener nods his head when you're explaining your program, wake him up.
112. Computer Science is embarrassed by the computer.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
21. Optimization hinders evolution.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
8. A programming language is low level when its programs require attention to the irrelevant.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
21. Optimization hinders evolution.
27. Once you understand how to write a program get someone else to write it.
57. It is easier to change the specification to fit the program than vice versa.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
5. If a program manipulates a large amount of data, it does so in a small number of ways.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
12. Recursion is the root of computation since it trades description for time.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
23. To understand a program you must become both the machine and the program.
119. Programming is an unnatural act.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
66. Making something variable is easy. Controlling duration of constancy is the trick.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
111. Why did the Roman Empire collapse? What is Latin for office automation?
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
119. Programming is an unnatural act.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
46. Like punning, programming is a play on words.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
78. If your computer speaks English, it was probably made in Japan.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
4. Every program is a part of some other program and rarely fits.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
40. There are two ways to write error-free programs; only the third one works.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
23. To understand a program you must become both the machine and the program.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
103. Purely applicative languages are poorly applicable.
66. Making something variable is easy. Controlling duration of constancy is the trick.
21. Optimization hinders evolution.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
105. You can't communicate complexity, only an awareness of it.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
4. Every program is a part of some other program and rarely fits.
1. One man's constant is another man's variable.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
105. You can't communicate complexity, only an awareness of it.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
61. In programming, as in everything else, to be in error is to be reborn.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
55. A LISP programmer knows the value of everything, but the cost of nothing.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
100. We will never run out of things to program as long as there is a single program around.
115. Most people find the concept of programming obvious, but the doing impossible.
78. If your computer speaks English, it was probably made in Japan.
41. Some programming languages manage to absorb change, but withstand progress.
3. Syntactic sugar causes cancer of the semicolon.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
12. Recursion is the root of computation since it trades description for time.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
78. If your computer speaks English, it was probably made in Japan.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
5. If a program manipulates a large amount of data, it does so in a small number of ways.
57. It is easier to change the specification to fit the program than vice versa.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
111. Why did the Roman Empire collapse? What is Latin for office automation?
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
102. One can't proceed from the informal to the formal by formal means.
7. It is easier to write an incorrect program than understand a correct one.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
76. It is the user who should parameterize procedures, not their creators.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
23. To understand a program you must become both the machine and the program.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
62. In computing, invariants are ephemeral.
21. Optimization hinders evolution.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
98. In computing, the mean time to failure keeps getting shorter.
96. Computers don't introduce order anywhere as much as they expose opportunities.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
46. Like punning, programming is a play on words.
105. You can't communicate complexity, only an awareness of it.
111. Why did the Roman Empire collapse? What is Latin for office automation?
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
72. An adequate bootstrap is a contradiction in terms.
40. There are two ways to write error-free programs; only the third one works.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
63. When we write programs that "learn", it turns out that we do and they don't.
8. A programming language is low level when its programs require attention to the irrelevant.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
63. When we write programs that "learn", it turns out that we do and they don't.
38. Structured Programming supports the law of the excluded middle.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
104. The proof of a system's value is its existence.
79. A year spent in artificial intelligence is enough to make one believe in God.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
63. When we write programs that "learn", it turns out that we do and they don't.
57. It is easier to change the specification to fit the program than vice versa.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
55. A LISP programmer knows the value of everything, but the cost of nothing.
18. A program without a loop and a structured variable isn't worth writing.
66. Making something variable is easy. Controlling duration of constancy is the trick.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
112. Computer Science is embarrassed by the computer.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
8. A programming language is low level when its programs require attention to the irrelevant.
61. In programming, as in everything else, to be in error is to be reborn.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
40. There are two ways to write error-free programs; only the third one works.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
103. Purely applicative languages are poorly applicable.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
14. In the long run every program becomes rococo - then rubble.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
103. Purely applicative languages are poorly applicable.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
72. An adequate bootstrap is a contradiction in terms.
57. It is easier to change the specification to fit the program than vice versa.
55. A LISP programmer knows the value of everything, but the cost of nothing.
21. Optimization hinders evolution.
61. In programming, as in everything else, to be in error is to be reborn.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
95. Don't have good ideas if you aren't willing to be responsible for them.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
66. Making something variable is easy. Controlling duration of constancy is the trick.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
110. Editing is a rewording activity.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
17. If a listener nods his head when you're explaining your program, wake him up.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
3. Syntactic sugar causes cancer of the semicolon.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
12. Recursion is the root of computation since it trades description for time.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
115. Most people find the concept of programming obvious, but the doing impossible.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
98. In computing, the mean time to failure keeps getting shorter.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
108. Whenever two programmers meet to criticize their programs, both are silent.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
62. In computing, invariants are ephemeral.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
95. Don't have good ideas if you aren't willing to be responsible for them.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
4. Every program is a part of some other program and rarely fits.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
18. A program without a loop and a structured variable isn't worth writing.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
41. Some programming languages manage to absorb change, but withstand progress.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
41. Some programming languages manage to absorb change, but withstand progress.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
108. Whenever two programmers meet to criticize their programs, both are silent.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
7. It is easier to write an incorrect program than understand a correct one.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
100. We will never run out of things to program as long as there is a single program around.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
1. One man's constant is another man's variable.
55. A LISP programmer knows the value of everything, but the cost of nothing.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
96. Computers don't introduce order anywhere as much as they expose opportunities.
31. Simplicity does not precede complexity, but follows it.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
21. Optimization hinders evolution.
7. It is easier to write an incorrect program than understand a correct one.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
90. Computation has made the tree flower.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
115. Most people find the concept of programming obvious, but the doing impossible.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
55. A LISP programmer knows the value of everything, but the cost of nothing.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
8. A programming language is low level when its programs require attention to the irrelevant.
103. Purely applicative languages are poorly applicable.
62. In computing, invariants are ephemeral.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
41. Some programming languages manage to absorb change, but withstand progress.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
114. Within a computer natural language is unnatural.
27. Once you understand how to write a program get someone else to write it.
12. Recursion is the root of computation since it trades description for time.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
78. If your computer speaks English, it was probably made in Japan.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
46. Like punning, programming is a play on words.
4. Every program is a part of some other program and rarely fits.
66. Making something variable is easy. Controlling duration of constancy is the trick.
40. There are two ways to write error-free programs; only the third one works.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
21. Optimization hinders evolution.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
18. A program without a loop and a structured variable isn't worth writing.
61. In programming, as in everything else, to be in error is to be reborn.
17. If a listener nods his head when you're explaining your program, wake him up.
96. Computers don't introduce order anywhere as much as they expose opportunities.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
78. If your computer speaks English, it was probably made in Japan.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
18. A program without a loop and a structured variable isn't worth writing.
115. Most people find the concept of programming obvious, but the doing impossible.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
19. A language that doesn't affect the way you think about programming, is not worth knowing.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
7. It is easier to write an incorrect program than understand a correct one.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
1. One man's constant is another man's variable.
96. Computers don't introduce order anywhere as much as they expose opportunities.
12. Recursion is the root of computation since it trades description for time.
4. Every program is a part of some other program and rarely fits.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
108. Whenever two programmers meet to criticize their programs, both are silent.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
90. Computation has made the tree flower.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
21. Optimization hinders evolution.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
4. Every program is a part of some other program and rarely fits.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
55. A LISP programmer knows the value of everything, but the cost of nothing.
100. We will never run out of things to program as long as there is a single program around.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
60. In seeking the unattainable, simplicity only gets in the way.
38. Structured Programming supports the law of the excluded middle.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
47. As Will Rogers would have said, "There is no such thing as a free variable."
96. Computers don't introduce order anywhere as much as they expose opportunities.
78. If your computer speaks English, it was probably made in Japan.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
63. When we write programs that "learn", it turns out that we do and they don't.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
3. Syntactic sugar causes cancer of the semicolon.
110. Editing is a rewording activity.
63. When we write programs that "learn", it turns out that we do and they don't.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
119. Programming is an unnatural act.
57. It is easier to change the specification to fit the program than vice versa.
111. Why did the Roman Empire collapse? What is Latin for office automation?
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
72. An adequate bootstrap is a contradiction in terms.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
76. It is the user who should parameterize procedures, not their creators.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
3. Syntactic sugar causes cancer of the semicolon.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
47. As Will Rogers would have said, "There is no such thing as a free variable."
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
111. Why did the Roman Empire collapse? What is Latin for office automation?
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
4. Every program is a part of some other program and rarely fits.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
1. One man's constant is another man's variable.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
3. Syntactic sugar causes cancer of the semicolon.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
112. Computer Science is embarrassed by the computer.
8. A programming language is low level when its programs require attention to the irrelevant.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
96. Computers don't introduce order anywhere as much as they expose opportunities.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
46. Like punning, programming is a play on words.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
105. You can't communicate complexity, only an awareness of it.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
112. Computer Science is embarrassed by the computer.
14. In the long run every program becomes rococo - then rubble.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
4. Every program is a part of some other program and rarely fits.
108. Whenever two programmers meet to criticize their programs, both are silent.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
100. We will never run out of things to program as long as there is a single program around.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
40. There are two ways to write error-free programs; only the third one works.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
15. Everything should be built top-down, except the first time.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
115. Most people find the concept of programming obvious, but the doing impossible.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
11. If you have a procedure with ten parameters, you probably missed some.
104. The proof of a system's value is its existence.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
90. Computation has made the tree flower.
22. A good system can't have a weak command language.
40. There are two ways to write error-free programs; only the third one works.
40. There are two ways to write error-free programs; only the third one works.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
66. Making something variable is easy. Controlling duration of constancy is the trick.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
7. It is easier to write an incorrect program than understand a correct one.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
108. Whenever two programmers meet to criticize their programs, both are silent.
8. A programming language is low level when its programs require attention to the irrelevant.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
7. It is easier to write an incorrect program than understand a correct one.
22. A good system can't have a weak command language.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
23. To understand a program you must become both the machine and the program.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
3. Syntactic sugar causes cancer of the semicolon.
102. One can't proceed from the informal to the formal by formal means.
23. To understand a program you must become both the machine and the program.
103. Purely applicative languages are poorly applicable.
4. Every program is a part of some other program and rarely fits.
11. If you have a procedure with ten parameters, you probably missed some.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
18. A program without a loop and a structured variable isn't worth writing.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
38. Structured Programming supports the law of the excluded middle.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
72. An adequate bootstrap is a contradiction in terms.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
43. In software systems, it is often the early bird that makes the worm.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
79. A year spent in artificial intelligence is enough to make one believe in God.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
98. In computing, the mean time to failure keeps getting shorter.
14. In the long run every program becomes rococo - then rubble.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
11. If you have a procedure with ten parameters, you probably missed some.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
38. Structured Programming supports the law of the excluded middle.
57. It is easier to change the specification to fit the program than vice versa.
79. A year spent in artificial intelligence is enough to make one believe in God.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
112. Computer Science is embarrassed by the computer.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
104. The proof of a system's value is its existence.
119. Programming is an unnatural act.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
3. Syntactic sugar causes cancer of the semicolon.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
7. It is easier to write an incorrect program than understand a correct one.
21. Optimization hinders evolution.
108. Whenever two programmers meet to criticize their programs, both are silent.
3. Syntactic sugar causes cancer of the semicolon.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
78. If your computer speaks English, it was probably made in Japan.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
4. Every program is a part of some other program and rarely fits.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
78. If your computer speaks English, it was probably made in Japan.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
5. If a program manipulates a large amount of data, it does so in a small number of ways.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
11. If you have a procedure with ten parameters, you probably missed some.
46. Like punning, programming is a play on words.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
21. Optimization hinders evolution.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
27. Once you understand how to write a program get someone else to write it.
63. When we write programs that "learn", it turns out that we do and they don't.
66. Making something variable is easy. Controlling duration of constancy is the trick.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
31. Simplicity does not precede complexity, but follows it.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
12. Recursion is the root of computation since it trades description for time.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
102. One can't proceed from the informal to the formal by formal means.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
111. Why did the Roman Empire collapse? What is Latin for office automation?
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
76. It is the user who should parameterize procedures, not their creators.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
95. Don't have good ideas if you aren't willing to be responsible for them.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
15. Everything should be built top-down, except the first time.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
40. There are two ways to write error-free programs; only the third one works.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
96. Computers don't introduce order anywhere as much as they expose opportunities.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
115. Most people find the concept of programming obvious, but the doing impossible.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
78. If your computer speaks English, it was probably made in Japan.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
110. Editing is a rewording activity.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
95. Don't have good ideas if you aren't willing to be responsible for them.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
57. It is easier to change the specification to fit the program than vice versa.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
105. You can't communicate complexity, only an awareness of it.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
115. Most people find the concept of programming obvious, but the doing impossible.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
1. One man's constant is another man's variable.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
66. Making something variable is easy. Controlling duration of constancy is the trick.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
108. Whenever two programmers meet to criticize their programs, both are silent.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
61. In programming, as in everything else, to be in error is to be reborn.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
103. Purely applicative languages are poorly applicable.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
21. Optimization hinders evolution.
57. It is easier to change the specification to fit the program than vice versa.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
47. As Will Rogers would have said, "There is no such thing as a free variable."
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
23. To understand a program you must become both the machine and the program.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
110. Editing is a rewording activity.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
3. Syntactic sugar causes cancer of the semicolon.
17. If a listener nods his head when you're explaining your program, wake him up.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
12. Recursion is the root of computation since it trades description for time.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
76. It is the user who should parameterize procedures, not their creators.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
108. Whenever two programmers meet to criticize their programs, both are silent.
78. If your computer speaks English, it was probably made in Japan.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
76. It is the user who should parameterize procedures, not their creators.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
23. To understand a program you must become both the machine and the program.
55. A LISP programmer knows the value of everything, but the cost of nothing.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
78. If your computer speaks English, it was probably made in Japan.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
90. Computation has made the tree flower.
18. A program without a loop and a structured variable isn't worth writing.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
108. Whenever two programmers meet to criticize their programs, both are silent.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
46. Like punning, programming is a play on words.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
62. In computing, invariants are ephemeral.
90. Computation has made the tree flower.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
60. In seeking the unattainable, simplicity only gets in the way.
102. One can't proceed from the informal to the formal by formal means.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
63. When we write programs that "learn", it turns out that we do and they don't.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
79. A year spent in artificial intelligence is enough to make one believe in God.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
108. Whenever two programmers meet to criticize their programs, both are silent.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
79. A year spent in artificial intelligence is enough to make one believe in God.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
8. A programming language is low level when its programs require attention to the irrelevant.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
4. Every program is a part of some other program and rarely fits.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
110. Editing is a rewording activity.
7. It is easier to write an incorrect program than understand a correct one.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
57. It is easier to change the specification to fit the program than vice versa.
17. If a listener nods his head when you're explaining your program, wake him up.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
79. A year spent in artificial intelligence is enough to make one believe in God.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
110. Editing is a rewording activity.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
4. Every program is a part of some other program and rarely fits.
43. In software systems, it is often the early bird that makes the worm.
108. Whenever two programmers meet to criticize their programs, both are silent.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
78. If your computer speaks English, it was probably made in Japan.
41. Some programming languages manage to absorb change, but withstand progress.
15. Everything should be built top-down, except the first time.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
46. Like punning, programming is a play on words.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
112. Computer Science is embarrassed by the computer.
78. If your computer speaks English, it was probably made in Japan.
1. One man's constant is another man's variable.
61. In programming, as in everything else, to be in error is to be reborn.
76. It is the user who should parameterize procedures, not their creators.
47. As Will Rogers would have said, "There is no such thing as a free variable."
18. A program without a loop and a structured variable isn't worth writing.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
46. Like punning, programming is a play on words.
27. Once you understand how to write a program get someone else to write it.
61. In programming, as in everything else, to be in error is to be reborn.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
31. Simplicity does not precede complexity, but follows it.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
3. Syntactic sugar causes cancer of the semicolon.
63. When we write programs that "learn", it turns out that we do and they don't.
31. Simplicity does not precede complexity, but follows it.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
61. In programming, as in everything else, to be in error is to be reborn.
21. Optimization hinders evolution.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
98. In computing, the mean time to failure keeps getting shorter.
95. Don't have good ideas if you aren't willing to be responsible for them.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
62. In computing, invariants are ephemeral.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
96. Computers don't introduce order anywhere as much as they expose opportunities.
12. Recursion is the root of computation since it trades description for time.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
98. In computing, the mean time to failure keeps getting shorter.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
90. Computation has made the tree flower.
90. Computation has made the tree flower.
7. It is easier to write an incorrect program than understand a correct one.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
57. It is easier to change the specification to fit the program than vice versa.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
79. A year spent in artificial intelligence is enough to make one believe in God.
63. When we write programs that "learn", it turns out that we do and they don't.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
90. Computation has made the tree flower.
110. Editing is a rewording activity.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
47. As Will Rogers would have said, "There is no such thing as a free variable."
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
100. We will never run out of things to program as long as there is a single program around.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
78. If your computer speaks English, it was probably made in Japan.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
76. It is the user who should parameterize procedures, not their creators.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
95. Don't have good ideas if you aren't willing to be responsible for them.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
38. Structured Programming supports the law of the excluded middle.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
102. One can't proceed from the informal to the formal by formal means.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
96. Computers don't introduce order anywhere as much as they expose opportunities.
55. A LISP programmer knows the value of everything, but the cost of nothing.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
3. Syntactic sugar causes cancer of the semicolon.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
90. Computation has made the tree flower.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
17. If a listener nods his head when you're explaining your program, wake him up.
1. One man's constant is another man's variable.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
40. There are two ways to write error-free programs; only the third one works.
115. Most people find the concept of programming obvious, but the doing impossible.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
114. Within a computer natural language is unnatural.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
4. Every program is a part of some other program and rarely fits.
40. There are two ways to write error-free programs; only the third one works.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
90. Computation has made the tree flower.
96. Computers don't introduce order anywhere as much as they expose opportunities.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
8. A programming language is low level when its programs require attention to the irrelevant.
47. As Will Rogers would have said, "There is no such thing as a free variable."
63. When we write programs that "learn", it turns out that we do and they don't.
78. If your computer speaks English, it was probably made in Japan.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
14. In the long run every program becomes rococo - then rubble.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
114. Within a computer natural language is unnatural.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
119. Programming is an unnatural act.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
15. Everything should be built top-down, except the first time.
103. Purely applicative languages are poorly applicable.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
95. Don't have good ideas if you aren't willing to be responsible for them.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
47. As Will Rogers would have said, "There is no such thing as a free variable."
1. One man's constant is another man's variable.
18. A program without a loop and a structured variable isn't worth writing.
59. In English every word can be verbed. Would that it were so in our programming languages.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
14. In the long run every program becomes rococo - then rubble.
15. Everything should be built top-down, except the first time.
43. In software systems, it is often the early bird that makes the worm.
76. It is the user who should parameterize procedures, not their creators.
105. You can't communicate complexity, only an awareness of it.
4. Every program is a part of some other program and rarely fits.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
11. If you have a procedure with ten parameters, you probably missed some.
104. The proof of a system's value is its existence.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
105. You can't communicate complexity, only an awareness of it.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
98. In computing, the mean time to failure keeps getting shorter.
59. In English every word can be verbed. Would that it were so in our programming languages.
57. It is easier to change the specification to fit the program than vice versa.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
103. Purely applicative languages are poorly applicable.
119. Programming is an unnatural act.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
43. In software systems, it is often the early bird that makes the worm.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
27. Once you understand how to write a program get someone else to write it.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
40. There are two ways to write error-free programs; only the third one works.
78. If your computer speaks English, it was probably made in Japan.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
66. Making something variable is easy. Controlling duration of constancy is the trick.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
5. If a program manipulates a large amount of data, it does so in a small number of ways.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
3. Syntactic sugar causes cancer of the semicolon.
79. A year spent in artificial intelligence is enough to make one believe in God.
110. Editing is a rewording activity.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
12. Recursion is the root of computation since it trades description for time.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
23. To understand a program you must become both the machine and the program.
110. Editing is a rewording activity.
96. Computers don't introduce order anywhere as much as they expose opportunities.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
66. Making something variable is easy. Controlling duration of constancy is the trick.
78. If your computer speaks English, it was probably made in Japan.
7. It is easier to write an incorrect program than understand a correct one.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
112. Computer Science is embarrassed by the computer.
8. A programming language is low level when its programs require attention to the irrelevant.
79. A year spent in artificial intelligence is enough to make one believe in God.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
108. Whenever two programmers meet to criticize their programs, both are silent.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
17. If a listener nods his head when you're explaining your program, wake him up.
8. A programming language is low level when its programs require attention to the irrelevant.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
96. Computers don't introduce order anywhere as much as they expose opportunities.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
61. In programming, as in everything else, to be in error is to be reborn.
62. In computing, invariants are ephemeral.
98. In computing, the mean time to failure keeps getting shorter.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
100. We will never run out of things to program as long as there is a single program around.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
55. A LISP programmer knows the value of everything, but the cost of nothing.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
55. A LISP programmer knows the value of everything, but the cost of nothing.
61. In programming, as in everything else, to be in error is to be reborn.
103. Purely applicative languages are poorly applicable.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
119. Programming is an unnatural act.
111. Why did the Roman Empire collapse? What is Latin for office automation?
103. Purely applicative languages are poorly applicable.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
96. Computers don't introduce order anywhere as much as they expose opportunities.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
40. There are two ways to write error-free programs; only the third one works.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
47. As Will Rogers would have said, "There is no such thing as a free variable."
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
61. In programming, as in everything else, to be in error is to be reborn.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
98. In computing, the mean time to failure keeps getting shorter.
66. Making something variable is easy. Controlling duration of constancy is the trick.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
15. Everything should be built top-down, except the first time.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
72. An adequate bootstrap is a contradiction in terms.
11. If you have a procedure with ten parameters, you probably missed some.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
114. Within a computer natural language is unnatural.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
96. Computers don't introduce order anywhere as much as they expose opportunities.
22. A good system can't have a weak command language.
1. One man's constant is another man's variable.
112. Computer Science is embarrassed by the computer.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
112. Computer Science is embarrassed by the computer.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
8. A programming language is low level when its programs require attention to the irrelevant.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
95. Don't have good ideas if you aren't willing to be responsible for them.
22. A good system can't have a weak command language.
31. Simplicity does not precede complexity, but follows it.
100. We will never run out of things to program as long as there is a single program around.
62. In computing, invariants are ephemeral.
105. You can't communicate complexity, only an awareness of it.
15. Everything should be built top-down, except the first time.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
12. Recursion is the root of computation since it trades description for time.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
66. Making something variable is easy. Controlling duration of constancy is the trick.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
72. An adequate bootstrap is a contradiction in terms.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
112. Computer Science is embarrassed by the computer.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
8. A programming language is low level when its programs require attention to the irrelevant.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
23. To understand a program you must become both the machine and the program.
105. You can't communicate complexity, only an awareness of it.
79. A year spent in artificial intelligence is enough to make one believe in God.
3. Syntactic sugar causes cancer of the semicolon.
8. A programming language is low level when its programs require attention to the irrelevant.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
95. Don't have good ideas if you aren't willing to be responsible for them.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
111. Why did the Roman Empire collapse? What is Latin for office automation?
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
60. In seeking the unattainable, simplicity only gets in the way.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
61. In programming, as in everything else, to be in error is to be reborn.
1. One man's constant is another man's variable.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
22. A good system can't have a weak command language.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
61. In programming, as in everything else, to be in error is to be reborn.
119. Programming is an unnatural act.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
40. There are two ways to write error-free programs; only the third one works.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
95. Don't have good ideas if you aren't willing to be responsible for them.
79. A year spent in artificial intelligence is enough to make one believe in God.
95. Don't have good ideas if you aren't willing to be responsible for them.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
27. Once you understand how to write a program get someone else to write it.
95. Don't have good ideas if you aren't willing to be responsible for them.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
23. To understand a program you must become both the machine and the program.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
105. You can't communicate complexity, only an awareness of it.
8. A programming language is low level when its programs require attention to the irrelevant.
27. Once you understand how to write a program get someone else to write it.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
95. Don't have good ideas if you aren't willing to be responsible for them.
90. Computation has made the tree flower.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
41. Some programming languages manage to absorb change, but withstand progress.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
38. Structured Programming supports the law of the excluded middle.
98. In computing, the mean time to failure keeps getting shorter.
63. When we write programs that "learn", it turns out that we do and they don't.
8. A programming language is low level when its programs require attention to the irrelevant.
38. Structured Programming supports the law of the excluded middle.
23. To understand a program you must become both the machine and the program.
110. Editing is a rewording activity.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
60. In seeking the unattainable, simplicity only gets in the way.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
14. In the long run every program becomes rococo - then rubble.
15. Everything should be built top-down, except the first time.
112. Computer Science is embarrassed by the computer.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
110. Editing is a rewording activity.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
110. Editing is a rewording activity.
55. A LISP programmer knows the value of everything, but the cost of nothing.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
61. In programming, as in everything else, to be in error is to be reborn.
112. Computer Science is embarrassed by the computer.
27. Once you understand how to write a program get someone else to write it.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
11. If you have a procedure with ten parameters, you probably missed some.
46. Like punning, programming is a play on words.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
115. Most people find the concept of programming obvious, but the doing impossible.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
90. Computation has made the tree flower.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
60. In seeking the unattainable, simplicity only gets in the way.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
12. Recursion is the root of computation since it trades description for time.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
11. If you have a procedure with ten parameters, you probably missed some.
79. A year spent in artificial intelligence is enough to make one believe in God.
43. In software systems, it is often the early bird that makes the worm.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
104. The proof of a system's value is its existence.
60. In seeking the unattainable, simplicity only gets in the way.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
66. Making something variable is easy. Controlling duration of constancy is the trick.
23. To understand a program you must become both the machine and the program.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
12. Recursion is the root of computation since it trades description for time.
95. Don't have good ideas if you aren't willing to be responsible for them.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
100. We will never run out of things to program as long as there is a single program around.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
90. Computation has made the tree flower.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
115. Most people find the concept of programming obvious, but the doing impossible.
105. You can't communicate complexity, only an awareness of it.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
102. One can't proceed from the informal to the formal by formal means.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
27. Once you understand how to write a program get someone else to write it.
114. Within a computer natural language is unnatural.
115. Most people find the concept of programming obvious, but the doing impossible.
14. In the long run every program becomes rococo - then rubble.
105. You can't communicate complexity, only an awareness of it.
43. In software systems, it is often the early bird that makes the worm.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
98. In computing, the mean time to failure keeps getting shorter.
100. We will never run out of things to program as long as there is a single program around.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
90. Computation has made the tree flower.
61. In programming, as in everything else, to be in error is to be reborn.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
103. Purely applicative languages are poorly applicable.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
27. Once you understand how to write a program get someone else to write it.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
112. Computer Science is embarrassed by the computer.
21. Optimization hinders evolution.
55. A LISP programmer knows the value of everything, but the cost of nothing.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
57. It is easier to change the specification to fit the program than vice versa.
60. In seeking the unattainable, simplicity only gets in the way.
76. It is the user who should parameterize procedures, not their creators.
4. Every program is a part of some other program and rarely fits.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
72. An adequate bootstrap is a contradiction in terms.
46. Like punning, programming is a play on words.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
108. Whenever two programmers meet to criticize their programs, both are silent.
22. A good system can't have a weak command language.
103. Purely applicative languages are poorly applicable.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
15. Everything should be built top-down, except the first time.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
72. An adequate bootstrap is a contradiction in terms.
110. Editing is a rewording activity.
7. It is easier to write an incorrect program than understand a correct one.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
102. One can't proceed from the informal to the formal by formal means.
76. It is the user who should parameterize procedures, not their creators.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
110. Editing is a rewording activity.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
95. Don't have good ideas if you aren't willing to be responsible for them.
100. We will never run out of things to program as long as there is a single program around.
23. To understand a program you must become both the machine and the program.
23. To understand a program you must become both the machine and the program.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
1. One man's constant is another man's variable.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
112. Computer Science is embarrassed by the computer.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
112. Computer Science is embarrassed by the computer.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
3. Syntactic sugar causes cancer of the semicolon.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
115. Most people find the concept of programming obvious, but the doing impossible.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
72. An adequate bootstrap is a contradiction in terms.
112. Computer Science is embarrassed by the computer.
108. Whenever two programmers meet to criticize their programs, both are silent.
98. In computing, the mean time to failure keeps getting shorter.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
55. A LISP programmer knows the value of everything, but the cost of nothing.
38. Structured Programming supports the law of the excluded middle.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
90. Computation has made the tree flower.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
59. In English every word can be verbed. Would that it were so in our programming languages.
15. Everything should be built top-down, except the first time.
100. We will never run out of things to program as long as there is a single program around.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
103. Purely applicative languages are poorly applicable.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
1. One man's constant is another man's variable.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
18. A program without a loop and a structured variable isn't worth writing.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
103. Purely applicative languages are poorly applicable.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
63. When we write programs that "learn", it turns out that we do and they don't.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
100. We will never run out of things to program as long as there is a single program around.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
12. Recursion is the root of computation since it trades description for time.
72. An adequate bootstrap is a contradiction in terms.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
61. In programming, as in everything else, to be in error is to be reborn.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
63. When we write programs that "learn", it turns out that we do and they don't.
17. If a listener nods his head when you're explaining your program, wake him up.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
7. It is easier to write an incorrect program than understand a correct one.
95. Don't have good ideas if you aren't willing to be responsible for them.
40. There are two ways to write error-free programs; only the third one works.
95. Don't have good ideas if you aren't willing to be responsible for them.
90. Computation has made the tree flower.
108. Whenever two programmers meet to criticize their programs, both are silent.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
4. Every program is a part of some other program and rarely fits.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
79. A year spent in artificial intelligence is enough to make one believe in God.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
110. Editing is a rewording activity.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
1. One man's constant is another man's variable.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
95. Don't have good ideas if you aren't willing to be responsible for them.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
105. You can't communicate complexity, only an awareness of it.
90. Computation has made the tree flower.
100. We will never run out of things to program as long as there is a single program around.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
72. An adequate bootstrap is a contradiction in terms.
40. There are two ways to write error-free programs; only the third one works.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
108. Whenever two programmers meet to criticize their programs, both are silent.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
110. Editing is a rewording activity.
31. Simplicity does not precede complexity, but follows it.
112. Computer Science is embarrassed by the computer.
22. A good system can't have a weak command language.
111. Why did the Roman Empire collapse? What is Latin for office automation?
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
59. In English every word can be verbed. Would that it were so in our programming languages.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
60. In seeking the unattainable, simplicity only gets in the way.
43. In software systems, it is often the early bird that makes the worm.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
78. If your computer speaks English, it was probably made in Japan.
112. Computer Science is embarrassed by the computer.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
31. Simplicity does not precede complexity, but follows it.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
46. Like punning, programming is a play on words.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
105. You can't communicate complexity, only an awareness of it.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
17. If a listener nods his head when you're explaining your program, wake him up.
1. One man's constant is another man's variable.
55. A LISP programmer knows the value of everything, but the cost of nothing.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
46. Like punning, programming is a play on words.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
47. As Will Rogers would have said, "There is no such thing as a free variable."
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
95. Don't have good ideas if you aren't willing to be responsible for them.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
1. One man's constant is another man's variable.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
60. In seeking the unattainable, simplicity only gets in the way.
40. There are two ways to write error-free programs; only the third one works.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
15. Everything should be built top-down, except the first time.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
62. In computing, invariants are ephemeral.
104. The proof of a system's value is its existence.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
114. Within a computer natural language is unnatural.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
62. In computing, invariants are ephemeral.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
100. We will never run out of things to program as long as there is a single program around.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
8. A programming language is low level when its programs require attention to the irrelevant.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
46. Like punning, programming is a play on words.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
3. Syntactic sugar causes cancer of the semicolon.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
57. It is easier to change the specification to fit the program than vice versa.
46. Like punning, programming is a play on words.
114. Within a computer natural language is unnatural.
112. Computer Science is embarrassed by the computer.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
96. Computers don't introduce order anywhere as much as they expose opportunities.
76. It is the user who should parameterize procedures, not their creators.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
90. Computation has made the tree flower.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
115. Most people find the concept of programming obvious, but the doing impossible.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
119. Programming is an unnatural act.
3. Syntactic sugar causes cancer of the semicolon.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
108. Whenever two programmers meet to criticize their programs, both are silent.
47. As Will Rogers would have said, "There is no such thing as a free variable."
18. A program without a loop and a structured variable isn't worth writing.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
60. In seeking the unattainable, simplicity only gets in the way.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
38. Structured Programming supports the law of the excluded middle.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
15. Everything should be built top-down, except the first time.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
119. Programming is an unnatural act.
41. Some programming languages manage to absorb change, but withstand progress.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
15. Everything should be built top-down, except the first time.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
119. Programming is an unnatural act.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
8. A programming language is low level when its programs require attention to the irrelevant.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
4. Every program is a part of some other program and rarely fits.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
40. There are two ways to write error-free programs; only the third one works.
14. In the long run every program becomes rococo - then rubble.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
23. To understand a program you must become both the machine and the program.
79. A year spent in artificial intelligence is enough to make one believe in God.
103. Purely applicative languages are poorly applicable.
66. Making something variable is easy. Controlling duration of constancy is the trick.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
103. Purely applicative languages are poorly applicable.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
18. A program without a loop and a structured variable isn't worth writing.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
79. A year spent in artificial intelligence is enough to make one believe in God.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
23. To understand a program you must become both the machine and the program.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
3. Syntactic sugar causes cancer of the semicolon.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
98. In computing, the mean time to failure keeps getting shorter.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
115. Most people find the concept of programming obvious, but the doing impossible.
18. A program without a loop and a structured variable isn't worth writing.
61. In programming, as in everything else, to be in error is to be reborn.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
14. In the long run every program becomes rococo - then rubble.
114. Within a computer natural language is unnatural.
76. It is the user who should parameterize procedures, not their creators.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
90. Computation has made the tree flower.
43. In software systems, it is often the early bird that makes the worm.
23. To understand a program you must become both the machine and the program.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
4. Every program is a part of some other program and rarely fits.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
43. In software systems, it is often the early bird that makes the worm.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
72. An adequate bootstrap is a contradiction in terms.
3. Syntactic sugar causes cancer of the semicolon.
102. One can't proceed from the informal to the formal by formal means.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
95. Don't have good ideas if you aren't willing to be responsible for them.
78. If your computer speaks English, it was probably made in Japan.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
38. Structured Programming supports the law of the excluded middle.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
47. As Will Rogers would have said, "There is no such thing as a free variable."
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
102. One can't proceed from the informal to the formal by formal means.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
98. In computing, the mean time to failure keeps getting shorter.
47. As Will Rogers would have said, "There is no such thing as a free variable."
111. Why did the Roman Empire collapse? What is Latin for office automation?
79. A year spent in artificial intelligence is enough to make one believe in God.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
40. There are two ways to write error-free programs; only the third one works.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
46. Like punning, programming is a play on words.
66. Making something variable is easy. Controlling duration of constancy is the trick.
1. One man's constant is another man's variable.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
110. Editing is a rewording activity.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
3. Syntactic sugar causes cancer of the semicolon.
98. In computing, the mean time to failure keeps getting shorter.
102. One can't proceed from the informal to the formal by formal means.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
79. A year spent in artificial intelligence is enough to make one believe in God.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
62. In computing, invariants are ephemeral.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
12. Recursion is the root of computation since it trades description for time.
103. Purely applicative languages are poorly applicable.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
112. Computer Science is embarrassed by the computer.
22. A good system can't have a weak command language.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
57. It is easier to change the specification to fit the program than vice versa.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
108. Whenever two programmers meet to criticize their programs, both are silent.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
38. Structured Programming supports the law of the excluded middle.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
98. In computing, the mean time to failure keeps getting shorter.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
90. Computation has made the tree flower.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
108. Whenever two programmers meet to criticize their programs, both are silent.
119. Programming is an unnatural act.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
79. A year spent in artificial intelligence is enough to make one believe in God.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
31. Simplicity does not precede complexity, but follows it.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
78. If your computer speaks English, it was probably made in Japan.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
114. Within a computer natural language is unnatural.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
72. An adequate bootstrap is a contradiction in terms.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
21. Optimization hinders evolution.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
38. Structured Programming supports the law of the excluded middle.
61. In programming, as in everything else, to be in error is to be reborn.
22. A good system can't have a weak command language.
38. Structured Programming supports the law of the excluded middle.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
62. In computing, invariants are ephemeral.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
108. Whenever two programmers meet to criticize their programs, both are silent.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
60. In seeking the unattainable, simplicity only gets in the way.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
79. A year spent in artificial intelligence is enough to make one believe in God.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
76. It is the user who should parameterize procedures, not their creators.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
76. It is the user who should parameterize procedures, not their creators.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
47. As Will Rogers would have said, "There is no such thing as a free variable."
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
21. Optimization hinders evolution.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
3. Syntactic sugar causes cancer of the semicolon.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
95. Don't have good ideas if you aren't willing to be responsible for them.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
66. Making something variable is easy. Controlling duration of constancy is the trick.
103. Purely applicative languages are poorly applicable.
14. In the long run every program becomes rococo - then rubble.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
90. Computation has made the tree flower.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
104. The proof of a system's value is its existence.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
115. Most people find the concept of programming obvious, but the doing impossible.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
63. When we write programs that "learn", it turns out that we do and they don't.
100. We will never run out of things to program as long as there is a single program around.
62. In computing, invariants are ephemeral.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
31. Simplicity does not precede complexity, but follows it.
41. Some programming languages manage to absorb change, but withstand progress.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
104. The proof of a system's value is its existence.
1. One man's constant is another man's variable.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
12. Recursion is the root of computation since it trades description for time.
90. Computation has made the tree flower.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
59. In English every word can be verbed. Would that it were so in our programming languages.
47. As Will Rogers would have said, "There is no such thing as a free variable."
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
62. In computing, invariants are ephemeral.
15. Everything should be built top-down, except the first time.
66. Making something variable is easy. Controlling duration of constancy is the trick.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
31. Simplicity does not precede complexity, but follows it.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
96. Computers don't introduce order anywhere as much as they expose opportunities.
78. If your computer speaks English, it was probably made in Japan.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
47. As Will Rogers would have said, "There is no such thing as a free variable."
14. In the long run every program becomes rococo - then rubble.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
11. If you have a procedure with ten parameters, you probably missed some.
27. Once you understand how to write a program get someone else to write it.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
57. It is easier to change the specification to fit the program than vice versa.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
114. Within a computer natural language is unnatural.
63. When we write programs that "learn", it turns out that we do and they don't.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
63. When we write programs that "learn", it turns out that we do and they don't.
110. Editing is a rewording activity.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
60. In seeking the unattainable, simplicity only gets in the way.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
110. Editing is a rewording activity.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
21. Optimization hinders evolution.
47. As Will Rogers would have said, "There is no such thing as a free variable."
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
41. Some programming languages manage to absorb change, but withstand progress.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
8. A programming language is low level when its programs require attention to the irrelevant.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
7. It is easier to write an incorrect program than understand a correct one.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
21. Optimization hinders evolution.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
31. Simplicity does not precede complexity, but follows it.
61. In programming, as in everything else, to be in error is to be reborn.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
62. In computing, invariants are ephemeral.
90. Computation has made the tree flower.
76. It is the user who should parameterize procedures, not their creators.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
103. Purely applicative languages are poorly applicable.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
59. In English every word can be verbed. Would that it were so in our programming languages.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
110. Editing is a rewording activity.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
7. It is easier to write an incorrect program than understand a correct one.
3. Syntactic sugar causes cancer of the semicolon.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
62. In computing, invariants are ephemeral.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
57. It is easier to change the specification to fit the program than vice versa.
61. In programming, as in everything else, to be in error is to be reborn.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
119. Programming is an unnatural act.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
18. A program without a loop and a structured variable isn't worth writing.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
66. Making something variable is easy. Controlling duration of constancy is the trick.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
57. It is easier to change the specification to fit the program than vice versa.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
17. If a listener nods his head when you're explaining your program, wake him up.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
111. Why did the Roman Empire collapse? What is Latin for office automation?
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
18. A program without a loop and a structured variable isn't worth writing.
72. An adequate bootstrap is a contradiction in terms.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
27. Once you understand how to write a program get someone else to write it.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
46. Like punning, programming is a play on words.
27. Once you understand how to write a program get someone else to write it.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
11. If you have a procedure with ten parameters, you probably missed some.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
21. Optimization hinders evolution.
31. Simplicity does not precede complexity, but follows it.
72. An adequate bootstrap is a contradiction in terms.
57. It is easier to change the specification to fit the program than vice versa.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
40. There are two ways to write error-free programs; only the third one works.
18. A program without a loop and a structured variable isn't worth writing.
90. Computation has made the tree flower.
15. Everything should be built top-down, except the first time.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
115. Most people find the concept of programming obvious, but the doing impossible.
59. In English every word can be verbed. Would that it were so in our programming languages.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
38. Structured Programming supports the law of the excluded middle.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
115. Most people find the concept of programming obvious, but the doing impossible.
98. In computing, the mean time to failure keeps getting shorter.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
21. Optimization hinders evolution.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
114. Within a computer natural language is unnatural.
14. In the long run every program becomes rococo - then rubble.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
95. Don't have good ideas if you aren't willing to be responsible for them.
17. If a listener nods his head when you're explaining your program, wake him up.
31. Simplicity does not precede complexity, but follows it.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
17. If a listener nods his head when you're explaining your program, wake him up.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
104. The proof of a system's value is its existence.
60. In seeking the unattainable, simplicity only gets in the way.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
108. Whenever two programmers meet to criticize their programs, both are silent.
57. It is easier to change the specification to fit the program than vice versa.
72. An adequate bootstrap is a contradiction in terms.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
47. As Will Rogers would have said, "There is no such thing as a free variable."
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
47. As Will Rogers would have said, "There is no such thing as a free variable."
40. There are two ways to write error-free programs; only the third one works.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
105. You can't communicate complexity, only an awareness of it.
12. Recursion is the root of computation since it trades description for time.
43. In software systems, it is often the early bird that makes the worm.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
95. Don't have good ideas if you aren't willing to be responsible for them.
22. A good system can't have a weak command language.
104. The proof of a system's value is its existence.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
59. In English every word can be verbed. Would that it were so in our programming languages.
14. In the long run every program becomes rococo - then rubble.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
78. If your computer speaks English, it was probably made in Japan.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
3. Syntactic sugar causes cancer of the semicolon.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
79. A year spent in artificial intelligence is enough to make one believe in God.
8. A programming language is low level when its programs require attention to the irrelevant.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
114. Within a computer natural language is unnatural.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
4. Every program is a part of some other program and rarely fits.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
17. If a listener nods his head when you're explaining your program, wake him up.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
8. A programming language is low level when its programs require attention to the irrelevant.
104. The proof of a system's value is its existence.
55. A LISP programmer knows the value of everything, but the cost of nothing.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
40. There are two ways to write error-free programs; only the third one works.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
76. It is the user who should parameterize procedures, not their creators.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
1. One man's constant is another man's variable.
22. A good system can't have a weak command language.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
46. Like punning, programming is a play on words.
115. Most people find the concept of programming obvious, but the doing impossible.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
103. Purely applicative languages are poorly applicable.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
114. Within a computer natural language is unnatural.
8. A programming language is low level when its programs require attention to the irrelevant.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
98. In computing, the mean time to failure keeps getting shorter.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
112. Computer Science is embarrassed by the computer.
11. If you have a procedure with ten parameters, you probably missed some.
7. It is easier to write an incorrect program than understand a correct one.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
115. Most people find the concept of programming obvious, but the doing impossible.
66. Making something variable is easy. Controlling duration of constancy is the trick.
47. As Will Rogers would have said, "There is no such thing as a free variable."
38. Structured Programming supports the law of the excluded middle.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
119. Programming is an unnatural act.
38. Structured Programming supports the law of the excluded middle.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
62. In computing, invariants are ephemeral.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
22. A good system can't have a weak command language.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
22. A good system can't have a weak command language.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
62. In computing, invariants are ephemeral.
98. In computing, the mean time to failure keeps getting shorter.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
96. Computers don't introduce order anywhere as much as they expose opportunities.
100. We will never run out of things to program as long as there is a single program around.
72. An adequate bootstrap is a contradiction in terms.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
46. Like punning, programming is a play on words.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
7. It is easier to write an incorrect program than understand a correct one.
15. Everything should be built top-down, except the first time.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
72. An adequate bootstrap is a contradiction in terms.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
27. Once you understand how to write a program get someone else to write it.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
114. Within a computer natural language is unnatural.
111. Why did the Roman Empire collapse? What is Latin for office automation?
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
119. Programming is an unnatural act.
78. If your computer speaks English, it was probably made in Japan.
8. A programming language is low level when its programs require attention to the irrelevant.
61. In programming, as in everything else, to be in error is to be reborn.
98. In computing, the mean time to failure keeps getting shorter.
7. It is easier to write an incorrect program than understand a correct one.
59. In English every word can be verbed. Would that it were so in our programming languages.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
112. Computer Science is embarrassed by the computer.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
43. In software systems, it is often the early bird that makes the worm.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
119. Programming is an unnatural act.
62. In computing, invariants are ephemeral.
95. Don't have good ideas if you aren't willing to be responsible for them.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
14. In the long run every program becomes rococo - then rubble.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
66. Making something variable is easy. Controlling duration of constancy is the trick.
27. Once you understand how to write a program get someone else to write it.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
72. An adequate bootstrap is a contradiction in terms.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
112. Computer Science is embarrassed by the computer.
11. If you have a procedure with ten parameters, you probably missed some.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
5. If a program manipulates a large amount of data, it does so in a small number of ways.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
21. Optimization hinders evolution.
79. A year spent in artificial intelligence is enough to make one believe in God.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
100. We will never run out of things to program as long as there is a single program around.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
61. In programming, as in everything else, to be in error is to be reborn.
14. In the long run every program becomes rococo - then rubble.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
27. Once you understand how to write a program get someone else to write it.
63. When we write programs that "learn", it turns out that we do and they don't.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
18. A program without a loop and a structured variable isn't worth writing.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
22. A good system can't have a weak command language.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
55. A LISP programmer knows the value of everything, but the cost of nothing.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
78. If your computer speaks English, it was probably made in Japan.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
59. In English every word can be verbed. Would that it were so in our programming languages.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
4. Every program is a part of some other program and rarely fits.
11. If you have a procedure with ten parameters, you probably missed some.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
11. If you have a procedure with ten parameters, you probably missed some.
4. Every program is a part of some other program and rarely fits.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
18. A program without a loop and a structured variable isn't worth writing.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
103. Purely applicative languages are poorly applicable.
100. We will never run out of things to program as long as there is a single program around.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
63. When we write programs that "learn", it turns out that we do and they don't.
59. In English every word can be verbed. Would that it were so in our programming languages.
112. Computer Science is embarrassed by the computer.
15. Everything should be built top-down, except the first time.
95. Don't have good ideas if you aren't willing to be responsible for them.
46. Like punning, programming is a play on words.
4. Every program is a part of some other program and rarely fits.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
57. It is easier to change the specification to fit the program than vice versa.
79. A year spent in artificial intelligence is enough to make one believe in God.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
3. Syntactic sugar causes cancer of the semicolon.
110. Editing is a rewording activity.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
103. Purely applicative languages are poorly applicable.
46. Like punning, programming is a play on words.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
14. In the long run every program becomes rococo - then rubble.
15. Everything should be built top-down, except the first time.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
102. One can't proceed from the informal to the formal by formal means.
17. If a listener nods his head when you're explaining your program, wake him up.
78. If your computer speaks English, it was probably made in Japan.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
115. Most people find the concept of programming obvious, but the doing impossible.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
103. Purely applicative languages are poorly applicable.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
11. If you have a procedure with ten parameters, you probably missed some.
61. In programming, as in everything else, to be in error is to be reborn.
8. A programming language is low level when its programs require attention to the irrelevant.
62. In computing, invariants are ephemeral.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
43. In software systems, it is often the early bird that makes the worm.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
79. A year spent in artificial intelligence is enough to make one believe in God.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
115. Most people find the concept of programming obvious, but the doing impossible.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
15. Everything should be built top-down, except the first time.
40. There are two ways to write error-free programs; only the third one works.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
38. Structured Programming supports the law of the excluded middle.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
57. It is easier to change the specification to fit the program than vice versa.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
11. If you have a procedure with ten parameters, you probably missed some.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
38. Structured Programming supports the law of the excluded middle.
7. It is easier to write an incorrect program than understand a correct one.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
104. The proof of a system's value is its existence.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
59. In English every word can be verbed. Would that it were so in our programming languages.
63. When we write programs that "learn", it turns out that we do and they don't.
114. Within a computer natural language is unnatural.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
59. In English every word can be verbed. Would that it were so in our programming languages.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
17. If a listener nods his head when you're explaining your program, wake him up.
43. In software systems, it is often the early bird that makes the worm.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
102. One can't proceed from the informal to the formal by formal means.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
57. It is easier to change the specification to fit the program than vice versa.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
62. In computing, invariants are ephemeral.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
40. There are two ways to write error-free programs; only the third one works.
100. We will never run out of things to program as long as there is a single program around.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
108. Whenever two programmers meet to criticize their programs, both are silent.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
95. Don't have good ideas if you aren't willing to be responsible for them.
111. Why did the Roman Empire collapse? What is Latin for office automation?
95. Don't have good ideas if you aren't willing to be responsible for them.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
95. Don't have good ideas if you aren't willing to be responsible for them.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
61. In programming, as in everything else, to be in error is to be reborn.
40. There are two ways to write error-free programs; only the third one works.
60. In seeking the unattainable, simplicity only gets in the way.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
104. The proof of a system's value is its existence.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
104. The proof of a system's value is its existence.
18. A program without a loop and a structured variable isn't worth writing.
47. As Will Rogers would have said, "There is no such thing as a free variable."
57. It is easier to change the specification to fit the program than vice versa.
60. In seeking the unattainable, simplicity only gets in the way.
103. Purely applicative languages are poorly applicable.
8. A programming language is low level when its programs require attention to the irrelevant.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
1. One man's constant is another man's variable.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
59. In English every word can be verbed. Would that it were so in our programming languages.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
15. Everything should be built top-down, except the first time.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
79. A year spent in artificial intelligence is enough to make one believe in God.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
31. Simplicity does not precede complexity, but follows it.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
47. As Will Rogers would have said, "There is no such thing as a free variable."
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
79. A year spent in artificial intelligence is enough to make one believe in God.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
112. Computer Science is embarrassed by the computer.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
15. Everything should be built top-down, except the first time.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
7. It is easier to write an incorrect program than understand a correct one.
96. Computers don't introduce order anywhere as much as they expose opportunities.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
110. Editing is a rewording activity.
108. Whenever two programmers meet to criticize their programs, both are silent.
59. In English every word can be verbed. Would that it were so in our programming languages.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
23. To understand a program you must become both the machine and the program.
46. Like punning, programming is a play on words.
7. It is easier to write an incorrect program than understand a correct one.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
17. If a listener nods his head when you're explaining your program, wake him up.
12. Recursion is the root of computation since it trades description for time.
27. Once you understand how to write a program get someone else to write it.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
14. In the long run every program becomes rococo - then rubble.
