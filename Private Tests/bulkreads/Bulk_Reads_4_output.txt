39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
8. A programming language is low level when its programs require attention to the irrelevant.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
72. An adequate bootstrap is a contradiction in terms.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
14. In the long run every program becomes rococo - then rubble.
22. A good system can't have a weak command language.
59. In English every word can be verbed. Would that it were so in our programming languages.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
61. In programming, as in everything else, to be in error is to be reborn.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
57. It is easier to change the specification to fit the program than vice versa.
17. If a listener nods his head when you're explaining your program, wake him up.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
40. There are two ways to write error-free programs; only the third one works.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
7. It is easier to write an incorrect program than understand a correct one.
21. Optimization hinders evolution.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
3. Syntactic sugar causes cancer of the semicolon.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
43. In software systems, it is often the early bird that makes the worm.
21. Optimization hinders evolution.
63. When we write programs that "learn", it turns out that we do and they don't.
61. In programming, as in everything else, to be in error is to be reborn.
63. When we write programs that "learn", it turns out that we do and they don't.
4. Every program is a part of some other program and rarely fits.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
79. A year spent in artificial intelligence is enough to make one believe in God.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
15. Everything should be built top-down, except the first time.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
115. Most people find the concept of programming obvious, but the doing impossible.
40. There are two ways to write error-free programs; only the third one works.
14. In the long run every program becomes rococo - then rubble.
12. Recursion is the root of computation since it trades description for time.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
100. We will never run out of things to program as long as there is a single program around.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
62. In computing, invariants are ephemeral.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
15. Everything should be built top-down, except the first time.
79. A year spent in artificial intelligence is enough to make one believe in God.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
102. One can't proceed from the informal to the formal by formal means.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
103. Purely applicative languages are poorly applicable.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
18. A program without a loop and a structured variable isn't worth writing.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
41. Some programming languages manage to absorb change, but withstand progress.
55. A LISP programmer knows the value of everything, but the cost of nothing.
105. You can't communicate complexity, only an awareness of it.
1. One man's constant is another man's variable.
43. In software systems, it is often the early bird that makes the worm.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
3. Syntactic sugar causes cancer of the semicolon.
43. In software systems, it is often the early bird that makes the worm.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
38. Structured Programming supports the law of the excluded middle.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
104. The proof of a system's value is its existence.
114. Within a computer natural language is unnatural.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
40. There are two ways to write error-free programs; only the third one works.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
38. Structured Programming supports the law of the excluded middle.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
4. Every program is a part of some other program and rarely fits.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
8. A programming language is low level when its programs require attention to the irrelevant.
60. In seeking the unattainable, simplicity only gets in the way.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
11. If you have a procedure with ten parameters, you probably missed some.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
62. In computing, invariants are ephemeral.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
22. A good system can't have a weak command language.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
76. It is the user who should parameterize procedures, not their creators.
11. If you have a procedure with ten parameters, you probably missed some.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
114. Within a computer natural language is unnatural.
72. An adequate bootstrap is a contradiction in terms.
27. Once you understand how to write a program get someone else to write it.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
31. Simplicity does not precede complexity, but follows it.
57. It is easier to change the specification to fit the program than vice versa.
21. Optimization hinders evolution.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
31. Simplicity does not precede complexity, but follows it.
43. In software systems, it is often the early bird that makes the worm.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
22. A good system can't have a weak command language.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
61. In programming, as in everything else, to be in error is to be reborn.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
8. A programming language is low level when its programs require attention to the irrelevant.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
119. Programming is an unnatural act.
96. Computers don't introduce order anywhere as much as they expose opportunities.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
27. Once you understand how to write a program get someone else to write it.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
115. Most people find the concept of programming obvious, but the doing impossible.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
78. If your computer speaks English, it was probably made in Japan.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
66. Making something variable is easy. Controlling duration of constancy is the trick.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
104. The proof of a system's value is its existence.
108. Whenever two programmers meet to criticize their programs, both are silent.
27. Once you understand how to write a program get someone else to write it.
63. When we write programs that "learn", it turns out that we do and they don't.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
115. Most people find the concept of programming obvious, but the doing impossible.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
110. Editing is a rewording activity.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
4. Every program is a part of some other program and rarely fits.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
11. If you have a procedure with ten parameters, you probably missed some.
57. It is easier to change the specification to fit the program than vice versa.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
98. In computing, the mean time to failure keeps getting shorter.
27. Once you understand how to write a program get someone else to write it.
110. Editing is a rewording activity.
21. Optimization hinders evolution.
96. Computers don't introduce order anywhere as much as they expose opportunities.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
40. There are two ways to write error-free programs; only the third one works.
7. It is easier to write an incorrect program than understand a correct one.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
96. Computers don't introduce order anywhere as much as they expose opportunities.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
60. In seeking the unattainable, simplicity only gets in the way.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
111. Why did the Roman Empire collapse? What is Latin for office automation?
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
11. If you have a procedure with ten parameters, you probably missed some.
108. Whenever two programmers meet to criticize their programs, both are silent.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
98. In computing, the mean time to failure keeps getting shorter.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
103. Purely applicative languages are poorly applicable.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
104. The proof of a system's value is its existence.
57. It is easier to change the specification to fit the program than vice versa.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
78. If your computer speaks English, it was probably made in Japan.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
55. A LISP programmer knows the value of everything, but the cost of nothing.
110. Editing is a rewording activity.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
62. In computing, invariants are ephemeral.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
62. In computing, invariants are ephemeral.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
90. Computation has made the tree flower.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
66. Making something variable is easy. Controlling duration of constancy is the trick.
112. Computer Science is embarrassed by the computer.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
11. If you have a procedure with ten parameters, you probably missed some.
111. Why did the Roman Empire collapse? What is Latin for office automation?
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
102. One can't proceed from the informal to the formal by formal means.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
18. A program without a loop and a structured variable isn't worth writing.
31. Simplicity does not precede complexity, but follows it.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
17. If a listener nods his head when you're explaining your program, wake him up.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
108. Whenever two programmers meet to criticize their programs, both are silent.
23. To understand a program you must become both the machine and the program.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
12. Recursion is the root of computation since it trades description for time.
76. It is the user who should parameterize procedures, not their creators.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
46. Like punning, programming is a play on words.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
96. Computers don't introduce order anywhere as much as they expose opportunities.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
23. To understand a program you must become both the machine and the program.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
66. Making something variable is easy. Controlling duration of constancy is the trick.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
115. Most people find the concept of programming obvious, but the doing impossible.
55. A LISP programmer knows the value of everything, but the cost of nothing.
18. A program without a loop and a structured variable isn't worth writing.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
23. To understand a program you must become both the machine and the program.
23. To understand a program you must become both the machine and the program.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
31. Simplicity does not precede complexity, but follows it.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
119. Programming is an unnatural act.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
60. In seeking the unattainable, simplicity only gets in the way.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
21. Optimization hinders evolution.
98. In computing, the mean time to failure keeps getting shorter.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
59. In English every word can be verbed. Would that it were so in our programming languages.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
59. In English every word can be verbed. Would that it were so in our programming languages.
47. As Will Rogers would have said, "There is no such thing as a free variable."
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
76. It is the user who should parameterize procedures, not their creators.
3. Syntactic sugar causes cancer of the semicolon.
95. Don't have good ideas if you aren't willing to be responsible for them.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
103. Purely applicative languages are poorly applicable.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
110. Editing is a rewording activity.
57. It is easier to change the specification to fit the program than vice versa.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
43. In software systems, it is often the early bird that makes the worm.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
1. One man's constant is another man's variable.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
12. Recursion is the root of computation since it trades description for time.
31. Simplicity does not precede complexity, but follows it.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
115. Most people find the concept of programming obvious, but the doing impossible.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
4. Every program is a part of some other program and rarely fits.
119. Programming is an unnatural act.
41. Some programming languages manage to absorb change, but withstand progress.
43. In software systems, it is often the early bird that makes the worm.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
21. Optimization hinders evolution.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
41. Some programming languages manage to absorb change, but withstand progress.
8. A programming language is low level when its programs require attention to the irrelevant.
76. It is the user who should parameterize procedures, not their creators.
76. It is the user who should parameterize procedures, not their creators.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
76. It is the user who should parameterize procedures, not their creators.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
23. To understand a program you must become both the machine and the program.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
17. If a listener nods his head when you're explaining your program, wake him up.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
63. When we write programs that "learn", it turns out that we do and they don't.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
61. In programming, as in everything else, to be in error is to be reborn.
90. Computation has made the tree flower.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
31. Simplicity does not precede complexity, but follows it.
43. In software systems, it is often the early bird that makes the worm.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
79. A year spent in artificial intelligence is enough to make one believe in God.
22. A good system can't have a weak command language.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
47. As Will Rogers would have said, "There is no such thing as a free variable."
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
102. One can't proceed from the informal to the formal by formal means.
11. If you have a procedure with ten parameters, you probably missed some.
17. If a listener nods his head when you're explaining your program, wake him up.
103. Purely applicative languages are poorly applicable.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
79. A year spent in artificial intelligence is enough to make one believe in God.
15. Everything should be built top-down, except the first time.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
55. A LISP programmer knows the value of everything, but the cost of nothing.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
114. Within a computer natural language is unnatural.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
78. If your computer speaks English, it was probably made in Japan.
103. Purely applicative languages are poorly applicable.
40. There are two ways to write error-free programs; only the third one works.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
43. In software systems, it is often the early bird that makes the worm.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
95. Don't have good ideas if you aren't willing to be responsible for them.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
1. One man's constant is another man's variable.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
43. In software systems, it is often the early bird that makes the worm.
76. It is the user who should parameterize procedures, not their creators.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
17. If a listener nods his head when you're explaining your program, wake him up.
43. In software systems, it is often the early bird that makes the worm.
7. It is easier to write an incorrect program than understand a correct one.
103. Purely applicative languages are poorly applicable.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
27. Once you understand how to write a program get someone else to write it.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
41. Some programming languages manage to absorb change, but withstand progress.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
46. Like punning, programming is a play on words.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
47. As Will Rogers would have said, "There is no such thing as a free variable."
95. Don't have good ideas if you aren't willing to be responsible for them.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
3. Syntactic sugar causes cancer of the semicolon.
59. In English every word can be verbed. Would that it were so in our programming languages.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
31. Simplicity does not precede complexity, but follows it.
63. When we write programs that "learn", it turns out that we do and they don't.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
57. It is easier to change the specification to fit the program than vice versa.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
76. It is the user who should parameterize procedures, not their creators.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
55. A LISP programmer knows the value of everything, but the cost of nothing.
62. In computing, invariants are ephemeral.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
8. A programming language is low level when its programs require attention to the irrelevant.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
61. In programming, as in everything else, to be in error is to be reborn.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
12. Recursion is the root of computation since it trades description for time.
62. In computing, invariants are ephemeral.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
4. Every program is a part of some other program and rarely fits.
104. The proof of a system's value is its existence.
108. Whenever two programmers meet to criticize their programs, both are silent.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
61. In programming, as in everything else, to be in error is to be reborn.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
102. One can't proceed from the informal to the formal by formal means.
110. Editing is a rewording activity.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
11. If you have a procedure with ten parameters, you probably missed some.
55. A LISP programmer knows the value of everything, but the cost of nothing.
103. Purely applicative languages are poorly applicable.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
41. Some programming languages manage to absorb change, but withstand progress.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
72. An adequate bootstrap is a contradiction in terms.
18. A program without a loop and a structured variable isn't worth writing.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
4. Every program is a part of some other program and rarely fits.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
59. In English every word can be verbed. Would that it were so in our programming languages.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
115. Most people find the concept of programming obvious, but the doing impossible.
104. The proof of a system's value is its existence.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
14. In the long run every program becomes rococo - then rubble.
60. In seeking the unattainable, simplicity only gets in the way.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
79. A year spent in artificial intelligence is enough to make one believe in God.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
27. Once you understand how to write a program get someone else to write it.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
61. In programming, as in everything else, to be in error is to be reborn.
41. Some programming languages manage to absorb change, but withstand progress.
7. It is easier to write an incorrect program than understand a correct one.
8. A programming language is low level when its programs require attention to the irrelevant.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
98. In computing, the mean time to failure keeps getting shorter.
90. Computation has made the tree flower.
23. To understand a program you must become both the machine and the program.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
61. In programming, as in everything else, to be in error is to be reborn.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
31. Simplicity does not precede complexity, but follows it.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
98. In computing, the mean time to failure keeps getting shorter.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
96. Computers don't introduce order anywhere as much as they expose opportunities.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
98. In computing, the mean time to failure keeps getting shorter.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
40. There are two ways to write error-free programs; only the third one works.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
43. In software systems, it is often the early bird that makes the worm.
98. In computing, the mean time to failure keeps getting shorter.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
11. If you have a procedure with ten parameters, you probably missed some.
22. A good system can't have a weak command language.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
98. In computing, the mean time to failure keeps getting shorter.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
98. In computing, the mean time to failure keeps getting shorter.
115. Most people find the concept of programming obvious, but the doing impossible.
18. A program without a loop and a structured variable isn't worth writing.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
59. In English every word can be verbed. Would that it were so in our programming languages.
61. In programming, as in everything else, to be in error is to be reborn.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
14. In the long run every program becomes rococo - then rubble.
27. Once you understand how to write a program get someone else to write it.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
40. There are two ways to write error-free programs; only the third one works.
43. In software systems, it is often the early bird that makes the worm.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
21. Optimization hinders evolution.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
59. In English every word can be verbed. Would that it were so in our programming languages.
41. Some programming languages manage to absorb change, but withstand progress.
108. Whenever two programmers meet to criticize their programs, both are silent.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
100. We will never run out of things to program as long as there is a single program around.
119. Programming is an unnatural act.
112. Computer Science is embarrassed by the computer.
95. Don't have good ideas if you aren't willing to be responsible for them.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
43. In software systems, it is often the early bird that makes the worm.
102. One can't proceed from the informal to the formal by formal means.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
112. Computer Science is embarrassed by the computer.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
96. Computers don't introduce order anywhere as much as they expose opportunities.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
110. Editing is a rewording activity.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
38. Structured Programming supports the law of the excluded middle.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
43. In software systems, it is often the early bird that makes the worm.
41. Some programming languages manage to absorb change, but withstand progress.
55. A LISP programmer knows the value of everything, but the cost of nothing.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
76. It is the user who should parameterize procedures, not their creators.
23. To understand a program you must become both the machine and the program.
7. It is easier to write an incorrect program than understand a correct one.
76. It is the user who should parameterize procedures, not their creators.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
21. Optimization hinders evolution.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
4. Every program is a part of some other program and rarely fits.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
46. Like punning, programming is a play on words.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
23. To understand a program you must become both the machine and the program.
100. We will never run out of things to program as long as there is a single program around.
66. Making something variable is easy. Controlling duration of constancy is the trick.
12. Recursion is the root of computation since it trades description for time.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
62. In computing, invariants are ephemeral.
90. Computation has made the tree flower.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
46. Like punning, programming is a play on words.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
108. Whenever two programmers meet to criticize their programs, both are silent.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
43. In software systems, it is often the early bird that makes the worm.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
59. In English every word can be verbed. Would that it were so in our programming languages.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
78. If your computer speaks English, it was probably made in Japan.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
59. In English every word can be verbed. Would that it were so in our programming languages.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
60. In seeking the unattainable, simplicity only gets in the way.
55. A LISP programmer knows the value of everything, but the cost of nothing.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
41. Some programming languages manage to absorb change, but withstand progress.
27. Once you understand how to write a program get someone else to write it.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
66. Making something variable is easy. Controlling duration of constancy is the trick.
41. Some programming languages manage to absorb change, but withstand progress.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
14. In the long run every program becomes rococo - then rubble.
18. A program without a loop and a structured variable isn't worth writing.
103. Purely applicative languages are poorly applicable.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
12. Recursion is the root of computation since it trades description for time.
60. In seeking the unattainable, simplicity only gets in the way.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
41. Some programming languages manage to absorb change, but withstand progress.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
21. Optimization hinders evolution.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
114. Within a computer natural language is unnatural.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
31. Simplicity does not precede complexity, but follows it.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
1. One man's constant is another man's variable.
95. Don't have good ideas if you aren't willing to be responsible for them.
66. Making something variable is easy. Controlling duration of constancy is the trick.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
90. Computation has made the tree flower.
27. Once you understand how to write a program get someone else to write it.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
108. Whenever two programmers meet to criticize their programs, both are silent.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
23. To understand a program you must become both the machine and the program.
63. When we write programs that "learn", it turns out that we do and they don't.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
47. As Will Rogers would have said, "There is no such thing as a free variable."
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
1. One man's constant is another man's variable.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
1. One man's constant is another man's variable.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
72. An adequate bootstrap is a contradiction in terms.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
100. We will never run out of things to program as long as there is a single program around.
66. Making something variable is easy. Controlling duration of constancy is the trick.
40. There are two ways to write error-free programs; only the third one works.
66. Making something variable is easy. Controlling duration of constancy is the trick.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
110. Editing is a rewording activity.
103. Purely applicative languages are poorly applicable.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
104. The proof of a system's value is its existence.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
105. You can't communicate complexity, only an awareness of it.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
17. If a listener nods his head when you're explaining your program, wake him up.
102. One can't proceed from the informal to the formal by formal means.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
31. Simplicity does not precede complexity, but follows it.
115. Most people find the concept of programming obvious, but the doing impossible.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
111. Why did the Roman Empire collapse? What is Latin for office automation?
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
102. One can't proceed from the informal to the formal by formal means.
78. If your computer speaks English, it was probably made in Japan.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
27. Once you understand how to write a program get someone else to write it.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
60. In seeking the unattainable, simplicity only gets in the way.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
23. To understand a program you must become both the machine and the program.
62. In computing, invariants are ephemeral.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
17. If a listener nods his head when you're explaining your program, wake him up.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
100. We will never run out of things to program as long as there is a single program around.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
46. Like punning, programming is a play on words.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
22. A good system can't have a weak command language.
7. It is easier to write an incorrect program than understand a correct one.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
38. Structured Programming supports the law of the excluded middle.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
46. Like punning, programming is a play on words.
31. Simplicity does not precede complexity, but follows it.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
108. Whenever two programmers meet to criticize their programs, both are silent.
31. Simplicity does not precede complexity, but follows it.
104. The proof of a system's value is its existence.
90. Computation has made the tree flower.
112. Computer Science is embarrassed by the computer.
15. Everything should be built top-down, except the first time.
38. Structured Programming supports the law of the excluded middle.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
8. A programming language is low level when its programs require attention to the irrelevant.
115. Most people find the concept of programming obvious, but the doing impossible.
38. Structured Programming supports the law of the excluded middle.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
47. As Will Rogers would have said, "There is no such thing as a free variable."
17. If a listener nods his head when you're explaining your program, wake him up.
72. An adequate bootstrap is a contradiction in terms.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
55. A LISP programmer knows the value of everything, but the cost of nothing.
23. To understand a program you must become both the machine and the program.
7. It is easier to write an incorrect program than understand a correct one.
112. Computer Science is embarrassed by the computer.
31. Simplicity does not precede complexity, but follows it.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
46. Like punning, programming is a play on words.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
18. A program without a loop and a structured variable isn't worth writing.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
40. There are two ways to write error-free programs; only the third one works.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
3. Syntactic sugar causes cancer of the semicolon.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
119. Programming is an unnatural act.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
31. Simplicity does not precede complexity, but follows it.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
72. An adequate bootstrap is a contradiction in terms.
90. Computation has made the tree flower.
8. A programming language is low level when its programs require attention to the irrelevant.
14. In the long run every program becomes rococo - then rubble.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
95. Don't have good ideas if you aren't willing to be responsible for them.
3. Syntactic sugar causes cancer of the semicolon.
104. The proof of a system's value is its existence.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
14. In the long run every program becomes rococo - then rubble.
57. It is easier to change the specification to fit the program than vice versa.
43. In software systems, it is often the early bird that makes the worm.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
15. Everything should be built top-down, except the first time.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
96. Computers don't introduce order anywhere as much as they expose opportunities.
61. In programming, as in everything else, to be in error is to be reborn.
43. In software systems, it is often the early bird that makes the worm.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
4. Every program is a part of some other program and rarely fits.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
57. It is easier to change the specification to fit the program than vice versa.
12. Recursion is the root of computation since it trades description for time.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
104. The proof of a system's value is its existence.
14. In the long run every program becomes rococo - then rubble.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
61. In programming, as in everything else, to be in error is to be reborn.
8. A programming language is low level when its programs require attention to the irrelevant.
111. Why did the Roman Empire collapse? What is Latin for office automation?
22. A good system can't have a weak command language.
104. The proof of a system's value is its existence.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
112. Computer Science is embarrassed by the computer.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
90. Computation has made the tree flower.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
100. We will never run out of things to program as long as there is a single program around.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
12. Recursion is the root of computation since it trades description for time.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
115. Most people find the concept of programming obvious, but the doing impossible.
14. In the long run every program becomes rococo - then rubble.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
7. It is easier to write an incorrect program than understand a correct one.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
15. Everything should be built top-down, except the first time.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
102. One can't proceed from the informal to the formal by formal means.
15. Everything should be built top-down, except the first time.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
40. There are two ways to write error-free programs; only the third one works.
104. The proof of a system's value is its existence.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
1. One man's constant is another man's variable.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
59. In English every word can be verbed. Would that it were so in our programming languages.
7. It is easier to write an incorrect program than understand a correct one.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
17. If a listener nods his head when you're explaining your program, wake him up.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
72. An adequate bootstrap is a contradiction in terms.
105. You can't communicate complexity, only an awareness of it.
115. Most people find the concept of programming obvious, but the doing impossible.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
115. Most people find the concept of programming obvious, but the doing impossible.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
60. In seeking the unattainable, simplicity only gets in the way.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
66. Making something variable is easy. Controlling duration of constancy is the trick.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
110. Editing is a rewording activity.
15. Everything should be built top-down, except the first time.
43. In software systems, it is often the early bird that makes the worm.
59. In English every word can be verbed. Would that it were so in our programming languages.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
27. Once you understand how to write a program get someone else to write it.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
76. It is the user who should parameterize procedures, not their creators.
59. In English every word can be verbed. Would that it were so in our programming languages.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
14. In the long run every program becomes rococo - then rubble.
76. It is the user who should parameterize procedures, not their creators.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
21. Optimization hinders evolution.
55. A LISP programmer knows the value of everything, but the cost of nothing.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
115. Most people find the concept of programming obvious, but the doing impossible.
55. A LISP programmer knows the value of everything, but the cost of nothing.
102. One can't proceed from the informal to the formal by formal means.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
47. As Will Rogers would have said, "There is no such thing as a free variable."
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
105. You can't communicate complexity, only an awareness of it.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
110. Editing is a rewording activity.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
23. To understand a program you must become both the machine and the program.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
27. Once you understand how to write a program get someone else to write it.
63. When we write programs that "learn", it turns out that we do and they don't.
111. Why did the Roman Empire collapse? What is Latin for office automation?
103. Purely applicative languages are poorly applicable.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
100. We will never run out of things to program as long as there is a single program around.
27. Once you understand how to write a program get someone else to write it.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
11. If you have a procedure with ten parameters, you probably missed some.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
90. Computation has made the tree flower.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
14. In the long run every program becomes rococo - then rubble.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
104. The proof of a system's value is its existence.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
111. Why did the Roman Empire collapse? What is Latin for office automation?
61. In programming, as in everything else, to be in error is to be reborn.
60. In seeking the unattainable, simplicity only gets in the way.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
22. A good system can't have a weak command language.
59. In English every word can be verbed. Would that it were so in our programming languages.
108. Whenever two programmers meet to criticize their programs, both are silent.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
76. It is the user who should parameterize procedures, not their creators.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
18. A program without a loop and a structured variable isn't worth writing.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
110. Editing is a rewording activity.
96. Computers don't introduce order anywhere as much as they expose opportunities.
3. Syntactic sugar causes cancer of the semicolon.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
46. Like punning, programming is a play on words.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
27. Once you understand how to write a program get someone else to write it.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
55. A LISP programmer knows the value of everything, but the cost of nothing.
57. It is easier to change the specification to fit the program than vice versa.
40. There are two ways to write error-free programs; only the third one works.
4. Every program is a part of some other program and rarely fits.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
11. If you have a procedure with ten parameters, you probably missed some.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
114. Within a computer natural language is unnatural.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
40. There are two ways to write error-free programs; only the third one works.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
103. Purely applicative languages are poorly applicable.
17. If a listener nods his head when you're explaining your program, wake him up.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
61. In programming, as in everything else, to be in error is to be reborn.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
72. An adequate bootstrap is a contradiction in terms.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
3. Syntactic sugar causes cancer of the semicolon.
72. An adequate bootstrap is a contradiction in terms.
11. If you have a procedure with ten parameters, you probably missed some.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
103. Purely applicative languages are poorly applicable.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
17. If a listener nods his head when you're explaining your program, wake him up.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
46. Like punning, programming is a play on words.
98. In computing, the mean time to failure keeps getting shorter.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
62. In computing, invariants are ephemeral.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
72. An adequate bootstrap is a contradiction in terms.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
98. In computing, the mean time to failure keeps getting shorter.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
63. When we write programs that "learn", it turns out that we do and they don't.
47. As Will Rogers would have said, "There is no such thing as a free variable."
110. Editing is a rewording activity.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
57. It is easier to change the specification to fit the program than vice versa.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
66. Making something variable is easy. Controlling duration of constancy is the trick.
104. The proof of a system's value is its existence.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
47. As Will Rogers would have said, "There is no such thing as a free variable."
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
59. In English every word can be verbed. Would that it were so in our programming languages.
78. If your computer speaks English, it was probably made in Japan.
7. It is easier to write an incorrect program than understand a correct one.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
111. Why did the Roman Empire collapse? What is Latin for office automation?
63. When we write programs that "learn", it turns out that we do and they don't.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
110. Editing is a rewording activity.
114. Within a computer natural language is unnatural.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
95. Don't have good ideas if you aren't willing to be responsible for them.
22. A good system can't have a weak command language.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
102. One can't proceed from the informal to the formal by formal means.
55. A LISP programmer knows the value of everything, but the cost of nothing.
43. In software systems, it is often the early bird that makes the worm.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
119. Programming is an unnatural act.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
12. Recursion is the root of computation since it trades description for time.
41. Some programming languages manage to absorb change, but withstand progress.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
11. If you have a procedure with ten parameters, you probably missed some.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
18. A program without a loop and a structured variable isn't worth writing.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
43. In software systems, it is often the early bird that makes the worm.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
17. If a listener nods his head when you're explaining your program, wake him up.
62. In computing, invariants are ephemeral.
111. Why did the Roman Empire collapse? What is Latin for office automation?
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
21. Optimization hinders evolution.
22. A good system can't have a weak command language.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
115. Most people find the concept of programming obvious, but the doing impossible.
15. Everything should be built top-down, except the first time.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
98. In computing, the mean time to failure keeps getting shorter.
110. Editing is a rewording activity.
63. When we write programs that "learn", it turns out that we do and they don't.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
4. Every program is a part of some other program and rarely fits.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
46. Like punning, programming is a play on words.
41. Some programming languages manage to absorb change, but withstand progress.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
110. Editing is a rewording activity.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
8. A programming language is low level when its programs require attention to the irrelevant.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
8. A programming language is low level when its programs require attention to the irrelevant.
114. Within a computer natural language is unnatural.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
59. In English every word can be verbed. Would that it were so in our programming languages.
112. Computer Science is embarrassed by the computer.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
18. A program without a loop and a structured variable isn't worth writing.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
40. There are two ways to write error-free programs; only the third one works.
110. Editing is a rewording activity.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
47. As Will Rogers would have said, "There is no such thing as a free variable."
59. In English every word can be verbed. Would that it were so in our programming languages.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
61. In programming, as in everything else, to be in error is to be reborn.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
111. Why did the Roman Empire collapse? What is Latin for office automation?
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
108. Whenever two programmers meet to criticize their programs, both are silent.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
7. It is easier to write an incorrect program than understand a correct one.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
46. Like punning, programming is a play on words.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
15. Everything should be built top-down, except the first time.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
66. Making something variable is easy. Controlling duration of constancy is the trick.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
47. As Will Rogers would have said, "There is no such thing as a free variable."
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
90. Computation has made the tree flower.
23. To understand a program you must become both the machine and the program.
72. An adequate bootstrap is a contradiction in terms.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
7. It is easier to write an incorrect program than understand a correct one.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
21. Optimization hinders evolution.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
21. Optimization hinders evolution.
27. Once you understand how to write a program get someone else to write it.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
1. One man's constant is another man's variable.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
1. One man's constant is another man's variable.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
40. There are two ways to write error-free programs; only the third one works.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
47. As Will Rogers would have said, "There is no such thing as a free variable."
46. Like punning, programming is a play on words.
112. Computer Science is embarrassed by the computer.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
61. In programming, as in everything else, to be in error is to be reborn.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
102. One can't proceed from the informal to the formal by formal means.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
119. Programming is an unnatural act.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
3. Syntactic sugar causes cancer of the semicolon.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
95. Don't have good ideas if you aren't willing to be responsible for them.
66. Making something variable is easy. Controlling duration of constancy is the trick.
27. Once you understand how to write a program get someone else to write it.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
1. One man's constant is another man's variable.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
47. As Will Rogers would have said, "There is no such thing as a free variable."
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
103. Purely applicative languages are poorly applicable.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
112. Computer Science is embarrassed by the computer.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
41. Some programming languages manage to absorb change, but withstand progress.
62. In computing, invariants are ephemeral.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
60. In seeking the unattainable, simplicity only gets in the way.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
103. Purely applicative languages are poorly applicable.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
8. A programming language is low level when its programs require attention to the irrelevant.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
43. In software systems, it is often the early bird that makes the worm.
12. Recursion is the root of computation since it trades description for time.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
111. Why did the Roman Empire collapse? What is Latin for office automation?
31. Simplicity does not precede complexity, but follows it.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
46. Like punning, programming is a play on words.
18. A program without a loop and a structured variable isn't worth writing.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
15. Everything should be built top-down, except the first time.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
1. One man's constant is another man's variable.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
96. Computers don't introduce order anywhere as much as they expose opportunities.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
47. As Will Rogers would have said, "There is no such thing as a free variable."
98. In computing, the mean time to failure keeps getting shorter.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
14. In the long run every program becomes rococo - then rubble.
98. In computing, the mean time to failure keeps getting shorter.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
7. It is easier to write an incorrect program than understand a correct one.
98. In computing, the mean time to failure keeps getting shorter.
23. To understand a program you must become both the machine and the program.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
76. It is the user who should parameterize procedures, not their creators.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
14. In the long run every program becomes rococo - then rubble.
46. Like punning, programming is a play on words.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
23. To understand a program you must become both the machine and the program.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
17. If a listener nods his head when you're explaining your program, wake him up.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
78. If your computer speaks English, it was probably made in Japan.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
8. A programming language is low level when its programs require attention to the irrelevant.
7. It is easier to write an incorrect program than understand a correct one.
114. Within a computer natural language is unnatural.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
11. If you have a procedure with ten parameters, you probably missed some.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
72. An adequate bootstrap is a contradiction in terms.
115. Most people find the concept of programming obvious, but the doing impossible.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
62. In computing, invariants are ephemeral.
15. Everything should be built top-down, except the first time.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
103. Purely applicative languages are poorly applicable.
61. In programming, as in everything else, to be in error is to be reborn.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
66. Making something variable is easy. Controlling duration of constancy is the trick.
108. Whenever two programmers meet to criticize their programs, both are silent.
1. One man's constant is another man's variable.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
100. We will never run out of things to program as long as there is a single program around.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
112. Computer Science is embarrassed by the computer.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
4. Every program is a part of some other program and rarely fits.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
63. When we write programs that "learn", it turns out that we do and they don't.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
104. The proof of a system's value is its existence.
47. As Will Rogers would have said, "There is no such thing as a free variable."
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
98. In computing, the mean time to failure keeps getting shorter.
79. A year spent in artificial intelligence is enough to make one believe in God.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
95. Don't have good ideas if you aren't willing to be responsible for them.
95. Don't have good ideas if you aren't willing to be responsible for them.
115. Most people find the concept of programming obvious, but the doing impossible.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
76. It is the user who should parameterize procedures, not their creators.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
79. A year spent in artificial intelligence is enough to make one believe in God.
46. Like punning, programming is a play on words.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
96. Computers don't introduce order anywhere as much as they expose opportunities.
23. To understand a program you must become both the machine and the program.
79. A year spent in artificial intelligence is enough to make one believe in God.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
100. We will never run out of things to program as long as there is a single program around.
98. In computing, the mean time to failure keeps getting shorter.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
18. A program without a loop and a structured variable isn't worth writing.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
78. If your computer speaks English, it was probably made in Japan.
23. To understand a program you must become both the machine and the program.
63. When we write programs that "learn", it turns out that we do and they don't.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
55. A LISP programmer knows the value of everything, but the cost of nothing.
96. Computers don't introduce order anywhere as much as they expose opportunities.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
4. Every program is a part of some other program and rarely fits.
41. Some programming languages manage to absorb change, but withstand progress.
15. Everything should be built top-down, except the first time.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
103. Purely applicative languages are poorly applicable.
47. As Will Rogers would have said, "There is no such thing as a free variable."
105. You can't communicate complexity, only an awareness of it.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
15. Everything should be built top-down, except the first time.
11. If you have a procedure with ten parameters, you probably missed some.
40. There are two ways to write error-free programs; only the third one works.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
112. Computer Science is embarrassed by the computer.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
119. Programming is an unnatural act.
7. It is easier to write an incorrect program than understand a correct one.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
55. A LISP programmer knows the value of everything, but the cost of nothing.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
27. Once you understand how to write a program get someone else to write it.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
38. Structured Programming supports the law of the excluded middle.
21. Optimization hinders evolution.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
57. It is easier to change the specification to fit the program than vice versa.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
14. In the long run every program becomes rococo - then rubble.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
31. Simplicity does not precede complexity, but follows it.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
100. We will never run out of things to program as long as there is a single program around.
102. One can't proceed from the informal to the formal by formal means.
62. In computing, invariants are ephemeral.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
95. Don't have good ideas if you aren't willing to be responsible for them.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
98. In computing, the mean time to failure keeps getting shorter.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
90. Computation has made the tree flower.
55. A LISP programmer knows the value of everything, but the cost of nothing.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
112. Computer Science is embarrassed by the computer.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
63. When we write programs that "learn", it turns out that we do and they don't.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
72. An adequate bootstrap is a contradiction in terms.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
110. Editing is a rewording activity.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
22. A good system can't have a weak command language.
66. Making something variable is easy. Controlling duration of constancy is the trick.
115. Most people find the concept of programming obvious, but the doing impossible.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
104. The proof of a system's value is its existence.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
60. In seeking the unattainable, simplicity only gets in the way.
1. One man's constant is another man's variable.
66. Making something variable is easy. Controlling duration of constancy is the trick.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
23. To understand a program you must become both the machine and the program.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
3. Syntactic sugar causes cancer of the semicolon.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
41. Some programming languages manage to absorb change, but withstand progress.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
62. In computing, invariants are ephemeral.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
11. If you have a procedure with ten parameters, you probably missed some.
63. When we write programs that "learn", it turns out that we do and they don't.
47. As Will Rogers would have said, "There is no such thing as a free variable."
8. A programming language is low level when its programs require attention to the irrelevant.
46. Like punning, programming is a play on words.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
27. Once you understand how to write a program get someone else to write it.
98. In computing, the mean time to failure keeps getting shorter.
115. Most people find the concept of programming obvious, but the doing impossible.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
114. Within a computer natural language is unnatural.
60. In seeking the unattainable, simplicity only gets in the way.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
46. Like punning, programming is a play on words.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
3. Syntactic sugar causes cancer of the semicolon.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
103. Purely applicative languages are poorly applicable.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
27. Once you understand how to write a program get someone else to write it.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
76. It is the user who should parameterize procedures, not their creators.
21. Optimization hinders evolution.
18. A program without a loop and a structured variable isn't worth writing.
61. In programming, as in everything else, to be in error is to be reborn.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
59. In English every word can be verbed. Would that it were so in our programming languages.
27. Once you understand how to write a program get someone else to write it.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
17. If a listener nods his head when you're explaining your program, wake him up.
96. Computers don't introduce order anywhere as much as they expose opportunities.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
1. One man's constant is another man's variable.
46. Like punning, programming is a play on words.
60. In seeking the unattainable, simplicity only gets in the way.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
38. Structured Programming supports the law of the excluded middle.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
96. Computers don't introduce order anywhere as much as they expose opportunities.
41. Some programming languages manage to absorb change, but withstand progress.
23. To understand a program you must become both the machine and the program.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
98. In computing, the mean time to failure keeps getting shorter.
12. Recursion is the root of computation since it trades description for time.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
17. If a listener nods his head when you're explaining your program, wake him up.
115. Most people find the concept of programming obvious, but the doing impossible.
15. Everything should be built top-down, except the first time.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
3. Syntactic sugar causes cancer of the semicolon.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
98. In computing, the mean time to failure keeps getting shorter.
12. Recursion is the root of computation since it trades description for time.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
41. Some programming languages manage to absorb change, but withstand progress.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
5. If a program manipulates a large amount of data, it does so in a small number of ways.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
95. Don't have good ideas if you aren't willing to be responsible for them.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
27. Once you understand how to write a program get someone else to write it.
62. In computing, invariants are ephemeral.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
112. Computer Science is embarrassed by the computer.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
104. The proof of a system's value is its existence.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
103. Purely applicative languages are poorly applicable.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
66. Making something variable is easy. Controlling duration of constancy is the trick.
43. In software systems, it is often the early bird that makes the worm.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
21. Optimization hinders evolution.
62. In computing, invariants are ephemeral.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
8. A programming language is low level when its programs require attention to the irrelevant.
18. A program without a loop and a structured variable isn't worth writing.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
31. Simplicity does not precede complexity, but follows it.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
23. To understand a program you must become both the machine and the program.
8. A programming language is low level when its programs require attention to the irrelevant.
14. In the long run every program becomes rococo - then rubble.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
115. Most people find the concept of programming obvious, but the doing impossible.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
90. Computation has made the tree flower.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
46. Like punning, programming is a play on words.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
21. Optimization hinders evolution.
11. If you have a procedure with ten parameters, you probably missed some.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
90. Computation has made the tree flower.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
114. Within a computer natural language is unnatural.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
78. If your computer speaks English, it was probably made in Japan.
98. In computing, the mean time to failure keeps getting shorter.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
79. A year spent in artificial intelligence is enough to make one believe in God.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
107. The debate rages on: is PL/I Bachtrian or Dromedary?
8. A programming language is low level when its programs require attention to the irrelevant.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
104. The proof of a system's value is its existence.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
12. Recursion is the root of computation since it trades description for time.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
21. Optimization hinders evolution.
47. As Will Rogers would have said, "There is no such thing as a free variable."
76. It is the user who should parameterize procedures, not their creators.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
14. In the long run every program becomes rococo - then rubble.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
110. Editing is a rewording activity.
96. Computers don't introduce order anywhere as much as they expose opportunities.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
90. Computation has made the tree flower.
7. It is easier to write an incorrect program than understand a correct one.
40. There are two ways to write error-free programs; only the third one works.
104. The proof of a system's value is its existence.
22. A good system can't have a weak command language.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
62. In computing, invariants are ephemeral.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
18. A program without a loop and a structured variable isn't worth writing.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
18. A program without a loop and a structured variable isn't worth writing.
110. Editing is a rewording activity.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
100. We will never run out of things to program as long as there is a single program around.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
17. If a listener nods his head when you're explaining your program, wake him up.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
38. Structured Programming supports the law of the excluded middle.
14. In the long run every program becomes rococo - then rubble.
18. A program without a loop and a structured variable isn't worth writing.
104. The proof of a system's value is its existence.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
60. In seeking the unattainable, simplicity only gets in the way.
31. Simplicity does not precede complexity, but follows it.
18. A program without a loop and a structured variable isn't worth writing.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
96. Computers don't introduce order anywhere as much as they expose opportunities.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
66. Making something variable is easy. Controlling duration of constancy is the trick.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
43. In software systems, it is often the early bird that makes the worm.
47. As Will Rogers would have said, "There is no such thing as a free variable."
98. In computing, the mean time to failure keeps getting shorter.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
18. A program without a loop and a structured variable isn't worth writing.
72. An adequate bootstrap is a contradiction in terms.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
105. You can't communicate complexity, only an awareness of it.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
57. It is easier to change the specification to fit the program than vice versa.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
41. Some programming languages manage to absorb change, but withstand progress.
66. Making something variable is easy. Controlling duration of constancy is the trick.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
8. A programming language is low level when its programs require attention to the irrelevant.
18. A program without a loop and a structured variable isn't worth writing.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
119. Programming is an unnatural act.
98. In computing, the mean time to failure keeps getting shorter.
95. Don't have good ideas if you aren't willing to be responsible for them.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
90. Computation has made the tree flower.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
102. One can't proceed from the informal to the formal by formal means.
38. Structured Programming supports the law of the excluded middle.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
40. There are two ways to write error-free programs; only the third one works.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
78. If your computer speaks English, it was probably made in Japan.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
119. Programming is an unnatural act.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
79. A year spent in artificial intelligence is enough to make one believe in God.
59. In English every word can be verbed. Would that it were so in our programming languages.
61. In programming, as in everything else, to be in error is to be reborn.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
59. In English every word can be verbed. Would that it were so in our programming languages.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
46. Like punning, programming is a play on words.
61. In programming, as in everything else, to be in error is to be reborn.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
110. Editing is a rewording activity.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
11. If you have a procedure with ten parameters, you probably missed some.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
63. When we write programs that "learn", it turns out that we do and they don't.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
90. Computation has made the tree flower.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
22. A good system can't have a weak command language.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
95. Don't have good ideas if you aren't willing to be responsible for them.
63. When we write programs that "learn", it turns out that we do and they don't.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
63. When we write programs that "learn", it turns out that we do and they don't.
108. Whenever two programmers meet to criticize their programs, both are silent.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
27. Once you understand how to write a program get someone else to write it.
119. Programming is an unnatural act.
61. In programming, as in everything else, to be in error is to be reborn.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
55. A LISP programmer knows the value of everything, but the cost of nothing.
4. Every program is a part of some other program and rarely fits.
1. One man's constant is another man's variable.
46. Like punning, programming is a play on words.
114. Within a computer natural language is unnatural.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
108. Whenever two programmers meet to criticize their programs, both are silent.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
79. A year spent in artificial intelligence is enough to make one believe in God.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
14. In the long run every program becomes rococo - then rubble.
112. Computer Science is embarrassed by the computer.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
21. Optimization hinders evolution.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
38. Structured Programming supports the law of the excluded middle.
78. If your computer speaks English, it was probably made in Japan.
40. There are two ways to write error-free programs; only the third one works.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
102. One can't proceed from the informal to the formal by formal means.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
18. A program without a loop and a structured variable isn't worth writing.
40. There are two ways to write error-free programs; only the third one works.
15. Everything should be built top-down, except the first time.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
31. Simplicity does not precede complexity, but follows it.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
17. If a listener nods his head when you're explaining your program, wake him up.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
46. Like punning, programming is a play on words.
60. In seeking the unattainable, simplicity only gets in the way.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
107. The debate rages on: is PL/I Bachtrian or Dromedary?
95. Don't have good ideas if you aren't willing to be responsible for them.
14. In the long run every program becomes rococo - then rubble.
21. Optimization hinders evolution.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
1. One man's constant is another man's variable.
40. There are two ways to write error-free programs; only the third one works.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
102. One can't proceed from the informal to the formal by formal means.
40. There are two ways to write error-free programs; only the third one works.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
72. An adequate bootstrap is a contradiction in terms.
8. A programming language is low level when its programs require attention to the irrelevant.
14. In the long run every program becomes rococo - then rubble.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
18. A program without a loop and a structured variable isn't worth writing.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
22. A good system can't have a weak command language.
27. Once you understand how to write a program get someone else to write it.
95. Don't have good ideas if you aren't willing to be responsible for them.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
3. Syntactic sugar causes cancer of the semicolon.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
15. Everything should be built top-down, except the first time.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
7. It is easier to write an incorrect program than understand a correct one.
66. Making something variable is easy. Controlling duration of constancy is the trick.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
15. Everything should be built top-down, except the first time.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
8. A programming language is low level when its programs require attention to the irrelevant.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
40. There are two ways to write error-free programs; only the third one works.
76. It is the user who should parameterize procedures, not their creators.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
76. It is the user who should parameterize procedures, not their creators.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
46. Like punning, programming is a play on words.
27. Once you understand how to write a program get someone else to write it.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
114. Within a computer natural language is unnatural.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
46. Like punning, programming is a play on words.
112. Computer Science is embarrassed by the computer.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
46. Like punning, programming is a play on words.
105. You can't communicate complexity, only an awareness of it.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
46. Like punning, programming is a play on words.
12. Recursion is the root of computation since it trades description for time.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
47. As Will Rogers would have said, "There is no such thing as a free variable."
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
21. Optimization hinders evolution.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
3. Syntactic sugar causes cancer of the semicolon.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
105. You can't communicate complexity, only an awareness of it.
115. Most people find the concept of programming obvious, but the doing impossible.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
38. Structured Programming supports the law of the excluded middle.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
40. There are two ways to write error-free programs; only the third one works.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
79. A year spent in artificial intelligence is enough to make one believe in God.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
38. Structured Programming supports the law of the excluded middle.
96. Computers don't introduce order anywhere as much as they expose opportunities.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
8. A programming language is low level when its programs require attention to the irrelevant.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
63. When we write programs that "learn", it turns out that we do and they don't.
55. A LISP programmer knows the value of everything, but the cost of nothing.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
38. Structured Programming supports the law of the excluded middle.
108. Whenever two programmers meet to criticize their programs, both are silent.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
103. Purely applicative languages are poorly applicable.
108. Whenever two programmers meet to criticize their programs, both are silent.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
90. Computation has made the tree flower.
14. In the long run every program becomes rococo - then rubble.
21. Optimization hinders evolution.
78. If your computer speaks English, it was probably made in Japan.
90. Computation has made the tree flower.
60. In seeking the unattainable, simplicity only gets in the way.
8. A programming language is low level when its programs require attention to the irrelevant.
11. If you have a procedure with ten parameters, you probably missed some.
18. A program without a loop and a structured variable isn't worth writing.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
40. There are two ways to write error-free programs; only the third one works.
3. Syntactic sugar causes cancer of the semicolon.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
112. Computer Science is embarrassed by the computer.
108. Whenever two programmers meet to criticize their programs, both are silent.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
111. Why did the Roman Empire collapse? What is Latin for office automation?
23. To understand a program you must become both the machine and the program.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
40. There are two ways to write error-free programs; only the third one works.
55. A LISP programmer knows the value of everything, but the cost of nothing.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
96. Computers don't introduce order anywhere as much as they expose opportunities.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
41. Some programming languages manage to absorb change, but withstand progress.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
59. In English every word can be verbed. Would that it were so in our programming languages.
79. A year spent in artificial intelligence is enough to make one believe in God.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
62. In computing, invariants are ephemeral.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
115. Most people find the concept of programming obvious, but the doing impossible.
98. In computing, the mean time to failure keeps getting shorter.
100. We will never run out of things to program as long as there is a single program around.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
1. One man's constant is another man's variable.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
3. Syntactic sugar causes cancer of the semicolon.
111. Why did the Roman Empire collapse? What is Latin for office automation?
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
12. Recursion is the root of computation since it trades description for time.
60. In seeking the unattainable, simplicity only gets in the way.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
12. Recursion is the root of computation since it trades description for time.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
3. Syntactic sugar causes cancer of the semicolon.
57. It is easier to change the specification to fit the program than vice versa.
72. An adequate bootstrap is a contradiction in terms.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
17. If a listener nods his head when you're explaining your program, wake him up.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
17. If a listener nods his head when you're explaining your program, wake him up.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
98. In computing, the mean time to failure keeps getting shorter.
63. When we write programs that "learn", it turns out that we do and they don't.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
8. A programming language is low level when its programs require attention to the irrelevant.
114. Within a computer natural language is unnatural.
72. An adequate bootstrap is a contradiction in terms.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
104. The proof of a system's value is its existence.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
115. Most people find the concept of programming obvious, but the doing impossible.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
1. One man's constant is another man's variable.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
12. Recursion is the root of computation since it trades description for time.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
110. Editing is a rewording activity.
72. An adequate bootstrap is a contradiction in terms.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
12. Recursion is the root of computation since it trades description for time.
66. Making something variable is easy. Controlling duration of constancy is the trick.
18. A program without a loop and a structured variable isn't worth writing.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
78. If your computer speaks English, it was probably made in Japan.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
79. A year spent in artificial intelligence is enough to make one believe in God.
1. One man's constant is another man's variable.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
12. Recursion is the root of computation since it trades description for time.
14. In the long run every program becomes rococo - then rubble.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
11. If you have a procedure with ten parameters, you probably missed some.
110. Editing is a rewording activity.
41. Some programming languages manage to absorb change, but withstand progress.
12. Recursion is the root of computation since it trades description for time.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
103. Purely applicative languages are poorly applicable.
61. In programming, as in everything else, to be in error is to be reborn.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
96. Computers don't introduce order anywhere as much as they expose opportunities.
12. Recursion is the root of computation since it trades description for time.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
12. Recursion is the root of computation since it trades description for time.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
38. Structured Programming supports the law of the excluded middle.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
112. Computer Science is embarrassed by the computer.
21. Optimization hinders evolution.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
46. Like punning, programming is a play on words.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
60. In seeking the unattainable, simplicity only gets in the way.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
63. When we write programs that "learn", it turns out that we do and they don't.
8. A programming language is low level when its programs require attention to the irrelevant.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
3. Syntactic sugar causes cancer of the semicolon.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
4. Every program is a part of some other program and rarely fits.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
40. There are two ways to write error-free programs; only the third one works.
103. Purely applicative languages are poorly applicable.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
100. We will never run out of things to program as long as there is a single program around.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
62. In computing, invariants are ephemeral.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
43. In software systems, it is often the early bird that makes the worm.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
1. One man's constant is another man's variable.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
43. In software systems, it is often the early bird that makes the worm.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
38. Structured Programming supports the law of the excluded middle.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
22. A good system can't have a weak command language.
40. There are two ways to write error-free programs; only the third one works.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
47. As Will Rogers would have said, "There is no such thing as a free variable."
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
103. Purely applicative languages are poorly applicable.
105. You can't communicate complexity, only an awareness of it.
8. A programming language is low level when its programs require attention to the irrelevant.
114. Within a computer natural language is unnatural.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
105. You can't communicate complexity, only an awareness of it.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
38. Structured Programming supports the law of the excluded middle.
38. Structured Programming supports the law of the excluded middle.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
55. A LISP programmer knows the value of everything, but the cost of nothing.
55. A LISP programmer knows the value of everything, but the cost of nothing.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
96. Computers don't introduce order anywhere as much as they expose opportunities.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
115. Most people find the concept of programming obvious, but the doing impossible.
108. Whenever two programmers meet to criticize their programs, both are silent.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
4. Every program is a part of some other program and rarely fits.
41. Some programming languages manage to absorb change, but withstand progress.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
61. In programming, as in everything else, to be in error is to be reborn.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
66. Making something variable is easy. Controlling duration of constancy is the trick.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
55. A LISP programmer knows the value of everything, but the cost of nothing.
62. In computing, invariants are ephemeral.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
72. An adequate bootstrap is a contradiction in terms.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
12. Recursion is the root of computation since it trades description for time.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
55. A LISP programmer knows the value of everything, but the cost of nothing.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
95. Don't have good ideas if you aren't willing to be responsible for them.
78. If your computer speaks English, it was probably made in Japan.
43. In software systems, it is often the early bird that makes the worm.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
1. One man's constant is another man's variable.
102. One can't proceed from the informal to the formal by formal means.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
8. A programming language is low level when its programs require attention to the irrelevant.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
100. We will never run out of things to program as long as there is a single program around.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
79. A year spent in artificial intelligence is enough to make one believe in God.
3. Syntactic sugar causes cancer of the semicolon.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
103. Purely applicative languages are poorly applicable.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
11. If you have a procedure with ten parameters, you probably missed some.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
15. Everything should be built top-down, except the first time.
41. Some programming languages manage to absorb change, but withstand progress.
38. Structured Programming supports the law of the excluded middle.
40. There are two ways to write error-free programs; only the third one works.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
105. You can't communicate complexity, only an awareness of it.
95. Don't have good ideas if you aren't willing to be responsible for them.
61. In programming, as in everything else, to be in error is to be reborn.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
23. To understand a program you must become both the machine and the program.
40. There are two ways to write error-free programs; only the third one works.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
43. In software systems, it is often the early bird that makes the worm.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
76. It is the user who should parameterize procedures, not their creators.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
41. Some programming languages manage to absorb change, but withstand progress.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
7. It is easier to write an incorrect program than understand a correct one.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
66. Making something variable is easy. Controlling duration of constancy is the trick.
14. In the long run every program becomes rococo - then rubble.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
59. In English every word can be verbed. Would that it were so in our programming languages.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
79. A year spent in artificial intelligence is enough to make one believe in God.
115. Most people find the concept of programming obvious, but the doing impossible.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
110. Editing is a rewording activity.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
18. A program without a loop and a structured variable isn't worth writing.
27. Once you understand how to write a program get someone else to write it.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
108. Whenever two programmers meet to criticize their programs, both are silent.
102. One can't proceed from the informal to the formal by formal means.
11. If you have a procedure with ten parameters, you probably missed some.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
22. A good system can't have a weak command language.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
60. In seeking the unattainable, simplicity only gets in the way.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
62. In computing, invariants are ephemeral.
27. Once you understand how to write a program get someone else to write it.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
31. Simplicity does not precede complexity, but follows it.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
72. An adequate bootstrap is a contradiction in terms.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
47. As Will Rogers would have said, "There is no such thing as a free variable."
41. Some programming languages manage to absorb change, but withstand progress.
7. It is easier to write an incorrect program than understand a correct one.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
43. In software systems, it is often the early bird that makes the worm.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
5. If a program manipulates a large amount of data, it does so in a small number of ways.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
103. Purely applicative languages are poorly applicable.
14. In the long run every program becomes rococo - then rubble.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
7. It is easier to write an incorrect program than understand a correct one.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
12. Recursion is the root of computation since it trades description for time.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
1. One man's constant is another man's variable.
114. Within a computer natural language is unnatural.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
27. Once you understand how to write a program get someone else to write it.
59. In English every word can be verbed. Would that it were so in our programming languages.
31. Simplicity does not precede complexity, but follows it.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
40. There are two ways to write error-free programs; only the third one works.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
60. In seeking the unattainable, simplicity only gets in the way.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
66. Making something variable is easy. Controlling duration of constancy is the trick.
3. Syntactic sugar causes cancer of the semicolon.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
46. Like punning, programming is a play on words.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
110. Editing is a rewording activity.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
1. One man's constant is another man's variable.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
79. A year spent in artificial intelligence is enough to make one believe in God.
55. A LISP programmer knows the value of everything, but the cost of nothing.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
114. Within a computer natural language is unnatural.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
79. A year spent in artificial intelligence is enough to make one believe in God.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
63. When we write programs that "learn", it turns out that we do and they don't.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
15. Everything should be built top-down, except the first time.
78. If your computer speaks English, it was probably made in Japan.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
4. Every program is a part of some other program and rarely fits.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
18. A program without a loop and a structured variable isn't worth writing.
14. In the long run every program becomes rococo - then rubble.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
119. Programming is an unnatural act.
100. We will never run out of things to program as long as there is a single program around.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
57. It is easier to change the specification to fit the program than vice versa.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
90. Computation has made the tree flower.
41. Some programming languages manage to absorb change, but withstand progress.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
108. Whenever two programmers meet to criticize their programs, both are silent.
23. To understand a program you must become both the machine and the program.
40. There are two ways to write error-free programs; only the third one works.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
4. Every program is a part of some other program and rarely fits.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
102. One can't proceed from the informal to the formal by formal means.
95. Don't have good ideas if you aren't willing to be responsible for them.
8. A programming language is low level when its programs require attention to the irrelevant.
22. A good system can't have a weak command language.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
95. Don't have good ideas if you aren't willing to be responsible for them.
95. Don't have good ideas if you aren't willing to be responsible for them.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
18. A program without a loop and a structured variable isn't worth writing.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
59. In English every word can be verbed. Would that it were so in our programming languages.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
19. A language that doesn't affect the way you think about programming, is not worth knowing.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
14. In the long run every program becomes rococo - then rubble.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
21. Optimization hinders evolution.
15. Everything should be built top-down, except the first time.
60. In seeking the unattainable, simplicity only gets in the way.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
112. Computer Science is embarrassed by the computer.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
59. In English every word can be verbed. Would that it were so in our programming languages.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
76. It is the user who should parameterize procedures, not their creators.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
79. A year spent in artificial intelligence is enough to make one believe in God.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
72. An adequate bootstrap is a contradiction in terms.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
79. A year spent in artificial intelligence is enough to make one believe in God.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
76. It is the user who should parameterize procedures, not their creators.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
79. A year spent in artificial intelligence is enough to make one believe in God.
66. Making something variable is easy. Controlling duration of constancy is the trick.
96. Computers don't introduce order anywhere as much as they expose opportunities.
43. In software systems, it is often the early bird that makes the worm.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
100. We will never run out of things to program as long as there is a single program around.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
95. Don't have good ideas if you aren't willing to be responsible for them.
55. A LISP programmer knows the value of everything, but the cost of nothing.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
111. Why did the Roman Empire collapse? What is Latin for office automation?
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
15. Everything should be built top-down, except the first time.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
104. The proof of a system's value is its existence.
57. It is easier to change the specification to fit the program than vice versa.
21. Optimization hinders evolution.
79. A year spent in artificial intelligence is enough to make one believe in God.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
18. A program without a loop and a structured variable isn't worth writing.
108. Whenever two programmers meet to criticize their programs, both are silent.
17. If a listener nods his head when you're explaining your program, wake him up.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
115. Most people find the concept of programming obvious, but the doing impossible.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
108. Whenever two programmers meet to criticize their programs, both are silent.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
3. Syntactic sugar causes cancer of the semicolon.
61. In programming, as in everything else, to be in error is to be reborn.
7. It is easier to write an incorrect program than understand a correct one.
27. Once you understand how to write a program get someone else to write it.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
95. Don't have good ideas if you aren't willing to be responsible for them.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
105. You can't communicate complexity, only an awareness of it.
59. In English every word can be verbed. Would that it were so in our programming languages.
103. Purely applicative languages are poorly applicable.
7. It is easier to write an incorrect program than understand a correct one.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
47. As Will Rogers would have said, "There is no such thing as a free variable."
5. If a program manipulates a large amount of data, it does so in a small number of ways.
110. Editing is a rewording activity.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
98. In computing, the mean time to failure keeps getting shorter.
23. To understand a program you must become both the machine and the program.
102. One can't proceed from the informal to the formal by formal means.
22. A good system can't have a weak command language.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
108. Whenever two programmers meet to criticize their programs, both are silent.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
41. Some programming languages manage to absorb change, but withstand progress.
61. In programming, as in everything else, to be in error is to be reborn.
63. When we write programs that "learn", it turns out that we do and they don't.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
111. Why did the Roman Empire collapse? What is Latin for office automation?
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
23. To understand a program you must become both the machine and the program.
115. Most people find the concept of programming obvious, but the doing impossible.
57. It is easier to change the specification to fit the program than vice versa.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
55. A LISP programmer knows the value of everything, but the cost of nothing.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
23. To understand a program you must become both the machine and the program.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
3. Syntactic sugar causes cancer of the semicolon.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
96. Computers don't introduce order anywhere as much as they expose opportunities.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
40. There are two ways to write error-free programs; only the third one works.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
60. In seeking the unattainable, simplicity only gets in the way.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
5. If a program manipulates a large amount of data, it does so in a small number of ways.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
76. It is the user who should parameterize procedures, not their creators.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
76. It is the user who should parameterize procedures, not their creators.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
60. In seeking the unattainable, simplicity only gets in the way.
110. Editing is a rewording activity.
111. Why did the Roman Empire collapse? What is Latin for office automation?
59. In English every word can be verbed. Would that it were so in our programming languages.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
110. Editing is a rewording activity.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
11. If you have a procedure with ten parameters, you probably missed some.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
104. The proof of a system's value is its existence.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
79. A year spent in artificial intelligence is enough to make one believe in God.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
105. You can't communicate complexity, only an awareness of it.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
105. You can't communicate complexity, only an awareness of it.
100. We will never run out of things to program as long as there is a single program around.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
14. In the long run every program becomes rococo - then rubble.
8. A programming language is low level when its programs require attention to the irrelevant.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
7. It is easier to write an incorrect program than understand a correct one.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
98. In computing, the mean time to failure keeps getting shorter.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
108. Whenever two programmers meet to criticize their programs, both are silent.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
57. It is easier to change the specification to fit the program than vice versa.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
100. We will never run out of things to program as long as there is a single program around.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
55. A LISP programmer knows the value of everything, but the cost of nothing.
47. As Will Rogers would have said, "There is no such thing as a free variable."
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
18. A program without a loop and a structured variable isn't worth writing.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
15. Everything should be built top-down, except the first time.
40. There are two ways to write error-free programs; only the third one works.
76. It is the user who should parameterize procedures, not their creators.
47. As Will Rogers would have said, "There is no such thing as a free variable."
119. Programming is an unnatural act.
112. Computer Science is embarrassed by the computer.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
60. In seeking the unattainable, simplicity only gets in the way.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
60. In seeking the unattainable, simplicity only gets in the way.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
105. You can't communicate complexity, only an awareness of it.
60. In seeking the unattainable, simplicity only gets in the way.
102. One can't proceed from the informal to the formal by formal means.
112. Computer Science is embarrassed by the computer.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
4. Every program is a part of some other program and rarely fits.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
98. In computing, the mean time to failure keeps getting shorter.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
8. A programming language is low level when its programs require attention to the irrelevant.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
55. A LISP programmer knows the value of everything, but the cost of nothing.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
60. In seeking the unattainable, simplicity only gets in the way.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
100. We will never run out of things to program as long as there is a single program around.
119. Programming is an unnatural act.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
3. Syntactic sugar causes cancer of the semicolon.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
27. Once you understand how to write a program get someone else to write it.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
76. It is the user who should parameterize procedures, not their creators.
115. Most people find the concept of programming obvious, but the doing impossible.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
4. Every program is a part of some other program and rarely fits.
15. Everything should be built top-down, except the first time.
79. A year spent in artificial intelligence is enough to make one believe in God.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
72. An adequate bootstrap is a contradiction in terms.
22. A good system can't have a weak command language.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
40. There are two ways to write error-free programs; only the third one works.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
11. If you have a procedure with ten parameters, you probably missed some.
3. Syntactic sugar causes cancer of the semicolon.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
23. To understand a program you must become both the machine and the program.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
55. A LISP programmer knows the value of everything, but the cost of nothing.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
14. In the long run every program becomes rococo - then rubble.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
8. A programming language is low level when its programs require attention to the irrelevant.
110. Editing is a rewording activity.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
112. Computer Science is embarrassed by the computer.
63. When we write programs that "learn", it turns out that we do and they don't.
95. Don't have good ideas if you aren't willing to be responsible for them.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
112. Computer Science is embarrassed by the computer.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
22. A good system can't have a weak command language.
114. Within a computer natural language is unnatural.
55. A LISP programmer knows the value of everything, but the cost of nothing.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
62. In computing, invariants are ephemeral.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
104. The proof of a system's value is its existence.
95. Don't have good ideas if you aren't willing to be responsible for them.
40. There are two ways to write error-free programs; only the third one works.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
27. Once you understand how to write a program get someone else to write it.
112. Computer Science is embarrassed by the computer.
31. Simplicity does not precede complexity, but follows it.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
119. Programming is an unnatural act.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
21. Optimization hinders evolution.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
110. Editing is a rewording activity.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
95. Don't have good ideas if you aren't willing to be responsible for them.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
95. Don't have good ideas if you aren't willing to be responsible for them.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
112. Computer Science is embarrassed by the computer.
115. Most people find the concept of programming obvious, but the doing impossible.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
14. In the long run every program becomes rococo - then rubble.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
72. An adequate bootstrap is a contradiction in terms.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
41. Some programming languages manage to absorb change, but withstand progress.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
61. In programming, as in everything else, to be in error is to be reborn.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
66. Making something variable is easy. Controlling duration of constancy is the trick.
41. Some programming languages manage to absorb change, but withstand progress.
98. In computing, the mean time to failure keeps getting shorter.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
100. We will never run out of things to program as long as there is a single program around.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
76. It is the user who should parameterize procedures, not their creators.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
76. It is the user who should parameterize procedures, not their creators.
105. You can't communicate complexity, only an awareness of it.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
62. In computing, invariants are ephemeral.
22. A good system can't have a weak command language.
59. In English every word can be verbed. Would that it were so in our programming languages.
46. Like punning, programming is a play on words.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
107. The debate rages on: is PL/I Bachtrian or Dromedary?
43. In software systems, it is often the early bird that makes the worm.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
47. As Will Rogers would have said, "There is no such thing as a free variable."
66. Making something variable is easy. Controlling duration of constancy is the trick.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
21. Optimization hinders evolution.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
102. One can't proceed from the informal to the formal by formal means.
12. Recursion is the root of computation since it trades description for time.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
12. Recursion is the root of computation since it trades description for time.
57. It is easier to change the specification to fit the program than vice versa.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
27. Once you understand how to write a program get someone else to write it.
38. Structured Programming supports the law of the excluded middle.
104. The proof of a system's value is its existence.
110. Editing is a rewording activity.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
3. Syntactic sugar causes cancer of the semicolon.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
111. Why did the Roman Empire collapse? What is Latin for office automation?
66. Making something variable is easy. Controlling duration of constancy is the trick.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
14. In the long run every program becomes rococo - then rubble.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
15. Everything should be built top-down, except the first time.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
12. Recursion is the root of computation since it trades description for time.
14. In the long run every program becomes rococo - then rubble.
60. In seeking the unattainable, simplicity only gets in the way.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
23. To understand a program you must become both the machine and the program.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
104. The proof of a system's value is its existence.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
14. In the long run every program becomes rococo - then rubble.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
7. It is easier to write an incorrect program than understand a correct one.
119. Programming is an unnatural act.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
111. Why did the Roman Empire collapse? What is Latin for office automation?
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
72. An adequate bootstrap is a contradiction in terms.
31. Simplicity does not precede complexity, but follows it.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
47. As Will Rogers would have said, "There is no such thing as a free variable."
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
46. Like punning, programming is a play on words.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
115. Most people find the concept of programming obvious, but the doing impossible.
11. If you have a procedure with ten parameters, you probably missed some.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
119. Programming is an unnatural act.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
96. Computers don't introduce order anywhere as much as they expose opportunities.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
110. Editing is a rewording activity.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
38. Structured Programming supports the law of the excluded middle.
103. Purely applicative languages are poorly applicable.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
102. One can't proceed from the informal to the formal by formal means.
78. If your computer speaks English, it was probably made in Japan.
55. A LISP programmer knows the value of everything, but the cost of nothing.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
103. Purely applicative languages are poorly applicable.
112. Computer Science is embarrassed by the computer.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
111. Why did the Roman Empire collapse? What is Latin for office automation?
46. Like punning, programming is a play on words.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
11. If you have a procedure with ten parameters, you probably missed some.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
57. It is easier to change the specification to fit the program than vice versa.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
72. An adequate bootstrap is a contradiction in terms.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
103. Purely applicative languages are poorly applicable.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
22. A good system can't have a weak command language.
15. Everything should be built top-down, except the first time.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
63. When we write programs that "learn", it turns out that we do and they don't.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
18. A program without a loop and a structured variable isn't worth writing.
18. A program without a loop and a structured variable isn't worth writing.
61. In programming, as in everything else, to be in error is to be reborn.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
59. In English every word can be verbed. Would that it were so in our programming languages.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
21. Optimization hinders evolution.
40. There are two ways to write error-free programs; only the third one works.
1. One man's constant is another man's variable.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
110. Editing is a rewording activity.
63. When we write programs that "learn", it turns out that we do and they don't.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
110. Editing is a rewording activity.
3. Syntactic sugar causes cancer of the semicolon.
43. In software systems, it is often the early bird that makes the worm.
47. As Will Rogers would have said, "There is no such thing as a free variable."
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
100. We will never run out of things to program as long as there is a single program around.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
79. A year spent in artificial intelligence is enough to make one believe in God.
104. The proof of a system's value is its existence.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
47. As Will Rogers would have said, "There is no such thing as a free variable."
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
72. An adequate bootstrap is a contradiction in terms.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
21. Optimization hinders evolution.
8. A programming language is low level when its programs require attention to the irrelevant.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
90. Computation has made the tree flower.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
96. Computers don't introduce order anywhere as much as they expose opportunities.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
3. Syntactic sugar causes cancer of the semicolon.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
108. Whenever two programmers meet to criticize their programs, both are silent.
7. It is easier to write an incorrect program than understand a correct one.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
17. If a listener nods his head when you're explaining your program, wake him up.
110. Editing is a rewording activity.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
79. A year spent in artificial intelligence is enough to make one believe in God.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
18. A program without a loop and a structured variable isn't worth writing.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
57. It is easier to change the specification to fit the program than vice versa.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
98. In computing, the mean time to failure keeps getting shorter.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
103. Purely applicative languages are poorly applicable.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
98. In computing, the mean time to failure keeps getting shorter.
47. As Will Rogers would have said, "There is no such thing as a free variable."
59. In English every word can be verbed. Would that it were so in our programming languages.
110. Editing is a rewording activity.
27. Once you understand how to write a program get someone else to write it.
63. When we write programs that "learn", it turns out that we do and they don't.
102. One can't proceed from the informal to the formal by formal means.
43. In software systems, it is often the early bird that makes the worm.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
40. There are two ways to write error-free programs; only the third one works.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
57. It is easier to change the specification to fit the program than vice versa.
72. An adequate bootstrap is a contradiction in terms.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
72. An adequate bootstrap is a contradiction in terms.
59. In English every word can be verbed. Would that it were so in our programming languages.
8. A programming language is low level when its programs require attention to the irrelevant.
27. Once you understand how to write a program get someone else to write it.
38. Structured Programming supports the law of the excluded middle.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
5. If a program manipulates a large amount of data, it does so in a small number of ways.
12. Recursion is the root of computation since it trades description for time.
102. One can't proceed from the informal to the formal by formal means.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
41. Some programming languages manage to absorb change, but withstand progress.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
46. Like punning, programming is a play on words.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
115. Most people find the concept of programming obvious, but the doing impossible.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
61. In programming, as in everything else, to be in error is to be reborn.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
59. In English every word can be verbed. Would that it were so in our programming languages.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
18. A program without a loop and a structured variable isn't worth writing.
102. One can't proceed from the informal to the formal by formal means.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
1. One man's constant is another man's variable.
18. A program without a loop and a structured variable isn't worth writing.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
62. In computing, invariants are ephemeral.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
3. Syntactic sugar causes cancer of the semicolon.
95. Don't have good ideas if you aren't willing to be responsible for them.
21. Optimization hinders evolution.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
114. Within a computer natural language is unnatural.
111. Why did the Roman Empire collapse? What is Latin for office automation?
4. Every program is a part of some other program and rarely fits.
105. You can't communicate complexity, only an awareness of it.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
103. Purely applicative languages are poorly applicable.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
95. Don't have good ideas if you aren't willing to be responsible for them.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
40. There are two ways to write error-free programs; only the third one works.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
31. Simplicity does not precede complexity, but follows it.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
100. We will never run out of things to program as long as there is a single program around.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
103. Purely applicative languages are poorly applicable.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
98. In computing, the mean time to failure keeps getting shorter.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
17. If a listener nods his head when you're explaining your program, wake him up.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
41. Some programming languages manage to absorb change, but withstand progress.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
38. Structured Programming supports the law of the excluded middle.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
79. A year spent in artificial intelligence is enough to make one believe in God.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
31. Simplicity does not precede complexity, but follows it.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
22. A good system can't have a weak command language.
79. A year spent in artificial intelligence is enough to make one believe in God.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
43. In software systems, it is often the early bird that makes the worm.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
14. In the long run every program becomes rococo - then rubble.
41. Some programming languages manage to absorb change, but withstand progress.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
119. Programming is an unnatural act.
38. Structured Programming supports the law of the excluded middle.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
104. The proof of a system's value is its existence.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
63. When we write programs that "learn", it turns out that we do and they don't.
98. In computing, the mean time to failure keeps getting shorter.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
114. Within a computer natural language is unnatural.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
17. If a listener nods his head when you're explaining your program, wake him up.
46. Like punning, programming is a play on words.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
3. Syntactic sugar causes cancer of the semicolon.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
47. As Will Rogers would have said, "There is no such thing as a free variable."
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
95. Don't have good ideas if you aren't willing to be responsible for them.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
1. One man's constant is another man's variable.
103. Purely applicative languages are poorly applicable.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
100. We will never run out of things to program as long as there is a single program around.
31. Simplicity does not precede complexity, but follows it.
104. The proof of a system's value is its existence.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
61. In programming, as in everything else, to be in error is to be reborn.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
22. A good system can't have a weak command language.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
96. Computers don't introduce order anywhere as much as they expose opportunities.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
3. Syntactic sugar causes cancer of the semicolon.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
105. You can't communicate complexity, only an awareness of it.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
114. Within a computer natural language is unnatural.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
62. In computing, invariants are ephemeral.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
100. We will never run out of things to program as long as there is a single program around.
60. In seeking the unattainable, simplicity only gets in the way.
112. Computer Science is embarrassed by the computer.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
27. Once you understand how to write a program get someone else to write it.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
21. Optimization hinders evolution.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
40. There are two ways to write error-free programs; only the third one works.
1. One man's constant is another man's variable.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
15. Everything should be built top-down, except the first time.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
98. In computing, the mean time to failure keeps getting shorter.
12. Recursion is the root of computation since it trades description for time.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
62. In computing, invariants are ephemeral.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
115. Most people find the concept of programming obvious, but the doing impossible.
57. It is easier to change the specification to fit the program than vice versa.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
31. Simplicity does not precede complexity, but follows it.
115. Most people find the concept of programming obvious, but the doing impossible.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
95. Don't have good ideas if you aren't willing to be responsible for them.
15. Everything should be built top-down, except the first time.
31. Simplicity does not precede complexity, but follows it.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
112. Computer Science is embarrassed by the computer.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
115. Most people find the concept of programming obvious, but the doing impossible.
14. In the long run every program becomes rococo - then rubble.
47. As Will Rogers would have said, "There is no such thing as a free variable."
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
102. One can't proceed from the informal to the formal by formal means.
21. Optimization hinders evolution.
98. In computing, the mean time to failure keeps getting shorter.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
95. Don't have good ideas if you aren't willing to be responsible for them.
4. Every program is a part of some other program and rarely fits.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
62. In computing, invariants are ephemeral.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
66. Making something variable is easy. Controlling duration of constancy is the trick.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
66. Making something variable is easy. Controlling duration of constancy is the trick.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
22. A good system can't have a weak command language.
108. Whenever two programmers meet to criticize their programs, both are silent.
60. In seeking the unattainable, simplicity only gets in the way.
110. Editing is a rewording activity.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
7. It is easier to write an incorrect program than understand a correct one.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
98. In computing, the mean time to failure keeps getting shorter.
66. Making something variable is easy. Controlling duration of constancy is the trick.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
90. Computation has made the tree flower.
115. Most people find the concept of programming obvious, but the doing impossible.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
47. As Will Rogers would have said, "There is no such thing as a free variable."
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
59. In English every word can be verbed. Would that it were so in our programming languages.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
110. Editing is a rewording activity.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
115. Most people find the concept of programming obvious, but the doing impossible.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
60. In seeking the unattainable, simplicity only gets in the way.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
63. When we write programs that "learn", it turns out that we do and they don't.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
5. If a program manipulates a large amount of data, it does so in a small number of ways.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
119. Programming is an unnatural act.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
7. It is easier to write an incorrect program than understand a correct one.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
14. In the long run every program becomes rococo - then rubble.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
18. A program without a loop and a structured variable isn't worth writing.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
47. As Will Rogers would have said, "There is no such thing as a free variable."
12. Recursion is the root of computation since it trades description for time.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
47. As Will Rogers would have said, "There is no such thing as a free variable."
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
23. To understand a program you must become both the machine and the program.
90. Computation has made the tree flower.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
8. A programming language is low level when its programs require attention to the irrelevant.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
22. A good system can't have a weak command language.
3. Syntactic sugar causes cancer of the semicolon.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
21. Optimization hinders evolution.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
90. Computation has made the tree flower.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
47. As Will Rogers would have said, "There is no such thing as a free variable."
78. If your computer speaks English, it was probably made in Japan.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
55. A LISP programmer knows the value of everything, but the cost of nothing.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
119. Programming is an unnatural act.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
104. The proof of a system's value is its existence.
38. Structured Programming supports the law of the excluded middle.
105. You can't communicate complexity, only an awareness of it.
3. Syntactic sugar causes cancer of the semicolon.
78. If your computer speaks English, it was probably made in Japan.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
40. There are two ways to write error-free programs; only the third one works.
110. Editing is a rewording activity.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
41. Some programming languages manage to absorb change, but withstand progress.
110. Editing is a rewording activity.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
61. In programming, as in everything else, to be in error is to be reborn.
96. Computers don't introduce order anywhere as much as they expose opportunities.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
21. Optimization hinders evolution.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
1. One man's constant is another man's variable.
115. Most people find the concept of programming obvious, but the doing impossible.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
111. Why did the Roman Empire collapse? What is Latin for office automation?
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
19. A language that doesn't affect the way you think about programming, is not worth knowing.
98. In computing, the mean time to failure keeps getting shorter.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
90. Computation has made the tree flower.
11. If you have a procedure with ten parameters, you probably missed some.
57. It is easier to change the specification to fit the program than vice versa.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
3. Syntactic sugar causes cancer of the semicolon.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
14. In the long run every program becomes rococo - then rubble.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
3. Syntactic sugar causes cancer of the semicolon.
4. Every program is a part of some other program and rarely fits.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
15. Everything should be built top-down, except the first time.
72. An adequate bootstrap is a contradiction in terms.
95. Don't have good ideas if you aren't willing to be responsible for them.
114. Within a computer natural language is unnatural.
43. In software systems, it is often the early bird that makes the worm.
41. Some programming languages manage to absorb change, but withstand progress.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
38. Structured Programming supports the law of the excluded middle.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
60. In seeking the unattainable, simplicity only gets in the way.
43. In software systems, it is often the early bird that makes the worm.
61. In programming, as in everything else, to be in error is to be reborn.
108. Whenever two programmers meet to criticize their programs, both are silent.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
46. Like punning, programming is a play on words.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
59. In English every word can be verbed. Would that it were so in our programming languages.
47. As Will Rogers would have said, "There is no such thing as a free variable."
90. Computation has made the tree flower.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
59. In English every word can be verbed. Would that it were so in our programming languages.
105. You can't communicate complexity, only an awareness of it.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
3. Syntactic sugar causes cancer of the semicolon.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
79. A year spent in artificial intelligence is enough to make one believe in God.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
90. Computation has made the tree flower.
100. We will never run out of things to program as long as there is a single program around.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
108. Whenever two programmers meet to criticize their programs, both are silent.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
23. To understand a program you must become both the machine and the program.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
76. It is the user who should parameterize procedures, not their creators.
1. One man's constant is another man's variable.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
43. In software systems, it is often the early bird that makes the worm.
55. A LISP programmer knows the value of everything, but the cost of nothing.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
110. Editing is a rewording activity.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
108. Whenever two programmers meet to criticize their programs, both are silent.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
115. Most people find the concept of programming obvious, but the doing impossible.
18. A program without a loop and a structured variable isn't worth writing.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
46. Like punning, programming is a play on words.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
46. Like punning, programming is a play on words.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
105. You can't communicate complexity, only an awareness of it.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
22. A good system can't have a weak command language.
61. In programming, as in everything else, to be in error is to be reborn.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
11. If you have a procedure with ten parameters, you probably missed some.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
104. The proof of a system's value is its existence.
79. A year spent in artificial intelligence is enough to make one believe in God.
90. Computation has made the tree flower.
31. Simplicity does not precede complexity, but follows it.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
47. As Will Rogers would have said, "There is no such thing as a free variable."
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
72. An adequate bootstrap is a contradiction in terms.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
3. Syntactic sugar causes cancer of the semicolon.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
21. Optimization hinders evolution.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
79. A year spent in artificial intelligence is enough to make one believe in God.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
1. One man's constant is another man's variable.
72. An adequate bootstrap is a contradiction in terms.
41. Some programming languages manage to absorb change, but withstand progress.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
98. In computing, the mean time to failure keeps getting shorter.
59. In English every word can be verbed. Would that it were so in our programming languages.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
62. In computing, invariants are ephemeral.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
62. In computing, invariants are ephemeral.
55. A LISP programmer knows the value of everything, but the cost of nothing.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
104. The proof of a system's value is its existence.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
100. We will never run out of things to program as long as there is a single program around.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
15. Everything should be built top-down, except the first time.
119. Programming is an unnatural act.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
7. It is easier to write an incorrect program than understand a correct one.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
104. The proof of a system's value is its existence.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
38. Structured Programming supports the law of the excluded middle.
104. The proof of a system's value is its existence.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
95. Don't have good ideas if you aren't willing to be responsible for them.
114. Within a computer natural language is unnatural.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
108. Whenever two programmers meet to criticize their programs, both are silent.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
76. It is the user who should parameterize procedures, not their creators.
66. Making something variable is easy. Controlling duration of constancy is the trick.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
103. Purely applicative languages are poorly applicable.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
115. Most people find the concept of programming obvious, but the doing impossible.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
40. There are two ways to write error-free programs; only the third one works.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
102. One can't proceed from the informal to the formal by formal means.
60. In seeking the unattainable, simplicity only gets in the way.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
95. Don't have good ideas if you aren't willing to be responsible for them.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
119. Programming is an unnatural act.
112. Computer Science is embarrassed by the computer.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
61. In programming, as in everything else, to be in error is to be reborn.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
63. When we write programs that "learn", it turns out that we do and they don't.
102. One can't proceed from the informal to the formal by formal means.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
4. Every program is a part of some other program and rarely fits.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
115. Most people find the concept of programming obvious, but the doing impossible.
79. A year spent in artificial intelligence is enough to make one believe in God.
102. One can't proceed from the informal to the formal by formal means.
41. Some programming languages manage to absorb change, but withstand progress.
62. In computing, invariants are ephemeral.
47. As Will Rogers would have said, "There is no such thing as a free variable."
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
4. Every program is a part of some other program and rarely fits.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
43. In software systems, it is often the early bird that makes the worm.
108. Whenever two programmers meet to criticize their programs, both are silent.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
105. You can't communicate complexity, only an awareness of it.
38. Structured Programming supports the law of the excluded middle.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
31. Simplicity does not precede complexity, but follows it.
12. Recursion is the root of computation since it trades description for time.
115. Most people find the concept of programming obvious, but the doing impossible.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
21. Optimization hinders evolution.
108. Whenever two programmers meet to criticize their programs, both are silent.
47. As Will Rogers would have said, "There is no such thing as a free variable."
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
31. Simplicity does not precede complexity, but follows it.
59. In English every word can be verbed. Would that it were so in our programming languages.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
41. Some programming languages manage to absorb change, but withstand progress.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
46. Like punning, programming is a play on words.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
38. Structured Programming supports the law of the excluded middle.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
15. Everything should be built top-down, except the first time.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
38. Structured Programming supports the law of the excluded middle.
105. You can't communicate complexity, only an awareness of it.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
21. Optimization hinders evolution.
62. In computing, invariants are ephemeral.
27. Once you understand how to write a program get someone else to write it.
23. To understand a program you must become both the machine and the program.
61. In programming, as in everything else, to be in error is to be reborn.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
119. Programming is an unnatural act.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
31. Simplicity does not precede complexity, but follows it.
95. Don't have good ideas if you aren't willing to be responsible for them.
98. In computing, the mean time to failure keeps getting shorter.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
55. A LISP programmer knows the value of everything, but the cost of nothing.
90. Computation has made the tree flower.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
46. Like punning, programming is a play on words.
40. There are two ways to write error-free programs; only the third one works.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
46. Like punning, programming is a play on words.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
100. We will never run out of things to program as long as there is a single program around.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
23. To understand a program you must become both the machine and the program.
62. In computing, invariants are ephemeral.
79. A year spent in artificial intelligence is enough to make one believe in God.
23. To understand a program you must become both the machine and the program.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
3. Syntactic sugar causes cancer of the semicolon.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
98. In computing, the mean time to failure keeps getting shorter.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
7. It is easier to write an incorrect program than understand a correct one.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
43. In software systems, it is often the early bird that makes the worm.
23. To understand a program you must become both the machine and the program.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
21. Optimization hinders evolution.
31. Simplicity does not precede complexity, but follows it.
43. In software systems, it is often the early bird that makes the worm.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
90. Computation has made the tree flower.
95. Don't have good ideas if you aren't willing to be responsible for them.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
100. We will never run out of things to program as long as there is a single program around.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
38. Structured Programming supports the law of the excluded middle.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
5. If a program manipulates a large amount of data, it does so in a small number of ways.
60. In seeking the unattainable, simplicity only gets in the way.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
22. A good system can't have a weak command language.
66. Making something variable is easy. Controlling duration of constancy is the trick.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
4. Every program is a part of some other program and rarely fits.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
114. Within a computer natural language is unnatural.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
96. Computers don't introduce order anywhere as much as they expose opportunities.
61. In programming, as in everything else, to be in error is to be reborn.
76. It is the user who should parameterize procedures, not their creators.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
110. Editing is a rewording activity.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
62. In computing, invariants are ephemeral.
63. When we write programs that "learn", it turns out that we do and they don't.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
61. In programming, as in everything else, to be in error is to be reborn.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
3. Syntactic sugar causes cancer of the semicolon.
96. Computers don't introduce order anywhere as much as they expose opportunities.
57. It is easier to change the specification to fit the program than vice versa.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
108. Whenever two programmers meet to criticize their programs, both are silent.
31. Simplicity does not precede complexity, but follows it.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
14. In the long run every program becomes rococo - then rubble.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
22. A good system can't have a weak command language.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
27. Once you understand how to write a program get someone else to write it.
22. A good system can't have a weak command language.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
76. It is the user who should parameterize procedures, not their creators.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
78. If your computer speaks English, it was probably made in Japan.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
4. Every program is a part of some other program and rarely fits.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
55. A LISP programmer knows the value of everything, but the cost of nothing.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
23. To understand a program you must become both the machine and the program.
119. Programming is an unnatural act.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
62. In computing, invariants are ephemeral.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
40. There are two ways to write error-free programs; only the third one works.
90. Computation has made the tree flower.
108. Whenever two programmers meet to criticize their programs, both are silent.
96. Computers don't introduce order anywhere as much as they expose opportunities.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
76. It is the user who should parameterize procedures, not their creators.
105. You can't communicate complexity, only an awareness of it.
41. Some programming languages manage to absorb change, but withstand progress.
72. An adequate bootstrap is a contradiction in terms.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
41. Some programming languages manage to absorb change, but withstand progress.
108. Whenever two programmers meet to criticize their programs, both are silent.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
105. You can't communicate complexity, only an awareness of it.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
108. Whenever two programmers meet to criticize their programs, both are silent.
108. Whenever two programmers meet to criticize their programs, both are silent.
12. Recursion is the root of computation since it trades description for time.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
7. It is easier to write an incorrect program than understand a correct one.
115. Most people find the concept of programming obvious, but the doing impossible.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
57. It is easier to change the specification to fit the program than vice versa.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
3. Syntactic sugar causes cancer of the semicolon.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
43. In software systems, it is often the early bird that makes the worm.
112. Computer Science is embarrassed by the computer.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
4. Every program is a part of some other program and rarely fits.
12. Recursion is the root of computation since it trades description for time.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
41. Some programming languages manage to absorb change, but withstand progress.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
40. There are two ways to write error-free programs; only the third one works.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
46. Like punning, programming is a play on words.
11. If you have a procedure with ten parameters, you probably missed some.
63. When we write programs that "learn", it turns out that we do and they don't.
98. In computing, the mean time to failure keeps getting shorter.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
112. Computer Science is embarrassed by the computer.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
46. Like punning, programming is a play on words.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
38. Structured Programming supports the law of the excluded middle.
4. Every program is a part of some other program and rarely fits.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
23. To understand a program you must become both the machine and the program.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
100. We will never run out of things to program as long as there is a single program around.
110. Editing is a rewording activity.
27. Once you understand how to write a program get someone else to write it.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
14. In the long run every program becomes rococo - then rubble.
72. An adequate bootstrap is a contradiction in terms.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
55. A LISP programmer knows the value of everything, but the cost of nothing.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
21. Optimization hinders evolution.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
78. If your computer speaks English, it was probably made in Japan.
61. In programming, as in everything else, to be in error is to be reborn.
1. One man's constant is another man's variable.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
15. Everything should be built top-down, except the first time.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
105. You can't communicate complexity, only an awareness of it.
40. There are two ways to write error-free programs; only the third one works.
115. Most people find the concept of programming obvious, but the doing impossible.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
17. If a listener nods his head when you're explaining your program, wake him up.
90. Computation has made the tree flower.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
78. If your computer speaks English, it was probably made in Japan.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
27. Once you understand how to write a program get someone else to write it.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
78. If your computer speaks English, it was probably made in Japan.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
96. Computers don't introduce order anywhere as much as they expose opportunities.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
14. In the long run every program becomes rococo - then rubble.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
14. In the long run every program becomes rococo - then rubble.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
55. A LISP programmer knows the value of everything, but the cost of nothing.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
15. Everything should be built top-down, except the first time.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
60. In seeking the unattainable, simplicity only gets in the way.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
61. In programming, as in everything else, to be in error is to be reborn.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
3. Syntactic sugar causes cancer of the semicolon.
96. Computers don't introduce order anywhere as much as they expose opportunities.
47. As Will Rogers would have said, "There is no such thing as a free variable."
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
63. When we write programs that "learn", it turns out that we do and they don't.
31. Simplicity does not precede complexity, but follows it.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
66. Making something variable is easy. Controlling duration of constancy is the trick.
27. Once you understand how to write a program get someone else to write it.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
47. As Will Rogers would have said, "There is no such thing as a free variable."
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
62. In computing, invariants are ephemeral.
8. A programming language is low level when its programs require attention to the irrelevant.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
61. In programming, as in everything else, to be in error is to be reborn.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
119. Programming is an unnatural act.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
7. It is easier to write an incorrect program than understand a correct one.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
41. Some programming languages manage to absorb change, but withstand progress.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
105. You can't communicate complexity, only an awareness of it.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
108. Whenever two programmers meet to criticize their programs, both are silent.
111. Why did the Roman Empire collapse? What is Latin for office automation?
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
102. One can't proceed from the informal to the formal by formal means.
31. Simplicity does not precede complexity, but follows it.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
76. It is the user who should parameterize procedures, not their creators.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
5. If a program manipulates a large amount of data, it does so in a small number of ways.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
43. In software systems, it is often the early bird that makes the worm.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
98. In computing, the mean time to failure keeps getting shorter.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
41. Some programming languages manage to absorb change, but withstand progress.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
27. Once you understand how to write a program get someone else to write it.
3. Syntactic sugar causes cancer of the semicolon.
78. If your computer speaks English, it was probably made in Japan.
104. The proof of a system's value is its existence.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
98. In computing, the mean time to failure keeps getting shorter.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
79. A year spent in artificial intelligence is enough to make one believe in God.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
90. Computation has made the tree flower.
55. A LISP programmer knows the value of everything, but the cost of nothing.
108. Whenever two programmers meet to criticize their programs, both are silent.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
7. It is easier to write an incorrect program than understand a correct one.
61. In programming, as in everything else, to be in error is to be reborn.
66. Making something variable is easy. Controlling duration of constancy is the trick.
110. Editing is a rewording activity.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
3. Syntactic sugar causes cancer of the semicolon.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
14. In the long run every program becomes rococo - then rubble.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
63. When we write programs that "learn", it turns out that we do and they don't.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
108. Whenever two programmers meet to criticize their programs, both are silent.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
78. If your computer speaks English, it was probably made in Japan.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
104. The proof of a system's value is its existence.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
66. Making something variable is easy. Controlling duration of constancy is the trick.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
90. Computation has made the tree flower.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
112. Computer Science is embarrassed by the computer.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
104. The proof of a system's value is its existence.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
40. There are two ways to write error-free programs; only the third one works.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
14. In the long run every program becomes rococo - then rubble.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
43. In software systems, it is often the early bird that makes the worm.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
40. There are two ways to write error-free programs; only the third one works.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
38. Structured Programming supports the law of the excluded middle.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
60. In seeking the unattainable, simplicity only gets in the way.
55. A LISP programmer knows the value of everything, but the cost of nothing.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
90. Computation has made the tree flower.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
100. We will never run out of things to program as long as there is a single program around.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
79. A year spent in artificial intelligence is enough to make one believe in God.
17. If a listener nods his head when you're explaining your program, wake him up.
96. Computers don't introduce order anywhere as much as they expose opportunities.
102. One can't proceed from the informal to the formal by formal means.
43. In software systems, it is often the early bird that makes the worm.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
8. A programming language is low level when its programs require attention to the irrelevant.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
17. If a listener nods his head when you're explaining your program, wake him up.
110. Editing is a rewording activity.
43. In software systems, it is often the early bird that makes the worm.
66. Making something variable is easy. Controlling duration of constancy is the trick.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
22. A good system can't have a weak command language.
66. Making something variable is easy. Controlling duration of constancy is the trick.
14. In the long run every program becomes rococo - then rubble.
31. Simplicity does not precede complexity, but follows it.
78. If your computer speaks English, it was probably made in Japan.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
12. Recursion is the root of computation since it trades description for time.
104. The proof of a system's value is its existence.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
61. In programming, as in everything else, to be in error is to be reborn.
7. It is easier to write an incorrect program than understand a correct one.
79. A year spent in artificial intelligence is enough to make one believe in God.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
31. Simplicity does not precede complexity, but follows it.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
59. In English every word can be verbed. Would that it were so in our programming languages.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
43. In software systems, it is often the early bird that makes the worm.
76. It is the user who should parameterize procedures, not their creators.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
23. To understand a program you must become both the machine and the program.
43. In software systems, it is often the early bird that makes the worm.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
115. Most people find the concept of programming obvious, but the doing impossible.
102. One can't proceed from the informal to the formal by formal means.
59. In English every word can be verbed. Would that it were so in our programming languages.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
21. Optimization hinders evolution.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
66. Making something variable is easy. Controlling duration of constancy is the trick.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
61. In programming, as in everything else, to be in error is to be reborn.
72. An adequate bootstrap is a contradiction in terms.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
18. A program without a loop and a structured variable isn't worth writing.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
112. Computer Science is embarrassed by the computer.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
55. A LISP programmer knows the value of everything, but the cost of nothing.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
105. You can't communicate complexity, only an awareness of it.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
103. Purely applicative languages are poorly applicable.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
17. If a listener nods his head when you're explaining your program, wake him up.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
14. In the long run every program becomes rococo - then rubble.
114. Within a computer natural language is unnatural.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
18. A program without a loop and a structured variable isn't worth writing.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
66. Making something variable is easy. Controlling duration of constancy is the trick.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
27. Once you understand how to write a program get someone else to write it.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
104. The proof of a system's value is its existence.
43. In software systems, it is often the early bird that makes the worm.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
63. When we write programs that "learn", it turns out that we do and they don't.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
57. It is easier to change the specification to fit the program than vice versa.
103. Purely applicative languages are poorly applicable.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
119. Programming is an unnatural act.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
40. There are two ways to write error-free programs; only the third one works.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
21. Optimization hinders evolution.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
114. Within a computer natural language is unnatural.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
119. Programming is an unnatural act.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
63. When we write programs that "learn", it turns out that we do and they don't.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
114. Within a computer natural language is unnatural.
102. One can't proceed from the informal to the formal by formal means.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
60. In seeking the unattainable, simplicity only gets in the way.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
103. Purely applicative languages are poorly applicable.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
41. Some programming languages manage to absorb change, but withstand progress.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
43. In software systems, it is often the early bird that makes the worm.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
43. In software systems, it is often the early bird that makes the worm.
115. Most people find the concept of programming obvious, but the doing impossible.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
55. A LISP programmer knows the value of everything, but the cost of nothing.
78. If your computer speaks English, it was probably made in Japan.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
100. We will never run out of things to program as long as there is a single program around.
104. The proof of a system's value is its existence.
100. We will never run out of things to program as long as there is a single program around.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
103. Purely applicative languages are poorly applicable.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
46. Like punning, programming is a play on words.
57. It is easier to change the specification to fit the program than vice versa.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
66. Making something variable is easy. Controlling duration of constancy is the trick.
12. Recursion is the root of computation since it trades description for time.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
79. A year spent in artificial intelligence is enough to make one believe in God.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
41. Some programming languages manage to absorb change, but withstand progress.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
21. Optimization hinders evolution.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
43. In software systems, it is often the early bird that makes the worm.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
47. As Will Rogers would have said, "There is no such thing as a free variable."
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
104. The proof of a system's value is its existence.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
76. It is the user who should parameterize procedures, not their creators.
11. If you have a procedure with ten parameters, you probably missed some.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
90. Computation has made the tree flower.
7. It is easier to write an incorrect program than understand a correct one.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
47. As Will Rogers would have said, "There is no such thing as a free variable."
46. Like punning, programming is a play on words.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
98. In computing, the mean time to failure keeps getting shorter.
96. Computers don't introduce order anywhere as much as they expose opportunities.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
57. It is easier to change the specification to fit the program than vice versa.
3. Syntactic sugar causes cancer of the semicolon.
108. Whenever two programmers meet to criticize their programs, both are silent.
41. Some programming languages manage to absorb change, but withstand progress.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
17. If a listener nods his head when you're explaining your program, wake him up.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
4. Every program is a part of some other program and rarely fits.
21. Optimization hinders evolution.
15. Everything should be built top-down, except the first time.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
57. It is easier to change the specification to fit the program than vice versa.
43. In software systems, it is often the early bird that makes the worm.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
11. If you have a procedure with ten parameters, you probably missed some.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
11. If you have a procedure with ten parameters, you probably missed some.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
114. Within a computer natural language is unnatural.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
90. Computation has made the tree flower.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
103. Purely applicative languages are poorly applicable.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
1. One man's constant is another man's variable.
40. There are two ways to write error-free programs; only the third one works.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
8. A programming language is low level when its programs require attention to the irrelevant.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
115. Most people find the concept of programming obvious, but the doing impossible.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
95. Don't have good ideas if you aren't willing to be responsible for them.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
3. Syntactic sugar causes cancer of the semicolon.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
96. Computers don't introduce order anywhere as much as they expose opportunities.
119. Programming is an unnatural act.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
62. In computing, invariants are ephemeral.
95. Don't have good ideas if you aren't willing to be responsible for them.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
55. A LISP programmer knows the value of everything, but the cost of nothing.
3. Syntactic sugar causes cancer of the semicolon.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
15. Everything should be built top-down, except the first time.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
96. Computers don't introduce order anywhere as much as they expose opportunities.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
17. If a listener nods his head when you're explaining your program, wake him up.
23. To understand a program you must become both the machine and the program.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
1. One man's constant is another man's variable.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
23. To understand a program you must become both the machine and the program.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
22. A good system can't have a weak command language.
72. An adequate bootstrap is a contradiction in terms.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
61. In programming, as in everything else, to be in error is to be reborn.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
72. An adequate bootstrap is a contradiction in terms.
41. Some programming languages manage to absorb change, but withstand progress.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
1. One man's constant is another man's variable.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
61. In programming, as in everything else, to be in error is to be reborn.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
18. A program without a loop and a structured variable isn't worth writing.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
112. Computer Science is embarrassed by the computer.
27. Once you understand how to write a program get someone else to write it.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
110. Editing is a rewording activity.
46. Like punning, programming is a play on words.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
40. There are two ways to write error-free programs; only the third one works.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
31. Simplicity does not precede complexity, but follows it.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
111. Why did the Roman Empire collapse? What is Latin for office automation?
119. Programming is an unnatural act.
112. Computer Science is embarrassed by the computer.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
40. There are two ways to write error-free programs; only the third one works.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
21. Optimization hinders evolution.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
1. One man's constant is another man's variable.
105. You can't communicate complexity, only an awareness of it.
119. Programming is an unnatural act.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
66. Making something variable is easy. Controlling duration of constancy is the trick.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
40. There are two ways to write error-free programs; only the third one works.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
17. If a listener nods his head when you're explaining your program, wake him up.
12. Recursion is the root of computation since it trades description for time.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
72. An adequate bootstrap is a contradiction in terms.
38. Structured Programming supports the law of the excluded middle.
96. Computers don't introduce order anywhere as much as they expose opportunities.
61. In programming, as in everything else, to be in error is to be reborn.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
57. It is easier to change the specification to fit the program than vice versa.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
110. Editing is a rewording activity.
17. If a listener nods his head when you're explaining your program, wake him up.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
60. In seeking the unattainable, simplicity only gets in the way.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
66. Making something variable is easy. Controlling duration of constancy is the trick.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
103. Purely applicative languages are poorly applicable.
105. You can't communicate complexity, only an awareness of it.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
7. It is easier to write an incorrect program than understand a correct one.
21. Optimization hinders evolution.
100. We will never run out of things to program as long as there is a single program around.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
11. If you have a procedure with ten parameters, you probably missed some.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
43. In software systems, it is often the early bird that makes the worm.
105. You can't communicate complexity, only an awareness of it.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
12. Recursion is the root of computation since it trades description for time.
96. Computers don't introduce order anywhere as much as they expose opportunities.
15. Everything should be built top-down, except the first time.
17. If a listener nods his head when you're explaining your program, wake him up.
60. In seeking the unattainable, simplicity only gets in the way.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
98. In computing, the mean time to failure keeps getting shorter.
59. In English every word can be verbed. Would that it were so in our programming languages.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
43. In software systems, it is often the early bird that makes the worm.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
98. In computing, the mean time to failure keeps getting shorter.
8. A programming language is low level when its programs require attention to the irrelevant.
14. In the long run every program becomes rococo - then rubble.
47. As Will Rogers would have said, "There is no such thing as a free variable."
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
112. Computer Science is embarrassed by the computer.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
12. Recursion is the root of computation since it trades description for time.
31. Simplicity does not precede complexity, but follows it.
57. It is easier to change the specification to fit the program than vice versa.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
3. Syntactic sugar causes cancer of the semicolon.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
55. A LISP programmer knows the value of everything, but the cost of nothing.
21. Optimization hinders evolution.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
107. The debate rages on: is PL/I Bachtrian or Dromedary?
47. As Will Rogers would have said, "There is no such thing as a free variable."
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
57. It is easier to change the specification to fit the program than vice versa.
7. It is easier to write an incorrect program than understand a correct one.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
115. Most people find the concept of programming obvious, but the doing impossible.
105. You can't communicate complexity, only an awareness of it.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
108. Whenever two programmers meet to criticize their programs, both are silent.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
15. Everything should be built top-down, except the first time.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
59. In English every word can be verbed. Would that it were so in our programming languages.
63. When we write programs that "learn", it turns out that we do and they don't.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
7. It is easier to write an incorrect program than understand a correct one.
79. A year spent in artificial intelligence is enough to make one believe in God.
11. If you have a procedure with ten parameters, you probably missed some.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
79. A year spent in artificial intelligence is enough to make one believe in God.
95. Don't have good ideas if you aren't willing to be responsible for them.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
62. In computing, invariants are ephemeral.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
15. Everything should be built top-down, except the first time.
18. A program without a loop and a structured variable isn't worth writing.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
112. Computer Science is embarrassed by the computer.
108. Whenever two programmers meet to criticize their programs, both are silent.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
110. Editing is a rewording activity.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
38. Structured Programming supports the law of the excluded middle.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
112. Computer Science is embarrassed by the computer.
47. As Will Rogers would have said, "There is no such thing as a free variable."
107. The debate rages on: is PL/I Bachtrian or Dromedary?
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
100. We will never run out of things to program as long as there is a single program around.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
43. In software systems, it is often the early bird that makes the worm.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
100. We will never run out of things to program as long as there is a single program around.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
102. One can't proceed from the informal to the formal by formal means.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
17. If a listener nods his head when you're explaining your program, wake him up.
21. Optimization hinders evolution.
14. In the long run every program becomes rococo - then rubble.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
21. Optimization hinders evolution.
76. It is the user who should parameterize procedures, not their creators.
22. A good system can't have a weak command language.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
79. A year spent in artificial intelligence is enough to make one believe in God.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
15. Everything should be built top-down, except the first time.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
115. Most people find the concept of programming obvious, but the doing impossible.
100. We will never run out of things to program as long as there is a single program around.
18. A program without a loop and a structured variable isn't worth writing.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
55. A LISP programmer knows the value of everything, but the cost of nothing.
110. Editing is a rewording activity.
63. When we write programs that "learn", it turns out that we do and they don't.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
46. Like punning, programming is a play on words.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
11. If you have a procedure with ten parameters, you probably missed some.
3. Syntactic sugar causes cancer of the semicolon.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
57. It is easier to change the specification to fit the program than vice versa.
103. Purely applicative languages are poorly applicable.
46. Like punning, programming is a play on words.
63. When we write programs that "learn", it turns out that we do and they don't.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
7. It is easier to write an incorrect program than understand a correct one.
41. Some programming languages manage to absorb change, but withstand progress.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
111. Why did the Roman Empire collapse? What is Latin for office automation?
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
8. A programming language is low level when its programs require attention to the irrelevant.
22. A good system can't have a weak command language.
95. Don't have good ideas if you aren't willing to be responsible for them.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
21. Optimization hinders evolution.
79. A year spent in artificial intelligence is enough to make one believe in God.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
102. One can't proceed from the informal to the formal by formal means.
27. Once you understand how to write a program get someone else to write it.
47. As Will Rogers would have said, "There is no such thing as a free variable."
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
95. Don't have good ideas if you aren't willing to be responsible for them.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
15. Everything should be built top-down, except the first time.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
60. In seeking the unattainable, simplicity only gets in the way.
59. In English every word can be verbed. Would that it were so in our programming languages.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
72. An adequate bootstrap is a contradiction in terms.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
15. Everything should be built top-down, except the first time.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
79. A year spent in artificial intelligence is enough to make one believe in God.
18. A program without a loop and a structured variable isn't worth writing.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
57. It is easier to change the specification to fit the program than vice versa.
22. A good system can't have a weak command language.
17. If a listener nods his head when you're explaining your program, wake him up.
119. Programming is an unnatural act.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
107. The debate rages on: is PL/I Bachtrian or Dromedary?
40. There are two ways to write error-free programs; only the third one works.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
22. A good system can't have a weak command language.
112. Computer Science is embarrassed by the computer.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
112. Computer Science is embarrassed by the computer.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
104. The proof of a system's value is its existence.
112. Computer Science is embarrassed by the computer.
7. It is easier to write an incorrect program than understand a correct one.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
15. Everything should be built top-down, except the first time.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
105. You can't communicate complexity, only an awareness of it.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
31. Simplicity does not precede complexity, but follows it.
100. We will never run out of things to program as long as there is a single program around.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
21. Optimization hinders evolution.
31. Simplicity does not precede complexity, but follows it.
7. It is easier to write an incorrect program than understand a correct one.
55. A LISP programmer knows the value of everything, but the cost of nothing.
96. Computers don't introduce order anywhere as much as they expose opportunities.
8. A programming language is low level when its programs require attention to the irrelevant.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
72. An adequate bootstrap is a contradiction in terms.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
62. In computing, invariants are ephemeral.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
63. When we write programs that "learn", it turns out that we do and they don't.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
62. In computing, invariants are ephemeral.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
17. If a listener nods his head when you're explaining your program, wake him up.
15. Everything should be built top-down, except the first time.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
22. A good system can't have a weak command language.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
41. Some programming languages manage to absorb change, but withstand progress.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
61. In programming, as in everything else, to be in error is to be reborn.
76. It is the user who should parameterize procedures, not their creators.
104. The proof of a system's value is its existence.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
23. To understand a program you must become both the machine and the program.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
23. To understand a program you must become both the machine and the program.
43. In software systems, it is often the early bird that makes the worm.
102. One can't proceed from the informal to the formal by formal means.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
115. Most people find the concept of programming obvious, but the doing impossible.
41. Some programming languages manage to absorb change, but withstand progress.
57. It is easier to change the specification to fit the program than vice versa.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
110. Editing is a rewording activity.
111. Why did the Roman Empire collapse? What is Latin for office automation?
95. Don't have good ideas if you aren't willing to be responsible for them.
3. Syntactic sugar causes cancer of the semicolon.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
98. In computing, the mean time to failure keeps getting shorter.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
111. Why did the Roman Empire collapse? What is Latin for office automation?
12. Recursion is the root of computation since it trades description for time.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
110. Editing is a rewording activity.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
5. If a program manipulates a large amount of data, it does so in a small number of ways.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
103. Purely applicative languages are poorly applicable.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
62. In computing, invariants are ephemeral.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
1. One man's constant is another man's variable.
104. The proof of a system's value is its existence.
66. Making something variable is easy. Controlling duration of constancy is the trick.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
90. Computation has made the tree flower.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
112. Computer Science is embarrassed by the computer.
15. Everything should be built top-down, except the first time.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
66. Making something variable is easy. Controlling duration of constancy is the trick.
60. In seeking the unattainable, simplicity only gets in the way.
110. Editing is a rewording activity.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
14. In the long run every program becomes rococo - then rubble.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
46. Like punning, programming is a play on words.
7. It is easier to write an incorrect program than understand a correct one.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
40. There are two ways to write error-free programs; only the third one works.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
47. As Will Rogers would have said, "There is no such thing as a free variable."
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
111. Why did the Roman Empire collapse? What is Latin for office automation?
43. In software systems, it is often the early bird that makes the worm.
3. Syntactic sugar causes cancer of the semicolon.
57. It is easier to change the specification to fit the program than vice versa.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
96. Computers don't introduce order anywhere as much as they expose opportunities.
98. In computing, the mean time to failure keeps getting shorter.
112. Computer Science is embarrassed by the computer.
114. Within a computer natural language is unnatural.
47. As Will Rogers would have said, "There is no such thing as a free variable."
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
102. One can't proceed from the informal to the formal by formal means.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
8. A programming language is low level when its programs require attention to the irrelevant.
110. Editing is a rewording activity.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
40. There are two ways to write error-free programs; only the third one works.
27. Once you understand how to write a program get someone else to write it.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
59. In English every word can be verbed. Would that it were so in our programming languages.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
46. Like punning, programming is a play on words.
102. One can't proceed from the informal to the formal by formal means.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
63. When we write programs that "learn", it turns out that we do and they don't.
112. Computer Science is embarrassed by the computer.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
46. Like punning, programming is a play on words.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
96. Computers don't introduce order anywhere as much as they expose opportunities.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
102. One can't proceed from the informal to the formal by formal means.
12. Recursion is the root of computation since it trades description for time.
4. Every program is a part of some other program and rarely fits.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
14. In the long run every program becomes rococo - then rubble.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
90. Computation has made the tree flower.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
78. If your computer speaks English, it was probably made in Japan.
61. In programming, as in everything else, to be in error is to be reborn.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
76. It is the user who should parameterize procedures, not their creators.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
59. In English every word can be verbed. Would that it were so in our programming languages.
38. Structured Programming supports the law of the excluded middle.
14. In the long run every program becomes rococo - then rubble.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
1. One man's constant is another man's variable.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
23. To understand a program you must become both the machine and the program.
41. Some programming languages manage to absorb change, but withstand progress.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
78. If your computer speaks English, it was probably made in Japan.
96. Computers don't introduce order anywhere as much as they expose opportunities.
41. Some programming languages manage to absorb change, but withstand progress.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
1. One man's constant is another man's variable.
12. Recursion is the root of computation since it trades description for time.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
62. In computing, invariants are ephemeral.
110. Editing is a rewording activity.
17. If a listener nods his head when you're explaining your program, wake him up.
59. In English every word can be verbed. Would that it were so in our programming languages.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
105. You can't communicate complexity, only an awareness of it.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
104. The proof of a system's value is its existence.
60. In seeking the unattainable, simplicity only gets in the way.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
18. A program without a loop and a structured variable isn't worth writing.
63. When we write programs that "learn", it turns out that we do and they don't.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
103. Purely applicative languages are poorly applicable.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
90. Computation has made the tree flower.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
79. A year spent in artificial intelligence is enough to make one believe in God.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
60. In seeking the unattainable, simplicity only gets in the way.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
90. Computation has made the tree flower.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
78. If your computer speaks English, it was probably made in Japan.
78. If your computer speaks English, it was probably made in Japan.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
4. Every program is a part of some other program and rarely fits.
27. Once you understand how to write a program get someone else to write it.
76. It is the user who should parameterize procedures, not their creators.
115. Most people find the concept of programming obvious, but the doing impossible.
59. In English every word can be verbed. Would that it were so in our programming languages.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
8. A programming language is low level when its programs require attention to the irrelevant.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
115. Most people find the concept of programming obvious, but the doing impossible.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
47. As Will Rogers would have said, "There is no such thing as a free variable."
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
7. It is easier to write an incorrect program than understand a correct one.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
15. Everything should be built top-down, except the first time.
90. Computation has made the tree flower.
59. In English every word can be verbed. Would that it were so in our programming languages.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
111. Why did the Roman Empire collapse? What is Latin for office automation?
112. Computer Science is embarrassed by the computer.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
76. It is the user who should parameterize procedures, not their creators.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
23. To understand a program you must become both the machine and the program.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
108. Whenever two programmers meet to criticize their programs, both are silent.
41. Some programming languages manage to absorb change, but withstand progress.
66. Making something variable is easy. Controlling duration of constancy is the trick.
22. A good system can't have a weak command language.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
76. It is the user who should parameterize procedures, not their creators.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
72. An adequate bootstrap is a contradiction in terms.
23. To understand a program you must become both the machine and the program.
60. In seeking the unattainable, simplicity only gets in the way.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
21. Optimization hinders evolution.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
21. Optimization hinders evolution.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
62. In computing, invariants are ephemeral.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
27. Once you understand how to write a program get someone else to write it.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
76. It is the user who should parameterize procedures, not their creators.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
114. Within a computer natural language is unnatural.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
108. Whenever two programmers meet to criticize their programs, both are silent.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
105. You can't communicate complexity, only an awareness of it.
60. In seeking the unattainable, simplicity only gets in the way.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
38. Structured Programming supports the law of the excluded middle.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
79. A year spent in artificial intelligence is enough to make one believe in God.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
18. A program without a loop and a structured variable isn't worth writing.
22. A good system can't have a weak command language.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
59. In English every word can be verbed. Would that it were so in our programming languages.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
61. In programming, as in everything else, to be in error is to be reborn.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
96. Computers don't introduce order anywhere as much as they expose opportunities.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
23. To understand a program you must become both the machine and the program.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
61. In programming, as in everything else, to be in error is to be reborn.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
98. In computing, the mean time to failure keeps getting shorter.
104. The proof of a system's value is its existence.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
17. If a listener nods his head when you're explaining your program, wake him up.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
3. Syntactic sugar causes cancer of the semicolon.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
46. Like punning, programming is a play on words.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
46. Like punning, programming is a play on words.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
15. Everything should be built top-down, except the first time.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
119. Programming is an unnatural act.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
14. In the long run every program becomes rococo - then rubble.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
115. Most people find the concept of programming obvious, but the doing impossible.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
12. Recursion is the root of computation since it trades description for time.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
8. A programming language is low level when its programs require attention to the irrelevant.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
66. Making something variable is easy. Controlling duration of constancy is the trick.
95. Don't have good ideas if you aren't willing to be responsible for them.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
96. Computers don't introduce order anywhere as much as they expose opportunities.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
114. Within a computer natural language is unnatural.
4. Every program is a part of some other program and rarely fits.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
98. In computing, the mean time to failure keeps getting shorter.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
18. A program without a loop and a structured variable isn't worth writing.
40. There are two ways to write error-free programs; only the third one works.
31. Simplicity does not precede complexity, but follows it.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
4. Every program is a part of some other program and rarely fits.
12. Recursion is the root of computation since it trades description for time.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
23. To understand a program you must become both the machine and the program.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
55. A LISP programmer knows the value of everything, but the cost of nothing.
59. In English every word can be verbed. Would that it were so in our programming languages.
115. Most people find the concept of programming obvious, but the doing impossible.
60. In seeking the unattainable, simplicity only gets in the way.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
14. In the long run every program becomes rococo - then rubble.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
57. It is easier to change the specification to fit the program than vice versa.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
66. Making something variable is easy. Controlling duration of constancy is the trick.
60. In seeking the unattainable, simplicity only gets in the way.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
105. You can't communicate complexity, only an awareness of it.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
96. Computers don't introduce order anywhere as much as they expose opportunities.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
21. Optimization hinders evolution.
110. Editing is a rewording activity.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
57. It is easier to change the specification to fit the program than vice versa.
60. In seeking the unattainable, simplicity only gets in the way.
114. Within a computer natural language is unnatural.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
57. It is easier to change the specification to fit the program than vice versa.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
14. In the long run every program becomes rococo - then rubble.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
66. Making something variable is easy. Controlling duration of constancy is the trick.
3. Syntactic sugar causes cancer of the semicolon.
104. The proof of a system's value is its existence.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
105. You can't communicate complexity, only an awareness of it.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
55. A LISP programmer knows the value of everything, but the cost of nothing.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
119. Programming is an unnatural act.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
59. In English every word can be verbed. Would that it were so in our programming languages.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
7. It is easier to write an incorrect program than understand a correct one.
63. When we write programs that "learn", it turns out that we do and they don't.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
11. If you have a procedure with ten parameters, you probably missed some.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
7. It is easier to write an incorrect program than understand a correct one.
4. Every program is a part of some other program and rarely fits.
14. In the long run every program becomes rococo - then rubble.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
27. Once you understand how to write a program get someone else to write it.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
47. As Will Rogers would have said, "There is no such thing as a free variable."
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
38. Structured Programming supports the law of the excluded middle.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
115. Most people find the concept of programming obvious, but the doing impossible.
57. It is easier to change the specification to fit the program than vice versa.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
14. In the long run every program becomes rococo - then rubble.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
11. If you have a procedure with ten parameters, you probably missed some.
7. It is easier to write an incorrect program than understand a correct one.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
95. Don't have good ideas if you aren't willing to be responsible for them.
22. A good system can't have a weak command language.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
47. As Will Rogers would have said, "There is no such thing as a free variable."
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
41. Some programming languages manage to absorb change, but withstand progress.
79. A year spent in artificial intelligence is enough to make one believe in God.
59. In English every word can be verbed. Would that it were so in our programming languages.
43. In software systems, it is often the early bird that makes the worm.
105. You can't communicate complexity, only an awareness of it.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
4. Every program is a part of some other program and rarely fits.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
78. If your computer speaks English, it was probably made in Japan.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
12. Recursion is the root of computation since it trades description for time.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
62. In computing, invariants are ephemeral.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
8. A programming language is low level when its programs require attention to the irrelevant.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
4. Every program is a part of some other program and rarely fits.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
110. Editing is a rewording activity.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
105. You can't communicate complexity, only an awareness of it.
103. Purely applicative languages are poorly applicable.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
108. Whenever two programmers meet to criticize their programs, both are silent.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
38. Structured Programming supports the law of the excluded middle.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
41. Some programming languages manage to absorb change, but withstand progress.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
108. Whenever two programmers meet to criticize their programs, both are silent.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
110. Editing is a rewording activity.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
79. A year spent in artificial intelligence is enough to make one believe in God.
66. Making something variable is easy. Controlling duration of constancy is the trick.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
40. There are two ways to write error-free programs; only the third one works.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
119. Programming is an unnatural act.
18. A program without a loop and a structured variable isn't worth writing.
14. In the long run every program becomes rococo - then rubble.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
8. A programming language is low level when its programs require attention to the irrelevant.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
105. You can't communicate complexity, only an awareness of it.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
38. Structured Programming supports the law of the excluded middle.
57. It is easier to change the specification to fit the program than vice versa.
79. A year spent in artificial intelligence is enough to make one believe in God.
40. There are two ways to write error-free programs; only the third one works.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
79. A year spent in artificial intelligence is enough to make one believe in God.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
14. In the long run every program becomes rococo - then rubble.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
119. Programming is an unnatural act.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
98. In computing, the mean time to failure keeps getting shorter.
17. If a listener nods his head when you're explaining your program, wake him up.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
60. In seeking the unattainable, simplicity only gets in the way.
23. To understand a program you must become both the machine and the program.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
43. In software systems, it is often the early bird that makes the worm.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
61. In programming, as in everything else, to be in error is to be reborn.
61. In programming, as in everything else, to be in error is to be reborn.
119. Programming is an unnatural act.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
27. Once you understand how to write a program get someone else to write it.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
31. Simplicity does not precede complexity, but follows it.
119. Programming is an unnatural act.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
110. Editing is a rewording activity.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
66. Making something variable is easy. Controlling duration of constancy is the trick.
38. Structured Programming supports the law of the excluded middle.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
15. Everything should be built top-down, except the first time.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
46. Like punning, programming is a play on words.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
46. Like punning, programming is a play on words.
112. Computer Science is embarrassed by the computer.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
119. Programming is an unnatural act.
1. One man's constant is another man's variable.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
21. Optimization hinders evolution.
79. A year spent in artificial intelligence is enough to make one believe in God.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
11. If you have a procedure with ten parameters, you probably missed some.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
14. In the long run every program becomes rococo - then rubble.
96. Computers don't introduce order anywhere as much as they expose opportunities.
14. In the long run every program becomes rococo - then rubble.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
31. Simplicity does not precede complexity, but follows it.
63. When we write programs that "learn", it turns out that we do and they don't.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
57. It is easier to change the specification to fit the program than vice versa.
79. A year spent in artificial intelligence is enough to make one believe in God.
100. We will never run out of things to program as long as there is a single program around.
102. One can't proceed from the informal to the formal by formal means.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
27. Once you understand how to write a program get someone else to write it.
61. In programming, as in everything else, to be in error is to be reborn.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
72. An adequate bootstrap is a contradiction in terms.
43. In software systems, it is often the early bird that makes the worm.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
43. In software systems, it is often the early bird that makes the worm.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
4. Every program is a part of some other program and rarely fits.
23. To understand a program you must become both the machine and the program.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
12. Recursion is the root of computation since it trades description for time.
59. In English every word can be verbed. Would that it were so in our programming languages.
110. Editing is a rewording activity.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
102. One can't proceed from the informal to the formal by formal means.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
112. Computer Science is embarrassed by the computer.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
114. Within a computer natural language is unnatural.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
18. A program without a loop and a structured variable isn't worth writing.
59. In English every word can be verbed. Would that it were so in our programming languages.
119. Programming is an unnatural act.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
104. The proof of a system's value is its existence.
112. Computer Science is embarrassed by the computer.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
100. We will never run out of things to program as long as there is a single program around.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
62. In computing, invariants are ephemeral.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
18. A program without a loop and a structured variable isn't worth writing.
55. A LISP programmer knows the value of everything, but the cost of nothing.
41. Some programming languages manage to absorb change, but withstand progress.
114. Within a computer natural language is unnatural.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
1. One man's constant is another man's variable.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
95. Don't have good ideas if you aren't willing to be responsible for them.
18. A program without a loop and a structured variable isn't worth writing.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
55. A LISP programmer knows the value of everything, but the cost of nothing.
31. Simplicity does not precede complexity, but follows it.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
96. Computers don't introduce order anywhere as much as they expose opportunities.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
23. To understand a program you must become both the machine and the program.
46. Like punning, programming is a play on words.
18. A program without a loop and a structured variable isn't worth writing.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
14. In the long run every program becomes rococo - then rubble.
63. When we write programs that "learn", it turns out that we do and they don't.
15. Everything should be built top-down, except the first time.
66. Making something variable is easy. Controlling duration of constancy is the trick.
61. In programming, as in everything else, to be in error is to be reborn.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
110. Editing is a rewording activity.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
57. It is easier to change the specification to fit the program than vice versa.
102. One can't proceed from the informal to the formal by formal means.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
63. When we write programs that "learn", it turns out that we do and they don't.
98. In computing, the mean time to failure keeps getting shorter.
4. Every program is a part of some other program and rarely fits.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
22. A good system can't have a weak command language.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
72. An adequate bootstrap is a contradiction in terms.
63. When we write programs that "learn", it turns out that we do and they don't.
90. Computation has made the tree flower.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
8. A programming language is low level when its programs require attention to the irrelevant.
105. You can't communicate complexity, only an awareness of it.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
105. You can't communicate complexity, only an awareness of it.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
62. In computing, invariants are ephemeral.
8. A programming language is low level when its programs require attention to the irrelevant.
79. A year spent in artificial intelligence is enough to make one believe in God.
63. When we write programs that "learn", it turns out that we do and they don't.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
110. Editing is a rewording activity.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
40. There are two ways to write error-free programs; only the third one works.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
27. Once you understand how to write a program get someone else to write it.
90. Computation has made the tree flower.
14. In the long run every program becomes rococo - then rubble.
40. There are two ways to write error-free programs; only the third one works.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
98. In computing, the mean time to failure keeps getting shorter.
43. In software systems, it is often the early bird that makes the worm.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
27. Once you understand how to write a program get someone else to write it.
57. It is easier to change the specification to fit the program than vice versa.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
57. It is easier to change the specification to fit the program than vice versa.
111. Why did the Roman Empire collapse? What is Latin for office automation?
31. Simplicity does not precede complexity, but follows it.
110. Editing is a rewording activity.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
100. We will never run out of things to program as long as there is a single program around.
63. When we write programs that "learn", it turns out that we do and they don't.
46. Like punning, programming is a play on words.
60. In seeking the unattainable, simplicity only gets in the way.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
98. In computing, the mean time to failure keeps getting shorter.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
38. Structured Programming supports the law of the excluded middle.
59. In English every word can be verbed. Would that it were so in our programming languages.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
79. A year spent in artificial intelligence is enough to make one believe in God.
43. In software systems, it is often the early bird that makes the worm.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
108. Whenever two programmers meet to criticize their programs, both are silent.
112. Computer Science is embarrassed by the computer.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
66. Making something variable is easy. Controlling duration of constancy is the trick.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
46. Like punning, programming is a play on words.
79. A year spent in artificial intelligence is enough to make one believe in God.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
72. An adequate bootstrap is a contradiction in terms.
79. A year spent in artificial intelligence is enough to make one believe in God.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
14. In the long run every program becomes rococo - then rubble.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
12. Recursion is the root of computation since it trades description for time.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
1. One man's constant is another man's variable.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
41. Some programming languages manage to absorb change, but withstand progress.
72. An adequate bootstrap is a contradiction in terms.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
78. If your computer speaks English, it was probably made in Japan.
41. Some programming languages manage to absorb change, but withstand progress.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
38. Structured Programming supports the law of the excluded middle.
119. Programming is an unnatural act.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
17. If a listener nods his head when you're explaining your program, wake him up.
76. It is the user who should parameterize procedures, not their creators.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
61. In programming, as in everything else, to be in error is to be reborn.
76. It is the user who should parameterize procedures, not their creators.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
112. Computer Science is embarrassed by the computer.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
72. An adequate bootstrap is a contradiction in terms.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
7. It is easier to write an incorrect program than understand a correct one.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
119. Programming is an unnatural act.
76. It is the user who should parameterize procedures, not their creators.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
46. Like punning, programming is a play on words.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
72. An adequate bootstrap is a contradiction in terms.
41. Some programming languages manage to absorb change, but withstand progress.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
41. Some programming languages manage to absorb change, but withstand progress.
3. Syntactic sugar causes cancer of the semicolon.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
114. Within a computer natural language is unnatural.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
61. In programming, as in everything else, to be in error is to be reborn.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
59. In English every word can be verbed. Would that it were so in our programming languages.
40. There are two ways to write error-free programs; only the third one works.
3. Syntactic sugar causes cancer of the semicolon.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
62. In computing, invariants are ephemeral.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
59. In English every word can be verbed. Would that it were so in our programming languages.
115. Most people find the concept of programming obvious, but the doing impossible.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
90. Computation has made the tree flower.
66. Making something variable is easy. Controlling duration of constancy is the trick.
1. One man's constant is another man's variable.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
21. Optimization hinders evolution.
61. In programming, as in everything else, to be in error is to be reborn.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
72. An adequate bootstrap is a contradiction in terms.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
78. If your computer speaks English, it was probably made in Japan.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
27. Once you understand how to write a program get someone else to write it.
72. An adequate bootstrap is a contradiction in terms.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
115. Most people find the concept of programming obvious, but the doing impossible.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
43. In software systems, it is often the early bird that makes the worm.
119. Programming is an unnatural act.
72. An adequate bootstrap is a contradiction in terms.
95. Don't have good ideas if you aren't willing to be responsible for them.
108. Whenever two programmers meet to criticize their programs, both are silent.
103. Purely applicative languages are poorly applicable.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
110. Editing is a rewording activity.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
57. It is easier to change the specification to fit the program than vice versa.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
105. You can't communicate complexity, only an awareness of it.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
15. Everything should be built top-down, except the first time.
15. Everything should be built top-down, except the first time.
17. If a listener nods his head when you're explaining your program, wake him up.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
59. In English every word can be verbed. Would that it were so in our programming languages.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
76. It is the user who should parameterize procedures, not their creators.
15. Everything should be built top-down, except the first time.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
115. Most people find the concept of programming obvious, but the doing impossible.
12. Recursion is the root of computation since it trades description for time.
90. Computation has made the tree flower.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
104. The proof of a system's value is its existence.
115. Most people find the concept of programming obvious, but the doing impossible.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
105. You can't communicate complexity, only an awareness of it.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
61. In programming, as in everything else, to be in error is to be reborn.
27. Once you understand how to write a program get someone else to write it.
96. Computers don't introduce order anywhere as much as they expose opportunities.
31. Simplicity does not precede complexity, but follows it.
102. One can't proceed from the informal to the formal by formal means.
3. Syntactic sugar causes cancer of the semicolon.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
12. Recursion is the root of computation since it trades description for time.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
17. If a listener nods his head when you're explaining your program, wake him up.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
60. In seeking the unattainable, simplicity only gets in the way.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
17. If a listener nods his head when you're explaining your program, wake him up.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
21. Optimization hinders evolution.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
23. To understand a program you must become both the machine and the program.
60. In seeking the unattainable, simplicity only gets in the way.
95. Don't have good ideas if you aren't willing to be responsible for them.
72. An adequate bootstrap is a contradiction in terms.
96. Computers don't introduce order anywhere as much as they expose opportunities.
14. In the long run every program becomes rococo - then rubble.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
60. In seeking the unattainable, simplicity only gets in the way.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
119. Programming is an unnatural act.
66. Making something variable is easy. Controlling duration of constancy is the trick.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
14. In the long run every program becomes rococo - then rubble.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
41. Some programming languages manage to absorb change, but withstand progress.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
47. As Will Rogers would have said, "There is no such thing as a free variable."
14. In the long run every program becomes rococo - then rubble.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
96. Computers don't introduce order anywhere as much as they expose opportunities.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
3. Syntactic sugar causes cancer of the semicolon.
22. A good system can't have a weak command language.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
60. In seeking the unattainable, simplicity only gets in the way.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
59. In English every word can be verbed. Would that it were so in our programming languages.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
110. Editing is a rewording activity.
7. It is easier to write an incorrect program than understand a correct one.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
98. In computing, the mean time to failure keeps getting shorter.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
110. Editing is a rewording activity.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
103. Purely applicative languages are poorly applicable.
55. A LISP programmer knows the value of everything, but the cost of nothing.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
63. When we write programs that "learn", it turns out that we do and they don't.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
23. To understand a program you must become both the machine and the program.
110. Editing is a rewording activity.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
19. A language that doesn't affect the way you think about programming, is not worth knowing.
46. Like punning, programming is a play on words.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
114. Within a computer natural language is unnatural.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
18. A program without a loop and a structured variable isn't worth writing.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
66. Making something variable is easy. Controlling duration of constancy is the trick.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
8. A programming language is low level when its programs require attention to the irrelevant.
15. Everything should be built top-down, except the first time.
112. Computer Science is embarrassed by the computer.
46. Like punning, programming is a play on words.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
98. In computing, the mean time to failure keeps getting shorter.
1. One man's constant is another man's variable.
105. You can't communicate complexity, only an awareness of it.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
59. In English every word can be verbed. Would that it were so in our programming languages.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
76. It is the user who should parameterize procedures, not their creators.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
21. Optimization hinders evolution.
90. Computation has made the tree flower.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
105. You can't communicate complexity, only an awareness of it.
7. It is easier to write an incorrect program than understand a correct one.
78. If your computer speaks English, it was probably made in Japan.
114. Within a computer natural language is unnatural.
22. A good system can't have a weak command language.
95. Don't have good ideas if you aren't willing to be responsible for them.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
41. Some programming languages manage to absorb change, but withstand progress.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
112. Computer Science is embarrassed by the computer.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
96. Computers don't introduce order anywhere as much as they expose opportunities.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
95. Don't have good ideas if you aren't willing to be responsible for them.
105. You can't communicate complexity, only an awareness of it.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
62. In computing, invariants are ephemeral.
21. Optimization hinders evolution.
7. It is easier to write an incorrect program than understand a correct one.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
96. Computers don't introduce order anywhere as much as they expose opportunities.
21. Optimization hinders evolution.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
60. In seeking the unattainable, simplicity only gets in the way.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
57. It is easier to change the specification to fit the program than vice versa.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
8. A programming language is low level when its programs require attention to the irrelevant.
11. If you have a procedure with ten parameters, you probably missed some.
110. Editing is a rewording activity.
46. Like punning, programming is a play on words.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
27. Once you understand how to write a program get someone else to write it.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
114. Within a computer natural language is unnatural.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
17. If a listener nods his head when you're explaining your program, wake him up.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
12. Recursion is the root of computation since it trades description for time.
11. If you have a procedure with ten parameters, you probably missed some.
7. It is easier to write an incorrect program than understand a correct one.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
12. Recursion is the root of computation since it trades description for time.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
115. Most people find the concept of programming obvious, but the doing impossible.
4. Every program is a part of some other program and rarely fits.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
108. Whenever two programmers meet to criticize their programs, both are silent.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
79. A year spent in artificial intelligence is enough to make one believe in God.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
21. Optimization hinders evolution.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
95. Don't have good ideas if you aren't willing to be responsible for them.
22. A good system can't have a weak command language.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
3. Syntactic sugar causes cancer of the semicolon.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
105. You can't communicate complexity, only an awareness of it.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
55. A LISP programmer knows the value of everything, but the cost of nothing.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
22. A good system can't have a weak command language.
62. In computing, invariants are ephemeral.
114. Within a computer natural language is unnatural.
7. It is easier to write an incorrect program than understand a correct one.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
46. Like punning, programming is a play on words.
76. It is the user who should parameterize procedures, not their creators.
79. A year spent in artificial intelligence is enough to make one believe in God.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
41. Some programming languages manage to absorb change, but withstand progress.
90. Computation has made the tree flower.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
95. Don't have good ideas if you aren't willing to be responsible for them.
11. If you have a procedure with ten parameters, you probably missed some.
40. There are two ways to write error-free programs; only the third one works.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
102. One can't proceed from the informal to the formal by formal means.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
17. If a listener nods his head when you're explaining your program, wake him up.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
8. A programming language is low level when its programs require attention to the irrelevant.
79. A year spent in artificial intelligence is enough to make one believe in God.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
96. Computers don't introduce order anywhere as much as they expose opportunities.
7. It is easier to write an incorrect program than understand a correct one.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
62. In computing, invariants are ephemeral.
108. Whenever two programmers meet to criticize their programs, both are silent.
23. To understand a program you must become both the machine and the program.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
15. Everything should be built top-down, except the first time.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
47. As Will Rogers would have said, "There is no such thing as a free variable."
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
79. A year spent in artificial intelligence is enough to make one believe in God.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
43. In software systems, it is often the early bird that makes the worm.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
110. Editing is a rewording activity.
46. Like punning, programming is a play on words.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
104. The proof of a system's value is its existence.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
111. Why did the Roman Empire collapse? What is Latin for office automation?
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
112. Computer Science is embarrassed by the computer.
59. In English every word can be verbed. Would that it were so in our programming languages.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
112. Computer Science is embarrassed by the computer.
102. One can't proceed from the informal to the formal by formal means.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
112. Computer Science is embarrassed by the computer.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
60. In seeking the unattainable, simplicity only gets in the way.
115. Most people find the concept of programming obvious, but the doing impossible.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
41. Some programming languages manage to absorb change, but withstand progress.
4. Every program is a part of some other program and rarely fits.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
4. Every program is a part of some other program and rarely fits.
72. An adequate bootstrap is a contradiction in terms.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
55. A LISP programmer knows the value of everything, but the cost of nothing.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
119. Programming is an unnatural act.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
11. If you have a procedure with ten parameters, you probably missed some.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
18. A program without a loop and a structured variable isn't worth writing.
112. Computer Science is embarrassed by the computer.
111. Why did the Roman Empire collapse? What is Latin for office automation?
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
98. In computing, the mean time to failure keeps getting shorter.
8. A programming language is low level when its programs require attention to the irrelevant.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
61. In programming, as in everything else, to be in error is to be reborn.
66. Making something variable is easy. Controlling duration of constancy is the trick.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
90. Computation has made the tree flower.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
66. Making something variable is easy. Controlling duration of constancy is the trick.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
61. In programming, as in everything else, to be in error is to be reborn.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
119. Programming is an unnatural act.
66. Making something variable is easy. Controlling duration of constancy is the trick.
1. One man's constant is another man's variable.
27. Once you understand how to write a program get someone else to write it.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
1. One man's constant is another man's variable.
76. It is the user who should parameterize procedures, not their creators.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
17. If a listener nods his head when you're explaining your program, wake him up.
110. Editing is a rewording activity.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
78. If your computer speaks English, it was probably made in Japan.
63. When we write programs that "learn", it turns out that we do and they don't.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
11. If you have a procedure with ten parameters, you probably missed some.
43. In software systems, it is often the early bird that makes the worm.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
61. In programming, as in everything else, to be in error is to be reborn.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
104. The proof of a system's value is its existence.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
103. Purely applicative languages are poorly applicable.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
11. If you have a procedure with ten parameters, you probably missed some.
108. Whenever two programmers meet to criticize their programs, both are silent.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
102. One can't proceed from the informal to the formal by formal means.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
76. It is the user who should parameterize procedures, not their creators.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
59. In English every word can be verbed. Would that it were so in our programming languages.
66. Making something variable is easy. Controlling duration of constancy is the trick.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
78. If your computer speaks English, it was probably made in Japan.
23. To understand a program you must become both the machine and the program.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
47. As Will Rogers would have said, "There is no such thing as a free variable."
7. It is easier to write an incorrect program than understand a correct one.
115. Most people find the concept of programming obvious, but the doing impossible.
66. Making something variable is easy. Controlling duration of constancy is the trick.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
103. Purely applicative languages are poorly applicable.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
119. Programming is an unnatural act.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
90. Computation has made the tree flower.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
110. Editing is a rewording activity.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
15. Everything should be built top-down, except the first time.
15. Everything should be built top-down, except the first time.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
15. Everything should be built top-down, except the first time.
103. Purely applicative languages are poorly applicable.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
112. Computer Science is embarrassed by the computer.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
7. It is easier to write an incorrect program than understand a correct one.
57. It is easier to change the specification to fit the program than vice versa.
61. In programming, as in everything else, to be in error is to be reborn.
1. One man's constant is another man's variable.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
63. When we write programs that "learn", it turns out that we do and they don't.
11. If you have a procedure with ten parameters, you probably missed some.
98. In computing, the mean time to failure keeps getting shorter.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
31. Simplicity does not precede complexity, but follows it.
102. One can't proceed from the informal to the formal by formal means.
76. It is the user who should parameterize procedures, not their creators.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
111. Why did the Roman Empire collapse? What is Latin for office automation?
5. If a program manipulates a large amount of data, it does so in a small number of ways.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
1. One man's constant is another man's variable.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
108. Whenever two programmers meet to criticize their programs, both are silent.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
55. A LISP programmer knows the value of everything, but the cost of nothing.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
112. Computer Science is embarrassed by the computer.
22. A good system can't have a weak command language.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
12. Recursion is the root of computation since it trades description for time.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
11. If you have a procedure with ten parameters, you probably missed some.
59. In English every word can be verbed. Would that it were so in our programming languages.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
46. Like punning, programming is a play on words.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
17. If a listener nods his head when you're explaining your program, wake him up.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
60. In seeking the unattainable, simplicity only gets in the way.
63. When we write programs that "learn", it turns out that we do and they don't.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
112. Computer Science is embarrassed by the computer.
96. Computers don't introduce order anywhere as much as they expose opportunities.
55. A LISP programmer knows the value of everything, but the cost of nothing.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
79. A year spent in artificial intelligence is enough to make one believe in God.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
11. If you have a procedure with ten parameters, you probably missed some.
111. Why did the Roman Empire collapse? What is Latin for office automation?
8. A programming language is low level when its programs require attention to the irrelevant.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
7. It is easier to write an incorrect program than understand a correct one.
41. Some programming languages manage to absorb change, but withstand progress.
23. To understand a program you must become both the machine and the program.
119. Programming is an unnatural act.
59. In English every word can be verbed. Would that it were so in our programming languages.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
15. Everything should be built top-down, except the first time.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
102. One can't proceed from the informal to the formal by formal means.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
79. A year spent in artificial intelligence is enough to make one believe in God.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
108. Whenever two programmers meet to criticize their programs, both are silent.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
61. In programming, as in everything else, to be in error is to be reborn.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
47. As Will Rogers would have said, "There is no such thing as a free variable."
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
18. A program without a loop and a structured variable isn't worth writing.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
27. Once you understand how to write a program get someone else to write it.
1. One man's constant is another man's variable.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
7. It is easier to write an incorrect program than understand a correct one.
76. It is the user who should parameterize procedures, not their creators.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
12. Recursion is the root of computation since it trades description for time.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
104. The proof of a system's value is its existence.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
102. One can't proceed from the informal to the formal by formal means.
17. If a listener nods his head when you're explaining your program, wake him up.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
112. Computer Science is embarrassed by the computer.
98. In computing, the mean time to failure keeps getting shorter.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
102. One can't proceed from the informal to the formal by formal means.
55. A LISP programmer knows the value of everything, but the cost of nothing.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
46. Like punning, programming is a play on words.
76. It is the user who should parameterize procedures, not their creators.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
105. You can't communicate complexity, only an awareness of it.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
104. The proof of a system's value is its existence.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
31. Simplicity does not precede complexity, but follows it.
108. Whenever two programmers meet to criticize their programs, both are silent.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
57. It is easier to change the specification to fit the program than vice versa.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
76. It is the user who should parameterize procedures, not their creators.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
78. If your computer speaks English, it was probably made in Japan.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
112. Computer Science is embarrassed by the computer.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
17. If a listener nods his head when you're explaining your program, wake him up.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
40. There are two ways to write error-free programs; only the third one works.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
40. There are two ways to write error-free programs; only the third one works.
61. In programming, as in everything else, to be in error is to be reborn.
105. You can't communicate complexity, only an awareness of it.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
119. Programming is an unnatural act.
108. Whenever two programmers meet to criticize their programs, both are silent.
17. If a listener nods his head when you're explaining your program, wake him up.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
46. Like punning, programming is a play on words.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
47. As Will Rogers would have said, "There is no such thing as a free variable."
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
104. The proof of a system's value is its existence.
103. Purely applicative languages are poorly applicable.
7. It is easier to write an incorrect program than understand a correct one.
104. The proof of a system's value is its existence.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
72. An adequate bootstrap is a contradiction in terms.
4. Every program is a part of some other program and rarely fits.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
72. An adequate bootstrap is a contradiction in terms.
63. When we write programs that "learn", it turns out that we do and they don't.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
11. If you have a procedure with ten parameters, you probably missed some.
103. Purely applicative languages are poorly applicable.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
60. In seeking the unattainable, simplicity only gets in the way.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
105. You can't communicate complexity, only an awareness of it.
60. In seeking the unattainable, simplicity only gets in the way.
79. A year spent in artificial intelligence is enough to make one believe in God.
41. Some programming languages manage to absorb change, but withstand progress.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
119. Programming is an unnatural act.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
38. Structured Programming supports the law of the excluded middle.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
8. A programming language is low level when its programs require attention to the irrelevant.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
59. In English every word can be verbed. Would that it were so in our programming languages.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
57. It is easier to change the specification to fit the program than vice versa.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
95. Don't have good ideas if you aren't willing to be responsible for them.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
90. Computation has made the tree flower.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
72. An adequate bootstrap is a contradiction in terms.
4. Every program is a part of some other program and rarely fits.
7. It is easier to write an incorrect program than understand a correct one.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
114. Within a computer natural language is unnatural.
59. In English every word can be verbed. Would that it were so in our programming languages.
102. One can't proceed from the informal to the formal by formal means.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
3. Syntactic sugar causes cancer of the semicolon.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
104. The proof of a system's value is its existence.
105. You can't communicate complexity, only an awareness of it.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
104. The proof of a system's value is its existence.
59. In English every word can be verbed. Would that it were so in our programming languages.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
40. There are two ways to write error-free programs; only the third one works.
100. We will never run out of things to program as long as there is a single program around.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
17. If a listener nods his head when you're explaining your program, wake him up.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
63. When we write programs that "learn", it turns out that we do and they don't.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
21. Optimization hinders evolution.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
57. It is easier to change the specification to fit the program than vice versa.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
38. Structured Programming supports the law of the excluded middle.
119. Programming is an unnatural act.
110. Editing is a rewording activity.
102. One can't proceed from the informal to the formal by formal means.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
4. Every program is a part of some other program and rarely fits.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
3. Syntactic sugar causes cancer of the semicolon.
11. If you have a procedure with ten parameters, you probably missed some.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
63. When we write programs that "learn", it turns out that we do and they don't.
40. There are two ways to write error-free programs; only the third one works.
7. It is easier to write an incorrect program than understand a correct one.
78. If your computer speaks English, it was probably made in Japan.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
60. In seeking the unattainable, simplicity only gets in the way.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
41. Some programming languages manage to absorb change, but withstand progress.
41. Some programming languages manage to absorb change, but withstand progress.
100. We will never run out of things to program as long as there is a single program around.
114. Within a computer natural language is unnatural.
3. Syntactic sugar causes cancer of the semicolon.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
62. In computing, invariants are ephemeral.
22. A good system can't have a weak command language.
102. One can't proceed from the informal to the formal by formal means.
38. Structured Programming supports the law of the excluded middle.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
96. Computers don't introduce order anywhere as much as they expose opportunities.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
59. In English every word can be verbed. Would that it were so in our programming languages.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
23. To understand a program you must become both the machine and the program.
14. In the long run every program becomes rococo - then rubble.
47. As Will Rogers would have said, "There is no such thing as a free variable."
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
60. In seeking the unattainable, simplicity only gets in the way.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
114. Within a computer natural language is unnatural.
119. Programming is an unnatural act.
18. A program without a loop and a structured variable isn't worth writing.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
18. A program without a loop and a structured variable isn't worth writing.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
3. Syntactic sugar causes cancer of the semicolon.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
18. A program without a loop and a structured variable isn't worth writing.
59. In English every word can be verbed. Would that it were so in our programming languages.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
60. In seeking the unattainable, simplicity only gets in the way.
57. It is easier to change the specification to fit the program than vice versa.
38. Structured Programming supports the law of the excluded middle.
23. To understand a program you must become both the machine and the program.
43. In software systems, it is often the early bird that makes the worm.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
90. Computation has made the tree flower.
31. Simplicity does not precede complexity, but follows it.
78. If your computer speaks English, it was probably made in Japan.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
59. In English every word can be verbed. Would that it were so in our programming languages.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
95. Don't have good ideas if you aren't willing to be responsible for them.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
110. Editing is a rewording activity.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
63. When we write programs that "learn", it turns out that we do and they don't.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
98. In computing, the mean time to failure keeps getting shorter.
78. If your computer speaks English, it was probably made in Japan.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
90. Computation has made the tree flower.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
96. Computers don't introduce order anywhere as much as they expose opportunities.
66. Making something variable is easy. Controlling duration of constancy is the trick.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
96. Computers don't introduce order anywhere as much as they expose opportunities.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
43. In software systems, it is often the early bird that makes the worm.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
1. One man's constant is another man's variable.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
90. Computation has made the tree flower.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
31. Simplicity does not precede complexity, but follows it.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
112. Computer Science is embarrassed by the computer.
102. One can't proceed from the informal to the formal by formal means.
17. If a listener nods his head when you're explaining your program, wake him up.
105. You can't communicate complexity, only an awareness of it.
4. Every program is a part of some other program and rarely fits.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
100. We will never run out of things to program as long as there is a single program around.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
76. It is the user who should parameterize procedures, not their creators.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
95. Don't have good ideas if you aren't willing to be responsible for them.
110. Editing is a rewording activity.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
12. Recursion is the root of computation since it trades description for time.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
17. If a listener nods his head when you're explaining your program, wake him up.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
61. In programming, as in everything else, to be in error is to be reborn.
15. Everything should be built top-down, except the first time.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
43. In software systems, it is often the early bird that makes the worm.
40. There are two ways to write error-free programs; only the third one works.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
43. In software systems, it is often the early bird that makes the worm.
41. Some programming languages manage to absorb change, but withstand progress.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
3. Syntactic sugar causes cancer of the semicolon.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
115. Most people find the concept of programming obvious, but the doing impossible.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
96. Computers don't introduce order anywhere as much as they expose opportunities.
119. Programming is an unnatural act.
108. Whenever two programmers meet to criticize their programs, both are silent.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
22. A good system can't have a weak command language.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
100. We will never run out of things to program as long as there is a single program around.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
7. It is easier to write an incorrect program than understand a correct one.
22. A good system can't have a weak command language.
95. Don't have good ideas if you aren't willing to be responsible for them.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
60. In seeking the unattainable, simplicity only gets in the way.
90. Computation has made the tree flower.
12. Recursion is the root of computation since it trades description for time.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
115. Most people find the concept of programming obvious, but the doing impossible.
7. It is easier to write an incorrect program than understand a correct one.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
79. A year spent in artificial intelligence is enough to make one believe in God.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
46. Like punning, programming is a play on words.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
61. In programming, as in everything else, to be in error is to be reborn.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
8. A programming language is low level when its programs require attention to the irrelevant.
114. Within a computer natural language is unnatural.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
46. Like punning, programming is a play on words.
66. Making something variable is easy. Controlling duration of constancy is the trick.
104. The proof of a system's value is its existence.
62. In computing, invariants are ephemeral.
41. Some programming languages manage to absorb change, but withstand progress.
46. Like punning, programming is a play on words.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
59. In English every word can be verbed. Would that it were so in our programming languages.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
43. In software systems, it is often the early bird that makes the worm.
102. One can't proceed from the informal to the formal by formal means.
61. In programming, as in everything else, to be in error is to be reborn.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
8. A programming language is low level when its programs require attention to the irrelevant.
17. If a listener nods his head when you're explaining your program, wake him up.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
27. Once you understand how to write a program get someone else to write it.
79. A year spent in artificial intelligence is enough to make one believe in God.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
63. When we write programs that "learn", it turns out that we do and they don't.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
31. Simplicity does not precede complexity, but follows it.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
41. Some programming languages manage to absorb change, but withstand progress.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
41. Some programming languages manage to absorb change, but withstand progress.
78. If your computer speaks English, it was probably made in Japan.
27. Once you understand how to write a program get someone else to write it.
100. We will never run out of things to program as long as there is a single program around.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
43. In software systems, it is often the early bird that makes the worm.
102. One can't proceed from the informal to the formal by formal means.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
63. When we write programs that "learn", it turns out that we do and they don't.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
62. In computing, invariants are ephemeral.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
40. There are two ways to write error-free programs; only the third one works.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
46. Like punning, programming is a play on words.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
19. A language that doesn't affect the way you think about programming, is not worth knowing.
15. Everything should be built top-down, except the first time.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
105. You can't communicate complexity, only an awareness of it.
90. Computation has made the tree flower.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
40. There are two ways to write error-free programs; only the third one works.
95. Don't have good ideas if you aren't willing to be responsible for them.
115. Most people find the concept of programming obvious, but the doing impossible.
108. Whenever two programmers meet to criticize their programs, both are silent.
55. A LISP programmer knows the value of everything, but the cost of nothing.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
78. If your computer speaks English, it was probably made in Japan.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
104. The proof of a system's value is its existence.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
62. In computing, invariants are ephemeral.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
41. Some programming languages manage to absorb change, but withstand progress.
8. A programming language is low level when its programs require attention to the irrelevant.
66. Making something variable is easy. Controlling duration of constancy is the trick.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
19. A language that doesn't affect the way you think about programming, is not worth knowing.
72. An adequate bootstrap is a contradiction in terms.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
12. Recursion is the root of computation since it trades description for time.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
62. In computing, invariants are ephemeral.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
104. The proof of a system's value is its existence.
38. Structured Programming supports the law of the excluded middle.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
115. Most people find the concept of programming obvious, but the doing impossible.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
115. Most people find the concept of programming obvious, but the doing impossible.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
105. You can't communicate complexity, only an awareness of it.
38. Structured Programming supports the law of the excluded middle.
1. One man's constant is another man's variable.
31. Simplicity does not precede complexity, but follows it.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
63. When we write programs that "learn", it turns out that we do and they don't.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
119. Programming is an unnatural act.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
40. There are two ways to write error-free programs; only the third one works.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
15. Everything should be built top-down, except the first time.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
21. Optimization hinders evolution.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
105. You can't communicate complexity, only an awareness of it.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
108. Whenever two programmers meet to criticize their programs, both are silent.
66. Making something variable is easy. Controlling duration of constancy is the trick.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
12. Recursion is the root of computation since it trades description for time.
103. Purely applicative languages are poorly applicable.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
108. Whenever two programmers meet to criticize their programs, both are silent.
21. Optimization hinders evolution.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
119. Programming is an unnatural act.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
4. Every program is a part of some other program and rarely fits.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
111. Why did the Roman Empire collapse? What is Latin for office automation?
96. Computers don't introduce order anywhere as much as they expose opportunities.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
23. To understand a program you must become both the machine and the program.
31. Simplicity does not precede complexity, but follows it.
66. Making something variable is easy. Controlling duration of constancy is the trick.
1. One man's constant is another man's variable.
114. Within a computer natural language is unnatural.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
108. Whenever two programmers meet to criticize their programs, both are silent.
90. Computation has made the tree flower.
41. Some programming languages manage to absorb change, but withstand progress.
78. If your computer speaks English, it was probably made in Japan.
108. Whenever two programmers meet to criticize their programs, both are silent.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
60. In seeking the unattainable, simplicity only gets in the way.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
104. The proof of a system's value is its existence.
17. If a listener nods his head when you're explaining your program, wake him up.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
115. Most people find the concept of programming obvious, but the doing impossible.
108. Whenever two programmers meet to criticize their programs, both are silent.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
98. In computing, the mean time to failure keeps getting shorter.
22. A good system can't have a weak command language.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
63. When we write programs that "learn", it turns out that we do and they don't.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
41. Some programming languages manage to absorb change, but withstand progress.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
31. Simplicity does not precede complexity, but follows it.
40. There are two ways to write error-free programs; only the third one works.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
98. In computing, the mean time to failure keeps getting shorter.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
108. Whenever two programmers meet to criticize their programs, both are silent.
98. In computing, the mean time to failure keeps getting shorter.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
1. One man's constant is another man's variable.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
76. It is the user who should parameterize procedures, not their creators.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
119. Programming is an unnatural act.
38. Structured Programming supports the law of the excluded middle.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
95. Don't have good ideas if you aren't willing to be responsible for them.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
60. In seeking the unattainable, simplicity only gets in the way.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
8. A programming language is low level when its programs require attention to the irrelevant.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
103. Purely applicative languages are poorly applicable.
31. Simplicity does not precede complexity, but follows it.
4. Every program is a part of some other program and rarely fits.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
110. Editing is a rewording activity.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
11. If you have a procedure with ten parameters, you probably missed some.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
98. In computing, the mean time to failure keeps getting shorter.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
7. It is easier to write an incorrect program than understand a correct one.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
7. It is easier to write an incorrect program than understand a correct one.
4. Every program is a part of some other program and rarely fits.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
22. A good system can't have a weak command language.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
115. Most people find the concept of programming obvious, but the doing impossible.
61. In programming, as in everything else, to be in error is to be reborn.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
78. If your computer speaks English, it was probably made in Japan.
60. In seeking the unattainable, simplicity only gets in the way.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
79. A year spent in artificial intelligence is enough to make one believe in God.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
103. Purely applicative languages are poorly applicable.
57. It is easier to change the specification to fit the program than vice versa.
61. In programming, as in everything else, to be in error is to be reborn.
110. Editing is a rewording activity.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
96. Computers don't introduce order anywhere as much as they expose opportunities.
115. Most people find the concept of programming obvious, but the doing impossible.
104. The proof of a system's value is its existence.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
46. Like punning, programming is a play on words.
119. Programming is an unnatural act.
108. Whenever two programmers meet to criticize their programs, both are silent.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
47. As Will Rogers would have said, "There is no such thing as a free variable."
12. Recursion is the root of computation since it trades description for time.
4. Every program is a part of some other program and rarely fits.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
31. Simplicity does not precede complexity, but follows it.
15. Everything should be built top-down, except the first time.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
76. It is the user who should parameterize procedures, not their creators.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
61. In programming, as in everything else, to be in error is to be reborn.
104. The proof of a system's value is its existence.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
105. You can't communicate complexity, only an awareness of it.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
47. As Will Rogers would have said, "There is no such thing as a free variable."
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
57. It is easier to change the specification to fit the program than vice versa.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
21. Optimization hinders evolution.
103. Purely applicative languages are poorly applicable.
72. An adequate bootstrap is a contradiction in terms.
47. As Will Rogers would have said, "There is no such thing as a free variable."
8. A programming language is low level when its programs require attention to the irrelevant.
98. In computing, the mean time to failure keeps getting shorter.
11. If you have a procedure with ten parameters, you probably missed some.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
1. One man's constant is another man's variable.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
15. Everything should be built top-down, except the first time.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
60. In seeking the unattainable, simplicity only gets in the way.
104. The proof of a system's value is its existence.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
104. The proof of a system's value is its existence.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
62. In computing, invariants are ephemeral.
62. In computing, invariants are ephemeral.
41. Some programming languages manage to absorb change, but withstand progress.
98. In computing, the mean time to failure keeps getting shorter.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
114. Within a computer natural language is unnatural.
46. Like punning, programming is a play on words.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
102. One can't proceed from the informal to the formal by formal means.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
12. Recursion is the root of computation since it trades description for time.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
72. An adequate bootstrap is a contradiction in terms.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
111. Why did the Roman Empire collapse? What is Latin for office automation?
4. Every program is a part of some other program and rarely fits.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
47. As Will Rogers would have said, "There is no such thing as a free variable."
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
115. Most people find the concept of programming obvious, but the doing impossible.
4. Every program is a part of some other program and rarely fits.
78. If your computer speaks English, it was probably made in Japan.
79. A year spent in artificial intelligence is enough to make one believe in God.
90. Computation has made the tree flower.
115. Most people find the concept of programming obvious, but the doing impossible.
57. It is easier to change the specification to fit the program than vice versa.
7. It is easier to write an incorrect program than understand a correct one.
61. In programming, as in everything else, to be in error is to be reborn.
112. Computer Science is embarrassed by the computer.
112. Computer Science is embarrassed by the computer.
3. Syntactic sugar causes cancer of the semicolon.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
23. To understand a program you must become both the machine and the program.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
60. In seeking the unattainable, simplicity only gets in the way.
3. Syntactic sugar causes cancer of the semicolon.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
112. Computer Science is embarrassed by the computer.
119. Programming is an unnatural act.
102. One can't proceed from the informal to the formal by formal means.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
46. Like punning, programming is a play on words.
79. A year spent in artificial intelligence is enough to make one believe in God.
114. Within a computer natural language is unnatural.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
110. Editing is a rewording activity.
66. Making something variable is easy. Controlling duration of constancy is the trick.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
104. The proof of a system's value is its existence.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
3. Syntactic sugar causes cancer of the semicolon.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
95. Don't have good ideas if you aren't willing to be responsible for them.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
66. Making something variable is easy. Controlling duration of constancy is the trick.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
63. When we write programs that "learn", it turns out that we do and they don't.
108. Whenever two programmers meet to criticize their programs, both are silent.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
112. Computer Science is embarrassed by the computer.
98. In computing, the mean time to failure keeps getting shorter.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
4. Every program is a part of some other program and rarely fits.
15. Everything should be built top-down, except the first time.
103. Purely applicative languages are poorly applicable.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
40. There are two ways to write error-free programs; only the third one works.
61. In programming, as in everything else, to be in error is to be reborn.
4. Every program is a part of some other program and rarely fits.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
78. If your computer speaks English, it was probably made in Japan.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
55. A LISP programmer knows the value of everything, but the cost of nothing.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
40. There are two ways to write error-free programs; only the third one works.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
23. To understand a program you must become both the machine and the program.
72. An adequate bootstrap is a contradiction in terms.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
46. Like punning, programming is a play on words.
105. You can't communicate complexity, only an awareness of it.
7. It is easier to write an incorrect program than understand a correct one.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
79. A year spent in artificial intelligence is enough to make one believe in God.
60. In seeking the unattainable, simplicity only gets in the way.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
18. A program without a loop and a structured variable isn't worth writing.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
41. Some programming languages manage to absorb change, but withstand progress.
95. Don't have good ideas if you aren't willing to be responsible for them.
7. It is easier to write an incorrect program than understand a correct one.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
21. Optimization hinders evolution.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
96. Computers don't introduce order anywhere as much as they expose opportunities.
1. One man's constant is another man's variable.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
22. A good system can't have a weak command language.
95. Don't have good ideas if you aren't willing to be responsible for them.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
63. When we write programs that "learn", it turns out that we do and they don't.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
15. Everything should be built top-down, except the first time.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
115. Most people find the concept of programming obvious, but the doing impossible.
12. Recursion is the root of computation since it trades description for time.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
43. In software systems, it is often the early bird that makes the worm.
11. If you have a procedure with ten parameters, you probably missed some.
66. Making something variable is easy. Controlling duration of constancy is the trick.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
8. A programming language is low level when its programs require attention to the irrelevant.
72. An adequate bootstrap is a contradiction in terms.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
102. One can't proceed from the informal to the formal by formal means.
3. Syntactic sugar causes cancer of the semicolon.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
105. You can't communicate complexity, only an awareness of it.
17. If a listener nods his head when you're explaining your program, wake him up.
100. We will never run out of things to program as long as there is a single program around.
43. In software systems, it is often the early bird that makes the worm.
105. You can't communicate complexity, only an awareness of it.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
47. As Will Rogers would have said, "There is no such thing as a free variable."
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
76. It is the user who should parameterize procedures, not their creators.
79. A year spent in artificial intelligence is enough to make one believe in God.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
104. The proof of a system's value is its existence.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
108. Whenever two programmers meet to criticize their programs, both are silent.
79. A year spent in artificial intelligence is enough to make one believe in God.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
46. Like punning, programming is a play on words.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
57. It is easier to change the specification to fit the program than vice versa.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
108. Whenever two programmers meet to criticize their programs, both are silent.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
104. The proof of a system's value is its existence.
43. In software systems, it is often the early bird that makes the worm.
115. Most people find the concept of programming obvious, but the doing impossible.
114. Within a computer natural language is unnatural.
27. Once you understand how to write a program get someone else to write it.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
110. Editing is a rewording activity.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
110. Editing is a rewording activity.
108. Whenever two programmers meet to criticize their programs, both are silent.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
90. Computation has made the tree flower.
119. Programming is an unnatural act.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
23. To understand a program you must become both the machine and the program.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
79. A year spent in artificial intelligence is enough to make one believe in God.
119. Programming is an unnatural act.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
61. In programming, as in everything else, to be in error is to be reborn.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
4. Every program is a part of some other program and rarely fits.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
7. It is easier to write an incorrect program than understand a correct one.
90. Computation has made the tree flower.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
114. Within a computer natural language is unnatural.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
60. In seeking the unattainable, simplicity only gets in the way.
102. One can't proceed from the informal to the formal by formal means.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
112. Computer Science is embarrassed by the computer.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
3. Syntactic sugar causes cancer of the semicolon.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
41. Some programming languages manage to absorb change, but withstand progress.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
4. Every program is a part of some other program and rarely fits.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
60. In seeking the unattainable, simplicity only gets in the way.
40. There are two ways to write error-free programs; only the third one works.
40. There are two ways to write error-free programs; only the third one works.
112. Computer Science is embarrassed by the computer.
22. A good system can't have a weak command language.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
40. There are two ways to write error-free programs; only the third one works.
112. Computer Science is embarrassed by the computer.
96. Computers don't introduce order anywhere as much as they expose opportunities.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
104. The proof of a system's value is its existence.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
78. If your computer speaks English, it was probably made in Japan.
119. Programming is an unnatural act.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
40. There are two ways to write error-free programs; only the third one works.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
79. A year spent in artificial intelligence is enough to make one believe in God.
55. A LISP programmer knows the value of everything, but the cost of nothing.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
38. Structured Programming supports the law of the excluded middle.
78. If your computer speaks English, it was probably made in Japan.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
41. Some programming languages manage to absorb change, but withstand progress.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
40. There are two ways to write error-free programs; only the third one works.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
111. Why did the Roman Empire collapse? What is Latin for office automation?
11. If you have a procedure with ten parameters, you probably missed some.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
103. Purely applicative languages are poorly applicable.
111. Why did the Roman Empire collapse? What is Latin for office automation?
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
119. Programming is an unnatural act.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
47. As Will Rogers would have said, "There is no such thing as a free variable."
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
27. Once you understand how to write a program get someone else to write it.
59. In English every word can be verbed. Would that it were so in our programming languages.
12. Recursion is the root of computation since it trades description for time.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
31. Simplicity does not precede complexity, but follows it.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
96. Computers don't introduce order anywhere as much as they expose opportunities.
15. Everything should be built top-down, except the first time.
15. Everything should be built top-down, except the first time.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
21. Optimization hinders evolution.
66. Making something variable is easy. Controlling duration of constancy is the trick.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
46. Like punning, programming is a play on words.
15. Everything should be built top-down, except the first time.
47. As Will Rogers would have said, "There is no such thing as a free variable."
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
12. Recursion is the root of computation since it trades description for time.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
11. If you have a procedure with ten parameters, you probably missed some.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
38. Structured Programming supports the law of the excluded middle.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
55. A LISP programmer knows the value of everything, but the cost of nothing.
7. It is easier to write an incorrect program than understand a correct one.
27. Once you understand how to write a program get someone else to write it.
41. Some programming languages manage to absorb change, but withstand progress.
18. A program without a loop and a structured variable isn't worth writing.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
79. A year spent in artificial intelligence is enough to make one believe in God.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
110. Editing is a rewording activity.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
8. A programming language is low level when its programs require attention to the irrelevant.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
17. If a listener nods his head when you're explaining your program, wake him up.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
15. Everything should be built top-down, except the first time.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
12. Recursion is the root of computation since it trades description for time.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
47. As Will Rogers would have said, "There is no such thing as a free variable."
110. Editing is a rewording activity.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
76. It is the user who should parameterize procedures, not their creators.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
105. You can't communicate complexity, only an awareness of it.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
108. Whenever two programmers meet to criticize their programs, both are silent.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
21. Optimization hinders evolution.
119. Programming is an unnatural act.
55. A LISP programmer knows the value of everything, but the cost of nothing.
105. You can't communicate complexity, only an awareness of it.
60. In seeking the unattainable, simplicity only gets in the way.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
8. A programming language is low level when its programs require attention to the irrelevant.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
47. As Will Rogers would have said, "There is no such thing as a free variable."
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
59. In English every word can be verbed. Would that it were so in our programming languages.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
43. In software systems, it is often the early bird that makes the worm.
66. Making something variable is easy. Controlling duration of constancy is the trick.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
78. If your computer speaks English, it was probably made in Japan.
90. Computation has made the tree flower.
62. In computing, invariants are ephemeral.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
38. Structured Programming supports the law of the excluded middle.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
100. We will never run out of things to program as long as there is a single program around.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
19. A language that doesn't affect the way you think about programming, is not worth knowing.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
115. Most people find the concept of programming obvious, but the doing impossible.
7. It is easier to write an incorrect program than understand a correct one.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
57. It is easier to change the specification to fit the program than vice versa.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
17. If a listener nods his head when you're explaining your program, wake him up.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
12. Recursion is the root of computation since it trades description for time.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
21. Optimization hinders evolution.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
62. In computing, invariants are ephemeral.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
59. In English every word can be verbed. Would that it were so in our programming languages.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
41. Some programming languages manage to absorb change, but withstand progress.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
1. One man's constant is another man's variable.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
111. Why did the Roman Empire collapse? What is Latin for office automation?
40. There are two ways to write error-free programs; only the third one works.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
57. It is easier to change the specification to fit the program than vice versa.
95. Don't have good ideas if you aren't willing to be responsible for them.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
112. Computer Science is embarrassed by the computer.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
76. It is the user who should parameterize procedures, not their creators.
46. Like punning, programming is a play on words.
3. Syntactic sugar causes cancer of the semicolon.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
105. You can't communicate complexity, only an awareness of it.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
119. Programming is an unnatural act.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
8. A programming language is low level when its programs require attention to the irrelevant.
98. In computing, the mean time to failure keeps getting shorter.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
60. In seeking the unattainable, simplicity only gets in the way.
22. A good system can't have a weak command language.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
12. Recursion is the root of computation since it trades description for time.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
76. It is the user who should parameterize procedures, not their creators.
72. An adequate bootstrap is a contradiction in terms.
12. Recursion is the root of computation since it trades description for time.
15. Everything should be built top-down, except the first time.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
27. Once you understand how to write a program get someone else to write it.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
47. As Will Rogers would have said, "There is no such thing as a free variable."
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
31. Simplicity does not precede complexity, but follows it.
104. The proof of a system's value is its existence.
40. There are two ways to write error-free programs; only the third one works.
110. Editing is a rewording activity.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
111. Why did the Roman Empire collapse? What is Latin for office automation?
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
66. Making something variable is easy. Controlling duration of constancy is the trick.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
119. Programming is an unnatural act.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
102. One can't proceed from the informal to the formal by formal means.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
57. It is easier to change the specification to fit the program than vice versa.
57. It is easier to change the specification to fit the program than vice versa.
15. Everything should be built top-down, except the first time.
12. Recursion is the root of computation since it trades description for time.
57. It is easier to change the specification to fit the program than vice versa.
43. In software systems, it is often the early bird that makes the worm.
100. We will never run out of things to program as long as there is a single program around.
62. In computing, invariants are ephemeral.
60. In seeking the unattainable, simplicity only gets in the way.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
108. Whenever two programmers meet to criticize their programs, both are silent.
61. In programming, as in everything else, to be in error is to be reborn.
47. As Will Rogers would have said, "There is no such thing as a free variable."
66. Making something variable is easy. Controlling duration of constancy is the trick.
27. Once you understand how to write a program get someone else to write it.
104. The proof of a system's value is its existence.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
60. In seeking the unattainable, simplicity only gets in the way.
111. Why did the Roman Empire collapse? What is Latin for office automation?
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
8. A programming language is low level when its programs require attention to the irrelevant.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
90. Computation has made the tree flower.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
95. Don't have good ideas if you aren't willing to be responsible for them.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
57. It is easier to change the specification to fit the program than vice versa.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
15. Everything should be built top-down, except the first time.
79. A year spent in artificial intelligence is enough to make one believe in God.
3. Syntactic sugar causes cancer of the semicolon.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
3. Syntactic sugar causes cancer of the semicolon.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
100. We will never run out of things to program as long as there is a single program around.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
60. In seeking the unattainable, simplicity only gets in the way.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
8. A programming language is low level when its programs require attention to the irrelevant.
12. Recursion is the root of computation since it trades description for time.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
98. In computing, the mean time to failure keeps getting shorter.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
78. If your computer speaks English, it was probably made in Japan.
119. Programming is an unnatural act.
98. In computing, the mean time to failure keeps getting shorter.
90. Computation has made the tree flower.
8. A programming language is low level when its programs require attention to the irrelevant.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
22. A good system can't have a weak command language.
79. A year spent in artificial intelligence is enough to make one believe in God.
72. An adequate bootstrap is a contradiction in terms.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
112. Computer Science is embarrassed by the computer.
110. Editing is a rewording activity.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
103. Purely applicative languages are poorly applicable.
11. If you have a procedure with ten parameters, you probably missed some.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
105. You can't communicate complexity, only an awareness of it.
23. To understand a program you must become both the machine and the program.
62. In computing, invariants are ephemeral.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
114. Within a computer natural language is unnatural.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
115. Most people find the concept of programming obvious, but the doing impossible.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
3. Syntactic sugar causes cancer of the semicolon.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
112. Computer Science is embarrassed by the computer.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
62. In computing, invariants are ephemeral.
63. When we write programs that "learn", it turns out that we do and they don't.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
1. One man's constant is another man's variable.
62. In computing, invariants are ephemeral.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
108. Whenever two programmers meet to criticize their programs, both are silent.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
60. In seeking the unattainable, simplicity only gets in the way.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
57. It is easier to change the specification to fit the program than vice versa.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
79. A year spent in artificial intelligence is enough to make one believe in God.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
114. Within a computer natural language is unnatural.
112. Computer Science is embarrassed by the computer.
15. Everything should be built top-down, except the first time.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
96. Computers don't introduce order anywhere as much as they expose opportunities.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
61. In programming, as in everything else, to be in error is to be reborn.
14. In the long run every program becomes rococo - then rubble.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
4. Every program is a part of some other program and rarely fits.
100. We will never run out of things to program as long as there is a single program around.
114. Within a computer natural language is unnatural.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
61. In programming, as in everything else, to be in error is to be reborn.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
78. If your computer speaks English, it was probably made in Japan.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
47. As Will Rogers would have said, "There is no such thing as a free variable."
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
66. Making something variable is easy. Controlling duration of constancy is the trick.
114. Within a computer natural language is unnatural.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
14. In the long run every program becomes rococo - then rubble.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
18. A program without a loop and a structured variable isn't worth writing.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
60. In seeking the unattainable, simplicity only gets in the way.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
61. In programming, as in everything else, to be in error is to be reborn.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
1. One man's constant is another man's variable.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
59. In English every word can be verbed. Would that it were so in our programming languages.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
3. Syntactic sugar causes cancer of the semicolon.
103. Purely applicative languages are poorly applicable.
46. Like punning, programming is a play on words.
40. There are two ways to write error-free programs; only the third one works.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
102. One can't proceed from the informal to the formal by formal means.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
46. Like punning, programming is a play on words.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
41. Some programming languages manage to absorb change, but withstand progress.
7. It is easier to write an incorrect program than understand a correct one.
3. Syntactic sugar causes cancer of the semicolon.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
17. If a listener nods his head when you're explaining your program, wake him up.
119. Programming is an unnatural act.
38. Structured Programming supports the law of the excluded middle.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
78. If your computer speaks English, it was probably made in Japan.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
61. In programming, as in everything else, to be in error is to be reborn.
115. Most people find the concept of programming obvious, but the doing impossible.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
11. If you have a procedure with ten parameters, you probably missed some.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
100. We will never run out of things to program as long as there is a single program around.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
46. Like punning, programming is a play on words.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
63. When we write programs that "learn", it turns out that we do and they don't.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
3. Syntactic sugar causes cancer of the semicolon.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
15. Everything should be built top-down, except the first time.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
43. In software systems, it is often the early bird that makes the worm.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
108. Whenever two programmers meet to criticize their programs, both are silent.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
90. Computation has made the tree flower.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
79. A year spent in artificial intelligence is enough to make one believe in God.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
27. Once you understand how to write a program get someone else to write it.
95. Don't have good ideas if you aren't willing to be responsible for them.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
105. You can't communicate complexity, only an awareness of it.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
57. It is easier to change the specification to fit the program than vice versa.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
31. Simplicity does not precede complexity, but follows it.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
