10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
60. In seeking the unattainable, simplicity only gets in the way.
60. In seeking the unattainable, simplicity only gets in the way.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
12. Recursion is the root of computation since it trades description for time.
12. Recursion is the root of computation since it trades description for time.
43. In software systems, it is often the early bird that makes the worm.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
108. Whenever two programmers meet to criticize their programs, both are silent.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
55. A LISP programmer knows the value of everything, but the cost of nothing.
17. If a listener nods his head when you're explaining your program, wake him up.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
111. Why did the Roman Empire collapse? What is Latin for office automation?
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
38. Structured Programming supports the law of the excluded middle.
72. An adequate bootstrap is a contradiction in terms.
79. A year spent in artificial intelligence is enough to make one believe in God.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
38. Structured Programming supports the law of the excluded middle.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
103. Purely applicative languages are poorly applicable.
1. One man's constant is another man's variable.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
27. Once you understand how to write a program get someone else to write it.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
105. You can't communicate complexity, only an awareness of it.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
27. Once you understand how to write a program get someone else to write it.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
40. There are two ways to write error-free programs; only the third one works.
112. Computer Science is embarrassed by the computer.
43. In software systems, it is often the early bird that makes the worm.
55. A LISP programmer knows the value of everything, but the cost of nothing.
59. In English every word can be verbed. Would that it were so in our programming languages.
103. Purely applicative languages are poorly applicable.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
102. One can't proceed from the informal to the formal by formal means.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
95. Don't have good ideas if you aren't willing to be responsible for them.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
61. In programming, as in everything else, to be in error is to be reborn.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
60. In seeking the unattainable, simplicity only gets in the way.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
112. Computer Science is embarrassed by the computer.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
17. If a listener nods his head when you're explaining your program, wake him up.
7. It is easier to write an incorrect program than understand a correct one.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
102. One can't proceed from the informal to the formal by formal means.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
119. Programming is an unnatural act.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
46. Like punning, programming is a play on words.
22. A good system can't have a weak command language.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
46. Like punning, programming is a play on words.
14. In the long run every program becomes rococo - then rubble.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
40. There are two ways to write error-free programs; only the third one works.
102. One can't proceed from the informal to the formal by formal means.
100. We will never run out of things to program as long as there is a single program around.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
79. A year spent in artificial intelligence is enough to make one believe in God.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
23. To understand a program you must become both the machine and the program.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
119. Programming is an unnatural act.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
7. It is easier to write an incorrect program than understand a correct one.
3. Syntactic sugar causes cancer of the semicolon.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
60. In seeking the unattainable, simplicity only gets in the way.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
15. Everything should be built top-down, except the first time.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
41. Some programming languages manage to absorb change, but withstand progress.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
76. It is the user who should parameterize procedures, not their creators.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
63. When we write programs that "learn", it turns out that we do and they don't.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
95. Don't have good ideas if you aren't willing to be responsible for them.
15. Everything should be built top-down, except the first time.
102. One can't proceed from the informal to the formal by formal means.
59. In English every word can be verbed. Would that it were so in our programming languages.
119. Programming is an unnatural act.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
47. As Will Rogers would have said, "There is no such thing as a free variable."
14. In the long run every program becomes rococo - then rubble.
43. In software systems, it is often the early bird that makes the worm.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
62. In computing, invariants are ephemeral.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
98. In computing, the mean time to failure keeps getting shorter.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
57. It is easier to change the specification to fit the program than vice versa.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
38. Structured Programming supports the law of the excluded middle.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
18. A program without a loop and a structured variable isn't worth writing.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
95. Don't have good ideas if you aren't willing to be responsible for them.
3. Syntactic sugar causes cancer of the semicolon.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
60. In seeking the unattainable, simplicity only gets in the way.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
102. One can't proceed from the informal to the formal by formal means.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
7. It is easier to write an incorrect program than understand a correct one.
21. Optimization hinders evolution.
105. You can't communicate complexity, only an awareness of it.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
78. If your computer speaks English, it was probably made in Japan.
55. A LISP programmer knows the value of everything, but the cost of nothing.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
63. When we write programs that "learn", it turns out that we do and they don't.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
27. Once you understand how to write a program get someone else to write it.
119. Programming is an unnatural act.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
57. It is easier to change the specification to fit the program than vice versa.
11. If you have a procedure with ten parameters, you probably missed some.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
31. Simplicity does not precede complexity, but follows it.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
57. It is easier to change the specification to fit the program than vice versa.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
79. A year spent in artificial intelligence is enough to make one believe in God.
31. Simplicity does not precede complexity, but follows it.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
115. Most people find the concept of programming obvious, but the doing impossible.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
40. There are two ways to write error-free programs; only the third one works.
15. Everything should be built top-down, except the first time.
46. Like punning, programming is a play on words.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
103. Purely applicative languages are poorly applicable.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
3. Syntactic sugar causes cancer of the semicolon.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
43. In software systems, it is often the early bird that makes the worm.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
4. Every program is a part of some other program and rarely fits.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
105. You can't communicate complexity, only an awareness of it.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
112. Computer Science is embarrassed by the computer.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
61. In programming, as in everything else, to be in error is to be reborn.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
78. If your computer speaks English, it was probably made in Japan.
105. You can't communicate complexity, only an awareness of it.
12. Recursion is the root of computation since it trades description for time.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
62. In computing, invariants are ephemeral.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
4. Every program is a part of some other program and rarely fits.
78. If your computer speaks English, it was probably made in Japan.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
95. Don't have good ideas if you aren't willing to be responsible for them.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
12. Recursion is the root of computation since it trades description for time.
76. It is the user who should parameterize procedures, not their creators.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
18. A program without a loop and a structured variable isn't worth writing.
3. Syntactic sugar causes cancer of the semicolon.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
96. Computers don't introduce order anywhere as much as they expose opportunities.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
1. One man's constant is another man's variable.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
96. Computers don't introduce order anywhere as much as they expose opportunities.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
55. A LISP programmer knows the value of everything, but the cost of nothing.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
115. Most people find the concept of programming obvious, but the doing impossible.
57. It is easier to change the specification to fit the program than vice versa.
115. Most people find the concept of programming obvious, but the doing impossible.
18. A program without a loop and a structured variable isn't worth writing.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
98. In computing, the mean time to failure keeps getting shorter.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
115. Most people find the concept of programming obvious, but the doing impossible.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
100. We will never run out of things to program as long as there is a single program around.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
102. One can't proceed from the informal to the formal by formal means.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
63. When we write programs that "learn", it turns out that we do and they don't.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
112. Computer Science is embarrassed by the computer.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
18. A program without a loop and a structured variable isn't worth writing.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
79. A year spent in artificial intelligence is enough to make one believe in God.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
108. Whenever two programmers meet to criticize their programs, both are silent.
98. In computing, the mean time to failure keeps getting shorter.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
41. Some programming languages manage to absorb change, but withstand progress.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
21. Optimization hinders evolution.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
55. A LISP programmer knows the value of everything, but the cost of nothing.
18. A program without a loop and a structured variable isn't worth writing.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
114. Within a computer natural language is unnatural.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
78. If your computer speaks English, it was probably made in Japan.
21. Optimization hinders evolution.
38. Structured Programming supports the law of the excluded middle.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
78. If your computer speaks English, it was probably made in Japan.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
98. In computing, the mean time to failure keeps getting shorter.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
23. To understand a program you must become both the machine and the program.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
95. Don't have good ideas if you aren't willing to be responsible for them.
12. Recursion is the root of computation since it trades description for time.
40. There are two ways to write error-free programs; only the third one works.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
105. You can't communicate complexity, only an awareness of it.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
18. A program without a loop and a structured variable isn't worth writing.
38. Structured Programming supports the law of the excluded middle.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
17. If a listener nods his head when you're explaining your program, wake him up.
11. If you have a procedure with ten parameters, you probably missed some.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
31. Simplicity does not precede complexity, but follows it.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
104. The proof of a system's value is its existence.
115. Most people find the concept of programming obvious, but the doing impossible.
61. In programming, as in everything else, to be in error is to be reborn.
114. Within a computer natural language is unnatural.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
59. In English every word can be verbed. Would that it were so in our programming languages.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
66. Making something variable is easy. Controlling duration of constancy is the trick.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
90. Computation has made the tree flower.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
17. If a listener nods his head when you're explaining your program, wake him up.
76. It is the user who should parameterize procedures, not their creators.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
5. If a program manipulates a large amount of data, it does so in a small number of ways.
27. Once you understand how to write a program get someone else to write it.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
119. Programming is an unnatural act.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
59. In English every word can be verbed. Would that it were so in our programming languages.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
119. Programming is an unnatural act.
21. Optimization hinders evolution.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
15. Everything should be built top-down, except the first time.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
104. The proof of a system's value is its existence.
102. One can't proceed from the informal to the formal by formal means.
98. In computing, the mean time to failure keeps getting shorter.
55. A LISP programmer knows the value of everything, but the cost of nothing.
3. Syntactic sugar causes cancer of the semicolon.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
31. Simplicity does not precede complexity, but follows it.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
4. Every program is a part of some other program and rarely fits.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
21. Optimization hinders evolution.
14. In the long run every program becomes rococo - then rubble.
114. Within a computer natural language is unnatural.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
62. In computing, invariants are ephemeral.
15. Everything should be built top-down, except the first time.
4. Every program is a part of some other program and rarely fits.
76. It is the user who should parameterize procedures, not their creators.
4. Every program is a part of some other program and rarely fits.
57. It is easier to change the specification to fit the program than vice versa.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
57. It is easier to change the specification to fit the program than vice versa.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
105. You can't communicate complexity, only an awareness of it.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
76. It is the user who should parameterize procedures, not their creators.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
43. In software systems, it is often the early bird that makes the worm.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
7. It is easier to write an incorrect program than understand a correct one.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
40. There are two ways to write error-free programs; only the third one works.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
21. Optimization hinders evolution.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
59. In English every word can be verbed. Would that it were so in our programming languages.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
60. In seeking the unattainable, simplicity only gets in the way.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
41. Some programming languages manage to absorb change, but withstand progress.
112. Computer Science is embarrassed by the computer.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
100. We will never run out of things to program as long as there is a single program around.
78. If your computer speaks English, it was probably made in Japan.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
62. In computing, invariants are ephemeral.
78. If your computer speaks English, it was probably made in Japan.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
90. Computation has made the tree flower.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
66. Making something variable is easy. Controlling duration of constancy is the trick.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
112. Computer Science is embarrassed by the computer.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
103. Purely applicative languages are poorly applicable.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
22. A good system can't have a weak command language.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
90. Computation has made the tree flower.
103. Purely applicative languages are poorly applicable.
14. In the long run every program becomes rococo - then rubble.
62. In computing, invariants are ephemeral.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
102. One can't proceed from the informal to the formal by formal means.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
76. It is the user who should parameterize procedures, not their creators.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
108. Whenever two programmers meet to criticize their programs, both are silent.
15. Everything should be built top-down, except the first time.
105. You can't communicate complexity, only an awareness of it.
76. It is the user who should parameterize procedures, not their creators.
103. Purely applicative languages are poorly applicable.
62. In computing, invariants are ephemeral.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
40. There are two ways to write error-free programs; only the third one works.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
79. A year spent in artificial intelligence is enough to make one believe in God.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
59. In English every word can be verbed. Would that it were so in our programming languages.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
111. Why did the Roman Empire collapse? What is Latin for office automation?
40. There are two ways to write error-free programs; only the third one works.
102. One can't proceed from the informal to the formal by formal means.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
96. Computers don't introduce order anywhere as much as they expose opportunities.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
14. In the long run every program becomes rococo - then rubble.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
47. As Will Rogers would have said, "There is no such thing as a free variable."
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
103. Purely applicative languages are poorly applicable.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
72. An adequate bootstrap is a contradiction in terms.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
22. A good system can't have a weak command language.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
119. Programming is an unnatural act.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
72. An adequate bootstrap is a contradiction in terms.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
1. One man's constant is another man's variable.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
96. Computers don't introduce order anywhere as much as they expose opportunities.
14. In the long run every program becomes rococo - then rubble.
40. There are two ways to write error-free programs; only the third one works.
105. You can't communicate complexity, only an awareness of it.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
105. You can't communicate complexity, only an awareness of it.
14. In the long run every program becomes rococo - then rubble.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
41. Some programming languages manage to absorb change, but withstand progress.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
98. In computing, the mean time to failure keeps getting shorter.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
98. In computing, the mean time to failure keeps getting shorter.
103. Purely applicative languages are poorly applicable.
1. One man's constant is another man's variable.
62. In computing, invariants are ephemeral.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
79. A year spent in artificial intelligence is enough to make one believe in God.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
119. Programming is an unnatural act.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
110. Editing is a rewording activity.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
11. If you have a procedure with ten parameters, you probably missed some.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
59. In English every word can be verbed. Would that it were so in our programming languages.
41. Some programming languages manage to absorb change, but withstand progress.
27. Once you understand how to write a program get someone else to write it.
47. As Will Rogers would have said, "There is no such thing as a free variable."
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
63. When we write programs that "learn", it turns out that we do and they don't.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
108. Whenever two programmers meet to criticize their programs, both are silent.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
62. In computing, invariants are ephemeral.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
60. In seeking the unattainable, simplicity only gets in the way.
60. In seeking the unattainable, simplicity only gets in the way.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
14. In the long run every program becomes rococo - then rubble.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
76. It is the user who should parameterize procedures, not their creators.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
62. In computing, invariants are ephemeral.
57. It is easier to change the specification to fit the program than vice versa.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
72. An adequate bootstrap is a contradiction in terms.
38. Structured Programming supports the law of the excluded middle.
43. In software systems, it is often the early bird that makes the worm.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
12. Recursion is the root of computation since it trades description for time.
95. Don't have good ideas if you aren't willing to be responsible for them.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
15. Everything should be built top-down, except the first time.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
78. If your computer speaks English, it was probably made in Japan.
98. In computing, the mean time to failure keeps getting shorter.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
57. It is easier to change the specification to fit the program than vice versa.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
112. Computer Science is embarrassed by the computer.
102. One can't proceed from the informal to the formal by formal means.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
115. Most people find the concept of programming obvious, but the doing impossible.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
111. Why did the Roman Empire collapse? What is Latin for office automation?
15. Everything should be built top-down, except the first time.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
21. Optimization hinders evolution.
90. Computation has made the tree flower.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
21. Optimization hinders evolution.
79. A year spent in artificial intelligence is enough to make one believe in God.
61. In programming, as in everything else, to be in error is to be reborn.
21. Optimization hinders evolution.
15. Everything should be built top-down, except the first time.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
112. Computer Science is embarrassed by the computer.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
1. One man's constant is another man's variable.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
47. As Will Rogers would have said, "There is no such thing as a free variable."
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
111. Why did the Roman Empire collapse? What is Latin for office automation?
78. If your computer speaks English, it was probably made in Japan.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
114. Within a computer natural language is unnatural.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
79. A year spent in artificial intelligence is enough to make one believe in God.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
15. Everything should be built top-down, except the first time.
18. A program without a loop and a structured variable isn't worth writing.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
43. In software systems, it is often the early bird that makes the worm.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
18. A program without a loop and a structured variable isn't worth writing.
38. Structured Programming supports the law of the excluded middle.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
62. In computing, invariants are ephemeral.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
103. Purely applicative languages are poorly applicable.
8. A programming language is low level when its programs require attention to the irrelevant.
105. You can't communicate complexity, only an awareness of it.
62. In computing, invariants are ephemeral.
40. There are two ways to write error-free programs; only the third one works.
96. Computers don't introduce order anywhere as much as they expose opportunities.
98. In computing, the mean time to failure keeps getting shorter.
115. Most people find the concept of programming obvious, but the doing impossible.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
21. Optimization hinders evolution.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
66. Making something variable is easy. Controlling duration of constancy is the trick.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
115. Most people find the concept of programming obvious, but the doing impossible.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
14. In the long run every program becomes rococo - then rubble.
46. Like punning, programming is a play on words.
61. In programming, as in everything else, to be in error is to be reborn.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
105. You can't communicate complexity, only an awareness of it.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
11. If you have a procedure with ten parameters, you probably missed some.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
40. There are two ways to write error-free programs; only the third one works.
103. Purely applicative languages are poorly applicable.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
62. In computing, invariants are ephemeral.
114. Within a computer natural language is unnatural.
11. If you have a procedure with ten parameters, you probably missed some.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
14. In the long run every program becomes rococo - then rubble.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
114. Within a computer natural language is unnatural.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
100. We will never run out of things to program as long as there is a single program around.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
66. Making something variable is easy. Controlling duration of constancy is the trick.
98. In computing, the mean time to failure keeps getting shorter.
96. Computers don't introduce order anywhere as much as they expose opportunities.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
62. In computing, invariants are ephemeral.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
4. Every program is a part of some other program and rarely fits.
1. One man's constant is another man's variable.
17. If a listener nods his head when you're explaining your program, wake him up.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
105. You can't communicate complexity, only an awareness of it.
15. Everything should be built top-down, except the first time.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
98. In computing, the mean time to failure keeps getting shorter.
22. A good system can't have a weak command language.
41. Some programming languages manage to absorb change, but withstand progress.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
60. In seeking the unattainable, simplicity only gets in the way.
103. Purely applicative languages are poorly applicable.
104. The proof of a system's value is its existence.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
57. It is easier to change the specification to fit the program than vice versa.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
90. Computation has made the tree flower.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
112. Computer Science is embarrassed by the computer.
102. One can't proceed from the informal to the formal by formal means.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
8. A programming language is low level when its programs require attention to the irrelevant.
12. Recursion is the root of computation since it trades description for time.
90. Computation has made the tree flower.
8. A programming language is low level when its programs require attention to the irrelevant.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
4. Every program is a part of some other program and rarely fits.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
46. Like punning, programming is a play on words.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
55. A LISP programmer knows the value of everything, but the cost of nothing.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
105. You can't communicate complexity, only an awareness of it.
90. Computation has made the tree flower.
7. It is easier to write an incorrect program than understand a correct one.
55. A LISP programmer knows the value of everything, but the cost of nothing.
27. Once you understand how to write a program get someone else to write it.
59. In English every word can be verbed. Would that it were so in our programming languages.
14. In the long run every program becomes rococo - then rubble.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
47. As Will Rogers would have said, "There is no such thing as a free variable."
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
15. Everything should be built top-down, except the first time.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
4. Every program is a part of some other program and rarely fits.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
104. The proof of a system's value is its existence.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
98. In computing, the mean time to failure keeps getting shorter.
79. A year spent in artificial intelligence is enough to make one believe in God.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
5. If a program manipulates a large amount of data, it does so in a small number of ways.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
55. A LISP programmer knows the value of everything, but the cost of nothing.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
55. A LISP programmer knows the value of everything, but the cost of nothing.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
46. Like punning, programming is a play on words.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
102. One can't proceed from the informal to the formal by formal means.
108. Whenever two programmers meet to criticize their programs, both are silent.
40. There are two ways to write error-free programs; only the third one works.
95. Don't have good ideas if you aren't willing to be responsible for them.
27. Once you understand how to write a program get someone else to write it.
96. Computers don't introduce order anywhere as much as they expose opportunities.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
59. In English every word can be verbed. Would that it were so in our programming languages.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
112. Computer Science is embarrassed by the computer.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
31. Simplicity does not precede complexity, but follows it.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
23. To understand a program you must become both the machine and the program.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
7. It is easier to write an incorrect program than understand a correct one.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
100. We will never run out of things to program as long as there is a single program around.
15. Everything should be built top-down, except the first time.
59. In English every word can be verbed. Would that it were so in our programming languages.
22. A good system can't have a weak command language.
119. Programming is an unnatural act.
96. Computers don't introduce order anywhere as much as they expose opportunities.
15. Everything should be built top-down, except the first time.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
17. If a listener nods his head when you're explaining your program, wake him up.
112. Computer Science is embarrassed by the computer.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
15. Everything should be built top-down, except the first time.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
104. The proof of a system's value is its existence.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
103. Purely applicative languages are poorly applicable.
115. Most people find the concept of programming obvious, but the doing impossible.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
43. In software systems, it is often the early bird that makes the worm.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
115. Most people find the concept of programming obvious, but the doing impossible.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
60. In seeking the unattainable, simplicity only gets in the way.
90. Computation has made the tree flower.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
59. In English every word can be verbed. Would that it were so in our programming languages.
15. Everything should be built top-down, except the first time.
119. Programming is an unnatural act.
115. Most people find the concept of programming obvious, but the doing impossible.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
90. Computation has made the tree flower.
59. In English every word can be verbed. Would that it were so in our programming languages.
57. It is easier to change the specification to fit the program than vice versa.
4. Every program is a part of some other program and rarely fits.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
119. Programming is an unnatural act.
1. One man's constant is another man's variable.
95. Don't have good ideas if you aren't willing to be responsible for them.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
119. Programming is an unnatural act.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
108. Whenever two programmers meet to criticize their programs, both are silent.
46. Like punning, programming is a play on words.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
57. It is easier to change the specification to fit the program than vice versa.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
76. It is the user who should parameterize procedures, not their creators.
112. Computer Science is embarrassed by the computer.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
46. Like punning, programming is a play on words.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
27. Once you understand how to write a program get someone else to write it.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
57. It is easier to change the specification to fit the program than vice versa.
95. Don't have good ideas if you aren't willing to be responsible for them.
108. Whenever two programmers meet to criticize their programs, both are silent.
104. The proof of a system's value is its existence.
43. In software systems, it is often the early bird that makes the worm.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
15. Everything should be built top-down, except the first time.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
40. There are two ways to write error-free programs; only the third one works.
61. In programming, as in everything else, to be in error is to be reborn.
57. It is easier to change the specification to fit the program than vice versa.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
63. When we write programs that "learn", it turns out that we do and they don't.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
3. Syntactic sugar causes cancer of the semicolon.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
59. In English every word can be verbed. Would that it were so in our programming languages.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
110. Editing is a rewording activity.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
90. Computation has made the tree flower.
108. Whenever two programmers meet to criticize their programs, both are silent.
41. Some programming languages manage to absorb change, but withstand progress.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
78. If your computer speaks English, it was probably made in Japan.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
115. Most people find the concept of programming obvious, but the doing impossible.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
112. Computer Science is embarrassed by the computer.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
62. In computing, invariants are ephemeral.
112. Computer Science is embarrassed by the computer.
23. To understand a program you must become both the machine and the program.
114. Within a computer natural language is unnatural.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
63. When we write programs that "learn", it turns out that we do and they don't.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
60. In seeking the unattainable, simplicity only gets in the way.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
98. In computing, the mean time to failure keeps getting shorter.
47. As Will Rogers would have said, "There is no such thing as a free variable."
55. A LISP programmer knows the value of everything, but the cost of nothing.
79. A year spent in artificial intelligence is enough to make one believe in God.
62. In computing, invariants are ephemeral.
11. If you have a procedure with ten parameters, you probably missed some.
22. A good system can't have a weak command language.
11. If you have a procedure with ten parameters, you probably missed some.
105. You can't communicate complexity, only an awareness of it.
15. Everything should be built top-down, except the first time.
66. Making something variable is easy. Controlling duration of constancy is the trick.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
114. Within a computer natural language is unnatural.
102. One can't proceed from the informal to the formal by formal means.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
12. Recursion is the root of computation since it trades description for time.
79. A year spent in artificial intelligence is enough to make one believe in God.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
90. Computation has made the tree flower.
11. If you have a procedure with ten parameters, you probably missed some.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
1. One man's constant is another man's variable.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
72. An adequate bootstrap is a contradiction in terms.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
12. Recursion is the root of computation since it trades description for time.
79. A year spent in artificial intelligence is enough to make one believe in God.
105. You can't communicate complexity, only an awareness of it.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
78. If your computer speaks English, it was probably made in Japan.
63. When we write programs that "learn", it turns out that we do and they don't.
47. As Will Rogers would have said, "There is no such thing as a free variable."
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
4. Every program is a part of some other program and rarely fits.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
1. One man's constant is another man's variable.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
61. In programming, as in everything else, to be in error is to be reborn.
15. Everything should be built top-down, except the first time.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
31. Simplicity does not precede complexity, but follows it.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
22. A good system can't have a weak command language.
55. A LISP programmer knows the value of everything, but the cost of nothing.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
17. If a listener nods his head when you're explaining your program, wake him up.
100. We will never run out of things to program as long as there is a single program around.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
100. We will never run out of things to program as long as there is a single program around.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
38. Structured Programming supports the law of the excluded middle.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
95. Don't have good ideas if you aren't willing to be responsible for them.
18. A program without a loop and a structured variable isn't worth writing.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
114. Within a computer natural language is unnatural.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
8. A programming language is low level when its programs require attention to the irrelevant.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
60. In seeking the unattainable, simplicity only gets in the way.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
62. In computing, invariants are ephemeral.
78. If your computer speaks English, it was probably made in Japan.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
98. In computing, the mean time to failure keeps getting shorter.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
62. In computing, invariants are ephemeral.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
63. When we write programs that "learn", it turns out that we do and they don't.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
115. Most people find the concept of programming obvious, but the doing impossible.
105. You can't communicate complexity, only an awareness of it.
115. Most people find the concept of programming obvious, but the doing impossible.
4. Every program is a part of some other program and rarely fits.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
11. If you have a procedure with ten parameters, you probably missed some.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
40. There are two ways to write error-free programs; only the third one works.
47. As Will Rogers would have said, "There is no such thing as a free variable."
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
96. Computers don't introduce order anywhere as much as they expose opportunities.
79. A year spent in artificial intelligence is enough to make one believe in God.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
18. A program without a loop and a structured variable isn't worth writing.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
18. A program without a loop and a structured variable isn't worth writing.
27. Once you understand how to write a program get someone else to write it.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
55. A LISP programmer knows the value of everything, but the cost of nothing.
63. When we write programs that "learn", it turns out that we do and they don't.
17. If a listener nods his head when you're explaining your program, wake him up.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
59. In English every word can be verbed. Would that it were so in our programming languages.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
40. There are two ways to write error-free programs; only the third one works.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
4. Every program is a part of some other program and rarely fits.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
102. One can't proceed from the informal to the formal by formal means.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
46. Like punning, programming is a play on words.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
1. One man's constant is another man's variable.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
12. Recursion is the root of computation since it trades description for time.
1. One man's constant is another man's variable.
40. There are two ways to write error-free programs; only the third one works.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
23. To understand a program you must become both the machine and the program.
40. There are two ways to write error-free programs; only the third one works.
111. Why did the Roman Empire collapse? What is Latin for office automation?
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
104. The proof of a system's value is its existence.
108. Whenever two programmers meet to criticize their programs, both are silent.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
12. Recursion is the root of computation since it trades description for time.
14. In the long run every program becomes rococo - then rubble.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
17. If a listener nods his head when you're explaining your program, wake him up.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
60. In seeking the unattainable, simplicity only gets in the way.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
100. We will never run out of things to program as long as there is a single program around.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
40. There are two ways to write error-free programs; only the third one works.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
47. As Will Rogers would have said, "There is no such thing as a free variable."
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
76. It is the user who should parameterize procedures, not their creators.
47. As Will Rogers would have said, "There is no such thing as a free variable."
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
95. Don't have good ideas if you aren't willing to be responsible for them.
72. An adequate bootstrap is a contradiction in terms.
104. The proof of a system's value is its existence.
41. Some programming languages manage to absorb change, but withstand progress.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
8. A programming language is low level when its programs require attention to the irrelevant.
3. Syntactic sugar causes cancer of the semicolon.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
14. In the long run every program becomes rococo - then rubble.
114. Within a computer natural language is unnatural.
40. There are two ways to write error-free programs; only the third one works.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
17. If a listener nods his head when you're explaining your program, wake him up.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
66. Making something variable is easy. Controlling duration of constancy is the trick.
59. In English every word can be verbed. Would that it were so in our programming languages.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
21. Optimization hinders evolution.
8. A programming language is low level when its programs require attention to the irrelevant.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
23. To understand a program you must become both the machine and the program.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
98. In computing, the mean time to failure keeps getting shorter.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
11. If you have a procedure with ten parameters, you probably missed some.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
96. Computers don't introduce order anywhere as much as they expose opportunities.
14. In the long run every program becomes rococo - then rubble.
15. Everything should be built top-down, except the first time.
3. Syntactic sugar causes cancer of the semicolon.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
47. As Will Rogers would have said, "There is no such thing as a free variable."
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
23. To understand a program you must become both the machine and the program.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
96. Computers don't introduce order anywhere as much as they expose opportunities.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
27. Once you understand how to write a program get someone else to write it.
104. The proof of a system's value is its existence.
11. If you have a procedure with ten parameters, you probably missed some.
110. Editing is a rewording activity.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
115. Most people find the concept of programming obvious, but the doing impossible.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
14. In the long run every program becomes rococo - then rubble.
59. In English every word can be verbed. Would that it were so in our programming languages.
55. A LISP programmer knows the value of everything, but the cost of nothing.
4. Every program is a part of some other program and rarely fits.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
55. A LISP programmer knows the value of everything, but the cost of nothing.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
60. In seeking the unattainable, simplicity only gets in the way.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
98. In computing, the mean time to failure keeps getting shorter.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
78. If your computer speaks English, it was probably made in Japan.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
78. If your computer speaks English, it was probably made in Japan.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
96. Computers don't introduce order anywhere as much as they expose opportunities.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
79. A year spent in artificial intelligence is enough to make one believe in God.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
21. Optimization hinders evolution.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
4. Every program is a part of some other program and rarely fits.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
66. Making something variable is easy. Controlling duration of constancy is the trick.
11. If you have a procedure with ten parameters, you probably missed some.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
59. In English every word can be verbed. Would that it were so in our programming languages.
66. Making something variable is easy. Controlling duration of constancy is the trick.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
63. When we write programs that "learn", it turns out that we do and they don't.
21. Optimization hinders evolution.
55. A LISP programmer knows the value of everything, but the cost of nothing.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
112. Computer Science is embarrassed by the computer.
110. Editing is a rewording activity.
111. Why did the Roman Empire collapse? What is Latin for office automation?
12. Recursion is the root of computation since it trades description for time.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
90. Computation has made the tree flower.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
21. Optimization hinders evolution.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
78. If your computer speaks English, it was probably made in Japan.
8. A programming language is low level when its programs require attention to the irrelevant.
78. If your computer speaks English, it was probably made in Japan.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
55. A LISP programmer knows the value of everything, but the cost of nothing.
79. A year spent in artificial intelligence is enough to make one believe in God.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
102. One can't proceed from the informal to the formal by formal means.
31. Simplicity does not precede complexity, but follows it.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
112. Computer Science is embarrassed by the computer.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
78. If your computer speaks English, it was probably made in Japan.
100. We will never run out of things to program as long as there is a single program around.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
31. Simplicity does not precede complexity, but follows it.
60. In seeking the unattainable, simplicity only gets in the way.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
100. We will never run out of things to program as long as there is a single program around.
38. Structured Programming supports the law of the excluded middle.
57. It is easier to change the specification to fit the program than vice versa.
104. The proof of a system's value is its existence.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
7. It is easier to write an incorrect program than understand a correct one.
3. Syntactic sugar causes cancer of the semicolon.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
102. One can't proceed from the informal to the formal by formal means.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
40. There are two ways to write error-free programs; only the third one works.
72. An adequate bootstrap is a contradiction in terms.
103. Purely applicative languages are poorly applicable.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
110. Editing is a rewording activity.
96. Computers don't introduce order anywhere as much as they expose opportunities.
27. Once you understand how to write a program get someone else to write it.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
112. Computer Science is embarrassed by the computer.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
105. You can't communicate complexity, only an awareness of it.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
27. Once you understand how to write a program get someone else to write it.
46. Like punning, programming is a play on words.
17. If a listener nods his head when you're explaining your program, wake him up.
59. In English every word can be verbed. Would that it were so in our programming languages.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
7. It is easier to write an incorrect program than understand a correct one.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
78. If your computer speaks English, it was probably made in Japan.
72. An adequate bootstrap is a contradiction in terms.
17. If a listener nods his head when you're explaining your program, wake him up.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
112. Computer Science is embarrassed by the computer.
46. Like punning, programming is a play on words.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
43. In software systems, it is often the early bird that makes the worm.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
21. Optimization hinders evolution.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
95. Don't have good ideas if you aren't willing to be responsible for them.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
111. Why did the Roman Empire collapse? What is Latin for office automation?
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
4. Every program is a part of some other program and rarely fits.
46. Like punning, programming is a play on words.
100. We will never run out of things to program as long as there is a single program around.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
111. Why did the Roman Empire collapse? What is Latin for office automation?
8. A programming language is low level when its programs require attention to the irrelevant.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
60. In seeking the unattainable, simplicity only gets in the way.
62. In computing, invariants are ephemeral.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
22. A good system can't have a weak command language.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
72. An adequate bootstrap is a contradiction in terms.
114. Within a computer natural language is unnatural.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
119. Programming is an unnatural act.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
119. Programming is an unnatural act.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
57. It is easier to change the specification to fit the program than vice versa.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
46. Like punning, programming is a play on words.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
119. Programming is an unnatural act.
7. It is easier to write an incorrect program than understand a correct one.
114. Within a computer natural language is unnatural.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
100. We will never run out of things to program as long as there is a single program around.
90. Computation has made the tree flower.
62. In computing, invariants are ephemeral.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
12. Recursion is the root of computation since it trades description for time.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
11. If you have a procedure with ten parameters, you probably missed some.
108. Whenever two programmers meet to criticize their programs, both are silent.
112. Computer Science is embarrassed by the computer.
119. Programming is an unnatural act.
72. An adequate bootstrap is a contradiction in terms.
111. Why did the Roman Empire collapse? What is Latin for office automation?
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
47. As Will Rogers would have said, "There is no such thing as a free variable."
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
78. If your computer speaks English, it was probably made in Japan.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
104. The proof of a system's value is its existence.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
22. A good system can't have a weak command language.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
3. Syntactic sugar causes cancer of the semicolon.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
27. Once you understand how to write a program get someone else to write it.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
102. One can't proceed from the informal to the formal by formal means.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
12. Recursion is the root of computation since it trades description for time.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
41. Some programming languages manage to absorb change, but withstand progress.
102. One can't proceed from the informal to the formal by formal means.
43. In software systems, it is often the early bird that makes the worm.
110. Editing is a rewording activity.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
111. Why did the Roman Empire collapse? What is Latin for office automation?
8. A programming language is low level when its programs require attention to the irrelevant.
63. When we write programs that "learn", it turns out that we do and they don't.
61. In programming, as in everything else, to be in error is to be reborn.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
100. We will never run out of things to program as long as there is a single program around.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
79. A year spent in artificial intelligence is enough to make one believe in God.
59. In English every word can be verbed. Would that it were so in our programming languages.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
110. Editing is a rewording activity.
47. As Will Rogers would have said, "There is no such thing as a free variable."
7. It is easier to write an incorrect program than understand a correct one.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
60. In seeking the unattainable, simplicity only gets in the way.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
79. A year spent in artificial intelligence is enough to make one believe in God.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
119. Programming is an unnatural act.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
1. One man's constant is another man's variable.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
76. It is the user who should parameterize procedures, not their creators.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
55. A LISP programmer knows the value of everything, but the cost of nothing.
22. A good system can't have a weak command language.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
11. If you have a procedure with ten parameters, you probably missed some.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
14. In the long run every program becomes rococo - then rubble.
98. In computing, the mean time to failure keeps getting shorter.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
27. Once you understand how to write a program get someone else to write it.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
105. You can't communicate complexity, only an awareness of it.
1. One man's constant is another man's variable.
103. Purely applicative languages are poorly applicable.
31. Simplicity does not precede complexity, but follows it.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
98. In computing, the mean time to failure keeps getting shorter.
8. A programming language is low level when its programs require attention to the irrelevant.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
18. A program without a loop and a structured variable isn't worth writing.
102. One can't proceed from the informal to the formal by formal means.
100. We will never run out of things to program as long as there is a single program around.
96. Computers don't introduce order anywhere as much as they expose opportunities.
108. Whenever two programmers meet to criticize their programs, both are silent.
55. A LISP programmer knows the value of everything, but the cost of nothing.
110. Editing is a rewording activity.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
108. Whenever two programmers meet to criticize their programs, both are silent.
40. There are two ways to write error-free programs; only the third one works.
43. In software systems, it is often the early bird that makes the worm.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
22. A good system can't have a weak command language.
11. If you have a procedure with ten parameters, you probably missed some.
102. One can't proceed from the informal to the formal by formal means.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
31. Simplicity does not precede complexity, but follows it.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
47. As Will Rogers would have said, "There is no such thing as a free variable."
7. It is easier to write an incorrect program than understand a correct one.
79. A year spent in artificial intelligence is enough to make one believe in God.
100. We will never run out of things to program as long as there is a single program around.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
102. One can't proceed from the informal to the formal by formal means.
41. Some programming languages manage to absorb change, but withstand progress.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
14. In the long run every program becomes rococo - then rubble.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
23. To understand a program you must become both the machine and the program.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
98. In computing, the mean time to failure keeps getting shorter.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
119. Programming is an unnatural act.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
18. A program without a loop and a structured variable isn't worth writing.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
8. A programming language is low level when its programs require attention to the irrelevant.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
12. Recursion is the root of computation since it trades description for time.
100. We will never run out of things to program as long as there is a single program around.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
5. If a program manipulates a large amount of data, it does so in a small number of ways.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
111. Why did the Roman Empire collapse? What is Latin for office automation?
62. In computing, invariants are ephemeral.
114. Within a computer natural language is unnatural.
100. We will never run out of things to program as long as there is a single program around.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
63. When we write programs that "learn", it turns out that we do and they don't.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
90. Computation has made the tree flower.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
63. When we write programs that "learn", it turns out that we do and they don't.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
3. Syntactic sugar causes cancer of the semicolon.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
103. Purely applicative languages are poorly applicable.
12. Recursion is the root of computation since it trades description for time.
7. It is easier to write an incorrect program than understand a correct one.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
114. Within a computer natural language is unnatural.
40. There are two ways to write error-free programs; only the third one works.
8. A programming language is low level when its programs require attention to the irrelevant.
90. Computation has made the tree flower.
105. You can't communicate complexity, only an awareness of it.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
40. There are two ways to write error-free programs; only the third one works.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
23. To understand a program you must become both the machine and the program.
46. Like punning, programming is a play on words.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
17. If a listener nods his head when you're explaining your program, wake him up.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
90. Computation has made the tree flower.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
3. Syntactic sugar causes cancer of the semicolon.
60. In seeking the unattainable, simplicity only gets in the way.
17. If a listener nods his head when you're explaining your program, wake him up.
43. In software systems, it is often the early bird that makes the worm.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
78. If your computer speaks English, it was probably made in Japan.
41. Some programming languages manage to absorb change, but withstand progress.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
63. When we write programs that "learn", it turns out that we do and they don't.
105. You can't communicate complexity, only an awareness of it.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
31. Simplicity does not precede complexity, but follows it.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
22. A good system can't have a weak command language.
60. In seeking the unattainable, simplicity only gets in the way.
111. Why did the Roman Empire collapse? What is Latin for office automation?
57. It is easier to change the specification to fit the program than vice versa.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
41. Some programming languages manage to absorb change, but withstand progress.
90. Computation has made the tree flower.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
18. A program without a loop and a structured variable isn't worth writing.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
8. A programming language is low level when its programs require attention to the irrelevant.
31. Simplicity does not precede complexity, but follows it.
78. If your computer speaks English, it was probably made in Japan.
57. It is easier to change the specification to fit the program than vice versa.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
4. Every program is a part of some other program and rarely fits.
78. If your computer speaks English, it was probably made in Japan.
63. When we write programs that "learn", it turns out that we do and they don't.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
7. It is easier to write an incorrect program than understand a correct one.
66. Making something variable is easy. Controlling duration of constancy is the trick.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
11. If you have a procedure with ten parameters, you probably missed some.
17. If a listener nods his head when you're explaining your program, wake him up.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
4. Every program is a part of some other program and rarely fits.
46. Like punning, programming is a play on words.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
47. As Will Rogers would have said, "There is no such thing as a free variable."
23. To understand a program you must become both the machine and the program.
3. Syntactic sugar causes cancer of the semicolon.
27. Once you understand how to write a program get someone else to write it.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
7. It is easier to write an incorrect program than understand a correct one.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
46. Like punning, programming is a play on words.
7. It is easier to write an incorrect program than understand a correct one.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
66. Making something variable is easy. Controlling duration of constancy is the trick.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
18. A program without a loop and a structured variable isn't worth writing.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
66. Making something variable is easy. Controlling duration of constancy is the trick.
102. One can't proceed from the informal to the formal by formal means.
60. In seeking the unattainable, simplicity only gets in the way.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
105. You can't communicate complexity, only an awareness of it.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
115. Most people find the concept of programming obvious, but the doing impossible.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
108. Whenever two programmers meet to criticize their programs, both are silent.
7. It is easier to write an incorrect program than understand a correct one.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
104. The proof of a system's value is its existence.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
59. In English every word can be verbed. Would that it were so in our programming languages.
31. Simplicity does not precede complexity, but follows it.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
15. Everything should be built top-down, except the first time.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
102. One can't proceed from the informal to the formal by formal means.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
8. A programming language is low level when its programs require attention to the irrelevant.
12. Recursion is the root of computation since it trades description for time.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
18. A program without a loop and a structured variable isn't worth writing.
111. Why did the Roman Empire collapse? What is Latin for office automation?
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
79. A year spent in artificial intelligence is enough to make one believe in God.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
61. In programming, as in everything else, to be in error is to be reborn.
104. The proof of a system's value is its existence.
8. A programming language is low level when its programs require attention to the irrelevant.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
72. An adequate bootstrap is a contradiction in terms.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
41. Some programming languages manage to absorb change, but withstand progress.
7. It is easier to write an incorrect program than understand a correct one.
15. Everything should be built top-down, except the first time.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
12. Recursion is the root of computation since it trades description for time.
8. A programming language is low level when its programs require attention to the irrelevant.
115. Most people find the concept of programming obvious, but the doing impossible.
112. Computer Science is embarrassed by the computer.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
11. If you have a procedure with ten parameters, you probably missed some.
96. Computers don't introduce order anywhere as much as they expose opportunities.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
31. Simplicity does not precede complexity, but follows it.
62. In computing, invariants are ephemeral.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
111. Why did the Roman Empire collapse? What is Latin for office automation?
112. Computer Science is embarrassed by the computer.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
62. In computing, invariants are ephemeral.
63. When we write programs that "learn", it turns out that we do and they don't.
110. Editing is a rewording activity.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
76. It is the user who should parameterize procedures, not their creators.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
112. Computer Science is embarrassed by the computer.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
98. In computing, the mean time to failure keeps getting shorter.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
31. Simplicity does not precede complexity, but follows it.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
43. In software systems, it is often the early bird that makes the worm.
55. A LISP programmer knows the value of everything, but the cost of nothing.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
12. Recursion is the root of computation since it trades description for time.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
100. We will never run out of things to program as long as there is a single program around.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
12. Recursion is the root of computation since it trades description for time.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
112. Computer Science is embarrassed by the computer.
59. In English every word can be verbed. Would that it were so in our programming languages.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
41. Some programming languages manage to absorb change, but withstand progress.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
96. Computers don't introduce order anywhere as much as they expose opportunities.
15. Everything should be built top-down, except the first time.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
63. When we write programs that "learn", it turns out that we do and they don't.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
3. Syntactic sugar causes cancer of the semicolon.
22. A good system can't have a weak command language.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
11. If you have a procedure with ten parameters, you probably missed some.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
105. You can't communicate complexity, only an awareness of it.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
72. An adequate bootstrap is a contradiction in terms.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
105. You can't communicate complexity, only an awareness of it.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
31. Simplicity does not precede complexity, but follows it.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
59. In English every word can be verbed. Would that it were so in our programming languages.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
105. You can't communicate complexity, only an awareness of it.
111. Why did the Roman Empire collapse? What is Latin for office automation?
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
55. A LISP programmer knows the value of everything, but the cost of nothing.
102. One can't proceed from the informal to the formal by formal means.
27. Once you understand how to write a program get someone else to write it.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
57. It is easier to change the specification to fit the program than vice versa.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
96. Computers don't introduce order anywhere as much as they expose opportunities.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
63. When we write programs that "learn", it turns out that we do and they don't.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
78. If your computer speaks English, it was probably made in Japan.
23. To understand a program you must become both the machine and the program.
12. Recursion is the root of computation since it trades description for time.
57. It is easier to change the specification to fit the program than vice versa.
63. When we write programs that "learn", it turns out that we do and they don't.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
114. Within a computer natural language is unnatural.
14. In the long run every program becomes rococo - then rubble.
102. One can't proceed from the informal to the formal by formal means.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
90. Computation has made the tree flower.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
90. Computation has made the tree flower.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
114. Within a computer natural language is unnatural.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
4. Every program is a part of some other program and rarely fits.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
57. It is easier to change the specification to fit the program than vice versa.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
15. Everything should be built top-down, except the first time.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
47. As Will Rogers would have said, "There is no such thing as a free variable."
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
111. Why did the Roman Empire collapse? What is Latin for office automation?
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
59. In English every word can be verbed. Would that it were so in our programming languages.
14. In the long run every program becomes rococo - then rubble.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
108. Whenever two programmers meet to criticize their programs, both are silent.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
60. In seeking the unattainable, simplicity only gets in the way.
95. Don't have good ideas if you aren't willing to be responsible for them.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
38. Structured Programming supports the law of the excluded middle.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
72. An adequate bootstrap is a contradiction in terms.
115. Most people find the concept of programming obvious, but the doing impossible.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
43. In software systems, it is often the early bird that makes the worm.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
18. A program without a loop and a structured variable isn't worth writing.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
76. It is the user who should parameterize procedures, not their creators.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
66. Making something variable is easy. Controlling duration of constancy is the trick.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
112. Computer Science is embarrassed by the computer.
95. Don't have good ideas if you aren't willing to be responsible for them.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
78. If your computer speaks English, it was probably made in Japan.
55. A LISP programmer knows the value of everything, but the cost of nothing.
111. Why did the Roman Empire collapse? What is Latin for office automation?
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
61. In programming, as in everything else, to be in error is to be reborn.
59. In English every word can be verbed. Would that it were so in our programming languages.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
110. Editing is a rewording activity.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
96. Computers don't introduce order anywhere as much as they expose opportunities.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
105. You can't communicate complexity, only an awareness of it.
108. Whenever two programmers meet to criticize their programs, both are silent.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
119. Programming is an unnatural act.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
46. Like punning, programming is a play on words.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
27. Once you understand how to write a program get someone else to write it.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
55. A LISP programmer knows the value of everything, but the cost of nothing.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
119. Programming is an unnatural act.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
11. If you have a procedure with ten parameters, you probably missed some.
7. It is easier to write an incorrect program than understand a correct one.
3. Syntactic sugar causes cancer of the semicolon.
1. One man's constant is another man's variable.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
111. Why did the Roman Empire collapse? What is Latin for office automation?
60. In seeking the unattainable, simplicity only gets in the way.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
78. If your computer speaks English, it was probably made in Japan.
98. In computing, the mean time to failure keeps getting shorter.
108. Whenever two programmers meet to criticize their programs, both are silent.
100. We will never run out of things to program as long as there is a single program around.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
47. As Will Rogers would have said, "There is no such thing as a free variable."
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
55. A LISP programmer knows the value of everything, but the cost of nothing.
15. Everything should be built top-down, except the first time.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
110. Editing is a rewording activity.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
61. In programming, as in everything else, to be in error is to be reborn.
59. In English every word can be verbed. Would that it were so in our programming languages.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
41. Some programming languages manage to absorb change, but withstand progress.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
55. A LISP programmer knows the value of everything, but the cost of nothing.
61. In programming, as in everything else, to be in error is to be reborn.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
112. Computer Science is embarrassed by the computer.
114. Within a computer natural language is unnatural.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
23. To understand a program you must become both the machine and the program.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
41. Some programming languages manage to absorb change, but withstand progress.
12. Recursion is the root of computation since it trades description for time.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
110. Editing is a rewording activity.
38. Structured Programming supports the law of the excluded middle.
23. To understand a program you must become both the machine and the program.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
63. When we write programs that "learn", it turns out that we do and they don't.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
110. Editing is a rewording activity.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
12. Recursion is the root of computation since it trades description for time.
18. A program without a loop and a structured variable isn't worth writing.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
21. Optimization hinders evolution.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
14. In the long run every program becomes rococo - then rubble.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
115. Most people find the concept of programming obvious, but the doing impossible.
46. Like punning, programming is a play on words.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
14. In the long run every program becomes rococo - then rubble.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
102. One can't proceed from the informal to the formal by formal means.
108. Whenever two programmers meet to criticize their programs, both are silent.
95. Don't have good ideas if you aren't willing to be responsible for them.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
23. To understand a program you must become both the machine and the program.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
105. You can't communicate complexity, only an awareness of it.
4. Every program is a part of some other program and rarely fits.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
62. In computing, invariants are ephemeral.
1. One man's constant is another man's variable.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
60. In seeking the unattainable, simplicity only gets in the way.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
27. Once you understand how to write a program get someone else to write it.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
27. Once you understand how to write a program get someone else to write it.
95. Don't have good ideas if you aren't willing to be responsible for them.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
4. Every program is a part of some other program and rarely fits.
96. Computers don't introduce order anywhere as much as they expose opportunities.
119. Programming is an unnatural act.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
119. Programming is an unnatural act.
79. A year spent in artificial intelligence is enough to make one believe in God.
115. Most people find the concept of programming obvious, but the doing impossible.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
60. In seeking the unattainable, simplicity only gets in the way.
55. A LISP programmer knows the value of everything, but the cost of nothing.
7. It is easier to write an incorrect program than understand a correct one.
22. A good system can't have a weak command language.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
112. Computer Science is embarrassed by the computer.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
46. Like punning, programming is a play on words.
59. In English every word can be verbed. Would that it were so in our programming languages.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
23. To understand a program you must become both the machine and the program.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
104. The proof of a system's value is its existence.
23. To understand a program you must become both the machine and the program.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
76. It is the user who should parameterize procedures, not their creators.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
59. In English every word can be verbed. Would that it were so in our programming languages.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
60. In seeking the unattainable, simplicity only gets in the way.
78. If your computer speaks English, it was probably made in Japan.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
108. Whenever two programmers meet to criticize their programs, both are silent.
72. An adequate bootstrap is a contradiction in terms.
15. Everything should be built top-down, except the first time.
23. To understand a program you must become both the machine and the program.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
114. Within a computer natural language is unnatural.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
60. In seeking the unattainable, simplicity only gets in the way.
79. A year spent in artificial intelligence is enough to make one believe in God.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
119. Programming is an unnatural act.
114. Within a computer natural language is unnatural.
63. When we write programs that "learn", it turns out that we do and they don't.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
1. One man's constant is another man's variable.
105. You can't communicate complexity, only an awareness of it.
43. In software systems, it is often the early bird that makes the worm.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
31. Simplicity does not precede complexity, but follows it.
119. Programming is an unnatural act.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
4. Every program is a part of some other program and rarely fits.
63. When we write programs that "learn", it turns out that we do and they don't.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
79. A year spent in artificial intelligence is enough to make one believe in God.
40. There are two ways to write error-free programs; only the third one works.
112. Computer Science is embarrassed by the computer.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
104. The proof of a system's value is its existence.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
114. Within a computer natural language is unnatural.
96. Computers don't introduce order anywhere as much as they expose opportunities.
22. A good system can't have a weak command language.
104. The proof of a system's value is its existence.
59. In English every word can be verbed. Would that it were so in our programming languages.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
114. Within a computer natural language is unnatural.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
79. A year spent in artificial intelligence is enough to make one believe in God.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
55. A LISP programmer knows the value of everything, but the cost of nothing.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
72. An adequate bootstrap is a contradiction in terms.
95. Don't have good ideas if you aren't willing to be responsible for them.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
96. Computers don't introduce order anywhere as much as they expose opportunities.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
22. A good system can't have a weak command language.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
103. Purely applicative languages are poorly applicable.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
61. In programming, as in everything else, to be in error is to be reborn.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
104. The proof of a system's value is its existence.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
110. Editing is a rewording activity.
115. Most people find the concept of programming obvious, but the doing impossible.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
15. Everything should be built top-down, except the first time.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
41. Some programming languages manage to absorb change, but withstand progress.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
110. Editing is a rewording activity.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
21. Optimization hinders evolution.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
103. Purely applicative languages are poorly applicable.
112. Computer Science is embarrassed by the computer.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
55. A LISP programmer knows the value of everything, but the cost of nothing.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
38. Structured Programming supports the law of the excluded middle.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
114. Within a computer natural language is unnatural.
57. It is easier to change the specification to fit the program than vice versa.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
59. In English every word can be verbed. Would that it were so in our programming languages.
95. Don't have good ideas if you aren't willing to be responsible for them.
108. Whenever two programmers meet to criticize their programs, both are silent.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
61. In programming, as in everything else, to be in error is to be reborn.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
57. It is easier to change the specification to fit the program than vice versa.
27. Once you understand how to write a program get someone else to write it.
110. Editing is a rewording activity.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
22. A good system can't have a weak command language.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
66. Making something variable is easy. Controlling duration of constancy is the trick.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
15. Everything should be built top-down, except the first time.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
40. There are two ways to write error-free programs; only the third one works.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
103. Purely applicative languages are poorly applicable.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
7. It is easier to write an incorrect program than understand a correct one.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
103. Purely applicative languages are poorly applicable.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
110. Editing is a rewording activity.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
40. There are two ways to write error-free programs; only the third one works.
12. Recursion is the root of computation since it trades description for time.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
78. If your computer speaks English, it was probably made in Japan.
41. Some programming languages manage to absorb change, but withstand progress.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
40. There are two ways to write error-free programs; only the third one works.
111. Why did the Roman Empire collapse? What is Latin for office automation?
72. An adequate bootstrap is a contradiction in terms.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
47. As Will Rogers would have said, "There is no such thing as a free variable."
47. As Will Rogers would have said, "There is no such thing as a free variable."
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
114. Within a computer natural language is unnatural.
12. Recursion is the root of computation since it trades description for time.
78. If your computer speaks English, it was probably made in Japan.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
17. If a listener nods his head when you're explaining your program, wake him up.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
22. A good system can't have a weak command language.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
100. We will never run out of things to program as long as there is a single program around.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
21. Optimization hinders evolution.
23. To understand a program you must become both the machine and the program.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
112. Computer Science is embarrassed by the computer.
12. Recursion is the root of computation since it trades description for time.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
11. If you have a procedure with ten parameters, you probably missed some.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
14. In the long run every program becomes rococo - then rubble.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
17. If a listener nods his head when you're explaining your program, wake him up.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
90. Computation has made the tree flower.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
55. A LISP programmer knows the value of everything, but the cost of nothing.
4. Every program is a part of some other program and rarely fits.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
79. A year spent in artificial intelligence is enough to make one believe in God.
22. A good system can't have a weak command language.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
114. Within a computer natural language is unnatural.
114. Within a computer natural language is unnatural.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
21. Optimization hinders evolution.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
59. In English every word can be verbed. Would that it were so in our programming languages.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
55. A LISP programmer knows the value of everything, but the cost of nothing.
98. In computing, the mean time to failure keeps getting shorter.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
55. A LISP programmer knows the value of everything, but the cost of nothing.
60. In seeking the unattainable, simplicity only gets in the way.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
46. Like punning, programming is a play on words.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
76. It is the user who should parameterize procedures, not their creators.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
110. Editing is a rewording activity.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
98. In computing, the mean time to failure keeps getting shorter.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
110. Editing is a rewording activity.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
23. To understand a program you must become both the machine and the program.
78. If your computer speaks English, it was probably made in Japan.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
3. Syntactic sugar causes cancer of the semicolon.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
95. Don't have good ideas if you aren't willing to be responsible for them.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
79. A year spent in artificial intelligence is enough to make one believe in God.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
96. Computers don't introduce order anywhere as much as they expose opportunities.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
21. Optimization hinders evolution.
102. One can't proceed from the informal to the formal by formal means.
103. Purely applicative languages are poorly applicable.
115. Most people find the concept of programming obvious, but the doing impossible.
8. A programming language is low level when its programs require attention to the irrelevant.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
102. One can't proceed from the informal to the formal by formal means.
1. One man's constant is another man's variable.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
76. It is the user who should parameterize procedures, not their creators.
60. In seeking the unattainable, simplicity only gets in the way.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
66. Making something variable is easy. Controlling duration of constancy is the trick.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
119. Programming is an unnatural act.
4. Every program is a part of some other program and rarely fits.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
114. Within a computer natural language is unnatural.
105. You can't communicate complexity, only an awareness of it.
1. One man's constant is another man's variable.
119. Programming is an unnatural act.
60. In seeking the unattainable, simplicity only gets in the way.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
8. A programming language is low level when its programs require attention to the irrelevant.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
14. In the long run every program becomes rococo - then rubble.
103. Purely applicative languages are poorly applicable.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
15. Everything should be built top-down, except the first time.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
78. If your computer speaks English, it was probably made in Japan.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
40. There are two ways to write error-free programs; only the third one works.
114. Within a computer natural language is unnatural.
61. In programming, as in everything else, to be in error is to be reborn.
60. In seeking the unattainable, simplicity only gets in the way.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
8. A programming language is low level when its programs require attention to the irrelevant.
72. An adequate bootstrap is a contradiction in terms.
102. One can't proceed from the informal to the formal by formal means.
59. In English every word can be verbed. Would that it were so in our programming languages.
78. If your computer speaks English, it was probably made in Japan.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
7. It is easier to write an incorrect program than understand a correct one.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
11. If you have a procedure with ten parameters, you probably missed some.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
4. Every program is a part of some other program and rarely fits.
31. Simplicity does not precede complexity, but follows it.
78. If your computer speaks English, it was probably made in Japan.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
7. It is easier to write an incorrect program than understand a correct one.
8. A programming language is low level when its programs require attention to the irrelevant.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
96. Computers don't introduce order anywhere as much as they expose opportunities.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
38. Structured Programming supports the law of the excluded middle.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
60. In seeking the unattainable, simplicity only gets in the way.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
40. There are two ways to write error-free programs; only the third one works.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
8. A programming language is low level when its programs require attention to the irrelevant.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
8. A programming language is low level when its programs require attention to the irrelevant.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
76. It is the user who should parameterize procedures, not their creators.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
31. Simplicity does not precede complexity, but follows it.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
112. Computer Science is embarrassed by the computer.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
4. Every program is a part of some other program and rarely fits.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
27. Once you understand how to write a program get someone else to write it.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
8. A programming language is low level when its programs require attention to the irrelevant.
62. In computing, invariants are ephemeral.
17. If a listener nods his head when you're explaining your program, wake him up.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
95. Don't have good ideas if you aren't willing to be responsible for them.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
3. Syntactic sugar causes cancer of the semicolon.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
8. A programming language is low level when its programs require attention to the irrelevant.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
76. It is the user who should parameterize procedures, not their creators.
1. One man's constant is another man's variable.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
119. Programming is an unnatural act.
108. Whenever two programmers meet to criticize their programs, both are silent.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
66. Making something variable is easy. Controlling duration of constancy is the trick.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
107. The debate rages on: is PL/I Bachtrian or Dromedary?
15. Everything should be built top-down, except the first time.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
15. Everything should be built top-down, except the first time.
79. A year spent in artificial intelligence is enough to make one believe in God.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
3. Syntactic sugar causes cancer of the semicolon.
76. It is the user who should parameterize procedures, not their creators.
61. In programming, as in everything else, to be in error is to be reborn.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
79. A year spent in artificial intelligence is enough to make one believe in God.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
55. A LISP programmer knows the value of everything, but the cost of nothing.
63. When we write programs that "learn", it turns out that we do and they don't.
59. In English every word can be verbed. Would that it were so in our programming languages.
104. The proof of a system's value is its existence.
21. Optimization hinders evolution.
8. A programming language is low level when its programs require attention to the irrelevant.
12. Recursion is the root of computation since it trades description for time.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
63. When we write programs that "learn", it turns out that we do and they don't.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
110. Editing is a rewording activity.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
60. In seeking the unattainable, simplicity only gets in the way.
96. Computers don't introduce order anywhere as much as they expose opportunities.
98. In computing, the mean time to failure keeps getting shorter.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
3. Syntactic sugar causes cancer of the semicolon.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
90. Computation has made the tree flower.
7. It is easier to write an incorrect program than understand a correct one.
79. A year spent in artificial intelligence is enough to make one believe in God.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
63. When we write programs that "learn", it turns out that we do and they don't.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
14. In the long run every program becomes rococo - then rubble.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
22. A good system can't have a weak command language.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
1. One man's constant is another man's variable.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
114. Within a computer natural language is unnatural.
22. A good system can't have a weak command language.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
31. Simplicity does not precede complexity, but follows it.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
46. Like punning, programming is a play on words.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
18. A program without a loop and a structured variable isn't worth writing.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
96. Computers don't introduce order anywhere as much as they expose opportunities.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
98. In computing, the mean time to failure keeps getting shorter.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
115. Most people find the concept of programming obvious, but the doing impossible.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
18. A program without a loop and a structured variable isn't worth writing.
57. It is easier to change the specification to fit the program than vice versa.
72. An adequate bootstrap is a contradiction in terms.
95. Don't have good ideas if you aren't willing to be responsible for them.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
95. Don't have good ideas if you aren't willing to be responsible for them.
95. Don't have good ideas if you aren't willing to be responsible for them.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
3. Syntactic sugar causes cancer of the semicolon.
112. Computer Science is embarrassed by the computer.
104. The proof of a system's value is its existence.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
47. As Will Rogers would have said, "There is no such thing as a free variable."
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
72. An adequate bootstrap is a contradiction in terms.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
98. In computing, the mean time to failure keeps getting shorter.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
15. Everything should be built top-down, except the first time.
47. As Will Rogers would have said, "There is no such thing as a free variable."
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
72. An adequate bootstrap is a contradiction in terms.
4. Every program is a part of some other program and rarely fits.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
96. Computers don't introduce order anywhere as much as they expose opportunities.
100. We will never run out of things to program as long as there is a single program around.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
79. A year spent in artificial intelligence is enough to make one believe in God.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
76. It is the user who should parameterize procedures, not their creators.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
41. Some programming languages manage to absorb change, but withstand progress.
62. In computing, invariants are ephemeral.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
60. In seeking the unattainable, simplicity only gets in the way.
38. Structured Programming supports the law of the excluded middle.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
55. A LISP programmer knows the value of everything, but the cost of nothing.
18. A program without a loop and a structured variable isn't worth writing.
66. Making something variable is easy. Controlling duration of constancy is the trick.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
4. Every program is a part of some other program and rarely fits.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
46. Like punning, programming is a play on words.
31. Simplicity does not precede complexity, but follows it.
62. In computing, invariants are ephemeral.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
95. Don't have good ideas if you aren't willing to be responsible for them.
27. Once you understand how to write a program get someone else to write it.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
43. In software systems, it is often the early bird that makes the worm.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
111. Why did the Roman Empire collapse? What is Latin for office automation?
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
66. Making something variable is easy. Controlling duration of constancy is the trick.
11. If you have a procedure with ten parameters, you probably missed some.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
72. An adequate bootstrap is a contradiction in terms.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
62. In computing, invariants are ephemeral.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
119. Programming is an unnatural act.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
7. It is easier to write an incorrect program than understand a correct one.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
112. Computer Science is embarrassed by the computer.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
115. Most people find the concept of programming obvious, but the doing impossible.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
61. In programming, as in everything else, to be in error is to be reborn.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
27. Once you understand how to write a program get someone else to write it.
1. One man's constant is another man's variable.
3. Syntactic sugar causes cancer of the semicolon.
105. You can't communicate complexity, only an awareness of it.
8. A programming language is low level when its programs require attention to the irrelevant.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
103. Purely applicative languages are poorly applicable.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
95. Don't have good ideas if you aren't willing to be responsible for them.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
3. Syntactic sugar causes cancer of the semicolon.
78. If your computer speaks English, it was probably made in Japan.
110. Editing is a rewording activity.
103. Purely applicative languages are poorly applicable.
61. In programming, as in everything else, to be in error is to be reborn.
108. Whenever two programmers meet to criticize their programs, both are silent.
79. A year spent in artificial intelligence is enough to make one believe in God.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
63. When we write programs that "learn", it turns out that we do and they don't.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
96. Computers don't introduce order anywhere as much as they expose opportunities.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
43. In software systems, it is often the early bird that makes the worm.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
72. An adequate bootstrap is a contradiction in terms.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
21. Optimization hinders evolution.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
15. Everything should be built top-down, except the first time.
79. A year spent in artificial intelligence is enough to make one believe in God.
59. In English every word can be verbed. Would that it were so in our programming languages.
104. The proof of a system's value is its existence.
57. It is easier to change the specification to fit the program than vice versa.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
63. When we write programs that "learn", it turns out that we do and they don't.
110. Editing is a rewording activity.
12. Recursion is the root of computation since it trades description for time.
3. Syntactic sugar causes cancer of the semicolon.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
105. You can't communicate complexity, only an awareness of it.
41. Some programming languages manage to absorb change, but withstand progress.
100. We will never run out of things to program as long as there is a single program around.
41. Some programming languages manage to absorb change, but withstand progress.
63. When we write programs that "learn", it turns out that we do and they don't.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
18. A program without a loop and a structured variable isn't worth writing.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
12. Recursion is the root of computation since it trades description for time.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
102. One can't proceed from the informal to the formal by formal means.
79. A year spent in artificial intelligence is enough to make one believe in God.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
78. If your computer speaks English, it was probably made in Japan.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
76. It is the user who should parameterize procedures, not their creators.
114. Within a computer natural language is unnatural.
104. The proof of a system's value is its existence.
110. Editing is a rewording activity.
111. Why did the Roman Empire collapse? What is Latin for office automation?
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
72. An adequate bootstrap is a contradiction in terms.
90. Computation has made the tree flower.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
57. It is easier to change the specification to fit the program than vice versa.
3. Syntactic sugar causes cancer of the semicolon.
31. Simplicity does not precede complexity, but follows it.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
15. Everything should be built top-down, except the first time.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
62. In computing, invariants are ephemeral.
23. To understand a program you must become both the machine and the program.
90. Computation has made the tree flower.
14. In the long run every program becomes rococo - then rubble.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
8. A programming language is low level when its programs require attention to the irrelevant.
47. As Will Rogers would have said, "There is no such thing as a free variable."
115. Most people find the concept of programming obvious, but the doing impossible.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
1. One man's constant is another man's variable.
21. Optimization hinders evolution.
98. In computing, the mean time to failure keeps getting shorter.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
61. In programming, as in everything else, to be in error is to be reborn.
98. In computing, the mean time to failure keeps getting shorter.
63. When we write programs that "learn", it turns out that we do and they don't.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
12. Recursion is the root of computation since it trades description for time.
21. Optimization hinders evolution.
14. In the long run every program becomes rococo - then rubble.
46. Like punning, programming is a play on words.
114. Within a computer natural language is unnatural.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
79. A year spent in artificial intelligence is enough to make one believe in God.
112. Computer Science is embarrassed by the computer.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
62. In computing, invariants are ephemeral.
27. Once you understand how to write a program get someone else to write it.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
57. It is easier to change the specification to fit the program than vice versa.
43. In software systems, it is often the early bird that makes the worm.
1. One man's constant is another man's variable.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
100. We will never run out of things to program as long as there is a single program around.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
79. A year spent in artificial intelligence is enough to make one believe in God.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
62. In computing, invariants are ephemeral.
115. Most people find the concept of programming obvious, but the doing impossible.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
104. The proof of a system's value is its existence.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
119. Programming is an unnatural act.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
55. A LISP programmer knows the value of everything, but the cost of nothing.
3. Syntactic sugar causes cancer of the semicolon.
1. One man's constant is another man's variable.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
19. A language that doesn't affect the way you think about programming, is not worth knowing.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
119. Programming is an unnatural act.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
1. One man's constant is another man's variable.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
1. One man's constant is another man's variable.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
46. Like punning, programming is a play on words.
90. Computation has made the tree flower.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
79. A year spent in artificial intelligence is enough to make one believe in God.
21. Optimization hinders evolution.
23. To understand a program you must become both the machine and the program.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
1. One man's constant is another man's variable.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
66. Making something variable is easy. Controlling duration of constancy is the trick.
76. It is the user who should parameterize procedures, not their creators.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
72. An adequate bootstrap is a contradiction in terms.
23. To understand a program you must become both the machine and the program.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
62. In computing, invariants are ephemeral.
12. Recursion is the root of computation since it trades description for time.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
18. A program without a loop and a structured variable isn't worth writing.
47. As Will Rogers would have said, "There is no such thing as a free variable."
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
12. Recursion is the root of computation since it trades description for time.
1. One man's constant is another man's variable.
98. In computing, the mean time to failure keeps getting shorter.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
115. Most people find the concept of programming obvious, but the doing impossible.
60. In seeking the unattainable, simplicity only gets in the way.
112. Computer Science is embarrassed by the computer.
110. Editing is a rewording activity.
4. Every program is a part of some other program and rarely fits.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
43. In software systems, it is often the early bird that makes the worm.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
111. Why did the Roman Empire collapse? What is Latin for office automation?
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
4. Every program is a part of some other program and rarely fits.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
14. In the long run every program becomes rococo - then rubble.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
103. Purely applicative languages are poorly applicable.
27. Once you understand how to write a program get someone else to write it.
72. An adequate bootstrap is a contradiction in terms.
7. It is easier to write an incorrect program than understand a correct one.
103. Purely applicative languages are poorly applicable.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
3. Syntactic sugar causes cancer of the semicolon.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
31. Simplicity does not precede complexity, but follows it.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
40. There are two ways to write error-free programs; only the third one works.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
60. In seeking the unattainable, simplicity only gets in the way.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
12. Recursion is the root of computation since it trades description for time.
78. If your computer speaks English, it was probably made in Japan.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
21. Optimization hinders evolution.
23. To understand a program you must become both the machine and the program.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
72. An adequate bootstrap is a contradiction in terms.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
90. Computation has made the tree flower.
103. Purely applicative languages are poorly applicable.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
59. In English every word can be verbed. Would that it were so in our programming languages.
111. Why did the Roman Empire collapse? What is Latin for office automation?
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
62. In computing, invariants are ephemeral.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
105. You can't communicate complexity, only an awareness of it.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
78. If your computer speaks English, it was probably made in Japan.
61. In programming, as in everything else, to be in error is to be reborn.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
60. In seeking the unattainable, simplicity only gets in the way.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
15. Everything should be built top-down, except the first time.
66. Making something variable is easy. Controlling duration of constancy is the trick.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
31. Simplicity does not precede complexity, but follows it.
115. Most people find the concept of programming obvious, but the doing impossible.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
1. One man's constant is another man's variable.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
15. Everything should be built top-down, except the first time.
3. Syntactic sugar causes cancer of the semicolon.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
66. Making something variable is easy. Controlling duration of constancy is the trick.
78. If your computer speaks English, it was probably made in Japan.
7. It is easier to write an incorrect program than understand a correct one.
104. The proof of a system's value is its existence.
21. Optimization hinders evolution.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
112. Computer Science is embarrassed by the computer.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
96. Computers don't introduce order anywhere as much as they expose opportunities.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
18. A program without a loop and a structured variable isn't worth writing.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
112. Computer Science is embarrassed by the computer.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
96. Computers don't introduce order anywhere as much as they expose opportunities.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
105. You can't communicate complexity, only an awareness of it.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
76. It is the user who should parameterize procedures, not their creators.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
8. A programming language is low level when its programs require attention to the irrelevant.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
115. Most people find the concept of programming obvious, but the doing impossible.
11. If you have a procedure with ten parameters, you probably missed some.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
47. As Will Rogers would have said, "There is no such thing as a free variable."
38. Structured Programming supports the law of the excluded middle.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
114. Within a computer natural language is unnatural.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
114. Within a computer natural language is unnatural.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
96. Computers don't introduce order anywhere as much as they expose opportunities.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
22. A good system can't have a weak command language.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
98. In computing, the mean time to failure keeps getting shorter.
15. Everything should be built top-down, except the first time.
66. Making something variable is easy. Controlling duration of constancy is the trick.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
7. It is easier to write an incorrect program than understand a correct one.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
66. Making something variable is easy. Controlling duration of constancy is the trick.
3. Syntactic sugar causes cancer of the semicolon.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
112. Computer Science is embarrassed by the computer.
38. Structured Programming supports the law of the excluded middle.
110. Editing is a rewording activity.
112. Computer Science is embarrassed by the computer.
11. If you have a procedure with ten parameters, you probably missed some.
63. When we write programs that "learn", it turns out that we do and they don't.
105. You can't communicate complexity, only an awareness of it.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
40. There are two ways to write error-free programs; only the third one works.
31. Simplicity does not precede complexity, but follows it.
60. In seeking the unattainable, simplicity only gets in the way.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
14. In the long run every program becomes rococo - then rubble.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
41. Some programming languages manage to absorb change, but withstand progress.
62. In computing, invariants are ephemeral.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
14. In the long run every program becomes rococo - then rubble.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
112. Computer Science is embarrassed by the computer.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
43. In software systems, it is often the early bird that makes the worm.
115. Most people find the concept of programming obvious, but the doing impossible.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
114. Within a computer natural language is unnatural.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
4. Every program is a part of some other program and rarely fits.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
47. As Will Rogers would have said, "There is no such thing as a free variable."
98. In computing, the mean time to failure keeps getting shorter.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
72. An adequate bootstrap is a contradiction in terms.
41. Some programming languages manage to absorb change, but withstand progress.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
38. Structured Programming supports the law of the excluded middle.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
98. In computing, the mean time to failure keeps getting shorter.
55. A LISP programmer knows the value of everything, but the cost of nothing.
60. In seeking the unattainable, simplicity only gets in the way.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
114. Within a computer natural language is unnatural.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
8. A programming language is low level when its programs require attention to the irrelevant.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
17. If a listener nods his head when you're explaining your program, wake him up.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
104. The proof of a system's value is its existence.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
61. In programming, as in everything else, to be in error is to be reborn.
57. It is easier to change the specification to fit the program than vice versa.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
3. Syntactic sugar causes cancer of the semicolon.
59. In English every word can be verbed. Would that it were so in our programming languages.
3. Syntactic sugar causes cancer of the semicolon.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
40. There are two ways to write error-free programs; only the third one works.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
43. In software systems, it is often the early bird that makes the worm.
21. Optimization hinders evolution.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
119. Programming is an unnatural act.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
110. Editing is a rewording activity.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
31. Simplicity does not precede complexity, but follows it.
62. In computing, invariants are ephemeral.
79. A year spent in artificial intelligence is enough to make one believe in God.
31. Simplicity does not precede complexity, but follows it.
43. In software systems, it is often the early bird that makes the worm.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
17. If a listener nods his head when you're explaining your program, wake him up.
55. A LISP programmer knows the value of everything, but the cost of nothing.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
8. A programming language is low level when its programs require attention to the irrelevant.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
7. It is easier to write an incorrect program than understand a correct one.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
57. It is easier to change the specification to fit the program than vice versa.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
21. Optimization hinders evolution.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
114. Within a computer natural language is unnatural.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
76. It is the user who should parameterize procedures, not their creators.
78. If your computer speaks English, it was probably made in Japan.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
79. A year spent in artificial intelligence is enough to make one believe in God.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
57. It is easier to change the specification to fit the program than vice versa.
15. Everything should be built top-down, except the first time.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
57. It is easier to change the specification to fit the program than vice versa.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
31. Simplicity does not precede complexity, but follows it.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
17. If a listener nods his head when you're explaining your program, wake him up.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
18. A program without a loop and a structured variable isn't worth writing.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
119. Programming is an unnatural act.
110. Editing is a rewording activity.
111. Why did the Roman Empire collapse? What is Latin for office automation?
72. An adequate bootstrap is a contradiction in terms.
76. It is the user who should parameterize procedures, not their creators.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
11. If you have a procedure with ten parameters, you probably missed some.
66. Making something variable is easy. Controlling duration of constancy is the trick.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
63. When we write programs that "learn", it turns out that we do and they don't.
8. A programming language is low level when its programs require attention to the irrelevant.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
17. If a listener nods his head when you're explaining your program, wake him up.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
98. In computing, the mean time to failure keeps getting shorter.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
12. Recursion is the root of computation since it trades description for time.
22. A good system can't have a weak command language.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
76. It is the user who should parameterize procedures, not their creators.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
112. Computer Science is embarrassed by the computer.
103. Purely applicative languages are poorly applicable.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
14. In the long run every program becomes rococo - then rubble.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
112. Computer Science is embarrassed by the computer.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
17. If a listener nods his head when you're explaining your program, wake him up.
63. When we write programs that "learn", it turns out that we do and they don't.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
46. Like punning, programming is a play on words.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
18. A program without a loop and a structured variable isn't worth writing.
76. It is the user who should parameterize procedures, not their creators.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
12. Recursion is the root of computation since it trades description for time.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
12. Recursion is the root of computation since it trades description for time.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
96. Computers don't introduce order anywhere as much as they expose opportunities.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
96. Computers don't introduce order anywhere as much as they expose opportunities.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
8. A programming language is low level when its programs require attention to the irrelevant.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
108. Whenever two programmers meet to criticize their programs, both are silent.
22. A good system can't have a weak command language.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
22. A good system can't have a weak command language.
66. Making something variable is easy. Controlling duration of constancy is the trick.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
114. Within a computer natural language is unnatural.
108. Whenever two programmers meet to criticize their programs, both are silent.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
55. A LISP programmer knows the value of everything, but the cost of nothing.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
114. Within a computer natural language is unnatural.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
90. Computation has made the tree flower.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
47. As Will Rogers would have said, "There is no such thing as a free variable."
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
14. In the long run every program becomes rococo - then rubble.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
62. In computing, invariants are ephemeral.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
57. It is easier to change the specification to fit the program than vice versa.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
40. There are two ways to write error-free programs; only the third one works.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
38. Structured Programming supports the law of the excluded middle.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
21. Optimization hinders evolution.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
103. Purely applicative languages are poorly applicable.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
60. In seeking the unattainable, simplicity only gets in the way.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
66. Making something variable is easy. Controlling duration of constancy is the trick.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
112. Computer Science is embarrassed by the computer.
14. In the long run every program becomes rococo - then rubble.
62. In computing, invariants are ephemeral.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
112. Computer Science is embarrassed by the computer.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
57. It is easier to change the specification to fit the program than vice versa.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
62. In computing, invariants are ephemeral.
63. When we write programs that "learn", it turns out that we do and they don't.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
104. The proof of a system's value is its existence.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
18. A program without a loop and a structured variable isn't worth writing.
47. As Will Rogers would have said, "There is no such thing as a free variable."
11. If you have a procedure with ten parameters, you probably missed some.
23. To understand a program you must become both the machine and the program.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
66. Making something variable is easy. Controlling duration of constancy is the trick.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
22. A good system can't have a weak command language.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
78. If your computer speaks English, it was probably made in Japan.
78. If your computer speaks English, it was probably made in Japan.
40. There are two ways to write error-free programs; only the third one works.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
11. If you have a procedure with ten parameters, you probably missed some.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
112. Computer Science is embarrassed by the computer.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
57. It is easier to change the specification to fit the program than vice versa.
55. A LISP programmer knows the value of everything, but the cost of nothing.
115. Most people find the concept of programming obvious, but the doing impossible.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
61. In programming, as in everything else, to be in error is to be reborn.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
11. If you have a procedure with ten parameters, you probably missed some.
108. Whenever two programmers meet to criticize their programs, both are silent.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
112. Computer Science is embarrassed by the computer.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
31. Simplicity does not precede complexity, but follows it.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
61. In programming, as in everything else, to be in error is to be reborn.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
61. In programming, as in everything else, to be in error is to be reborn.
96. Computers don't introduce order anywhere as much as they expose opportunities.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
55. A LISP programmer knows the value of everything, but the cost of nothing.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
104. The proof of a system's value is its existence.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
21. Optimization hinders evolution.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
96. Computers don't introduce order anywhere as much as they expose opportunities.
100. We will never run out of things to program as long as there is a single program around.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
96. Computers don't introduce order anywhere as much as they expose opportunities.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
115. Most people find the concept of programming obvious, but the doing impossible.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
27. Once you understand how to write a program get someone else to write it.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
4. Every program is a part of some other program and rarely fits.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
102. One can't proceed from the informal to the formal by formal means.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
76. It is the user who should parameterize procedures, not their creators.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
119. Programming is an unnatural act.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
61. In programming, as in everything else, to be in error is to be reborn.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
76. It is the user who should parameterize procedures, not their creators.
60. In seeking the unattainable, simplicity only gets in the way.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
79. A year spent in artificial intelligence is enough to make one believe in God.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
11. If you have a procedure with ten parameters, you probably missed some.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
111. Why did the Roman Empire collapse? What is Latin for office automation?
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
104. The proof of a system's value is its existence.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
79. A year spent in artificial intelligence is enough to make one believe in God.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
60. In seeking the unattainable, simplicity only gets in the way.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
7. It is easier to write an incorrect program than understand a correct one.
119. Programming is an unnatural act.
57. It is easier to change the specification to fit the program than vice versa.
55. A LISP programmer knows the value of everything, but the cost of nothing.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
102. One can't proceed from the informal to the formal by formal means.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
112. Computer Science is embarrassed by the computer.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
108. Whenever two programmers meet to criticize their programs, both are silent.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
12. Recursion is the root of computation since it trades description for time.
108. Whenever two programmers meet to criticize their programs, both are silent.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
18. A program without a loop and a structured variable isn't worth writing.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
96. Computers don't introduce order anywhere as much as they expose opportunities.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
112. Computer Science is embarrassed by the computer.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
112. Computer Science is embarrassed by the computer.
108. Whenever two programmers meet to criticize their programs, both are silent.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
7. It is easier to write an incorrect program than understand a correct one.
105. You can't communicate complexity, only an awareness of it.
55. A LISP programmer knows the value of everything, but the cost of nothing.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
55. A LISP programmer knows the value of everything, but the cost of nothing.
103. Purely applicative languages are poorly applicable.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
61. In programming, as in everything else, to be in error is to be reborn.
38. Structured Programming supports the law of the excluded middle.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
115. Most people find the concept of programming obvious, but the doing impossible.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
108. Whenever two programmers meet to criticize their programs, both are silent.
38. Structured Programming supports the law of the excluded middle.
90. Computation has made the tree flower.
3. Syntactic sugar causes cancer of the semicolon.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
57. It is easier to change the specification to fit the program than vice versa.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
22. A good system can't have a weak command language.
98. In computing, the mean time to failure keeps getting shorter.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
7. It is easier to write an incorrect program than understand a correct one.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
96. Computers don't introduce order anywhere as much as they expose opportunities.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
63. When we write programs that "learn", it turns out that we do and they don't.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
62. In computing, invariants are ephemeral.
4. Every program is a part of some other program and rarely fits.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
119. Programming is an unnatural act.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
78. If your computer speaks English, it was probably made in Japan.
59. In English every word can be verbed. Would that it were so in our programming languages.
11. If you have a procedure with ten parameters, you probably missed some.
100. We will never run out of things to program as long as there is a single program around.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
76. It is the user who should parameterize procedures, not their creators.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
23. To understand a program you must become both the machine and the program.
12. Recursion is the root of computation since it trades description for time.
1. One man's constant is another man's variable.
27. Once you understand how to write a program get someone else to write it.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
47. As Will Rogers would have said, "There is no such thing as a free variable."
7. It is easier to write an incorrect program than understand a correct one.
63. When we write programs that "learn", it turns out that we do and they don't.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
55. A LISP programmer knows the value of everything, but the cost of nothing.
38. Structured Programming supports the law of the excluded middle.
111. Why did the Roman Empire collapse? What is Latin for office automation?
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
78. If your computer speaks English, it was probably made in Japan.
59. In English every word can be verbed. Would that it were so in our programming languages.
40. There are two ways to write error-free programs; only the third one works.
23. To understand a program you must become both the machine and the program.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
105. You can't communicate complexity, only an awareness of it.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
60. In seeking the unattainable, simplicity only gets in the way.
119. Programming is an unnatural act.
63. When we write programs that "learn", it turns out that we do and they don't.
110. Editing is a rewording activity.
105. You can't communicate complexity, only an awareness of it.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
96. Computers don't introduce order anywhere as much as they expose opportunities.
76. It is the user who should parameterize procedures, not their creators.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
114. Within a computer natural language is unnatural.
57. It is easier to change the specification to fit the program than vice versa.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
60. In seeking the unattainable, simplicity only gets in the way.
63. When we write programs that "learn", it turns out that we do and they don't.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
72. An adequate bootstrap is a contradiction in terms.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
72. An adequate bootstrap is a contradiction in terms.
14. In the long run every program becomes rococo - then rubble.
115. Most people find the concept of programming obvious, but the doing impossible.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
17. If a listener nods his head when you're explaining your program, wake him up.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
78. If your computer speaks English, it was probably made in Japan.
47. As Will Rogers would have said, "There is no such thing as a free variable."
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
76. It is the user who should parameterize procedures, not their creators.
59. In English every word can be verbed. Would that it were so in our programming languages.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
108. Whenever two programmers meet to criticize their programs, both are silent.
3. Syntactic sugar causes cancer of the semicolon.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
72. An adequate bootstrap is a contradiction in terms.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
115. Most people find the concept of programming obvious, but the doing impossible.
119. Programming is an unnatural act.
103. Purely applicative languages are poorly applicable.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
31. Simplicity does not precede complexity, but follows it.
55. A LISP programmer knows the value of everything, but the cost of nothing.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
43. In software systems, it is often the early bird that makes the worm.
63. When we write programs that "learn", it turns out that we do and they don't.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
31. Simplicity does not precede complexity, but follows it.
78. If your computer speaks English, it was probably made in Japan.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
1. One man's constant is another man's variable.
119. Programming is an unnatural act.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
104. The proof of a system's value is its existence.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
98. In computing, the mean time to failure keeps getting shorter.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
111. Why did the Roman Empire collapse? What is Latin for office automation?
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
59. In English every word can be verbed. Would that it were so in our programming languages.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
23. To understand a program you must become both the machine and the program.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
110. Editing is a rewording activity.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
62. In computing, invariants are ephemeral.
3. Syntactic sugar causes cancer of the semicolon.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
47. As Will Rogers would have said, "There is no such thing as a free variable."
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
110. Editing is a rewording activity.
21. Optimization hinders evolution.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
5. If a program manipulates a large amount of data, it does so in a small number of ways.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
96. Computers don't introduce order anywhere as much as they expose opportunities.
1. One man's constant is another man's variable.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
96. Computers don't introduce order anywhere as much as they expose opportunities.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
66. Making something variable is easy. Controlling duration of constancy is the trick.
66. Making something variable is easy. Controlling duration of constancy is the trick.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
27. Once you understand how to write a program get someone else to write it.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
114. Within a computer natural language is unnatural.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
11. If you have a procedure with ten parameters, you probably missed some.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
61. In programming, as in everything else, to be in error is to be reborn.
23. To understand a program you must become both the machine and the program.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
79. A year spent in artificial intelligence is enough to make one believe in God.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
23. To understand a program you must become both the machine and the program.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
66. Making something variable is easy. Controlling duration of constancy is the trick.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
15. Everything should be built top-down, except the first time.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
46. Like punning, programming is a play on words.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
119. Programming is an unnatural act.
43. In software systems, it is often the early bird that makes the worm.
47. As Will Rogers would have said, "There is no such thing as a free variable."
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
105. You can't communicate complexity, only an awareness of it.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
105. You can't communicate complexity, only an awareness of it.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
76. It is the user who should parameterize procedures, not their creators.
12. Recursion is the root of computation since it trades description for time.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
21. Optimization hinders evolution.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
110. Editing is a rewording activity.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
100. We will never run out of things to program as long as there is a single program around.
66. Making something variable is easy. Controlling duration of constancy is the trick.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
43. In software systems, it is often the early bird that makes the worm.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
62. In computing, invariants are ephemeral.
12. Recursion is the root of computation since it trades description for time.
17. If a listener nods his head when you're explaining your program, wake him up.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
43. In software systems, it is often the early bird that makes the worm.
119. Programming is an unnatural act.
12. Recursion is the root of computation since it trades description for time.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
98. In computing, the mean time to failure keeps getting shorter.
62. In computing, invariants are ephemeral.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
72. An adequate bootstrap is a contradiction in terms.
11. If you have a procedure with ten parameters, you probably missed some.
21. Optimization hinders evolution.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
22. A good system can't have a weak command language.
8. A programming language is low level when its programs require attention to the irrelevant.
8. A programming language is low level when its programs require attention to the irrelevant.
40. There are two ways to write error-free programs; only the third one works.
7. It is easier to write an incorrect program than understand a correct one.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
4. Every program is a part of some other program and rarely fits.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
1. One man's constant is another man's variable.
66. Making something variable is easy. Controlling duration of constancy is the trick.
112. Computer Science is embarrassed by the computer.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
38. Structured Programming supports the law of the excluded middle.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
61. In programming, as in everything else, to be in error is to be reborn.
27. Once you understand how to write a program get someone else to write it.
98. In computing, the mean time to failure keeps getting shorter.
15. Everything should be built top-down, except the first time.
96. Computers don't introduce order anywhere as much as they expose opportunities.
1. One man's constant is another man's variable.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
110. Editing is a rewording activity.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
62. In computing, invariants are ephemeral.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
66. Making something variable is easy. Controlling duration of constancy is the trick.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
55. A LISP programmer knows the value of everything, but the cost of nothing.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
79. A year spent in artificial intelligence is enough to make one believe in God.
90. Computation has made the tree flower.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
102. One can't proceed from the informal to the formal by formal means.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
11. If you have a procedure with ten parameters, you probably missed some.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
108. Whenever two programmers meet to criticize their programs, both are silent.
104. The proof of a system's value is its existence.
59. In English every word can be verbed. Would that it were so in our programming languages.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
8. A programming language is low level when its programs require attention to the irrelevant.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
114. Within a computer natural language is unnatural.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
38. Structured Programming supports the law of the excluded middle.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
8. A programming language is low level when its programs require attention to the irrelevant.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
55. A LISP programmer knows the value of everything, but the cost of nothing.
110. Editing is a rewording activity.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
55. A LISP programmer knows the value of everything, but the cost of nothing.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
31. Simplicity does not precede complexity, but follows it.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
59. In English every word can be verbed. Would that it were so in our programming languages.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
14. In the long run every program becomes rococo - then rubble.
60. In seeking the unattainable, simplicity only gets in the way.
23. To understand a program you must become both the machine and the program.
12. Recursion is the root of computation since it trades description for time.
1. One man's constant is another man's variable.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
31. Simplicity does not precede complexity, but follows it.
105. You can't communicate complexity, only an awareness of it.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
110. Editing is a rewording activity.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
98. In computing, the mean time to failure keeps getting shorter.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
46. Like punning, programming is a play on words.
96. Computers don't introduce order anywhere as much as they expose opportunities.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
57. It is easier to change the specification to fit the program than vice versa.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
21. Optimization hinders evolution.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
104. The proof of a system's value is its existence.
104. The proof of a system's value is its existence.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
114. Within a computer natural language is unnatural.
103. Purely applicative languages are poorly applicable.
22. A good system can't have a weak command language.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
17. If a listener nods his head when you're explaining your program, wake him up.
115. Most people find the concept of programming obvious, but the doing impossible.
102. One can't proceed from the informal to the formal by formal means.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
107. The debate rages on: is PL/I Bachtrian or Dromedary?
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
95. Don't have good ideas if you aren't willing to be responsible for them.
12. Recursion is the root of computation since it trades description for time.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
8. A programming language is low level when its programs require attention to the irrelevant.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
103. Purely applicative languages are poorly applicable.
96. Computers don't introduce order anywhere as much as they expose opportunities.
17. If a listener nods his head when you're explaining your program, wake him up.
103. Purely applicative languages are poorly applicable.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
108. Whenever two programmers meet to criticize their programs, both are silent.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
119. Programming is an unnatural act.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
60. In seeking the unattainable, simplicity only gets in the way.
76. It is the user who should parameterize procedures, not their creators.
40. There are two ways to write error-free programs; only the third one works.
57. It is easier to change the specification to fit the program than vice versa.
31. Simplicity does not precede complexity, but follows it.
15. Everything should be built top-down, except the first time.
8. A programming language is low level when its programs require attention to the irrelevant.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
114. Within a computer natural language is unnatural.
119. Programming is an unnatural act.
23. To understand a program you must become both the machine and the program.
11. If you have a procedure with ten parameters, you probably missed some.
62. In computing, invariants are ephemeral.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
105. You can't communicate complexity, only an awareness of it.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
46. Like punning, programming is a play on words.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
4. Every program is a part of some other program and rarely fits.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
110. Editing is a rewording activity.
41. Some programming languages manage to absorb change, but withstand progress.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
8. A programming language is low level when its programs require attention to the irrelevant.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
98. In computing, the mean time to failure keeps getting shorter.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
105. You can't communicate complexity, only an awareness of it.
41. Some programming languages manage to absorb change, but withstand progress.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
21. Optimization hinders evolution.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
98. In computing, the mean time to failure keeps getting shorter.
60. In seeking the unattainable, simplicity only gets in the way.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
66. Making something variable is easy. Controlling duration of constancy is the trick.
41. Some programming languages manage to absorb change, but withstand progress.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
66. Making something variable is easy. Controlling duration of constancy is the trick.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
7. It is easier to write an incorrect program than understand a correct one.
108. Whenever two programmers meet to criticize their programs, both are silent.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
105. You can't communicate complexity, only an awareness of it.
27. Once you understand how to write a program get someone else to write it.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
98. In computing, the mean time to failure keeps getting shorter.
108. Whenever two programmers meet to criticize their programs, both are silent.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
11. If you have a procedure with ten parameters, you probably missed some.
98. In computing, the mean time to failure keeps getting shorter.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
111. Why did the Roman Empire collapse? What is Latin for office automation?
59. In English every word can be verbed. Would that it were so in our programming languages.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
104. The proof of a system's value is its existence.
115. Most people find the concept of programming obvious, but the doing impossible.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
40. There are two ways to write error-free programs; only the third one works.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
119. Programming is an unnatural act.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
7. It is easier to write an incorrect program than understand a correct one.
90. Computation has made the tree flower.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
62. In computing, invariants are ephemeral.
111. Why did the Roman Empire collapse? What is Latin for office automation?
27. Once you understand how to write a program get someone else to write it.
3. Syntactic sugar causes cancer of the semicolon.
4. Every program is a part of some other program and rarely fits.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
112. Computer Science is embarrassed by the computer.
7. It is easier to write an incorrect program than understand a correct one.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
47. As Will Rogers would have said, "There is no such thing as a free variable."
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
21. Optimization hinders evolution.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
98. In computing, the mean time to failure keeps getting shorter.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
110. Editing is a rewording activity.
4. Every program is a part of some other program and rarely fits.
95. Don't have good ideas if you aren't willing to be responsible for them.
104. The proof of a system's value is its existence.
41. Some programming languages manage to absorb change, but withstand progress.
59. In English every word can be verbed. Would that it were so in our programming languages.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
14. In the long run every program becomes rococo - then rubble.
21. Optimization hinders evolution.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
103. Purely applicative languages are poorly applicable.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
76. It is the user who should parameterize procedures, not their creators.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
38. Structured Programming supports the law of the excluded middle.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
60. In seeking the unattainable, simplicity only gets in the way.
40. There are two ways to write error-free programs; only the third one works.
95. Don't have good ideas if you aren't willing to be responsible for them.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
102. One can't proceed from the informal to the formal by formal means.
108. Whenever two programmers meet to criticize their programs, both are silent.
46. Like punning, programming is a play on words.
47. As Will Rogers would have said, "There is no such thing as a free variable."
107. The debate rages on: is PL/I Bachtrian or Dromedary?
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
62. In computing, invariants are ephemeral.
15. Everything should be built top-down, except the first time.
46. Like punning, programming is a play on words.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
47. As Will Rogers would have said, "There is no such thing as a free variable."
103. Purely applicative languages are poorly applicable.
111. Why did the Roman Empire collapse? What is Latin for office automation?
11. If you have a procedure with ten parameters, you probably missed some.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
4. Every program is a part of some other program and rarely fits.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
41. Some programming languages manage to absorb change, but withstand progress.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
7. It is easier to write an incorrect program than understand a correct one.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
112. Computer Science is embarrassed by the computer.
63. When we write programs that "learn", it turns out that we do and they don't.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
14. In the long run every program becomes rococo - then rubble.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
102. One can't proceed from the informal to the formal by formal means.
66. Making something variable is easy. Controlling duration of constancy is the trick.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
1. One man's constant is another man's variable.
11. If you have a procedure with ten parameters, you probably missed some.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
95. Don't have good ideas if you aren't willing to be responsible for them.
7. It is easier to write an incorrect program than understand a correct one.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
46. Like punning, programming is a play on words.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
23. To understand a program you must become both the machine and the program.
21. Optimization hinders evolution.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
3. Syntactic sugar causes cancer of the semicolon.
104. The proof of a system's value is its existence.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
66. Making something variable is easy. Controlling duration of constancy is the trick.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
66. Making something variable is easy. Controlling duration of constancy is the trick.
103. Purely applicative languages are poorly applicable.
27. Once you understand how to write a program get someone else to write it.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
103. Purely applicative languages are poorly applicable.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
38. Structured Programming supports the law of the excluded middle.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
1. One man's constant is another man's variable.
18. A program without a loop and a structured variable isn't worth writing.
43. In software systems, it is often the early bird that makes the worm.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
3. Syntactic sugar causes cancer of the semicolon.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
100. We will never run out of things to program as long as there is a single program around.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
11. If you have a procedure with ten parameters, you probably missed some.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
23. To understand a program you must become both the machine and the program.
47. As Will Rogers would have said, "There is no such thing as a free variable."
62. In computing, invariants are ephemeral.
7. It is easier to write an incorrect program than understand a correct one.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
76. It is the user who should parameterize procedures, not their creators.
111. Why did the Roman Empire collapse? What is Latin for office automation?
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
108. Whenever two programmers meet to criticize their programs, both are silent.
27. Once you understand how to write a program get someone else to write it.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
111. Why did the Roman Empire collapse? What is Latin for office automation?
96. Computers don't introduce order anywhere as much as they expose opportunities.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
55. A LISP programmer knows the value of everything, but the cost of nothing.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
110. Editing is a rewording activity.
114. Within a computer natural language is unnatural.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
95. Don't have good ideas if you aren't willing to be responsible for them.
41. Some programming languages manage to absorb change, but withstand progress.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
63. When we write programs that "learn", it turns out that we do and they don't.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
78. If your computer speaks English, it was probably made in Japan.
59. In English every word can be verbed. Would that it were so in our programming languages.
63. When we write programs that "learn", it turns out that we do and they don't.
76. It is the user who should parameterize procedures, not their creators.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
78. If your computer speaks English, it was probably made in Japan.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
59. In English every word can be verbed. Would that it were so in our programming languages.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
17. If a listener nods his head when you're explaining your program, wake him up.
96. Computers don't introduce order anywhere as much as they expose opportunities.
102. One can't proceed from the informal to the formal by formal means.
8. A programming language is low level when its programs require attention to the irrelevant.
76. It is the user who should parameterize procedures, not their creators.
59. In English every word can be verbed. Would that it were so in our programming languages.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
90. Computation has made the tree flower.
47. As Will Rogers would have said, "There is no such thing as a free variable."
43. In software systems, it is often the early bird that makes the worm.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
43. In software systems, it is often the early bird that makes the worm.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
11. If you have a procedure with ten parameters, you probably missed some.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
103. Purely applicative languages are poorly applicable.
104. The proof of a system's value is its existence.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
114. Within a computer natural language is unnatural.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
38. Structured Programming supports the law of the excluded middle.
90. Computation has made the tree flower.
41. Some programming languages manage to absorb change, but withstand progress.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
98. In computing, the mean time to failure keeps getting shorter.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
102. One can't proceed from the informal to the formal by formal means.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
38. Structured Programming supports the law of the excluded middle.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
95. Don't have good ideas if you aren't willing to be responsible for them.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
57. It is easier to change the specification to fit the program than vice versa.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
105. You can't communicate complexity, only an awareness of it.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
3. Syntactic sugar causes cancer of the semicolon.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
27. Once you understand how to write a program get someone else to write it.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
27. Once you understand how to write a program get someone else to write it.
72. An adequate bootstrap is a contradiction in terms.
115. Most people find the concept of programming obvious, but the doing impossible.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
11. If you have a procedure with ten parameters, you probably missed some.
46. Like punning, programming is a play on words.
110. Editing is a rewording activity.
12. Recursion is the root of computation since it trades description for time.
46. Like punning, programming is a play on words.
76. It is the user who should parameterize procedures, not their creators.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
4. Every program is a part of some other program and rarely fits.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
17. If a listener nods his head when you're explaining your program, wake him up.
3. Syntactic sugar causes cancer of the semicolon.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
104. The proof of a system's value is its existence.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
14. In the long run every program becomes rococo - then rubble.
43. In software systems, it is often the early bird that makes the worm.
11. If you have a procedure with ten parameters, you probably missed some.
115. Most people find the concept of programming obvious, but the doing impossible.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
66. Making something variable is easy. Controlling duration of constancy is the trick.
11. If you have a procedure with ten parameters, you probably missed some.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
11. If you have a procedure with ten parameters, you probably missed some.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
27. Once you understand how to write a program get someone else to write it.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
98. In computing, the mean time to failure keeps getting shorter.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
90. Computation has made the tree flower.
79. A year spent in artificial intelligence is enough to make one believe in God.
23. To understand a program you must become both the machine and the program.
112. Computer Science is embarrassed by the computer.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
72. An adequate bootstrap is a contradiction in terms.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
105. You can't communicate complexity, only an awareness of it.
27. Once you understand how to write a program get someone else to write it.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
12. Recursion is the root of computation since it trades description for time.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
40. There are two ways to write error-free programs; only the third one works.
15. Everything should be built top-down, except the first time.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
66. Making something variable is easy. Controlling duration of constancy is the trick.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
111. Why did the Roman Empire collapse? What is Latin for office automation?
63. When we write programs that "learn", it turns out that we do and they don't.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
21. Optimization hinders evolution.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
110. Editing is a rewording activity.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
96. Computers don't introduce order anywhere as much as they expose opportunities.
7. It is easier to write an incorrect program than understand a correct one.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
12. Recursion is the root of computation since it trades description for time.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
40. There are two ways to write error-free programs; only the third one works.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
31. Simplicity does not precede complexity, but follows it.
96. Computers don't introduce order anywhere as much as they expose opportunities.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
72. An adequate bootstrap is a contradiction in terms.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
98. In computing, the mean time to failure keeps getting shorter.
114. Within a computer natural language is unnatural.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
108. Whenever two programmers meet to criticize their programs, both are silent.
47. As Will Rogers would have said, "There is no such thing as a free variable."
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
79. A year spent in artificial intelligence is enough to make one believe in God.
111. Why did the Roman Empire collapse? What is Latin for office automation?
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
57. It is easier to change the specification to fit the program than vice versa.
63. When we write programs that "learn", it turns out that we do and they don't.
12. Recursion is the root of computation since it trades description for time.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
12. Recursion is the root of computation since it trades description for time.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
43. In software systems, it is often the early bird that makes the worm.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
110. Editing is a rewording activity.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
111. Why did the Roman Empire collapse? What is Latin for office automation?
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
61. In programming, as in everything else, to be in error is to be reborn.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
14. In the long run every program becomes rococo - then rubble.
72. An adequate bootstrap is a contradiction in terms.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
96. Computers don't introduce order anywhere as much as they expose opportunities.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
12. Recursion is the root of computation since it trades description for time.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
11. If you have a procedure with ten parameters, you probably missed some.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
15. Everything should be built top-down, except the first time.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
114. Within a computer natural language is unnatural.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
41. Some programming languages manage to absorb change, but withstand progress.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
1. One man's constant is another man's variable.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
55. A LISP programmer knows the value of everything, but the cost of nothing.
12. Recursion is the root of computation since it trades description for time.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
104. The proof of a system's value is its existence.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
119. Programming is an unnatural act.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
105. You can't communicate complexity, only an awareness of it.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
11. If you have a procedure with ten parameters, you probably missed some.
111. Why did the Roman Empire collapse? What is Latin for office automation?
31. Simplicity does not precede complexity, but follows it.
114. Within a computer natural language is unnatural.
8. A programming language is low level when its programs require attention to the irrelevant.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
8. A programming language is low level when its programs require attention to the irrelevant.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
95. Don't have good ideas if you aren't willing to be responsible for them.
79. A year spent in artificial intelligence is enough to make one believe in God.
100. We will never run out of things to program as long as there is a single program around.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
111. Why did the Roman Empire collapse? What is Latin for office automation?
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
102. One can't proceed from the informal to the formal by formal means.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
95. Don't have good ideas if you aren't willing to be responsible for them.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
57. It is easier to change the specification to fit the program than vice versa.
111. Why did the Roman Empire collapse? What is Latin for office automation?
1. One man's constant is another man's variable.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
31. Simplicity does not precede complexity, but follows it.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
11. If you have a procedure with ten parameters, you probably missed some.
100. We will never run out of things to program as long as there is a single program around.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
96. Computers don't introduce order anywhere as much as they expose opportunities.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
105. You can't communicate complexity, only an awareness of it.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
115. Most people find the concept of programming obvious, but the doing impossible.
3. Syntactic sugar causes cancer of the semicolon.
3. Syntactic sugar causes cancer of the semicolon.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
18. A program without a loop and a structured variable isn't worth writing.
90. Computation has made the tree flower.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
63. When we write programs that "learn", it turns out that we do and they don't.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
61. In programming, as in everything else, to be in error is to be reborn.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
59. In English every word can be verbed. Would that it were so in our programming languages.
17. If a listener nods his head when you're explaining your program, wake him up.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
27. Once you understand how to write a program get someone else to write it.
12. Recursion is the root of computation since it trades description for time.
119. Programming is an unnatural act.
104. The proof of a system's value is its existence.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
100. We will never run out of things to program as long as there is a single program around.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
59. In English every word can be verbed. Would that it were so in our programming languages.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
90. Computation has made the tree flower.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
119. Programming is an unnatural act.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
27. Once you understand how to write a program get someone else to write it.
55. A LISP programmer knows the value of everything, but the cost of nothing.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
114. Within a computer natural language is unnatural.
40. There are two ways to write error-free programs; only the third one works.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
46. Like punning, programming is a play on words.
21. Optimization hinders evolution.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
119. Programming is an unnatural act.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
40. There are two ways to write error-free programs; only the third one works.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
104. The proof of a system's value is its existence.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
98. In computing, the mean time to failure keeps getting shorter.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
21. Optimization hinders evolution.
78. If your computer speaks English, it was probably made in Japan.
114. Within a computer natural language is unnatural.
61. In programming, as in everything else, to be in error is to be reborn.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
62. In computing, invariants are ephemeral.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
90. Computation has made the tree flower.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
95. Don't have good ideas if you aren't willing to be responsible for them.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
63. When we write programs that "learn", it turns out that we do and they don't.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
119. Programming is an unnatural act.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
63. When we write programs that "learn", it turns out that we do and they don't.
7. It is easier to write an incorrect program than understand a correct one.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
27. Once you understand how to write a program get someone else to write it.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
110. Editing is a rewording activity.
108. Whenever two programmers meet to criticize their programs, both are silent.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
107. The debate rages on: is PL/I Bachtrian or Dromedary?
66. Making something variable is easy. Controlling duration of constancy is the trick.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
63. When we write programs that "learn", it turns out that we do and they don't.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
55. A LISP programmer knows the value of everything, but the cost of nothing.
1. One man's constant is another man's variable.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
57. It is easier to change the specification to fit the program than vice versa.
21. Optimization hinders evolution.
21. Optimization hinders evolution.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
18. A program without a loop and a structured variable isn't worth writing.
11. If you have a procedure with ten parameters, you probably missed some.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
62. In computing, invariants are ephemeral.
98. In computing, the mean time to failure keeps getting shorter.
40. There are two ways to write error-free programs; only the third one works.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
61. In programming, as in everything else, to be in error is to be reborn.
66. Making something variable is easy. Controlling duration of constancy is the trick.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
62. In computing, invariants are ephemeral.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
43. In software systems, it is often the early bird that makes the worm.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
72. An adequate bootstrap is a contradiction in terms.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
40. There are two ways to write error-free programs; only the third one works.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
46. Like punning, programming is a play on words.
15. Everything should be built top-down, except the first time.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
119. Programming is an unnatural act.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
90. Computation has made the tree flower.
21. Optimization hinders evolution.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
43. In software systems, it is often the early bird that makes the worm.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
108. Whenever two programmers meet to criticize their programs, both are silent.
1. One man's constant is another man's variable.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
61. In programming, as in everything else, to be in error is to be reborn.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
38. Structured Programming supports the law of the excluded middle.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
63. When we write programs that "learn", it turns out that we do and they don't.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
98. In computing, the mean time to failure keeps getting shorter.
8. A programming language is low level when its programs require attention to the irrelevant.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
43. In software systems, it is often the early bird that makes the worm.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
112. Computer Science is embarrassed by the computer.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
11. If you have a procedure with ten parameters, you probably missed some.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
31. Simplicity does not precede complexity, but follows it.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
78. If your computer speaks English, it was probably made in Japan.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
4. Every program is a part of some other program and rarely fits.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
103. Purely applicative languages are poorly applicable.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
103. Purely applicative languages are poorly applicable.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
108. Whenever two programmers meet to criticize their programs, both are silent.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
46. Like punning, programming is a play on words.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
17. If a listener nods his head when you're explaining your program, wake him up.
43. In software systems, it is often the early bird that makes the worm.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
98. In computing, the mean time to failure keeps getting shorter.
63. When we write programs that "learn", it turns out that we do and they don't.
103. Purely applicative languages are poorly applicable.
90. Computation has made the tree flower.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
27. Once you understand how to write a program get someone else to write it.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
102. One can't proceed from the informal to the formal by formal means.
60. In seeking the unattainable, simplicity only gets in the way.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
102. One can't proceed from the informal to the formal by formal means.
76. It is the user who should parameterize procedures, not their creators.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
59. In English every word can be verbed. Would that it were so in our programming languages.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
110. Editing is a rewording activity.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
11. If you have a procedure with ten parameters, you probably missed some.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
11. If you have a procedure with ten parameters, you probably missed some.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
72. An adequate bootstrap is a contradiction in terms.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
110. Editing is a rewording activity.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
105. You can't communicate complexity, only an awareness of it.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
1. One man's constant is another man's variable.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
61. In programming, as in everything else, to be in error is to be reborn.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
15. Everything should be built top-down, except the first time.
21. Optimization hinders evolution.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
111. Why did the Roman Empire collapse? What is Latin for office automation?
15. Everything should be built top-down, except the first time.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
115. Most people find the concept of programming obvious, but the doing impossible.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
61. In programming, as in everything else, to be in error is to be reborn.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
46. Like punning, programming is a play on words.
12. Recursion is the root of computation since it trades description for time.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
59. In English every word can be verbed. Would that it were so in our programming languages.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
31. Simplicity does not precede complexity, but follows it.
60. In seeking the unattainable, simplicity only gets in the way.
57. It is easier to change the specification to fit the program than vice versa.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
115. Most people find the concept of programming obvious, but the doing impossible.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
18. A program without a loop and a structured variable isn't worth writing.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
11. If you have a procedure with ten parameters, you probably missed some.
40. There are two ways to write error-free programs; only the third one works.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
43. In software systems, it is often the early bird that makes the worm.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
112. Computer Science is embarrassed by the computer.
62. In computing, invariants are ephemeral.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
111. Why did the Roman Empire collapse? What is Latin for office automation?
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
115. Most people find the concept of programming obvious, but the doing impossible.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
79. A year spent in artificial intelligence is enough to make one believe in God.
7. It is easier to write an incorrect program than understand a correct one.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
12. Recursion is the root of computation since it trades description for time.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
38. Structured Programming supports the law of the excluded middle.
17. If a listener nods his head when you're explaining your program, wake him up.
103. Purely applicative languages are poorly applicable.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
104. The proof of a system's value is its existence.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
8. A programming language is low level when its programs require attention to the irrelevant.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
40. There are two ways to write error-free programs; only the third one works.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
55. A LISP programmer knows the value of everything, but the cost of nothing.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
104. The proof of a system's value is its existence.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
14. In the long run every program becomes rococo - then rubble.
110. Editing is a rewording activity.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
103. Purely applicative languages are poorly applicable.
63. When we write programs that "learn", it turns out that we do and they don't.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
115. Most people find the concept of programming obvious, but the doing impossible.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
119. Programming is an unnatural act.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
23. To understand a program you must become both the machine and the program.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
96. Computers don't introduce order anywhere as much as they expose opportunities.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
15. Everything should be built top-down, except the first time.
4. Every program is a part of some other program and rarely fits.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
40. There are two ways to write error-free programs; only the third one works.
63. When we write programs that "learn", it turns out that we do and they don't.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
47. As Will Rogers would have said, "There is no such thing as a free variable."
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
15. Everything should be built top-down, except the first time.
40. There are two ways to write error-free programs; only the third one works.
110. Editing is a rewording activity.
98. In computing, the mean time to failure keeps getting shorter.
60. In seeking the unattainable, simplicity only gets in the way.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
15. Everything should be built top-down, except the first time.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
57. It is easier to change the specification to fit the program than vice versa.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
31. Simplicity does not precede complexity, but follows it.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
22. A good system can't have a weak command language.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
115. Most people find the concept of programming obvious, but the doing impossible.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
7. It is easier to write an incorrect program than understand a correct one.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
78. If your computer speaks English, it was probably made in Japan.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
27. Once you understand how to write a program get someone else to write it.
12. Recursion is the root of computation since it trades description for time.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
104. The proof of a system's value is its existence.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
11. If you have a procedure with ten parameters, you probably missed some.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
63. When we write programs that "learn", it turns out that we do and they don't.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
72. An adequate bootstrap is a contradiction in terms.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
119. Programming is an unnatural act.
43. In software systems, it is often the early bird that makes the worm.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
108. Whenever two programmers meet to criticize their programs, both are silent.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
119. Programming is an unnatural act.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
119. Programming is an unnatural act.
112. Computer Science is embarrassed by the computer.
47. As Will Rogers would have said, "There is no such thing as a free variable."
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
105. You can't communicate complexity, only an awareness of it.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
61. In programming, as in everything else, to be in error is to be reborn.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
76. It is the user who should parameterize procedures, not their creators.
3. Syntactic sugar causes cancer of the semicolon.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
15. Everything should be built top-down, except the first time.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
61. In programming, as in everything else, to be in error is to be reborn.
104. The proof of a system's value is its existence.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
23. To understand a program you must become both the machine and the program.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
96. Computers don't introduce order anywhere as much as they expose opportunities.
114. Within a computer natural language is unnatural.
72. An adequate bootstrap is a contradiction in terms.
90. Computation has made the tree flower.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
72. An adequate bootstrap is a contradiction in terms.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
110. Editing is a rewording activity.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
55. A LISP programmer knows the value of everything, but the cost of nothing.
63. When we write programs that "learn", it turns out that we do and they don't.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
63. When we write programs that "learn", it turns out that we do and they don't.
111. Why did the Roman Empire collapse? What is Latin for office automation?
61. In programming, as in everything else, to be in error is to be reborn.
22. A good system can't have a weak command language.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
4. Every program is a part of some other program and rarely fits.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
43. In software systems, it is often the early bird that makes the worm.
47. As Will Rogers would have said, "There is no such thing as a free variable."
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
72. An adequate bootstrap is a contradiction in terms.
7. It is easier to write an incorrect program than understand a correct one.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
76. It is the user who should parameterize procedures, not their creators.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
18. A program without a loop and a structured variable isn't worth writing.
1. One man's constant is another man's variable.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
72. An adequate bootstrap is a contradiction in terms.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
111. Why did the Roman Empire collapse? What is Latin for office automation?
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
78. If your computer speaks English, it was probably made in Japan.
46. Like punning, programming is a play on words.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
63. When we write programs that "learn", it turns out that we do and they don't.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
59. In English every word can be verbed. Would that it were so in our programming languages.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
76. It is the user who should parameterize procedures, not their creators.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
59. In English every word can be verbed. Would that it were so in our programming languages.
47. As Will Rogers would have said, "There is no such thing as a free variable."
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
110. Editing is a rewording activity.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
62. In computing, invariants are ephemeral.
40. There are two ways to write error-free programs; only the third one works.
100. We will never run out of things to program as long as there is a single program around.
60. In seeking the unattainable, simplicity only gets in the way.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
102. One can't proceed from the informal to the formal by formal means.
60. In seeking the unattainable, simplicity only gets in the way.
4. Every program is a part of some other program and rarely fits.
18. A program without a loop and a structured variable isn't worth writing.
7. It is easier to write an incorrect program than understand a correct one.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
72. An adequate bootstrap is a contradiction in terms.
111. Why did the Roman Empire collapse? What is Latin for office automation?
72. An adequate bootstrap is a contradiction in terms.
15. Everything should be built top-down, except the first time.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
63. When we write programs that "learn", it turns out that we do and they don't.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
11. If you have a procedure with ten parameters, you probably missed some.
38. Structured Programming supports the law of the excluded middle.
96. Computers don't introduce order anywhere as much as they expose opportunities.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
66. Making something variable is easy. Controlling duration of constancy is the trick.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
3. Syntactic sugar causes cancer of the semicolon.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
40. There are two ways to write error-free programs; only the third one works.
102. One can't proceed from the informal to the formal by formal means.
103. Purely applicative languages are poorly applicable.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
119. Programming is an unnatural act.
55. A LISP programmer knows the value of everything, but the cost of nothing.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
18. A program without a loop and a structured variable isn't worth writing.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
59. In English every word can be verbed. Would that it were so in our programming languages.
104. The proof of a system's value is its existence.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
8. A programming language is low level when its programs require attention to the irrelevant.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
95. Don't have good ideas if you aren't willing to be responsible for them.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
38. Structured Programming supports the law of the excluded middle.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
95. Don't have good ideas if you aren't willing to be responsible for them.
102. One can't proceed from the informal to the formal by formal means.
105. You can't communicate complexity, only an awareness of it.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
60. In seeking the unattainable, simplicity only gets in the way.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
40. There are two ways to write error-free programs; only the third one works.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
60. In seeking the unattainable, simplicity only gets in the way.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
110. Editing is a rewording activity.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
111. Why did the Roman Empire collapse? What is Latin for office automation?
57. It is easier to change the specification to fit the program than vice versa.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
90. Computation has made the tree flower.
41. Some programming languages manage to absorb change, but withstand progress.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
66. Making something variable is easy. Controlling duration of constancy is the trick.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
78. If your computer speaks English, it was probably made in Japan.
112. Computer Science is embarrassed by the computer.
90. Computation has made the tree flower.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
7. It is easier to write an incorrect program than understand a correct one.
111. Why did the Roman Empire collapse? What is Latin for office automation?
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
27. Once you understand how to write a program get someone else to write it.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
115. Most people find the concept of programming obvious, but the doing impossible.
114. Within a computer natural language is unnatural.
31. Simplicity does not precede complexity, but follows it.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
66. Making something variable is easy. Controlling duration of constancy is the trick.
108. Whenever two programmers meet to criticize their programs, both are silent.
41. Some programming languages manage to absorb change, but withstand progress.
59. In English every word can be verbed. Would that it were so in our programming languages.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
72. An adequate bootstrap is a contradiction in terms.
119. Programming is an unnatural act.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
72. An adequate bootstrap is a contradiction in terms.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
78. If your computer speaks English, it was probably made in Japan.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
105. You can't communicate complexity, only an awareness of it.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
57. It is easier to change the specification to fit the program than vice versa.
41. Some programming languages manage to absorb change, but withstand progress.
3. Syntactic sugar causes cancer of the semicolon.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
104. The proof of a system's value is its existence.
90. Computation has made the tree flower.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
1. One man's constant is another man's variable.
108. Whenever two programmers meet to criticize their programs, both are silent.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
76. It is the user who should parameterize procedures, not their creators.
111. Why did the Roman Empire collapse? What is Latin for office automation?
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
66. Making something variable is easy. Controlling duration of constancy is the trick.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
18. A program without a loop and a structured variable isn't worth writing.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
90. Computation has made the tree flower.
104. The proof of a system's value is its existence.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
62. In computing, invariants are ephemeral.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
46. Like punning, programming is a play on words.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
114. Within a computer natural language is unnatural.
102. One can't proceed from the informal to the formal by formal means.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
61. In programming, as in everything else, to be in error is to be reborn.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
22. A good system can't have a weak command language.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
79. A year spent in artificial intelligence is enough to make one believe in God.
27. Once you understand how to write a program get someone else to write it.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
66. Making something variable is easy. Controlling duration of constancy is the trick.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
100. We will never run out of things to program as long as there is a single program around.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
46. Like punning, programming is a play on words.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
17. If a listener nods his head when you're explaining your program, wake him up.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
115. Most people find the concept of programming obvious, but the doing impossible.
96. Computers don't introduce order anywhere as much as they expose opportunities.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
27. Once you understand how to write a program get someone else to write it.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
55. A LISP programmer knows the value of everything, but the cost of nothing.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
90. Computation has made the tree flower.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
96. Computers don't introduce order anywhere as much as they expose opportunities.
4. Every program is a part of some other program and rarely fits.
59. In English every word can be verbed. Would that it were so in our programming languages.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
105. You can't communicate complexity, only an awareness of it.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
98. In computing, the mean time to failure keeps getting shorter.
98. In computing, the mean time to failure keeps getting shorter.
90. Computation has made the tree flower.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
22. A good system can't have a weak command language.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
90. Computation has made the tree flower.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
111. Why did the Roman Empire collapse? What is Latin for office automation?
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
79. A year spent in artificial intelligence is enough to make one believe in God.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
76. It is the user who should parameterize procedures, not their creators.
7. It is easier to write an incorrect program than understand a correct one.
46. Like punning, programming is a play on words.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
57. It is easier to change the specification to fit the program than vice versa.
96. Computers don't introduce order anywhere as much as they expose opportunities.
17. If a listener nods his head when you're explaining your program, wake him up.
105. You can't communicate complexity, only an awareness of it.
7. It is easier to write an incorrect program than understand a correct one.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
18. A program without a loop and a structured variable isn't worth writing.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
7. It is easier to write an incorrect program than understand a correct one.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
4. Every program is a part of some other program and rarely fits.
11. If you have a procedure with ten parameters, you probably missed some.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
72. An adequate bootstrap is a contradiction in terms.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
62. In computing, invariants are ephemeral.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
55. A LISP programmer knows the value of everything, but the cost of nothing.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
18. A program without a loop and a structured variable isn't worth writing.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
95. Don't have good ideas if you aren't willing to be responsible for them.
95. Don't have good ideas if you aren't willing to be responsible for them.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
78. If your computer speaks English, it was probably made in Japan.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
66. Making something variable is easy. Controlling duration of constancy is the trick.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
11. If you have a procedure with ten parameters, you probably missed some.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
78. If your computer speaks English, it was probably made in Japan.
79. A year spent in artificial intelligence is enough to make one believe in God.
40. There are two ways to write error-free programs; only the third one works.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
119. Programming is an unnatural act.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
27. Once you understand how to write a program get someone else to write it.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
47. As Will Rogers would have said, "There is no such thing as a free variable."
111. Why did the Roman Empire collapse? What is Latin for office automation?
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
90. Computation has made the tree flower.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
11. If you have a procedure with ten parameters, you probably missed some.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
18. A program without a loop and a structured variable isn't worth writing.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
72. An adequate bootstrap is a contradiction in terms.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
15. Everything should be built top-down, except the first time.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
100. We will never run out of things to program as long as there is a single program around.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
18. A program without a loop and a structured variable isn't worth writing.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
47. As Will Rogers would have said, "There is no such thing as a free variable."
95. Don't have good ideas if you aren't willing to be responsible for them.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
110. Editing is a rewording activity.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
119. Programming is an unnatural act.
38. Structured Programming supports the law of the excluded middle.
98. In computing, the mean time to failure keeps getting shorter.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
47. As Will Rogers would have said, "There is no such thing as a free variable."
112. Computer Science is embarrassed by the computer.
112. Computer Science is embarrassed by the computer.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
3. Syntactic sugar causes cancer of the semicolon.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
12. Recursion is the root of computation since it trades description for time.
104. The proof of a system's value is its existence.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
4. Every program is a part of some other program and rarely fits.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
61. In programming, as in everything else, to be in error is to be reborn.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
38. Structured Programming supports the law of the excluded middle.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
63. When we write programs that "learn", it turns out that we do and they don't.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
18. A program without a loop and a structured variable isn't worth writing.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
102. One can't proceed from the informal to the formal by formal means.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
38. Structured Programming supports the law of the excluded middle.
111. Why did the Roman Empire collapse? What is Latin for office automation?
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
78. If your computer speaks English, it was probably made in Japan.
31. Simplicity does not precede complexity, but follows it.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
95. Don't have good ideas if you aren't willing to be responsible for them.
66. Making something variable is easy. Controlling duration of constancy is the trick.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
12. Recursion is the root of computation since it trades description for time.
96. Computers don't introduce order anywhere as much as they expose opportunities.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
76. It is the user who should parameterize procedures, not their creators.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
38. Structured Programming supports the law of the excluded middle.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
110. Editing is a rewording activity.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
59. In English every word can be verbed. Would that it were so in our programming languages.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
104. The proof of a system's value is its existence.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
47. As Will Rogers would have said, "There is no such thing as a free variable."
23. To understand a program you must become both the machine and the program.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
40. There are two ways to write error-free programs; only the third one works.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
76. It is the user who should parameterize procedures, not their creators.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
27. Once you understand how to write a program get someone else to write it.
47. As Will Rogers would have said, "There is no such thing as a free variable."
41. Some programming languages manage to absorb change, but withstand progress.
27. Once you understand how to write a program get someone else to write it.
27. Once you understand how to write a program get someone else to write it.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
31. Simplicity does not precede complexity, but follows it.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
57. It is easier to change the specification to fit the program than vice versa.
78. If your computer speaks English, it was probably made in Japan.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
100. We will never run out of things to program as long as there is a single program around.
47. As Will Rogers would have said, "There is no such thing as a free variable."
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
110. Editing is a rewording activity.
27. Once you understand how to write a program get someone else to write it.
112. Computer Science is embarrassed by the computer.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
119. Programming is an unnatural act.
63. When we write programs that "learn", it turns out that we do and they don't.
22. A good system can't have a weak command language.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
90. Computation has made the tree flower.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
100. We will never run out of things to program as long as there is a single program around.
47. As Will Rogers would have said, "There is no such thing as a free variable."
115. Most people find the concept of programming obvious, but the doing impossible.
23. To understand a program you must become both the machine and the program.
11. If you have a procedure with ten parameters, you probably missed some.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
7. It is easier to write an incorrect program than understand a correct one.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
17. If a listener nods his head when you're explaining your program, wake him up.
104. The proof of a system's value is its existence.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
96. Computers don't introduce order anywhere as much as they expose opportunities.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
108. Whenever two programmers meet to criticize their programs, both are silent.
111. Why did the Roman Empire collapse? What is Latin for office automation?
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
55. A LISP programmer knows the value of everything, but the cost of nothing.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
27. Once you understand how to write a program get someone else to write it.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
23. To understand a program you must become both the machine and the program.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
79. A year spent in artificial intelligence is enough to make one believe in God.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
40. There are two ways to write error-free programs; only the third one works.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
27. Once you understand how to write a program get someone else to write it.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
111. Why did the Roman Empire collapse? What is Latin for office automation?
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
62. In computing, invariants are ephemeral.
112. Computer Science is embarrassed by the computer.
96. Computers don't introduce order anywhere as much as they expose opportunities.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
1. One man's constant is another man's variable.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
8. A programming language is low level when its programs require attention to the irrelevant.
90. Computation has made the tree flower.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
3. Syntactic sugar causes cancer of the semicolon.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
114. Within a computer natural language is unnatural.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
105. You can't communicate complexity, only an awareness of it.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
72. An adequate bootstrap is a contradiction in terms.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
1. One man's constant is another man's variable.
47. As Will Rogers would have said, "There is no such thing as a free variable."
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
27. Once you understand how to write a program get someone else to write it.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
1. One man's constant is another man's variable.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
3. Syntactic sugar causes cancer of the semicolon.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
100. We will never run out of things to program as long as there is a single program around.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
119. Programming is an unnatural act.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
47. As Will Rogers would have said, "There is no such thing as a free variable."
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
63. When we write programs that "learn", it turns out that we do and they don't.
114. Within a computer natural language is unnatural.
76. It is the user who should parameterize procedures, not their creators.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
7. It is easier to write an incorrect program than understand a correct one.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
108. Whenever two programmers meet to criticize their programs, both are silent.
78. If your computer speaks English, it was probably made in Japan.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
66. Making something variable is easy. Controlling duration of constancy is the trick.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
15. Everything should be built top-down, except the first time.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
22. A good system can't have a weak command language.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
60. In seeking the unattainable, simplicity only gets in the way.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
8. A programming language is low level when its programs require attention to the irrelevant.
111. Why did the Roman Empire collapse? What is Latin for office automation?
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
22. A good system can't have a weak command language.
112. Computer Science is embarrassed by the computer.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
110. Editing is a rewording activity.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
98. In computing, the mean time to failure keeps getting shorter.
108. Whenever two programmers meet to criticize their programs, both are silent.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
66. Making something variable is easy. Controlling duration of constancy is the trick.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
98. In computing, the mean time to failure keeps getting shorter.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
15. Everything should be built top-down, except the first time.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
63. When we write programs that "learn", it turns out that we do and they don't.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
95. Don't have good ideas if you aren't willing to be responsible for them.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
15. Everything should be built top-down, except the first time.
95. Don't have good ideas if you aren't willing to be responsible for them.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
78. If your computer speaks English, it was probably made in Japan.
76. It is the user who should parameterize procedures, not their creators.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
60. In seeking the unattainable, simplicity only gets in the way.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
111. Why did the Roman Empire collapse? What is Latin for office automation?
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
108. Whenever two programmers meet to criticize their programs, both are silent.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
61. In programming, as in everything else, to be in error is to be reborn.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
4. Every program is a part of some other program and rarely fits.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
112. Computer Science is embarrassed by the computer.
105. You can't communicate complexity, only an awareness of it.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
40. There are two ways to write error-free programs; only the third one works.
108. Whenever two programmers meet to criticize their programs, both are silent.
11. If you have a procedure with ten parameters, you probably missed some.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
61. In programming, as in everything else, to be in error is to be reborn.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
78. If your computer speaks English, it was probably made in Japan.
103. Purely applicative languages are poorly applicable.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
72. An adequate bootstrap is a contradiction in terms.
46. Like punning, programming is a play on words.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
46. Like punning, programming is a play on words.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
110. Editing is a rewording activity.
59. In English every word can be verbed. Would that it were so in our programming languages.
43. In software systems, it is often the early bird that makes the worm.
22. A good system can't have a weak command language.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
115. Most people find the concept of programming obvious, but the doing impossible.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
102. One can't proceed from the informal to the formal by formal means.
38. Structured Programming supports the law of the excluded middle.
18. A program without a loop and a structured variable isn't worth writing.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
21. Optimization hinders evolution.
18. A program without a loop and a structured variable isn't worth writing.
76. It is the user who should parameterize procedures, not their creators.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
3. Syntactic sugar causes cancer of the semicolon.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
17. If a listener nods his head when you're explaining your program, wake him up.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
7. It is easier to write an incorrect program than understand a correct one.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
100. We will never run out of things to program as long as there is a single program around.
103. Purely applicative languages are poorly applicable.
110. Editing is a rewording activity.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
27. Once you understand how to write a program get someone else to write it.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
55. A LISP programmer knows the value of everything, but the cost of nothing.
79. A year spent in artificial intelligence is enough to make one believe in God.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
11. If you have a procedure with ten parameters, you probably missed some.
40. There are two ways to write error-free programs; only the third one works.
22. A good system can't have a weak command language.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
31. Simplicity does not precede complexity, but follows it.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
8. A programming language is low level when its programs require attention to the irrelevant.
108. Whenever two programmers meet to criticize their programs, both are silent.
59. In English every word can be verbed. Would that it were so in our programming languages.
79. A year spent in artificial intelligence is enough to make one believe in God.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
114. Within a computer natural language is unnatural.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
38. Structured Programming supports the law of the excluded middle.
27. Once you understand how to write a program get someone else to write it.
102. One can't proceed from the informal to the formal by formal means.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
41. Some programming languages manage to absorb change, but withstand progress.
21. Optimization hinders evolution.
8. A programming language is low level when its programs require attention to the irrelevant.
79. A year spent in artificial intelligence is enough to make one believe in God.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
57. It is easier to change the specification to fit the program than vice versa.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
40. There are two ways to write error-free programs; only the third one works.
105. You can't communicate complexity, only an awareness of it.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
27. Once you understand how to write a program get someone else to write it.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
3. Syntactic sugar causes cancer of the semicolon.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
38. Structured Programming supports the law of the excluded middle.
63. When we write programs that "learn", it turns out that we do and they don't.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
111. Why did the Roman Empire collapse? What is Latin for office automation?
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
63. When we write programs that "learn", it turns out that we do and they don't.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
4. Every program is a part of some other program and rarely fits.
110. Editing is a rewording activity.
63. When we write programs that "learn", it turns out that we do and they don't.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
103. Purely applicative languages are poorly applicable.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
23. To understand a program you must become both the machine and the program.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
76. It is the user who should parameterize procedures, not their creators.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
21. Optimization hinders evolution.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
90. Computation has made the tree flower.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
105. You can't communicate complexity, only an awareness of it.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
76. It is the user who should parameterize procedures, not their creators.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
79. A year spent in artificial intelligence is enough to make one believe in God.
119. Programming is an unnatural act.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
22. A good system can't have a weak command language.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
17. If a listener nods his head when you're explaining your program, wake him up.
3. Syntactic sugar causes cancer of the semicolon.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
96. Computers don't introduce order anywhere as much as they expose opportunities.
112. Computer Science is embarrassed by the computer.
110. Editing is a rewording activity.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
46. Like punning, programming is a play on words.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
102. One can't proceed from the informal to the formal by formal means.
60. In seeking the unattainable, simplicity only gets in the way.
62. In computing, invariants are ephemeral.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
79. A year spent in artificial intelligence is enough to make one believe in God.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
8. A programming language is low level when its programs require attention to the irrelevant.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
110. Editing is a rewording activity.
41. Some programming languages manage to absorb change, but withstand progress.
1. One man's constant is another man's variable.
43. In software systems, it is often the early bird that makes the worm.
112. Computer Science is embarrassed by the computer.
100. We will never run out of things to program as long as there is a single program around.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
18. A program without a loop and a structured variable isn't worth writing.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
12. Recursion is the root of computation since it trades description for time.
115. Most people find the concept of programming obvious, but the doing impossible.
110. Editing is a rewording activity.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
55. A LISP programmer knows the value of everything, but the cost of nothing.
18. A program without a loop and a structured variable isn't worth writing.
8. A programming language is low level when its programs require attention to the irrelevant.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
31. Simplicity does not precede complexity, but follows it.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
66. Making something variable is easy. Controlling duration of constancy is the trick.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
57. It is easier to change the specification to fit the program than vice versa.
60. In seeking the unattainable, simplicity only gets in the way.
17. If a listener nods his head when you're explaining your program, wake him up.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
100. We will never run out of things to program as long as there is a single program around.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
114. Within a computer natural language is unnatural.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
55. A LISP programmer knows the value of everything, but the cost of nothing.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
96. Computers don't introduce order anywhere as much as they expose opportunities.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
59. In English every word can be verbed. Would that it were so in our programming languages.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
7. It is easier to write an incorrect program than understand a correct one.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
100. We will never run out of things to program as long as there is a single program around.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
90. Computation has made the tree flower.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
62. In computing, invariants are ephemeral.
112. Computer Science is embarrassed by the computer.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
4. Every program is a part of some other program and rarely fits.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
22. A good system can't have a weak command language.
66. Making something variable is easy. Controlling duration of constancy is the trick.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
57. It is easier to change the specification to fit the program than vice versa.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
60. In seeking the unattainable, simplicity only gets in the way.
63. When we write programs that "learn", it turns out that we do and they don't.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
112. Computer Science is embarrassed by the computer.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
40. There are two ways to write error-free programs; only the third one works.
31. Simplicity does not precede complexity, but follows it.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
96. Computers don't introduce order anywhere as much as they expose opportunities.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
110. Editing is a rewording activity.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
22. A good system can't have a weak command language.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
104. The proof of a system's value is its existence.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
11. If you have a procedure with ten parameters, you probably missed some.
104. The proof of a system's value is its existence.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
105. You can't communicate complexity, only an awareness of it.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
104. The proof of a system's value is its existence.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
63. When we write programs that "learn", it turns out that we do and they don't.
103. Purely applicative languages are poorly applicable.
119. Programming is an unnatural act.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
115. Most people find the concept of programming obvious, but the doing impossible.
103. Purely applicative languages are poorly applicable.
23. To understand a program you must become both the machine and the program.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
7. It is easier to write an incorrect program than understand a correct one.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
63. When we write programs that "learn", it turns out that we do and they don't.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
103. Purely applicative languages are poorly applicable.
21. Optimization hinders evolution.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
46. Like punning, programming is a play on words.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
23. To understand a program you must become both the machine and the program.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
4. Every program is a part of some other program and rarely fits.
90. Computation has made the tree flower.
60. In seeking the unattainable, simplicity only gets in the way.
61. In programming, as in everything else, to be in error is to be reborn.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
59. In English every word can be verbed. Would that it were so in our programming languages.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
21. Optimization hinders evolution.
76. It is the user who should parameterize procedures, not their creators.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
27. Once you understand how to write a program get someone else to write it.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
104. The proof of a system's value is its existence.
104. The proof of a system's value is its existence.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
115. Most people find the concept of programming obvious, but the doing impossible.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
112. Computer Science is embarrassed by the computer.
60. In seeking the unattainable, simplicity only gets in the way.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
47. As Will Rogers would have said, "There is no such thing as a free variable."
100. We will never run out of things to program as long as there is a single program around.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
22. A good system can't have a weak command language.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
22. A good system can't have a weak command language.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
27. Once you understand how to write a program get someone else to write it.
72. An adequate bootstrap is a contradiction in terms.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
43. In software systems, it is often the early bird that makes the worm.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
62. In computing, invariants are ephemeral.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
98. In computing, the mean time to failure keeps getting shorter.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
47. As Will Rogers would have said, "There is no such thing as a free variable."
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
105. You can't communicate complexity, only an awareness of it.
22. A good system can't have a weak command language.
102. One can't proceed from the informal to the formal by formal means.
17. If a listener nods his head when you're explaining your program, wake him up.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
12. Recursion is the root of computation since it trades description for time.
31. Simplicity does not precede complexity, but follows it.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
47. As Will Rogers would have said, "There is no such thing as a free variable."
90. Computation has made the tree flower.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
43. In software systems, it is often the early bird that makes the worm.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
27. Once you understand how to write a program get someone else to write it.
66. Making something variable is easy. Controlling duration of constancy is the trick.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
114. Within a computer natural language is unnatural.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
46. Like punning, programming is a play on words.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
72. An adequate bootstrap is a contradiction in terms.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
78. If your computer speaks English, it was probably made in Japan.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
22. A good system can't have a weak command language.
103. Purely applicative languages are poorly applicable.
114. Within a computer natural language is unnatural.
72. An adequate bootstrap is a contradiction in terms.
7. It is easier to write an incorrect program than understand a correct one.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
96. Computers don't introduce order anywhere as much as they expose opportunities.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
55. A LISP programmer knows the value of everything, but the cost of nothing.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
60. In seeking the unattainable, simplicity only gets in the way.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
23. To understand a program you must become both the machine and the program.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
105. You can't communicate complexity, only an awareness of it.
40. There are two ways to write error-free programs; only the third one works.
43. In software systems, it is often the early bird that makes the worm.
62. In computing, invariants are ephemeral.
43. In software systems, it is often the early bird that makes the worm.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
95. Don't have good ideas if you aren't willing to be responsible for them.
22. A good system can't have a weak command language.
110. Editing is a rewording activity.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
1. One man's constant is another man's variable.
4. Every program is a part of some other program and rarely fits.
59. In English every word can be verbed. Would that it were so in our programming languages.
63. When we write programs that "learn", it turns out that we do and they don't.
38. Structured Programming supports the law of the excluded middle.
7. It is easier to write an incorrect program than understand a correct one.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
4. Every program is a part of some other program and rarely fits.
40. There are two ways to write error-free programs; only the third one works.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
66. Making something variable is easy. Controlling duration of constancy is the trick.
11. If you have a procedure with ten parameters, you probably missed some.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
72. An adequate bootstrap is a contradiction in terms.
4. Every program is a part of some other program and rarely fits.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
31. Simplicity does not precede complexity, but follows it.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
23. To understand a program you must become both the machine and the program.
57. It is easier to change the specification to fit the program than vice versa.
21. Optimization hinders evolution.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
1. One man's constant is another man's variable.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
102. One can't proceed from the informal to the formal by formal means.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
57. It is easier to change the specification to fit the program than vice versa.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
108. Whenever two programmers meet to criticize their programs, both are silent.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
31. Simplicity does not precede complexity, but follows it.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
114. Within a computer natural language is unnatural.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
41. Some programming languages manage to absorb change, but withstand progress.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
98. In computing, the mean time to failure keeps getting shorter.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
111. Why did the Roman Empire collapse? What is Latin for office automation?
1. One man's constant is another man's variable.
40. There are two ways to write error-free programs; only the third one works.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
43. In software systems, it is often the early bird that makes the worm.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
78. If your computer speaks English, it was probably made in Japan.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
61. In programming, as in everything else, to be in error is to be reborn.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
103. Purely applicative languages are poorly applicable.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
100. We will never run out of things to program as long as there is a single program around.
11. If you have a procedure with ten parameters, you probably missed some.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
62. In computing, invariants are ephemeral.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
98. In computing, the mean time to failure keeps getting shorter.
1. One man's constant is another man's variable.
72. An adequate bootstrap is a contradiction in terms.
100. We will never run out of things to program as long as there is a single program around.
3. Syntactic sugar causes cancer of the semicolon.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
7. It is easier to write an incorrect program than understand a correct one.
12. Recursion is the root of computation since it trades description for time.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
102. One can't proceed from the informal to the formal by formal means.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
43. In software systems, it is often the early bird that makes the worm.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
15. Everything should be built top-down, except the first time.
15. Everything should be built top-down, except the first time.
76. It is the user who should parameterize procedures, not their creators.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
62. In computing, invariants are ephemeral.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
110. Editing is a rewording activity.
119. Programming is an unnatural act.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
1. One man's constant is another man's variable.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
62. In computing, invariants are ephemeral.
38. Structured Programming supports the law of the excluded middle.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
23. To understand a program you must become both the machine and the program.
21. Optimization hinders evolution.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
21. Optimization hinders evolution.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
15. Everything should be built top-down, except the first time.
55. A LISP programmer knows the value of everything, but the cost of nothing.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
115. Most people find the concept of programming obvious, but the doing impossible.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
111. Why did the Roman Empire collapse? What is Latin for office automation?
47. As Will Rogers would have said, "There is no such thing as a free variable."
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
59. In English every word can be verbed. Would that it were so in our programming languages.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
11. If you have a procedure with ten parameters, you probably missed some.
95. Don't have good ideas if you aren't willing to be responsible for them.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
46. Like punning, programming is a play on words.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
104. The proof of a system's value is its existence.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
40. There are two ways to write error-free programs; only the third one works.
15. Everything should be built top-down, except the first time.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
79. A year spent in artificial intelligence is enough to make one believe in God.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
23. To understand a program you must become both the machine and the program.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
4. Every program is a part of some other program and rarely fits.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
27. Once you understand how to write a program get someone else to write it.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
11. If you have a procedure with ten parameters, you probably missed some.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
46. Like punning, programming is a play on words.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
7. It is easier to write an incorrect program than understand a correct one.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
115. Most people find the concept of programming obvious, but the doing impossible.
1. One man's constant is another man's variable.
104. The proof of a system's value is its existence.
62. In computing, invariants are ephemeral.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
4. Every program is a part of some other program and rarely fits.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
38. Structured Programming supports the law of the excluded middle.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
104. The proof of a system's value is its existence.
8. A programming language is low level when its programs require attention to the irrelevant.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
38. Structured Programming supports the law of the excluded middle.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
104. The proof of a system's value is its existence.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
12. Recursion is the root of computation since it trades description for time.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
103. Purely applicative languages are poorly applicable.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
31. Simplicity does not precede complexity, but follows it.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
110. Editing is a rewording activity.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
43. In software systems, it is often the early bird that makes the worm.
110. Editing is a rewording activity.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
112. Computer Science is embarrassed by the computer.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
108. Whenever two programmers meet to criticize their programs, both are silent.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
104. The proof of a system's value is its existence.
115. Most people find the concept of programming obvious, but the doing impossible.
60. In seeking the unattainable, simplicity only gets in the way.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
119. Programming is an unnatural act.
27. Once you understand how to write a program get someone else to write it.
98. In computing, the mean time to failure keeps getting shorter.
61. In programming, as in everything else, to be in error is to be reborn.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
63. When we write programs that "learn", it turns out that we do and they don't.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
4. Every program is a part of some other program and rarely fits.
104. The proof of a system's value is its existence.
4. Every program is a part of some other program and rarely fits.
18. A program without a loop and a structured variable isn't worth writing.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
40. There are two ways to write error-free programs; only the third one works.
66. Making something variable is easy. Controlling duration of constancy is the trick.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
12. Recursion is the root of computation since it trades description for time.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
55. A LISP programmer knows the value of everything, but the cost of nothing.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
108. Whenever two programmers meet to criticize their programs, both are silent.
8. A programming language is low level when its programs require attention to the irrelevant.
96. Computers don't introduce order anywhere as much as they expose opportunities.
115. Most people find the concept of programming obvious, but the doing impossible.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
108. Whenever two programmers meet to criticize their programs, both are silent.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
108. Whenever two programmers meet to criticize their programs, both are silent.
57. It is easier to change the specification to fit the program than vice versa.
98. In computing, the mean time to failure keeps getting shorter.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
43. In software systems, it is often the early bird that makes the worm.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
23. To understand a program you must become both the machine and the program.
23. To understand a program you must become both the machine and the program.
72. An adequate bootstrap is a contradiction in terms.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
95. Don't have good ideas if you aren't willing to be responsible for them.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
57. It is easier to change the specification to fit the program than vice versa.
47. As Will Rogers would have said, "There is no such thing as a free variable."
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
79. A year spent in artificial intelligence is enough to make one believe in God.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
15. Everything should be built top-down, except the first time.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
23. To understand a program you must become both the machine and the program.
7. It is easier to write an incorrect program than understand a correct one.
17. If a listener nods his head when you're explaining your program, wake him up.
57. It is easier to change the specification to fit the program than vice versa.
14. In the long run every program becomes rococo - then rubble.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
111. Why did the Roman Empire collapse? What is Latin for office automation?
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
4. Every program is a part of some other program and rarely fits.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
115. Most people find the concept of programming obvious, but the doing impossible.
90. Computation has made the tree flower.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
61. In programming, as in everything else, to be in error is to be reborn.
1. One man's constant is another man's variable.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
46. Like punning, programming is a play on words.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
60. In seeking the unattainable, simplicity only gets in the way.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
47. As Will Rogers would have said, "There is no such thing as a free variable."
11. If you have a procedure with ten parameters, you probably missed some.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
111. Why did the Roman Empire collapse? What is Latin for office automation?
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
112. Computer Science is embarrassed by the computer.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
119. Programming is an unnatural act.
14. In the long run every program becomes rococo - then rubble.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
11. If you have a procedure with ten parameters, you probably missed some.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
62. In computing, invariants are ephemeral.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
17. If a listener nods his head when you're explaining your program, wake him up.
47. As Will Rogers would have said, "There is no such thing as a free variable."
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
14. In the long run every program becomes rococo - then rubble.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
3. Syntactic sugar causes cancer of the semicolon.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
79. A year spent in artificial intelligence is enough to make one believe in God.
100. We will never run out of things to program as long as there is a single program around.
40. There are two ways to write error-free programs; only the third one works.
103. Purely applicative languages are poorly applicable.
76. It is the user who should parameterize procedures, not their creators.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
102. One can't proceed from the informal to the formal by formal means.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
61. In programming, as in everything else, to be in error is to be reborn.
22. A good system can't have a weak command language.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
63. When we write programs that "learn", it turns out that we do and they don't.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
7. It is easier to write an incorrect program than understand a correct one.
21. Optimization hinders evolution.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
18. A program without a loop and a structured variable isn't worth writing.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
72. An adequate bootstrap is a contradiction in terms.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
23. To understand a program you must become both the machine and the program.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
119. Programming is an unnatural act.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
105. You can't communicate complexity, only an awareness of it.
98. In computing, the mean time to failure keeps getting shorter.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
66. Making something variable is easy. Controlling duration of constancy is the trick.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
105. You can't communicate complexity, only an awareness of it.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
17. If a listener nods his head when you're explaining your program, wake him up.
78. If your computer speaks English, it was probably made in Japan.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
27. Once you understand how to write a program get someone else to write it.
90. Computation has made the tree flower.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
1. One man's constant is another man's variable.
57. It is easier to change the specification to fit the program than vice versa.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
18. A program without a loop and a structured variable isn't worth writing.
115. Most people find the concept of programming obvious, but the doing impossible.
114. Within a computer natural language is unnatural.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
61. In programming, as in everything else, to be in error is to be reborn.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
98. In computing, the mean time to failure keeps getting shorter.
72. An adequate bootstrap is a contradiction in terms.
14. In the long run every program becomes rococo - then rubble.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
114. Within a computer natural language is unnatural.
72. An adequate bootstrap is a contradiction in terms.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
72. An adequate bootstrap is a contradiction in terms.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
63. When we write programs that "learn", it turns out that we do and they don't.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
12. Recursion is the root of computation since it trades description for time.
111. Why did the Roman Empire collapse? What is Latin for office automation?
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
111. Why did the Roman Empire collapse? What is Latin for office automation?
17. If a listener nods his head when you're explaining your program, wake him up.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
21. Optimization hinders evolution.
108. Whenever two programmers meet to criticize their programs, both are silent.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
43. In software systems, it is often the early bird that makes the worm.
66. Making something variable is easy. Controlling duration of constancy is the trick.
112. Computer Science is embarrassed by the computer.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
38. Structured Programming supports the law of the excluded middle.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
95. Don't have good ideas if you aren't willing to be responsible for them.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
100. We will never run out of things to program as long as there is a single program around.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
66. Making something variable is easy. Controlling duration of constancy is the trick.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
23. To understand a program you must become both the machine and the program.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
27. Once you understand how to write a program get someone else to write it.
115. Most people find the concept of programming obvious, but the doing impossible.
66. Making something variable is easy. Controlling duration of constancy is the trick.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
114. Within a computer natural language is unnatural.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
108. Whenever two programmers meet to criticize their programs, both are silent.
100. We will never run out of things to program as long as there is a single program around.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
103. Purely applicative languages are poorly applicable.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
15. Everything should be built top-down, except the first time.
98. In computing, the mean time to failure keeps getting shorter.
111. Why did the Roman Empire collapse? What is Latin for office automation?
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
57. It is easier to change the specification to fit the program than vice versa.
18. A program without a loop and a structured variable isn't worth writing.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
18. A program without a loop and a structured variable isn't worth writing.
108. Whenever two programmers meet to criticize their programs, both are silent.
111. Why did the Roman Empire collapse? What is Latin for office automation?
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
31. Simplicity does not precede complexity, but follows it.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
102. One can't proceed from the informal to the formal by formal means.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
18. A program without a loop and a structured variable isn't worth writing.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
72. An adequate bootstrap is a contradiction in terms.
108. Whenever two programmers meet to criticize their programs, both are silent.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
15. Everything should be built top-down, except the first time.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
60. In seeking the unattainable, simplicity only gets in the way.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
18. A program without a loop and a structured variable isn't worth writing.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
107. The debate rages on: is PL/I Bachtrian or Dromedary?
14. In the long run every program becomes rococo - then rubble.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
14. In the long run every program becomes rococo - then rubble.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
27. Once you understand how to write a program get someone else to write it.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
114. Within a computer natural language is unnatural.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
19. A language that doesn't affect the way you think about programming, is not worth knowing.
110. Editing is a rewording activity.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
104. The proof of a system's value is its existence.
102. One can't proceed from the informal to the formal by formal means.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
76. It is the user who should parameterize procedures, not their creators.
27. Once you understand how to write a program get someone else to write it.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
62. In computing, invariants are ephemeral.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
110. Editing is a rewording activity.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
59. In English every word can be verbed. Would that it were so in our programming languages.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
61. In programming, as in everything else, to be in error is to be reborn.
7. It is easier to write an incorrect program than understand a correct one.
31. Simplicity does not precede complexity, but follows it.
78. If your computer speaks English, it was probably made in Japan.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
40. There are two ways to write error-free programs; only the third one works.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
4. Every program is a part of some other program and rarely fits.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
78. If your computer speaks English, it was probably made in Japan.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
57. It is easier to change the specification to fit the program than vice versa.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
59. In English every word can be verbed. Would that it were so in our programming languages.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
119. Programming is an unnatural act.
79. A year spent in artificial intelligence is enough to make one believe in God.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
63. When we write programs that "learn", it turns out that we do and they don't.
23. To understand a program you must become both the machine and the program.
115. Most people find the concept of programming obvious, but the doing impossible.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
61. In programming, as in everything else, to be in error is to be reborn.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
110. Editing is a rewording activity.
7. It is easier to write an incorrect program than understand a correct one.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
72. An adequate bootstrap is a contradiction in terms.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
66. Making something variable is easy. Controlling duration of constancy is the trick.
105. You can't communicate complexity, only an awareness of it.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
79. A year spent in artificial intelligence is enough to make one believe in God.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
14. In the long run every program becomes rococo - then rubble.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
102. One can't proceed from the informal to the formal by formal means.
114. Within a computer natural language is unnatural.
96. Computers don't introduce order anywhere as much as they expose opportunities.
79. A year spent in artificial intelligence is enough to make one believe in God.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
47. As Will Rogers would have said, "There is no such thing as a free variable."
38. Structured Programming supports the law of the excluded middle.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
90. Computation has made the tree flower.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
7. It is easier to write an incorrect program than understand a correct one.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
63. When we write programs that "learn", it turns out that we do and they don't.
43. In software systems, it is often the early bird that makes the worm.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
102. One can't proceed from the informal to the formal by formal means.
59. In English every word can be verbed. Would that it were so in our programming languages.
41. Some programming languages manage to absorb change, but withstand progress.
119. Programming is an unnatural act.
103. Purely applicative languages are poorly applicable.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
100. We will never run out of things to program as long as there is a single program around.
66. Making something variable is easy. Controlling duration of constancy is the trick.
12. Recursion is the root of computation since it trades description for time.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
4. Every program is a part of some other program and rarely fits.
62. In computing, invariants are ephemeral.
72. An adequate bootstrap is a contradiction in terms.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
115. Most people find the concept of programming obvious, but the doing impossible.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
22. A good system can't have a weak command language.
59. In English every word can be verbed. Would that it were so in our programming languages.
100. We will never run out of things to program as long as there is a single program around.
55. A LISP programmer knows the value of everything, but the cost of nothing.
38. Structured Programming supports the law of the excluded middle.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
18. A program without a loop and a structured variable isn't worth writing.
72. An adequate bootstrap is a contradiction in terms.
11. If you have a procedure with ten parameters, you probably missed some.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
8. A programming language is low level when its programs require attention to the irrelevant.
17. If a listener nods his head when you're explaining your program, wake him up.
11. If you have a procedure with ten parameters, you probably missed some.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
98. In computing, the mean time to failure keeps getting shorter.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
112. Computer Science is embarrassed by the computer.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
102. One can't proceed from the informal to the formal by formal means.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
105. You can't communicate complexity, only an awareness of it.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
41. Some programming languages manage to absorb change, but withstand progress.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
62. In computing, invariants are ephemeral.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
100. We will never run out of things to program as long as there is a single program around.
47. As Will Rogers would have said, "There is no such thing as a free variable."
114. Within a computer natural language is unnatural.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
61. In programming, as in everything else, to be in error is to be reborn.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
43. In software systems, it is often the early bird that makes the worm.
119. Programming is an unnatural act.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
62. In computing, invariants are ephemeral.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
98. In computing, the mean time to failure keeps getting shorter.
4. Every program is a part of some other program and rarely fits.
22. A good system can't have a weak command language.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
60. In seeking the unattainable, simplicity only gets in the way.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
119. Programming is an unnatural act.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
98. In computing, the mean time to failure keeps getting shorter.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
15. Everything should be built top-down, except the first time.
38. Structured Programming supports the law of the excluded middle.
18. A program without a loop and a structured variable isn't worth writing.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
100. We will never run out of things to program as long as there is a single program around.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
21. Optimization hinders evolution.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
18. A program without a loop and a structured variable isn't worth writing.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
43. In software systems, it is often the early bird that makes the worm.
79. A year spent in artificial intelligence is enough to make one believe in God.
115. Most people find the concept of programming obvious, but the doing impossible.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
60. In seeking the unattainable, simplicity only gets in the way.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
43. In software systems, it is often the early bird that makes the worm.
104. The proof of a system's value is its existence.
115. Most people find the concept of programming obvious, but the doing impossible.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
8. A programming language is low level when its programs require attention to the irrelevant.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
115. Most people find the concept of programming obvious, but the doing impossible.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
104. The proof of a system's value is its existence.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
112. Computer Science is embarrassed by the computer.
100. We will never run out of things to program as long as there is a single program around.
119. Programming is an unnatural act.
79. A year spent in artificial intelligence is enough to make one believe in God.
40. There are two ways to write error-free programs; only the third one works.
7. It is easier to write an incorrect program than understand a correct one.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
112. Computer Science is embarrassed by the computer.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
11. If you have a procedure with ten parameters, you probably missed some.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
18. A program without a loop and a structured variable isn't worth writing.
60. In seeking the unattainable, simplicity only gets in the way.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
63. When we write programs that "learn", it turns out that we do and they don't.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
8. A programming language is low level when its programs require attention to the irrelevant.
111. Why did the Roman Empire collapse? What is Latin for office automation?
27. Once you understand how to write a program get someone else to write it.
61. In programming, as in everything else, to be in error is to be reborn.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
27. Once you understand how to write a program get someone else to write it.
3. Syntactic sugar causes cancer of the semicolon.
59. In English every word can be verbed. Would that it were so in our programming languages.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
21. Optimization hinders evolution.
4. Every program is a part of some other program and rarely fits.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
105. You can't communicate complexity, only an awareness of it.
104. The proof of a system's value is its existence.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
61. In programming, as in everything else, to be in error is to be reborn.
119. Programming is an unnatural act.
72. An adequate bootstrap is a contradiction in terms.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
103. Purely applicative languages are poorly applicable.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
95. Don't have good ideas if you aren't willing to be responsible for them.
23. To understand a program you must become both the machine and the program.
15. Everything should be built top-down, except the first time.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
1. One man's constant is another man's variable.
62. In computing, invariants are ephemeral.
105. You can't communicate complexity, only an awareness of it.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
22. A good system can't have a weak command language.
63. When we write programs that "learn", it turns out that we do and they don't.
38. Structured Programming supports the law of the excluded middle.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
78. If your computer speaks English, it was probably made in Japan.
79. A year spent in artificial intelligence is enough to make one believe in God.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
112. Computer Science is embarrassed by the computer.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
112. Computer Science is embarrassed by the computer.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
22. A good system can't have a weak command language.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
112. Computer Science is embarrassed by the computer.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
14. In the long run every program becomes rococo - then rubble.
62. In computing, invariants are ephemeral.
79. A year spent in artificial intelligence is enough to make one believe in God.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
72. An adequate bootstrap is a contradiction in terms.
40. There are two ways to write error-free programs; only the third one works.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
18. A program without a loop and a structured variable isn't worth writing.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
59. In English every word can be verbed. Would that it were so in our programming languages.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
4. Every program is a part of some other program and rarely fits.
79. A year spent in artificial intelligence is enough to make one believe in God.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
115. Most people find the concept of programming obvious, but the doing impossible.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
55. A LISP programmer knows the value of everything, but the cost of nothing.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
38. Structured Programming supports the law of the excluded middle.
104. The proof of a system's value is its existence.
31. Simplicity does not precede complexity, but follows it.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
61. In programming, as in everything else, to be in error is to be reborn.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
98. In computing, the mean time to failure keeps getting shorter.
46. Like punning, programming is a play on words.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
111. Why did the Roman Empire collapse? What is Latin for office automation?
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
27. Once you understand how to write a program get someone else to write it.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
115. Most people find the concept of programming obvious, but the doing impossible.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
100. We will never run out of things to program as long as there is a single program around.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
63. When we write programs that "learn", it turns out that we do and they don't.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
72. An adequate bootstrap is a contradiction in terms.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
78. If your computer speaks English, it was probably made in Japan.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
66. Making something variable is easy. Controlling duration of constancy is the trick.
95. Don't have good ideas if you aren't willing to be responsible for them.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
104. The proof of a system's value is its existence.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
102. One can't proceed from the informal to the formal by formal means.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
22. A good system can't have a weak command language.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
31. Simplicity does not precede complexity, but follows it.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
102. One can't proceed from the informal to the formal by formal means.
43. In software systems, it is often the early bird that makes the worm.
103. Purely applicative languages are poorly applicable.
23. To understand a program you must become both the machine and the program.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
18. A program without a loop and a structured variable isn't worth writing.
43. In software systems, it is often the early bird that makes the worm.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
8. A programming language is low level when its programs require attention to the irrelevant.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
60. In seeking the unattainable, simplicity only gets in the way.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
18. A program without a loop and a structured variable isn't worth writing.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
119. Programming is an unnatural act.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
15. Everything should be built top-down, except the first time.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
105. You can't communicate complexity, only an awareness of it.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
104. The proof of a system's value is its existence.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
18. A program without a loop and a structured variable isn't worth writing.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
111. Why did the Roman Empire collapse? What is Latin for office automation?
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
115. Most people find the concept of programming obvious, but the doing impossible.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
78. If your computer speaks English, it was probably made in Japan.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
102. One can't proceed from the informal to the formal by formal means.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
104. The proof of a system's value is its existence.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
108. Whenever two programmers meet to criticize their programs, both are silent.
22. A good system can't have a weak command language.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
31. Simplicity does not precede complexity, but follows it.
41. Some programming languages manage to absorb change, but withstand progress.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
15. Everything should be built top-down, except the first time.
17. If a listener nods his head when you're explaining your program, wake him up.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
40. There are two ways to write error-free programs; only the third one works.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
115. Most people find the concept of programming obvious, but the doing impossible.
111. Why did the Roman Empire collapse? What is Latin for office automation?
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
15. Everything should be built top-down, except the first time.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
62. In computing, invariants are ephemeral.
14. In the long run every program becomes rococo - then rubble.
14. In the long run every program becomes rococo - then rubble.
21. Optimization hinders evolution.
110. Editing is a rewording activity.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
17. If a listener nods his head when you're explaining your program, wake him up.
96. Computers don't introduce order anywhere as much as they expose opportunities.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
76. It is the user who should parameterize procedures, not their creators.
98. In computing, the mean time to failure keeps getting shorter.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
108. Whenever two programmers meet to criticize their programs, both are silent.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
78. If your computer speaks English, it was probably made in Japan.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
3. Syntactic sugar causes cancer of the semicolon.
27. Once you understand how to write a program get someone else to write it.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
1. One man's constant is another man's variable.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
27. Once you understand how to write a program get someone else to write it.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
22. A good system can't have a weak command language.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
112. Computer Science is embarrassed by the computer.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
103. Purely applicative languages are poorly applicable.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
105. You can't communicate complexity, only an awareness of it.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
38. Structured Programming supports the law of the excluded middle.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
14. In the long run every program becomes rococo - then rubble.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
12. Recursion is the root of computation since it trades description for time.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
27. Once you understand how to write a program get someone else to write it.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
38. Structured Programming supports the law of the excluded middle.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
102. One can't proceed from the informal to the formal by formal means.
76. It is the user who should parameterize procedures, not their creators.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
15. Everything should be built top-down, except the first time.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
14. In the long run every program becomes rococo - then rubble.
17. If a listener nods his head when you're explaining your program, wake him up.
102. One can't proceed from the informal to the formal by formal means.
22. A good system can't have a weak command language.
61. In programming, as in everything else, to be in error is to be reborn.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
95. Don't have good ideas if you aren't willing to be responsible for them.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
115. Most people find the concept of programming obvious, but the doing impossible.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
112. Computer Science is embarrassed by the computer.
79. A year spent in artificial intelligence is enough to make one believe in God.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
12. Recursion is the root of computation since it trades description for time.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
55. A LISP programmer knows the value of everything, but the cost of nothing.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
61. In programming, as in everything else, to be in error is to be reborn.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
18. A program without a loop and a structured variable isn't worth writing.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
63. When we write programs that "learn", it turns out that we do and they don't.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
96. Computers don't introduce order anywhere as much as they expose opportunities.
55. A LISP programmer knows the value of everything, but the cost of nothing.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
98. In computing, the mean time to failure keeps getting shorter.
59. In English every word can be verbed. Would that it were so in our programming languages.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
78. If your computer speaks English, it was probably made in Japan.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
14. In the long run every program becomes rococo - then rubble.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
18. A program without a loop and a structured variable isn't worth writing.
3. Syntactic sugar causes cancer of the semicolon.
100. We will never run out of things to program as long as there is a single program around.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
72. An adequate bootstrap is a contradiction in terms.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
38. Structured Programming supports the law of the excluded middle.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
79. A year spent in artificial intelligence is enough to make one believe in God.
95. Don't have good ideas if you aren't willing to be responsible for them.
40. There are two ways to write error-free programs; only the third one works.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
17. If a listener nods his head when you're explaining your program, wake him up.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
60. In seeking the unattainable, simplicity only gets in the way.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
95. Don't have good ideas if you aren't willing to be responsible for them.
114. Within a computer natural language is unnatural.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
95. Don't have good ideas if you aren't willing to be responsible for them.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
11. If you have a procedure with ten parameters, you probably missed some.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
23. To understand a program you must become both the machine and the program.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
8. A programming language is low level when its programs require attention to the irrelevant.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
59. In English every word can be verbed. Would that it were so in our programming languages.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
114. Within a computer natural language is unnatural.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
4. Every program is a part of some other program and rarely fits.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
8. A programming language is low level when its programs require attention to the irrelevant.
59. In English every word can be verbed. Would that it were so in our programming languages.
8. A programming language is low level when its programs require attention to the irrelevant.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
22. A good system can't have a weak command language.
96. Computers don't introduce order anywhere as much as they expose opportunities.
98. In computing, the mean time to failure keeps getting shorter.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
19. A language that doesn't affect the way you think about programming, is not worth knowing.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
3. Syntactic sugar causes cancer of the semicolon.
18. A program without a loop and a structured variable isn't worth writing.
66. Making something variable is easy. Controlling duration of constancy is the trick.
104. The proof of a system's value is its existence.
104. The proof of a system's value is its existence.
112. Computer Science is embarrassed by the computer.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
40. There are two ways to write error-free programs; only the third one works.
14. In the long run every program becomes rococo - then rubble.
119. Programming is an unnatural act.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
104. The proof of a system's value is its existence.
76. It is the user who should parameterize procedures, not their creators.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
46. Like punning, programming is a play on words.
110. Editing is a rewording activity.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
12. Recursion is the root of computation since it trades description for time.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
8. A programming language is low level when its programs require attention to the irrelevant.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
43. In software systems, it is often the early bird that makes the worm.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
59. In English every word can be verbed. Would that it were so in our programming languages.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
61. In programming, as in everything else, to be in error is to be reborn.
4. Every program is a part of some other program and rarely fits.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
90. Computation has made the tree flower.
40. There are two ways to write error-free programs; only the third one works.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
12. Recursion is the root of computation since it trades description for time.
41. Some programming languages manage to absorb change, but withstand progress.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
105. You can't communicate complexity, only an awareness of it.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
8. A programming language is low level when its programs require attention to the irrelevant.
61. In programming, as in everything else, to be in error is to be reborn.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
76. It is the user who should parameterize procedures, not their creators.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
14. In the long run every program becomes rococo - then rubble.
103. Purely applicative languages are poorly applicable.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
1. One man's constant is another man's variable.
111. Why did the Roman Empire collapse? What is Latin for office automation?
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
47. As Will Rogers would have said, "There is no such thing as a free variable."
12. Recursion is the root of computation since it trades description for time.
108. Whenever two programmers meet to criticize their programs, both are silent.
12. Recursion is the root of computation since it trades description for time.
47. As Will Rogers would have said, "There is no such thing as a free variable."
8. A programming language is low level when its programs require attention to the irrelevant.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
22. A good system can't have a weak command language.
63. When we write programs that "learn", it turns out that we do and they don't.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
62. In computing, invariants are ephemeral.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
23. To understand a program you must become both the machine and the program.
102. One can't proceed from the informal to the formal by formal means.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
66. Making something variable is easy. Controlling duration of constancy is the trick.
57. It is easier to change the specification to fit the program than vice versa.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
98. In computing, the mean time to failure keeps getting shorter.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
22. A good system can't have a weak command language.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
102. One can't proceed from the informal to the formal by formal means.
47. As Will Rogers would have said, "There is no such thing as a free variable."
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
47. As Will Rogers would have said, "There is no such thing as a free variable."
43. In software systems, it is often the early bird that makes the worm.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
43. In software systems, it is often the early bird that makes the worm.
105. You can't communicate complexity, only an awareness of it.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
78. If your computer speaks English, it was probably made in Japan.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
1. One man's constant is another man's variable.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
41. Some programming languages manage to absorb change, but withstand progress.
96. Computers don't introduce order anywhere as much as they expose opportunities.
62. In computing, invariants are ephemeral.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
111. Why did the Roman Empire collapse? What is Latin for office automation?
5. If a program manipulates a large amount of data, it does so in a small number of ways.
66. Making something variable is easy. Controlling duration of constancy is the trick.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
76. It is the user who should parameterize procedures, not their creators.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
31. Simplicity does not precede complexity, but follows it.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
47. As Will Rogers would have said, "There is no such thing as a free variable."
31. Simplicity does not precede complexity, but follows it.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
61. In programming, as in everything else, to be in error is to be reborn.
14. In the long run every program becomes rococo - then rubble.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
22. A good system can't have a weak command language.
111. Why did the Roman Empire collapse? What is Latin for office automation?
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
115. Most people find the concept of programming obvious, but the doing impossible.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
115. Most people find the concept of programming obvious, but the doing impossible.
110. Editing is a rewording activity.
47. As Will Rogers would have said, "There is no such thing as a free variable."
14. In the long run every program becomes rococo - then rubble.
114. Within a computer natural language is unnatural.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
43. In software systems, it is often the early bird that makes the worm.
41. Some programming languages manage to absorb change, but withstand progress.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
57. It is easier to change the specification to fit the program than vice versa.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
61. In programming, as in everything else, to be in error is to be reborn.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
43. In software systems, it is often the early bird that makes the worm.
4. Every program is a part of some other program and rarely fits.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
11. If you have a procedure with ten parameters, you probably missed some.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
17. If a listener nods his head when you're explaining your program, wake him up.
63. When we write programs that "learn", it turns out that we do and they don't.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
46. Like punning, programming is a play on words.
63. When we write programs that "learn", it turns out that we do and they don't.
90. Computation has made the tree flower.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
57. It is easier to change the specification to fit the program than vice versa.
3. Syntactic sugar causes cancer of the semicolon.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
31. Simplicity does not precede complexity, but follows it.
23. To understand a program you must become both the machine and the program.
105. You can't communicate complexity, only an awareness of it.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
62. In computing, invariants are ephemeral.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
98. In computing, the mean time to failure keeps getting shorter.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
108. Whenever two programmers meet to criticize their programs, both are silent.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
90. Computation has made the tree flower.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
5. If a program manipulates a large amount of data, it does so in a small number of ways.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
115. Most people find the concept of programming obvious, but the doing impossible.
3. Syntactic sugar causes cancer of the semicolon.
7. It is easier to write an incorrect program than understand a correct one.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
40. There are two ways to write error-free programs; only the third one works.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
72. An adequate bootstrap is a contradiction in terms.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
61. In programming, as in everything else, to be in error is to be reborn.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
55. A LISP programmer knows the value of everything, but the cost of nothing.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
104. The proof of a system's value is its existence.
4. Every program is a part of some other program and rarely fits.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
115. Most people find the concept of programming obvious, but the doing impossible.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
60. In seeking the unattainable, simplicity only gets in the way.
12. Recursion is the root of computation since it trades description for time.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
62. In computing, invariants are ephemeral.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
63. When we write programs that "learn", it turns out that we do and they don't.
108. Whenever two programmers meet to criticize their programs, both are silent.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
8. A programming language is low level when its programs require attention to the irrelevant.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
11. If you have a procedure with ten parameters, you probably missed some.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
66. Making something variable is easy. Controlling duration of constancy is the trick.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
112. Computer Science is embarrassed by the computer.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
38. Structured Programming supports the law of the excluded middle.
79. A year spent in artificial intelligence is enough to make one believe in God.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
27. Once you understand how to write a program get someone else to write it.
115. Most people find the concept of programming obvious, but the doing impossible.
105. You can't communicate complexity, only an awareness of it.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
79. A year spent in artificial intelligence is enough to make one believe in God.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
100. We will never run out of things to program as long as there is a single program around.
119. Programming is an unnatural act.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
11. If you have a procedure with ten parameters, you probably missed some.
90. Computation has made the tree flower.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
40. There are two ways to write error-free programs; only the third one works.
66. Making something variable is easy. Controlling duration of constancy is the trick.
79. A year spent in artificial intelligence is enough to make one believe in God.
12. Recursion is the root of computation since it trades description for time.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
18. A program without a loop and a structured variable isn't worth writing.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
72. An adequate bootstrap is a contradiction in terms.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
31. Simplicity does not precede complexity, but follows it.
78. If your computer speaks English, it was probably made in Japan.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
95. Don't have good ideas if you aren't willing to be responsible for them.
1. One man's constant is another man's variable.
23. To understand a program you must become both the machine and the program.
8. A programming language is low level when its programs require attention to the irrelevant.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
100. We will never run out of things to program as long as there is a single program around.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
15. Everything should be built top-down, except the first time.
66. Making something variable is easy. Controlling duration of constancy is the trick.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
119. Programming is an unnatural act.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
27. Once you understand how to write a program get someone else to write it.
17. If a listener nods his head when you're explaining your program, wake him up.
23. To understand a program you must become both the machine and the program.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
27. Once you understand how to write a program get someone else to write it.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
15. Everything should be built top-down, except the first time.
22. A good system can't have a weak command language.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
3. Syntactic sugar causes cancer of the semicolon.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
8. A programming language is low level when its programs require attention to the irrelevant.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
59. In English every word can be verbed. Would that it were so in our programming languages.
110. Editing is a rewording activity.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
47. As Will Rogers would have said, "There is no such thing as a free variable."
96. Computers don't introduce order anywhere as much as they expose opportunities.
43. In software systems, it is often the early bird that makes the worm.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
7. It is easier to write an incorrect program than understand a correct one.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
62. In computing, invariants are ephemeral.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
63. When we write programs that "learn", it turns out that we do and they don't.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
66. Making something variable is easy. Controlling duration of constancy is the trick.
18. A program without a loop and a structured variable isn't worth writing.
23. To understand a program you must become both the machine and the program.
8. A programming language is low level when its programs require attention to the irrelevant.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
110. Editing is a rewording activity.
63. When we write programs that "learn", it turns out that we do and they don't.
55. A LISP programmer knows the value of everything, but the cost of nothing.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
38. Structured Programming supports the law of the excluded middle.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
8. A programming language is low level when its programs require attention to the irrelevant.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
78. If your computer speaks English, it was probably made in Japan.
103. Purely applicative languages are poorly applicable.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
102. One can't proceed from the informal to the formal by formal means.
62. In computing, invariants are ephemeral.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
61. In programming, as in everything else, to be in error is to be reborn.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
102. One can't proceed from the informal to the formal by formal means.
119. Programming is an unnatural act.
11. If you have a procedure with ten parameters, you probably missed some.
90. Computation has made the tree flower.
115. Most people find the concept of programming obvious, but the doing impossible.
119. Programming is an unnatural act.
4. Every program is a part of some other program and rarely fits.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
11. If you have a procedure with ten parameters, you probably missed some.
8. A programming language is low level when its programs require attention to the irrelevant.
111. Why did the Roman Empire collapse? What is Latin for office automation?
1. One man's constant is another man's variable.
105. You can't communicate complexity, only an awareness of it.
38. Structured Programming supports the law of the excluded middle.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
8. A programming language is low level when its programs require attention to the irrelevant.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
12. Recursion is the root of computation since it trades description for time.
1. One man's constant is another man's variable.
59. In English every word can be verbed. Would that it were so in our programming languages.
11. If you have a procedure with ten parameters, you probably missed some.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
119. Programming is an unnatural act.
112. Computer Science is embarrassed by the computer.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
108. Whenever two programmers meet to criticize their programs, both are silent.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
40. There are two ways to write error-free programs; only the third one works.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
61. In programming, as in everything else, to be in error is to be reborn.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
66. Making something variable is easy. Controlling duration of constancy is the trick.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
7. It is easier to write an incorrect program than understand a correct one.
7. It is easier to write an incorrect program than understand a correct one.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
1. One man's constant is another man's variable.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
103. Purely applicative languages are poorly applicable.
38. Structured Programming supports the law of the excluded middle.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
23. To understand a program you must become both the machine and the program.
62. In computing, invariants are ephemeral.
1. One man's constant is another man's variable.
72. An adequate bootstrap is a contradiction in terms.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
41. Some programming languages manage to absorb change, but withstand progress.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
27. Once you understand how to write a program get someone else to write it.
31. Simplicity does not precede complexity, but follows it.
43. In software systems, it is often the early bird that makes the worm.
27. Once you understand how to write a program get someone else to write it.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
46. Like punning, programming is a play on words.
61. In programming, as in everything else, to be in error is to be reborn.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
1. One man's constant is another man's variable.
15. Everything should be built top-down, except the first time.
119. Programming is an unnatural act.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
96. Computers don't introduce order anywhere as much as they expose opportunities.
7. It is easier to write an incorrect program than understand a correct one.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
104. The proof of a system's value is its existence.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
15. Everything should be built top-down, except the first time.
108. Whenever two programmers meet to criticize their programs, both are silent.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
8. A programming language is low level when its programs require attention to the irrelevant.
119. Programming is an unnatural act.
100. We will never run out of things to program as long as there is a single program around.
57. It is easier to change the specification to fit the program than vice versa.
38. Structured Programming supports the law of the excluded middle.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
79. A year spent in artificial intelligence is enough to make one believe in God.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
100. We will never run out of things to program as long as there is a single program around.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
40. There are two ways to write error-free programs; only the third one works.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
12. Recursion is the root of computation since it trades description for time.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
108. Whenever two programmers meet to criticize their programs, both are silent.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
102. One can't proceed from the informal to the formal by formal means.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
31. Simplicity does not precede complexity, but follows it.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
22. A good system can't have a weak command language.
40. There are two ways to write error-free programs; only the third one works.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
61. In programming, as in everything else, to be in error is to be reborn.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
57. It is easier to change the specification to fit the program than vice versa.
61. In programming, as in everything else, to be in error is to be reborn.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
7. It is easier to write an incorrect program than understand a correct one.
23. To understand a program you must become both the machine and the program.
78. If your computer speaks English, it was probably made in Japan.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
59. In English every word can be verbed. Would that it were so in our programming languages.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
8. A programming language is low level when its programs require attention to the irrelevant.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
100. We will never run out of things to program as long as there is a single program around.
119. Programming is an unnatural act.
17. If a listener nods his head when you're explaining your program, wake him up.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
21. Optimization hinders evolution.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
60. In seeking the unattainable, simplicity only gets in the way.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
41. Some programming languages manage to absorb change, but withstand progress.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
72. An adequate bootstrap is a contradiction in terms.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
98. In computing, the mean time to failure keeps getting shorter.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
4. Every program is a part of some other program and rarely fits.
66. Making something variable is easy. Controlling duration of constancy is the trick.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
41. Some programming languages manage to absorb change, but withstand progress.
40. There are two ways to write error-free programs; only the third one works.
119. Programming is an unnatural act.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
96. Computers don't introduce order anywhere as much as they expose opportunities.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
111. Why did the Roman Empire collapse? What is Latin for office automation?
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
3. Syntactic sugar causes cancer of the semicolon.
31. Simplicity does not precede complexity, but follows it.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
7. It is easier to write an incorrect program than understand a correct one.
47. As Will Rogers would have said, "There is no such thing as a free variable."
40. There are two ways to write error-free programs; only the third one works.
7. It is easier to write an incorrect program than understand a correct one.
40. There are two ways to write error-free programs; only the third one works.
98. In computing, the mean time to failure keeps getting shorter.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
4. Every program is a part of some other program and rarely fits.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
22. A good system can't have a weak command language.
96. Computers don't introduce order anywhere as much as they expose opportunities.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
18. A program without a loop and a structured variable isn't worth writing.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
46. Like punning, programming is a play on words.
3. Syntactic sugar causes cancer of the semicolon.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
47. As Will Rogers would have said, "There is no such thing as a free variable."
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
14. In the long run every program becomes rococo - then rubble.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
23. To understand a program you must become both the machine and the program.
14. In the long run every program becomes rococo - then rubble.
115. Most people find the concept of programming obvious, but the doing impossible.
22. A good system can't have a weak command language.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
105. You can't communicate complexity, only an awareness of it.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
21. Optimization hinders evolution.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
7. It is easier to write an incorrect program than understand a correct one.
66. Making something variable is easy. Controlling duration of constancy is the trick.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
61. In programming, as in everything else, to be in error is to be reborn.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
105. You can't communicate complexity, only an awareness of it.
7. It is easier to write an incorrect program than understand a correct one.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
96. Computers don't introduce order anywhere as much as they expose opportunities.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
66. Making something variable is easy. Controlling duration of constancy is the trick.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
15. Everything should be built top-down, except the first time.
7. It is easier to write an incorrect program than understand a correct one.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
11. If you have a procedure with ten parameters, you probably missed some.
76. It is the user who should parameterize procedures, not their creators.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
21. Optimization hinders evolution.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
105. You can't communicate complexity, only an awareness of it.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
66. Making something variable is easy. Controlling duration of constancy is the trick.
23. To understand a program you must become both the machine and the program.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
119. Programming is an unnatural act.
78. If your computer speaks English, it was probably made in Japan.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
12. Recursion is the root of computation since it trades description for time.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
27. Once you understand how to write a program get someone else to write it.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
78. If your computer speaks English, it was probably made in Japan.
27. Once you understand how to write a program get someone else to write it.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
3. Syntactic sugar causes cancer of the semicolon.
17. If a listener nods his head when you're explaining your program, wake him up.
38. Structured Programming supports the law of the excluded middle.
61. In programming, as in everything else, to be in error is to be reborn.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
61. In programming, as in everything else, to be in error is to be reborn.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
15. Everything should be built top-down, except the first time.
119. Programming is an unnatural act.
15. Everything should be built top-down, except the first time.
14. In the long run every program becomes rococo - then rubble.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
5. If a program manipulates a large amount of data, it does so in a small number of ways.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
102. One can't proceed from the informal to the formal by formal means.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
96. Computers don't introduce order anywhere as much as they expose opportunities.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
18. A program without a loop and a structured variable isn't worth writing.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
41. Some programming languages manage to absorb change, but withstand progress.
115. Most people find the concept of programming obvious, but the doing impossible.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
96. Computers don't introduce order anywhere as much as they expose opportunities.
100. We will never run out of things to program as long as there is a single program around.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
104. The proof of a system's value is its existence.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
57. It is easier to change the specification to fit the program than vice versa.
31. Simplicity does not precede complexity, but follows it.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
114. Within a computer natural language is unnatural.
14. In the long run every program becomes rococo - then rubble.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
79. A year spent in artificial intelligence is enough to make one believe in God.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
103. Purely applicative languages are poorly applicable.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
59. In English every word can be verbed. Would that it were so in our programming languages.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
31. Simplicity does not precede complexity, but follows it.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
47. As Will Rogers would have said, "There is no such thing as a free variable."
100. We will never run out of things to program as long as there is a single program around.
43. In software systems, it is often the early bird that makes the worm.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
63. When we write programs that "learn", it turns out that we do and they don't.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
66. Making something variable is easy. Controlling duration of constancy is the trick.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
60. In seeking the unattainable, simplicity only gets in the way.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
103. Purely applicative languages are poorly applicable.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
55. A LISP programmer knows the value of everything, but the cost of nothing.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
66. Making something variable is easy. Controlling duration of constancy is the trick.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
27. Once you understand how to write a program get someone else to write it.
38. Structured Programming supports the law of the excluded middle.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
100. We will never run out of things to program as long as there is a single program around.
3. Syntactic sugar causes cancer of the semicolon.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
111. Why did the Roman Empire collapse? What is Latin for office automation?
105. You can't communicate complexity, only an awareness of it.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
76. It is the user who should parameterize procedures, not their creators.
1. One man's constant is another man's variable.
72. An adequate bootstrap is a contradiction in terms.
102. One can't proceed from the informal to the formal by formal means.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
17. If a listener nods his head when you're explaining your program, wake him up.
95. Don't have good ideas if you aren't willing to be responsible for them.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
102. One can't proceed from the informal to the formal by formal means.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
7. It is easier to write an incorrect program than understand a correct one.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
110. Editing is a rewording activity.
41. Some programming languages manage to absorb change, but withstand progress.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
114. Within a computer natural language is unnatural.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
38. Structured Programming supports the law of the excluded middle.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
60. In seeking the unattainable, simplicity only gets in the way.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
31. Simplicity does not precede complexity, but follows it.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
111. Why did the Roman Empire collapse? What is Latin for office automation?
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
96. Computers don't introduce order anywhere as much as they expose opportunities.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
111. Why did the Roman Empire collapse? What is Latin for office automation?
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
4. Every program is a part of some other program and rarely fits.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
15. Everything should be built top-down, except the first time.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
103. Purely applicative languages are poorly applicable.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
112. Computer Science is embarrassed by the computer.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
72. An adequate bootstrap is a contradiction in terms.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
61. In programming, as in everything else, to be in error is to be reborn.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
46. Like punning, programming is a play on words.
105. You can't communicate complexity, only an awareness of it.
59. In English every word can be verbed. Would that it were so in our programming languages.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
102. One can't proceed from the informal to the formal by formal means.
7. It is easier to write an incorrect program than understand a correct one.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
41. Some programming languages manage to absorb change, but withstand progress.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
66. Making something variable is easy. Controlling duration of constancy is the trick.
90. Computation has made the tree flower.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
114. Within a computer natural language is unnatural.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
96. Computers don't introduce order anywhere as much as they expose opportunities.
4. Every program is a part of some other program and rarely fits.
102. One can't proceed from the informal to the formal by formal means.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
3. Syntactic sugar causes cancer of the semicolon.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
100. We will never run out of things to program as long as there is a single program around.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
108. Whenever two programmers meet to criticize their programs, both are silent.
40. There are two ways to write error-free programs; only the third one works.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
103. Purely applicative languages are poorly applicable.
114. Within a computer natural language is unnatural.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
72. An adequate bootstrap is a contradiction in terms.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
66. Making something variable is easy. Controlling duration of constancy is the trick.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
15. Everything should be built top-down, except the first time.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
105. You can't communicate complexity, only an awareness of it.
43. In software systems, it is often the early bird that makes the worm.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
115. Most people find the concept of programming obvious, but the doing impossible.
59. In English every word can be verbed. Would that it were so in our programming languages.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
98. In computing, the mean time to failure keeps getting shorter.
17. If a listener nods his head when you're explaining your program, wake him up.
112. Computer Science is embarrassed by the computer.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
96. Computers don't introduce order anywhere as much as they expose opportunities.
76. It is the user who should parameterize procedures, not their creators.
79. A year spent in artificial intelligence is enough to make one believe in God.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
15. Everything should be built top-down, except the first time.
104. The proof of a system's value is its existence.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
108. Whenever two programmers meet to criticize their programs, both are silent.
22. A good system can't have a weak command language.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
105. You can't communicate complexity, only an awareness of it.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
61. In programming, as in everything else, to be in error is to be reborn.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
114. Within a computer natural language is unnatural.
60. In seeking the unattainable, simplicity only gets in the way.
15. Everything should be built top-down, except the first time.
72. An adequate bootstrap is a contradiction in terms.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
46. Like punning, programming is a play on words.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
79. A year spent in artificial intelligence is enough to make one believe in God.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
47. As Will Rogers would have said, "There is no such thing as a free variable."
78. If your computer speaks English, it was probably made in Japan.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
76. It is the user who should parameterize procedures, not their creators.
27. Once you understand how to write a program get someone else to write it.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
102. One can't proceed from the informal to the formal by formal means.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
15. Everything should be built top-down, except the first time.
23. To understand a program you must become both the machine and the program.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
96. Computers don't introduce order anywhere as much as they expose opportunities.
27. Once you understand how to write a program get someone else to write it.
104. The proof of a system's value is its existence.
60. In seeking the unattainable, simplicity only gets in the way.
95. Don't have good ideas if you aren't willing to be responsible for them.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
40. There are two ways to write error-free programs; only the third one works.
43. In software systems, it is often the early bird that makes the worm.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
102. One can't proceed from the informal to the formal by formal means.
4. Every program is a part of some other program and rarely fits.
108. Whenever two programmers meet to criticize their programs, both are silent.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
14. In the long run every program becomes rococo - then rubble.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
98. In computing, the mean time to failure keeps getting shorter.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
63. When we write programs that "learn", it turns out that we do and they don't.
14. In the long run every program becomes rococo - then rubble.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
66. Making something variable is easy. Controlling duration of constancy is the trick.
3. Syntactic sugar causes cancer of the semicolon.
103. Purely applicative languages are poorly applicable.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
111. Why did the Roman Empire collapse? What is Latin for office automation?
103. Purely applicative languages are poorly applicable.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
100. We will never run out of things to program as long as there is a single program around.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
100. We will never run out of things to program as long as there is a single program around.
47. As Will Rogers would have said, "There is no such thing as a free variable."
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
62. In computing, invariants are ephemeral.
110. Editing is a rewording activity.
105. You can't communicate complexity, only an awareness of it.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
3. Syntactic sugar causes cancer of the semicolon.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
22. A good system can't have a weak command language.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
38. Structured Programming supports the law of the excluded middle.
98. In computing, the mean time to failure keeps getting shorter.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
66. Making something variable is easy. Controlling duration of constancy is the trick.
59. In English every word can be verbed. Would that it were so in our programming languages.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
62. In computing, invariants are ephemeral.
27. Once you understand how to write a program get someone else to write it.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
18. A program without a loop and a structured variable isn't worth writing.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
23. To understand a program you must become both the machine and the program.
96. Computers don't introduce order anywhere as much as they expose opportunities.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
43. In software systems, it is often the early bird that makes the worm.
63. When we write programs that "learn", it turns out that we do and they don't.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
96. Computers don't introduce order anywhere as much as they expose opportunities.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
3. Syntactic sugar causes cancer of the semicolon.
12. Recursion is the root of computation since it trades description for time.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
43. In software systems, it is often the early bird that makes the worm.
63. When we write programs that "learn", it turns out that we do and they don't.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
110. Editing is a rewording activity.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
1. One man's constant is another man's variable.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
110. Editing is a rewording activity.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
22. A good system can't have a weak command language.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
95. Don't have good ideas if you aren't willing to be responsible for them.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
40. There are two ways to write error-free programs; only the third one works.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
108. Whenever two programmers meet to criticize their programs, both are silent.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
62. In computing, invariants are ephemeral.
41. Some programming languages manage to absorb change, but withstand progress.
95. Don't have good ideas if you aren't willing to be responsible for them.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
110. Editing is a rewording activity.
115. Most people find the concept of programming obvious, but the doing impossible.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
96. Computers don't introduce order anywhere as much as they expose opportunities.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
63. When we write programs that "learn", it turns out that we do and they don't.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
110. Editing is a rewording activity.
105. You can't communicate complexity, only an awareness of it.
78. If your computer speaks English, it was probably made in Japan.
98. In computing, the mean time to failure keeps getting shorter.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
55. A LISP programmer knows the value of everything, but the cost of nothing.
108. Whenever two programmers meet to criticize their programs, both are silent.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
14. In the long run every program becomes rococo - then rubble.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
3. Syntactic sugar causes cancer of the semicolon.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
15. Everything should be built top-down, except the first time.
66. Making something variable is easy. Controlling duration of constancy is the trick.
100. We will never run out of things to program as long as there is a single program around.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
31. Simplicity does not precede complexity, but follows it.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
100. We will never run out of things to program as long as there is a single program around.
63. When we write programs that "learn", it turns out that we do and they don't.
57. It is easier to change the specification to fit the program than vice versa.
111. Why did the Roman Empire collapse? What is Latin for office automation?
115. Most people find the concept of programming obvious, but the doing impossible.
23. To understand a program you must become both the machine and the program.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
11. If you have a procedure with ten parameters, you probably missed some.
112. Computer Science is embarrassed by the computer.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
8. A programming language is low level when its programs require attention to the irrelevant.
96. Computers don't introduce order anywhere as much as they expose opportunities.
66. Making something variable is easy. Controlling duration of constancy is the trick.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
12. Recursion is the root of computation since it trades description for time.
15. Everything should be built top-down, except the first time.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
98. In computing, the mean time to failure keeps getting shorter.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
114. Within a computer natural language is unnatural.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
55. A LISP programmer knows the value of everything, but the cost of nothing.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
23. To understand a program you must become both the machine and the program.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
108. Whenever two programmers meet to criticize their programs, both are silent.
95. Don't have good ideas if you aren't willing to be responsible for them.
22. A good system can't have a weak command language.
46. Like punning, programming is a play on words.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
38. Structured Programming supports the law of the excluded middle.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
112. Computer Science is embarrassed by the computer.
61. In programming, as in everything else, to be in error is to be reborn.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
12. Recursion is the root of computation since it trades description for time.
76. It is the user who should parameterize procedures, not their creators.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
18. A program without a loop and a structured variable isn't worth writing.
12. Recursion is the root of computation since it trades description for time.
8. A programming language is low level when its programs require attention to the irrelevant.
12. Recursion is the root of computation since it trades description for time.
119. Programming is an unnatural act.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
98. In computing, the mean time to failure keeps getting shorter.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
61. In programming, as in everything else, to be in error is to be reborn.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
8. A programming language is low level when its programs require attention to the irrelevant.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
96. Computers don't introduce order anywhere as much as they expose opportunities.
18. A program without a loop and a structured variable isn't worth writing.
112. Computer Science is embarrassed by the computer.
23. To understand a program you must become both the machine and the program.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
63. When we write programs that "learn", it turns out that we do and they don't.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
23. To understand a program you must become both the machine and the program.
15. Everything should be built top-down, except the first time.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
90. Computation has made the tree flower.
62. In computing, invariants are ephemeral.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
17. If a listener nods his head when you're explaining your program, wake him up.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
98. In computing, the mean time to failure keeps getting shorter.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
96. Computers don't introduce order anywhere as much as they expose opportunities.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
108. Whenever two programmers meet to criticize their programs, both are silent.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
103. Purely applicative languages are poorly applicable.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
59. In English every word can be verbed. Would that it were so in our programming languages.
60. In seeking the unattainable, simplicity only gets in the way.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
27. Once you understand how to write a program get someone else to write it.
23. To understand a program you must become both the machine and the program.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
1. One man's constant is another man's variable.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
41. Some programming languages manage to absorb change, but withstand progress.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
7. It is easier to write an incorrect program than understand a correct one.
3. Syntactic sugar causes cancer of the semicolon.
62. In computing, invariants are ephemeral.
47. As Will Rogers would have said, "There is no such thing as a free variable."
14. In the long run every program becomes rococo - then rubble.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
23. To understand a program you must become both the machine and the program.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
3. Syntactic sugar causes cancer of the semicolon.
111. Why did the Roman Empire collapse? What is Latin for office automation?
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
111. Why did the Roman Empire collapse? What is Latin for office automation?
107. The debate rages on: is PL/I Bachtrian or Dromedary?
11. If you have a procedure with ten parameters, you probably missed some.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
79. A year spent in artificial intelligence is enough to make one believe in God.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
8. A programming language is low level when its programs require attention to the irrelevant.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
8. A programming language is low level when its programs require attention to the irrelevant.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
66. Making something variable is easy. Controlling duration of constancy is the trick.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
22. A good system can't have a weak command language.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
15. Everything should be built top-down, except the first time.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
72. An adequate bootstrap is a contradiction in terms.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
55. A LISP programmer knows the value of everything, but the cost of nothing.
46. Like punning, programming is a play on words.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
11. If you have a procedure with ten parameters, you probably missed some.
103. Purely applicative languages are poorly applicable.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
41. Some programming languages manage to absorb change, but withstand progress.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
12. Recursion is the root of computation since it trades description for time.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
23. To understand a program you must become both the machine and the program.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
11. If you have a procedure with ten parameters, you probably missed some.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
111. Why did the Roman Empire collapse? What is Latin for office automation?
61. In programming, as in everything else, to be in error is to be reborn.
90. Computation has made the tree flower.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
1. One man's constant is another man's variable.
103. Purely applicative languages are poorly applicable.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
23. To understand a program you must become both the machine and the program.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
108. Whenever two programmers meet to criticize their programs, both are silent.
108. Whenever two programmers meet to criticize their programs, both are silent.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
119. Programming is an unnatural act.
119. Programming is an unnatural act.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
76. It is the user who should parameterize procedures, not their creators.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
104. The proof of a system's value is its existence.
1. One man's constant is another man's variable.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
40. There are two ways to write error-free programs; only the third one works.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
103. Purely applicative languages are poorly applicable.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
59. In English every word can be verbed. Would that it were so in our programming languages.
7. It is easier to write an incorrect program than understand a correct one.
18. A program without a loop and a structured variable isn't worth writing.
60. In seeking the unattainable, simplicity only gets in the way.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
27. Once you understand how to write a program get someone else to write it.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
95. Don't have good ideas if you aren't willing to be responsible for them.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
59. In English every word can be verbed. Would that it were so in our programming languages.
12. Recursion is the root of computation since it trades description for time.
47. As Will Rogers would have said, "There is no such thing as a free variable."
98. In computing, the mean time to failure keeps getting shorter.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
12. Recursion is the root of computation since it trades description for time.
110. Editing is a rewording activity.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
40. There are two ways to write error-free programs; only the third one works.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
8. A programming language is low level when its programs require attention to the irrelevant.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
41. Some programming languages manage to absorb change, but withstand progress.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
66. Making something variable is easy. Controlling duration of constancy is the trick.
105. You can't communicate complexity, only an awareness of it.
79. A year spent in artificial intelligence is enough to make one believe in God.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
100. We will never run out of things to program as long as there is a single program around.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
59. In English every word can be verbed. Would that it were so in our programming languages.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
114. Within a computer natural language is unnatural.
40. There are two ways to write error-free programs; only the third one works.
23. To understand a program you must become both the machine and the program.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
100. We will never run out of things to program as long as there is a single program around.
108. Whenever two programmers meet to criticize their programs, both are silent.
66. Making something variable is easy. Controlling duration of constancy is the trick.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
57. It is easier to change the specification to fit the program than vice versa.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
105. You can't communicate complexity, only an awareness of it.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
8. A programming language is low level when its programs require attention to the irrelevant.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
59. In English every word can be verbed. Would that it were so in our programming languages.
66. Making something variable is easy. Controlling duration of constancy is the trick.
78. If your computer speaks English, it was probably made in Japan.
15. Everything should be built top-down, except the first time.
119. Programming is an unnatural act.
111. Why did the Roman Empire collapse? What is Latin for office automation?
11. If you have a procedure with ten parameters, you probably missed some.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
8. A programming language is low level when its programs require attention to the irrelevant.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
90. Computation has made the tree flower.
15. Everything should be built top-down, except the first time.
14. In the long run every program becomes rococo - then rubble.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
111. Why did the Roman Empire collapse? What is Latin for office automation?
1. One man's constant is another man's variable.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
1. One man's constant is another man's variable.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
98. In computing, the mean time to failure keeps getting shorter.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
96. Computers don't introduce order anywhere as much as they expose opportunities.
40. There are two ways to write error-free programs; only the third one works.
60. In seeking the unattainable, simplicity only gets in the way.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
38. Structured Programming supports the law of the excluded middle.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
21. Optimization hinders evolution.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
21. Optimization hinders evolution.
111. Why did the Roman Empire collapse? What is Latin for office automation?
46. Like punning, programming is a play on words.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
96. Computers don't introduce order anywhere as much as they expose opportunities.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
98. In computing, the mean time to failure keeps getting shorter.
105. You can't communicate complexity, only an awareness of it.
100. We will never run out of things to program as long as there is a single program around.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
108. Whenever two programmers meet to criticize their programs, both are silent.
103. Purely applicative languages are poorly applicable.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
61. In programming, as in everything else, to be in error is to be reborn.
110. Editing is a rewording activity.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
90. Computation has made the tree flower.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
61. In programming, as in everything else, to be in error is to be reborn.
59. In English every word can be verbed. Would that it were so in our programming languages.
59. In English every word can be verbed. Would that it were so in our programming languages.
115. Most people find the concept of programming obvious, but the doing impossible.
17. If a listener nods his head when you're explaining your program, wake him up.
76. It is the user who should parameterize procedures, not their creators.
41. Some programming languages manage to absorb change, but withstand progress.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
1. One man's constant is another man's variable.
112. Computer Science is embarrassed by the computer.
18. A program without a loop and a structured variable isn't worth writing.
31. Simplicity does not precede complexity, but follows it.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
15. Everything should be built top-down, except the first time.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
5. If a program manipulates a large amount of data, it does so in a small number of ways.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
105. You can't communicate complexity, only an awareness of it.
96. Computers don't introduce order anywhere as much as they expose opportunities.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
47. As Will Rogers would have said, "There is no such thing as a free variable."
63. When we write programs that "learn", it turns out that we do and they don't.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
115. Most people find the concept of programming obvious, but the doing impossible.
79. A year spent in artificial intelligence is enough to make one believe in God.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
105. You can't communicate complexity, only an awareness of it.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
62. In computing, invariants are ephemeral.
3. Syntactic sugar causes cancer of the semicolon.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
3. Syntactic sugar causes cancer of the semicolon.
90. Computation has made the tree flower.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
57. It is easier to change the specification to fit the program than vice versa.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
72. An adequate bootstrap is a contradiction in terms.
103. Purely applicative languages are poorly applicable.
114. Within a computer natural language is unnatural.
12. Recursion is the root of computation since it trades description for time.
1. One man's constant is another man's variable.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
76. It is the user who should parameterize procedures, not their creators.
105. You can't communicate complexity, only an awareness of it.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
14. In the long run every program becomes rococo - then rubble.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
18. A program without a loop and a structured variable isn't worth writing.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
55. A LISP programmer knows the value of everything, but the cost of nothing.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
47. As Will Rogers would have said, "There is no such thing as a free variable."
38. Structured Programming supports the law of the excluded middle.
103. Purely applicative languages are poorly applicable.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
18. A program without a loop and a structured variable isn't worth writing.
66. Making something variable is easy. Controlling duration of constancy is the trick.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
60. In seeking the unattainable, simplicity only gets in the way.
62. In computing, invariants are ephemeral.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
119. Programming is an unnatural act.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
11. If you have a procedure with ten parameters, you probably missed some.
8. A programming language is low level when its programs require attention to the irrelevant.
31. Simplicity does not precede complexity, but follows it.
31. Simplicity does not precede complexity, but follows it.
119. Programming is an unnatural act.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
100. We will never run out of things to program as long as there is a single program around.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
27. Once you understand how to write a program get someone else to write it.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
90. Computation has made the tree flower.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
63. When we write programs that "learn", it turns out that we do and they don't.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
110. Editing is a rewording activity.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
76. It is the user who should parameterize procedures, not their creators.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
46. Like punning, programming is a play on words.
3. Syntactic sugar causes cancer of the semicolon.
7. It is easier to write an incorrect program than understand a correct one.
61. In programming, as in everything else, to be in error is to be reborn.
78. If your computer speaks English, it was probably made in Japan.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
100. We will never run out of things to program as long as there is a single program around.
38. Structured Programming supports the law of the excluded middle.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
23. To understand a program you must become both the machine and the program.
4. Every program is a part of some other program and rarely fits.
1. One man's constant is another man's variable.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
111. Why did the Roman Empire collapse? What is Latin for office automation?
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
15. Everything should be built top-down, except the first time.
108. Whenever two programmers meet to criticize their programs, both are silent.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
78. If your computer speaks English, it was probably made in Japan.
98. In computing, the mean time to failure keeps getting shorter.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
66. Making something variable is easy. Controlling duration of constancy is the trick.
95. Don't have good ideas if you aren't willing to be responsible for them.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
7. It is easier to write an incorrect program than understand a correct one.
55. A LISP programmer knows the value of everything, but the cost of nothing.
114. Within a computer natural language is unnatural.
31. Simplicity does not precede complexity, but follows it.
105. You can't communicate complexity, only an awareness of it.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
119. Programming is an unnatural act.
98. In computing, the mean time to failure keeps getting shorter.
40. There are two ways to write error-free programs; only the third one works.
63. When we write programs that "learn", it turns out that we do and they don't.
18. A program without a loop and a structured variable isn't worth writing.
111. Why did the Roman Empire collapse? What is Latin for office automation?
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
90. Computation has made the tree flower.
104. The proof of a system's value is its existence.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
110. Editing is a rewording activity.
62. In computing, invariants are ephemeral.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
8. A programming language is low level when its programs require attention to the irrelevant.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
57. It is easier to change the specification to fit the program than vice versa.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
61. In programming, as in everything else, to be in error is to be reborn.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
95. Don't have good ideas if you aren't willing to be responsible for them.
63. When we write programs that "learn", it turns out that we do and they don't.
63. When we write programs that "learn", it turns out that we do and they don't.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
96. Computers don't introduce order anywhere as much as they expose opportunities.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
62. In computing, invariants are ephemeral.
63. When we write programs that "learn", it turns out that we do and they don't.
63. When we write programs that "learn", it turns out that we do and they don't.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
102. One can't proceed from the informal to the formal by formal means.
23. To understand a program you must become both the machine and the program.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
96. Computers don't introduce order anywhere as much as they expose opportunities.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
110. Editing is a rewording activity.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
115. Most people find the concept of programming obvious, but the doing impossible.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
62. In computing, invariants are ephemeral.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
12. Recursion is the root of computation since it trades description for time.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
105. You can't communicate complexity, only an awareness of it.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
114. Within a computer natural language is unnatural.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
110. Editing is a rewording activity.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
15. Everything should be built top-down, except the first time.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
55. A LISP programmer knows the value of everything, but the cost of nothing.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
8. A programming language is low level when its programs require attention to the irrelevant.
11. If you have a procedure with ten parameters, you probably missed some.
4. Every program is a part of some other program and rarely fits.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
95. Don't have good ideas if you aren't willing to be responsible for them.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
43. In software systems, it is often the early bird that makes the worm.
62. In computing, invariants are ephemeral.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
105. You can't communicate complexity, only an awareness of it.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
115. Most people find the concept of programming obvious, but the doing impossible.
21. Optimization hinders evolution.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
103. Purely applicative languages are poorly applicable.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
115. Most people find the concept of programming obvious, but the doing impossible.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
60. In seeking the unattainable, simplicity only gets in the way.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
59. In English every word can be verbed. Would that it were so in our programming languages.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
46. Like punning, programming is a play on words.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
41. Some programming languages manage to absorb change, but withstand progress.
102. One can't proceed from the informal to the formal by formal means.
61. In programming, as in everything else, to be in error is to be reborn.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
21. Optimization hinders evolution.
103. Purely applicative languages are poorly applicable.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
95. Don't have good ideas if you aren't willing to be responsible for them.
40. There are two ways to write error-free programs; only the third one works.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
21. Optimization hinders evolution.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
96. Computers don't introduce order anywhere as much as they expose opportunities.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
62. In computing, invariants are ephemeral.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
59. In English every word can be verbed. Would that it were so in our programming languages.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
8. A programming language is low level when its programs require attention to the irrelevant.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
78. If your computer speaks English, it was probably made in Japan.
47. As Will Rogers would have said, "There is no such thing as a free variable."
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
22. A good system can't have a weak command language.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
90. Computation has made the tree flower.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
11. If you have a procedure with ten parameters, you probably missed some.
112. Computer Science is embarrassed by the computer.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
21. Optimization hinders evolution.
96. Computers don't introduce order anywhere as much as they expose opportunities.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
78. If your computer speaks English, it was probably made in Japan.
119. Programming is an unnatural act.
38. Structured Programming supports the law of the excluded middle.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
11. If you have a procedure with ten parameters, you probably missed some.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
105. You can't communicate complexity, only an awareness of it.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
14. In the long run every program becomes rococo - then rubble.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
115. Most people find the concept of programming obvious, but the doing impossible.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
43. In software systems, it is often the early bird that makes the worm.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
55. A LISP programmer knows the value of everything, but the cost of nothing.
3. Syntactic sugar causes cancer of the semicolon.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
112. Computer Science is embarrassed by the computer.
22. A good system can't have a weak command language.
98. In computing, the mean time to failure keeps getting shorter.
100. We will never run out of things to program as long as there is a single program around.
66. Making something variable is easy. Controlling duration of constancy is the trick.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
55. A LISP programmer knows the value of everything, but the cost of nothing.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
108. Whenever two programmers meet to criticize their programs, both are silent.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
61. In programming, as in everything else, to be in error is to be reborn.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
22. A good system can't have a weak command language.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
40. There are two ways to write error-free programs; only the third one works.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
76. It is the user who should parameterize procedures, not their creators.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
23. To understand a program you must become both the machine and the program.
43. In software systems, it is often the early bird that makes the worm.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
15. Everything should be built top-down, except the first time.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
47. As Will Rogers would have said, "There is no such thing as a free variable."
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
7. It is easier to write an incorrect program than understand a correct one.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
3. Syntactic sugar causes cancer of the semicolon.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
7. It is easier to write an incorrect program than understand a correct one.
59. In English every word can be verbed. Would that it were so in our programming languages.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
38. Structured Programming supports the law of the excluded middle.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
11. If you have a procedure with ten parameters, you probably missed some.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
22. A good system can't have a weak command language.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
12. Recursion is the root of computation since it trades description for time.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
40. There are two ways to write error-free programs; only the third one works.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
104. The proof of a system's value is its existence.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
12. Recursion is the root of computation since it trades description for time.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
115. Most people find the concept of programming obvious, but the doing impossible.
17. If a listener nods his head when you're explaining your program, wake him up.
105. You can't communicate complexity, only an awareness of it.
66. Making something variable is easy. Controlling duration of constancy is the trick.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
62. In computing, invariants are ephemeral.
115. Most people find the concept of programming obvious, but the doing impossible.
104. The proof of a system's value is its existence.
102. One can't proceed from the informal to the formal by formal means.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
103. Purely applicative languages are poorly applicable.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
61. In programming, as in everything else, to be in error is to be reborn.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
47. As Will Rogers would have said, "There is no such thing as a free variable."
96. Computers don't introduce order anywhere as much as they expose opportunities.
61. In programming, as in everything else, to be in error is to be reborn.
57. It is easier to change the specification to fit the program than vice versa.
18. A program without a loop and a structured variable isn't worth writing.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
46. Like punning, programming is a play on words.
104. The proof of a system's value is its existence.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
7. It is easier to write an incorrect program than understand a correct one.
108. Whenever two programmers meet to criticize their programs, both are silent.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
7. It is easier to write an incorrect program than understand a correct one.
23. To understand a program you must become both the machine and the program.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
55. A LISP programmer knows the value of everything, but the cost of nothing.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
21. Optimization hinders evolution.
27. Once you understand how to write a program get someone else to write it.
110. Editing is a rewording activity.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
21. Optimization hinders evolution.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
78. If your computer speaks English, it was probably made in Japan.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
21. Optimization hinders evolution.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
1. One man's constant is another man's variable.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
95. Don't have good ideas if you aren't willing to be responsible for them.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
76. It is the user who should parameterize procedures, not their creators.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
115. Most people find the concept of programming obvious, but the doing impossible.
8. A programming language is low level when its programs require attention to the irrelevant.
76. It is the user who should parameterize procedures, not their creators.
21. Optimization hinders evolution.
114. Within a computer natural language is unnatural.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
103. Purely applicative languages are poorly applicable.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
8. A programming language is low level when its programs require attention to the irrelevant.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
4. Every program is a part of some other program and rarely fits.
40. There are two ways to write error-free programs; only the third one works.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
22. A good system can't have a weak command language.
112. Computer Science is embarrassed by the computer.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
61. In programming, as in everything else, to be in error is to be reborn.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
8. A programming language is low level when its programs require attention to the irrelevant.
90. Computation has made the tree flower.
18. A program without a loop and a structured variable isn't worth writing.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
12. Recursion is the root of computation since it trades description for time.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
72. An adequate bootstrap is a contradiction in terms.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
4. Every program is a part of some other program and rarely fits.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
96. Computers don't introduce order anywhere as much as they expose opportunities.
17. If a listener nods his head when you're explaining your program, wake him up.
3. Syntactic sugar causes cancer of the semicolon.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
55. A LISP programmer knows the value of everything, but the cost of nothing.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
1. One man's constant is another man's variable.
23. To understand a program you must become both the machine and the program.
95. Don't have good ideas if you aren't willing to be responsible for them.
96. Computers don't introduce order anywhere as much as they expose opportunities.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
100. We will never run out of things to program as long as there is a single program around.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
105. You can't communicate complexity, only an awareness of it.
40. There are two ways to write error-free programs; only the third one works.
60. In seeking the unattainable, simplicity only gets in the way.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
78. If your computer speaks English, it was probably made in Japan.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
8. A programming language is low level when its programs require attention to the irrelevant.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
114. Within a computer natural language is unnatural.
111. Why did the Roman Empire collapse? What is Latin for office automation?
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
103. Purely applicative languages are poorly applicable.
104. The proof of a system's value is its existence.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
111. Why did the Roman Empire collapse? What is Latin for office automation?
95. Don't have good ideas if you aren't willing to be responsible for them.
21. Optimization hinders evolution.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
72. An adequate bootstrap is a contradiction in terms.
55. A LISP programmer knows the value of everything, but the cost of nothing.
108. Whenever two programmers meet to criticize their programs, both are silent.
55. A LISP programmer knows the value of everything, but the cost of nothing.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
11. If you have a procedure with ten parameters, you probably missed some.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
17. If a listener nods his head when you're explaining your program, wake him up.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
7. It is easier to write an incorrect program than understand a correct one.
22. A good system can't have a weak command language.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
105. You can't communicate complexity, only an awareness of it.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
79. A year spent in artificial intelligence is enough to make one believe in God.
17. If a listener nods his head when you're explaining your program, wake him up.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
103. Purely applicative languages are poorly applicable.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
104. The proof of a system's value is its existence.
21. Optimization hinders evolution.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
12. Recursion is the root of computation since it trades description for time.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
41. Some programming languages manage to absorb change, but withstand progress.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
15. Everything should be built top-down, except the first time.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
90. Computation has made the tree flower.
111. Why did the Roman Empire collapse? What is Latin for office automation?
5. If a program manipulates a large amount of data, it does so in a small number of ways.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
46. Like punning, programming is a play on words.
17. If a listener nods his head when you're explaining your program, wake him up.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
22. A good system can't have a weak command language.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
12. Recursion is the root of computation since it trades description for time.
3. Syntactic sugar causes cancer of the semicolon.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
78. If your computer speaks English, it was probably made in Japan.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
102. One can't proceed from the informal to the formal by formal means.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
40. There are two ways to write error-free programs; only the third one works.
47. As Will Rogers would have said, "There is no such thing as a free variable."
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
21. Optimization hinders evolution.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
111. Why did the Roman Empire collapse? What is Latin for office automation?
110. Editing is a rewording activity.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
46. Like punning, programming is a play on words.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
115. Most people find the concept of programming obvious, but the doing impossible.
79. A year spent in artificial intelligence is enough to make one believe in God.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
38. Structured Programming supports the law of the excluded middle.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
23. To understand a program you must become both the machine and the program.
47. As Will Rogers would have said, "There is no such thing as a free variable."
14. In the long run every program becomes rococo - then rubble.
110. Editing is a rewording activity.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
21. Optimization hinders evolution.
60. In seeking the unattainable, simplicity only gets in the way.
78. If your computer speaks English, it was probably made in Japan.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
103. Purely applicative languages are poorly applicable.
105. You can't communicate complexity, only an awareness of it.
21. Optimization hinders evolution.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
17. If a listener nods his head when you're explaining your program, wake him up.
7. It is easier to write an incorrect program than understand a correct one.
3. Syntactic sugar causes cancer of the semicolon.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
7. It is easier to write an incorrect program than understand a correct one.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
47. As Will Rogers would have said, "There is no such thing as a free variable."
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
17. If a listener nods his head when you're explaining your program, wake him up.
110. Editing is a rewording activity.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
55. A LISP programmer knows the value of everything, but the cost of nothing.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
104. The proof of a system's value is its existence.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
57. It is easier to change the specification to fit the program than vice versa.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
14. In the long run every program becomes rococo - then rubble.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
112. Computer Science is embarrassed by the computer.
31. Simplicity does not precede complexity, but follows it.
102. One can't proceed from the informal to the formal by formal means.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
114. Within a computer natural language is unnatural.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
14. In the long run every program becomes rococo - then rubble.
114. Within a computer natural language is unnatural.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
41. Some programming languages manage to absorb change, but withstand progress.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
12. Recursion is the root of computation since it trades description for time.
63. When we write programs that "learn", it turns out that we do and they don't.
23. To understand a program you must become both the machine and the program.
95. Don't have good ideas if you aren't willing to be responsible for them.
15. Everything should be built top-down, except the first time.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
4. Every program is a part of some other program and rarely fits.
63. When we write programs that "learn", it turns out that we do and they don't.
22. A good system can't have a weak command language.
22. A good system can't have a weak command language.
104. The proof of a system's value is its existence.
46. Like punning, programming is a play on words.
7. It is easier to write an incorrect program than understand a correct one.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
112. Computer Science is embarrassed by the computer.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
38. Structured Programming supports the law of the excluded middle.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
46. Like punning, programming is a play on words.
1. One man's constant is another man's variable.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
23. To understand a program you must become both the machine and the program.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
11. If you have a procedure with ten parameters, you probably missed some.
43. In software systems, it is often the early bird that makes the worm.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
78. If your computer speaks English, it was probably made in Japan.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
110. Editing is a rewording activity.
17. If a listener nods his head when you're explaining your program, wake him up.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
104. The proof of a system's value is its existence.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
22. A good system can't have a weak command language.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
72. An adequate bootstrap is a contradiction in terms.
61. In programming, as in everything else, to be in error is to be reborn.
21. Optimization hinders evolution.
76. It is the user who should parameterize procedures, not their creators.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
79. A year spent in artificial intelligence is enough to make one believe in God.
63. When we write programs that "learn", it turns out that we do and they don't.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
57. It is easier to change the specification to fit the program than vice versa.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
27. Once you understand how to write a program get someone else to write it.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
102. One can't proceed from the informal to the formal by formal means.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
66. Making something variable is easy. Controlling duration of constancy is the trick.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
114. Within a computer natural language is unnatural.
62. In computing, invariants are ephemeral.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
72. An adequate bootstrap is a contradiction in terms.
79. A year spent in artificial intelligence is enough to make one believe in God.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
103. Purely applicative languages are poorly applicable.
11. If you have a procedure with ten parameters, you probably missed some.
79. A year spent in artificial intelligence is enough to make one believe in God.
103. Purely applicative languages are poorly applicable.
46. Like punning, programming is a play on words.
108. Whenever two programmers meet to criticize their programs, both are silent.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
62. In computing, invariants are ephemeral.
76. It is the user who should parameterize procedures, not their creators.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
111. Why did the Roman Empire collapse? What is Latin for office automation?
17. If a listener nods his head when you're explaining your program, wake him up.
103. Purely applicative languages are poorly applicable.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
110. Editing is a rewording activity.
66. Making something variable is easy. Controlling duration of constancy is the trick.
108. Whenever two programmers meet to criticize their programs, both are silent.
46. Like punning, programming is a play on words.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
19. A language that doesn't affect the way you think about programming, is not worth knowing.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
66. Making something variable is easy. Controlling duration of constancy is the trick.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
23. To understand a program you must become both the machine and the program.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
47. As Will Rogers would have said, "There is no such thing as a free variable."
100. We will never run out of things to program as long as there is a single program around.
60. In seeking the unattainable, simplicity only gets in the way.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
47. As Will Rogers would have said, "There is no such thing as a free variable."
102. One can't proceed from the informal to the formal by formal means.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
8. A programming language is low level when its programs require attention to the irrelevant.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
66. Making something variable is easy. Controlling duration of constancy is the trick.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
55. A LISP programmer knows the value of everything, but the cost of nothing.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
111. Why did the Roman Empire collapse? What is Latin for office automation?
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
43. In software systems, it is often the early bird that makes the worm.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
43. In software systems, it is often the early bird that makes the worm.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
105. You can't communicate complexity, only an awareness of it.
62. In computing, invariants are ephemeral.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
62. In computing, invariants are ephemeral.
66. Making something variable is easy. Controlling duration of constancy is the trick.
41. Some programming languages manage to absorb change, but withstand progress.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
114. Within a computer natural language is unnatural.
66. Making something variable is easy. Controlling duration of constancy is the trick.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
115. Most people find the concept of programming obvious, but the doing impossible.
112. Computer Science is embarrassed by the computer.
27. Once you understand how to write a program get someone else to write it.
114. Within a computer natural language is unnatural.
66. Making something variable is easy. Controlling duration of constancy is the trick.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
78. If your computer speaks English, it was probably made in Japan.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
111. Why did the Roman Empire collapse? What is Latin for office automation?
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
103. Purely applicative languages are poorly applicable.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
38. Structured Programming supports the law of the excluded middle.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
3. Syntactic sugar causes cancer of the semicolon.
55. A LISP programmer knows the value of everything, but the cost of nothing.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
12. Recursion is the root of computation since it trades description for time.
100. We will never run out of things to program as long as there is a single program around.
22. A good system can't have a weak command language.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
27. Once you understand how to write a program get someone else to write it.
76. It is the user who should parameterize procedures, not their creators.
111. Why did the Roman Empire collapse? What is Latin for office automation?
104. The proof of a system's value is its existence.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
72. An adequate bootstrap is a contradiction in terms.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
3. Syntactic sugar causes cancer of the semicolon.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
4. Every program is a part of some other program and rarely fits.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
60. In seeking the unattainable, simplicity only gets in the way.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
79. A year spent in artificial intelligence is enough to make one believe in God.
108. Whenever two programmers meet to criticize their programs, both are silent.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
60. In seeking the unattainable, simplicity only gets in the way.
55. A LISP programmer knows the value of everything, but the cost of nothing.
14. In the long run every program becomes rococo - then rubble.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
104. The proof of a system's value is its existence.
108. Whenever two programmers meet to criticize their programs, both are silent.
3. Syntactic sugar causes cancer of the semicolon.
63. When we write programs that "learn", it turns out that we do and they don't.
78. If your computer speaks English, it was probably made in Japan.
66. Making something variable is easy. Controlling duration of constancy is the trick.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
55. A LISP programmer knows the value of everything, but the cost of nothing.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
61. In programming, as in everything else, to be in error is to be reborn.
15. Everything should be built top-down, except the first time.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
14. In the long run every program becomes rococo - then rubble.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
18. A program without a loop and a structured variable isn't worth writing.
114. Within a computer natural language is unnatural.
96. Computers don't introduce order anywhere as much as they expose opportunities.
15. Everything should be built top-down, except the first time.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
104. The proof of a system's value is its existence.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
100. We will never run out of things to program as long as there is a single program around.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
108. Whenever two programmers meet to criticize their programs, both are silent.
17. If a listener nods his head when you're explaining your program, wake him up.
115. Most people find the concept of programming obvious, but the doing impossible.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
60. In seeking the unattainable, simplicity only gets in the way.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
40. There are two ways to write error-free programs; only the third one works.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
62. In computing, invariants are ephemeral.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
108. Whenever two programmers meet to criticize their programs, both are silent.
46. Like punning, programming is a play on words.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
102. One can't proceed from the informal to the formal by formal means.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
18. A program without a loop and a structured variable isn't worth writing.
95. Don't have good ideas if you aren't willing to be responsible for them.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
72. An adequate bootstrap is a contradiction in terms.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
27. Once you understand how to write a program get someone else to write it.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
11. If you have a procedure with ten parameters, you probably missed some.
96. Computers don't introduce order anywhere as much as they expose opportunities.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
111. Why did the Roman Empire collapse? What is Latin for office automation?
78. If your computer speaks English, it was probably made in Japan.
46. Like punning, programming is a play on words.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
114. Within a computer natural language is unnatural.
46. Like punning, programming is a play on words.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
15. Everything should be built top-down, except the first time.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
63. When we write programs that "learn", it turns out that we do and they don't.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
38. Structured Programming supports the law of the excluded middle.
46. Like punning, programming is a play on words.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
21. Optimization hinders evolution.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
62. In computing, invariants are ephemeral.
43. In software systems, it is often the early bird that makes the worm.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
4. Every program is a part of some other program and rarely fits.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
62. In computing, invariants are ephemeral.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
102. One can't proceed from the informal to the formal by formal means.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
40. There are two ways to write error-free programs; only the third one works.
3. Syntactic sugar causes cancer of the semicolon.
15. Everything should be built top-down, except the first time.
79. A year spent in artificial intelligence is enough to make one believe in God.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
110. Editing is a rewording activity.
119. Programming is an unnatural act.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
105. You can't communicate complexity, only an awareness of it.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
61. In programming, as in everything else, to be in error is to be reborn.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
103. Purely applicative languages are poorly applicable.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
22. A good system can't have a weak command language.
17. If a listener nods his head when you're explaining your program, wake him up.
31. Simplicity does not precede complexity, but follows it.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
12. Recursion is the root of computation since it trades description for time.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
31. Simplicity does not precede complexity, but follows it.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
3. Syntactic sugar causes cancer of the semicolon.
111. Why did the Roman Empire collapse? What is Latin for office automation?
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
27. Once you understand how to write a program get someone else to write it.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
23. To understand a program you must become both the machine and the program.
47. As Will Rogers would have said, "There is no such thing as a free variable."
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
105. You can't communicate complexity, only an awareness of it.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
17. If a listener nods his head when you're explaining your program, wake him up.
38. Structured Programming supports the law of the excluded middle.
60. In seeking the unattainable, simplicity only gets in the way.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
63. When we write programs that "learn", it turns out that we do and they don't.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
66. Making something variable is easy. Controlling duration of constancy is the trick.
78. If your computer speaks English, it was probably made in Japan.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
7. It is easier to write an incorrect program than understand a correct one.
3. Syntactic sugar causes cancer of the semicolon.
8. A programming language is low level when its programs require attention to the irrelevant.
12. Recursion is the root of computation since it trades description for time.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
14. In the long run every program becomes rococo - then rubble.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
105. You can't communicate complexity, only an awareness of it.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
17. If a listener nods his head when you're explaining your program, wake him up.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
78. If your computer speaks English, it was probably made in Japan.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
98. In computing, the mean time to failure keeps getting shorter.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
100. We will never run out of things to program as long as there is a single program around.
40. There are two ways to write error-free programs; only the third one works.
18. A program without a loop and a structured variable isn't worth writing.
103. Purely applicative languages are poorly applicable.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
4. Every program is a part of some other program and rarely fits.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
3. Syntactic sugar causes cancer of the semicolon.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
31. Simplicity does not precede complexity, but follows it.
111. Why did the Roman Empire collapse? What is Latin for office automation?
14. In the long run every program becomes rococo - then rubble.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
115. Most people find the concept of programming obvious, but the doing impossible.
15. Everything should be built top-down, except the first time.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
100. We will never run out of things to program as long as there is a single program around.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
119. Programming is an unnatural act.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
104. The proof of a system's value is its existence.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
110. Editing is a rewording activity.
7. It is easier to write an incorrect program than understand a correct one.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
62. In computing, invariants are ephemeral.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
3. Syntactic sugar causes cancer of the semicolon.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
63. When we write programs that "learn", it turns out that we do and they don't.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
108. Whenever two programmers meet to criticize their programs, both are silent.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
21. Optimization hinders evolution.
108. Whenever two programmers meet to criticize their programs, both are silent.
4. Every program is a part of some other program and rarely fits.
40. There are two ways to write error-free programs; only the third one works.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
1. One man's constant is another man's variable.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
111. Why did the Roman Empire collapse? What is Latin for office automation?
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
55. A LISP programmer knows the value of everything, but the cost of nothing.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
8. A programming language is low level when its programs require attention to the irrelevant.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
102. One can't proceed from the informal to the formal by formal means.
41. Some programming languages manage to absorb change, but withstand progress.
15. Everything should be built top-down, except the first time.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
110. Editing is a rewording activity.
59. In English every word can be verbed. Would that it were so in our programming languages.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
62. In computing, invariants are ephemeral.
21. Optimization hinders evolution.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
104. The proof of a system's value is its existence.
108. Whenever two programmers meet to criticize their programs, both are silent.
115. Most people find the concept of programming obvious, but the doing impossible.
18. A program without a loop and a structured variable isn't worth writing.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
40. There are two ways to write error-free programs; only the third one works.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
47. As Will Rogers would have said, "There is no such thing as a free variable."
12. Recursion is the root of computation since it trades description for time.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
96. Computers don't introduce order anywhere as much as they expose opportunities.
23. To understand a program you must become both the machine and the program.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
63. When we write programs that "learn", it turns out that we do and they don't.
119. Programming is an unnatural act.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
7. It is easier to write an incorrect program than understand a correct one.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
100. We will never run out of things to program as long as there is a single program around.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
61. In programming, as in everything else, to be in error is to be reborn.
1. One man's constant is another man's variable.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
47. As Will Rogers would have said, "There is no such thing as a free variable."
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
21. Optimization hinders evolution.
102. One can't proceed from the informal to the formal by formal means.
108. Whenever two programmers meet to criticize their programs, both are silent.
90. Computation has made the tree flower.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
63. When we write programs that "learn", it turns out that we do and they don't.
100. We will never run out of things to program as long as there is a single program around.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
79. A year spent in artificial intelligence is enough to make one believe in God.
112. Computer Science is embarrassed by the computer.
15. Everything should be built top-down, except the first time.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
1. One man's constant is another man's variable.
63. When we write programs that "learn", it turns out that we do and they don't.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
46. Like punning, programming is a play on words.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
110. Editing is a rewording activity.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
59. In English every word can be verbed. Would that it were so in our programming languages.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
72. An adequate bootstrap is a contradiction in terms.
79. A year spent in artificial intelligence is enough to make one believe in God.
57. It is easier to change the specification to fit the program than vice versa.
3. Syntactic sugar causes cancer of the semicolon.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
63. When we write programs that "learn", it turns out that we do and they don't.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
11. If you have a procedure with ten parameters, you probably missed some.
78. If your computer speaks English, it was probably made in Japan.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
95. Don't have good ideas if you aren't willing to be responsible for them.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
76. It is the user who should parameterize procedures, not their creators.
38. Structured Programming supports the law of the excluded middle.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
14. In the long run every program becomes rococo - then rubble.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
7. It is easier to write an incorrect program than understand a correct one.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
8. A programming language is low level when its programs require attention to the irrelevant.
43. In software systems, it is often the early bird that makes the worm.
96. Computers don't introduce order anywhere as much as they expose opportunities.
40. There are two ways to write error-free programs; only the third one works.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
59. In English every word can be verbed. Would that it were so in our programming languages.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
8. A programming language is low level when its programs require attention to the irrelevant.
47. As Will Rogers would have said, "There is no such thing as a free variable."
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
61. In programming, as in everything else, to be in error is to be reborn.
23. To understand a program you must become both the machine and the program.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
11. If you have a procedure with ten parameters, you probably missed some.
90. Computation has made the tree flower.
15. Everything should be built top-down, except the first time.
112. Computer Science is embarrassed by the computer.
17. If a listener nods his head when you're explaining your program, wake him up.
8. A programming language is low level when its programs require attention to the irrelevant.
96. Computers don't introduce order anywhere as much as they expose opportunities.
78. If your computer speaks English, it was probably made in Japan.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
112. Computer Science is embarrassed by the computer.
95. Don't have good ideas if you aren't willing to be responsible for them.
76. It is the user who should parameterize procedures, not their creators.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
90. Computation has made the tree flower.
27. Once you understand how to write a program get someone else to write it.
66. Making something variable is easy. Controlling duration of constancy is the trick.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
59. In English every word can be verbed. Would that it were so in our programming languages.
114. Within a computer natural language is unnatural.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
60. In seeking the unattainable, simplicity only gets in the way.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
17. If a listener nods his head when you're explaining your program, wake him up.
108. Whenever two programmers meet to criticize their programs, both are silent.
104. The proof of a system's value is its existence.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
31. Simplicity does not precede complexity, but follows it.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
98. In computing, the mean time to failure keeps getting shorter.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
12. Recursion is the root of computation since it trades description for time.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
90. Computation has made the tree flower.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
15. Everything should be built top-down, except the first time.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
95. Don't have good ideas if you aren't willing to be responsible for them.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
14. In the long run every program becomes rococo - then rubble.
27. Once you understand how to write a program get someone else to write it.
110. Editing is a rewording activity.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
23. To understand a program you must become both the machine and the program.
47. As Will Rogers would have said, "There is no such thing as a free variable."
8. A programming language is low level when its programs require attention to the irrelevant.
40. There are two ways to write error-free programs; only the third one works.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
114. Within a computer natural language is unnatural.
55. A LISP programmer knows the value of everything, but the cost of nothing.
114. Within a computer natural language is unnatural.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
115. Most people find the concept of programming obvious, but the doing impossible.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
60. In seeking the unattainable, simplicity only gets in the way.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
55. A LISP programmer knows the value of everything, but the cost of nothing.
23. To understand a program you must become both the machine and the program.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
108. Whenever two programmers meet to criticize their programs, both are silent.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
23. To understand a program you must become both the machine and the program.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
72. An adequate bootstrap is a contradiction in terms.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
57. It is easier to change the specification to fit the program than vice versa.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
14. In the long run every program becomes rococo - then rubble.
8. A programming language is low level when its programs require attention to the irrelevant.
112. Computer Science is embarrassed by the computer.
76. It is the user who should parameterize procedures, not their creators.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
4. Every program is a part of some other program and rarely fits.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
1. One man's constant is another man's variable.
119. Programming is an unnatural act.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
103. Purely applicative languages are poorly applicable.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
27. Once you understand how to write a program get someone else to write it.
104. The proof of a system's value is its existence.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
115. Most people find the concept of programming obvious, but the doing impossible.
57. It is easier to change the specification to fit the program than vice versa.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
1. One man's constant is another man's variable.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
62. In computing, invariants are ephemeral.
119. Programming is an unnatural act.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
100. We will never run out of things to program as long as there is a single program around.
41. Some programming languages manage to absorb change, but withstand progress.
3. Syntactic sugar causes cancer of the semicolon.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
1. One man's constant is another man's variable.
61. In programming, as in everything else, to be in error is to be reborn.
61. In programming, as in everything else, to be in error is to be reborn.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
79. A year spent in artificial intelligence is enough to make one believe in God.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
60. In seeking the unattainable, simplicity only gets in the way.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
38. Structured Programming supports the law of the excluded middle.
63. When we write programs that "learn", it turns out that we do and they don't.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
100. We will never run out of things to program as long as there is a single program around.
66. Making something variable is easy. Controlling duration of constancy is the trick.
22. A good system can't have a weak command language.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
104. The proof of a system's value is its existence.
119. Programming is an unnatural act.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
110. Editing is a rewording activity.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
40. There are two ways to write error-free programs; only the third one works.
57. It is easier to change the specification to fit the program than vice versa.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
23. To understand a program you must become both the machine and the program.
38. Structured Programming supports the law of the excluded middle.
12. Recursion is the root of computation since it trades description for time.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
119. Programming is an unnatural act.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
114. Within a computer natural language is unnatural.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
43. In software systems, it is often the early bird that makes the worm.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
57. It is easier to change the specification to fit the program than vice versa.
21. Optimization hinders evolution.
8. A programming language is low level when its programs require attention to the irrelevant.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
110. Editing is a rewording activity.
15. Everything should be built top-down, except the first time.
72. An adequate bootstrap is a contradiction in terms.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
8. A programming language is low level when its programs require attention to the irrelevant.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
96. Computers don't introduce order anywhere as much as they expose opportunities.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
100. We will never run out of things to program as long as there is a single program around.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
18. A program without a loop and a structured variable isn't worth writing.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
98. In computing, the mean time to failure keeps getting shorter.
115. Most people find the concept of programming obvious, but the doing impossible.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
41. Some programming languages manage to absorb change, but withstand progress.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
18. A program without a loop and a structured variable isn't worth writing.
38. Structured Programming supports the law of the excluded middle.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
47. As Will Rogers would have said, "There is no such thing as a free variable."
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
21. Optimization hinders evolution.
59. In English every word can be verbed. Would that it were so in our programming languages.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
115. Most people find the concept of programming obvious, but the doing impossible.
90. Computation has made the tree flower.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
66. Making something variable is easy. Controlling duration of constancy is the trick.
108. Whenever two programmers meet to criticize their programs, both are silent.
8. A programming language is low level when its programs require attention to the irrelevant.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
18. A program without a loop and a structured variable isn't worth writing.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
110. Editing is a rewording activity.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
72. An adequate bootstrap is a contradiction in terms.
1. One man's constant is another man's variable.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
19. A language that doesn't affect the way you think about programming, is not worth knowing.
7. It is easier to write an incorrect program than understand a correct one.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
15. Everything should be built top-down, except the first time.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
11. If you have a procedure with ten parameters, you probably missed some.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
105. You can't communicate complexity, only an awareness of it.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
72. An adequate bootstrap is a contradiction in terms.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
66. Making something variable is easy. Controlling duration of constancy is the trick.
79. A year spent in artificial intelligence is enough to make one believe in God.
41. Some programming languages manage to absorb change, but withstand progress.
4. Every program is a part of some other program and rarely fits.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
47. As Will Rogers would have said, "There is no such thing as a free variable."
57. It is easier to change the specification to fit the program than vice versa.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
100. We will never run out of things to program as long as there is a single program around.
21. Optimization hinders evolution.
7. It is easier to write an incorrect program than understand a correct one.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
40. There are two ways to write error-free programs; only the third one works.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
102. One can't proceed from the informal to the formal by formal means.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
66. Making something variable is easy. Controlling duration of constancy is the trick.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
14. In the long run every program becomes rococo - then rubble.
111. Why did the Roman Empire collapse? What is Latin for office automation?
78. If your computer speaks English, it was probably made in Japan.
46. Like punning, programming is a play on words.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
46. Like punning, programming is a play on words.
47. As Will Rogers would have said, "There is no such thing as a free variable."
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
4. Every program is a part of some other program and rarely fits.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
7. It is easier to write an incorrect program than understand a correct one.
108. Whenever two programmers meet to criticize their programs, both are silent.
114. Within a computer natural language is unnatural.
14. In the long run every program becomes rococo - then rubble.
72. An adequate bootstrap is a contradiction in terms.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
79. A year spent in artificial intelligence is enough to make one believe in God.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
102. One can't proceed from the informal to the formal by formal means.
47. As Will Rogers would have said, "There is no such thing as a free variable."
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
90. Computation has made the tree flower.
76. It is the user who should parameterize procedures, not their creators.
96. Computers don't introduce order anywhere as much as they expose opportunities.
110. Editing is a rewording activity.
100. We will never run out of things to program as long as there is a single program around.
60. In seeking the unattainable, simplicity only gets in the way.
79. A year spent in artificial intelligence is enough to make one believe in God.
90. Computation has made the tree flower.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
41. Some programming languages manage to absorb change, but withstand progress.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
8. A programming language is low level when its programs require attention to the irrelevant.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
98. In computing, the mean time to failure keeps getting shorter.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
60. In seeking the unattainable, simplicity only gets in the way.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
27. Once you understand how to write a program get someone else to write it.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
12. Recursion is the root of computation since it trades description for time.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
17. If a listener nods his head when you're explaining your program, wake him up.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
78. If your computer speaks English, it was probably made in Japan.
61. In programming, as in everything else, to be in error is to be reborn.
22. A good system can't have a weak command language.
11. If you have a procedure with ten parameters, you probably missed some.
112. Computer Science is embarrassed by the computer.
111. Why did the Roman Empire collapse? What is Latin for office automation?
55. A LISP programmer knows the value of everything, but the cost of nothing.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
1. One man's constant is another man's variable.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
72. An adequate bootstrap is a contradiction in terms.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
14. In the long run every program becomes rococo - then rubble.
110. Editing is a rewording activity.
62. In computing, invariants are ephemeral.
23. To understand a program you must become both the machine and the program.
17. If a listener nods his head when you're explaining your program, wake him up.
47. As Will Rogers would have said, "There is no such thing as a free variable."
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
104. The proof of a system's value is its existence.
22. A good system can't have a weak command language.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
27. Once you understand how to write a program get someone else to write it.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
95. Don't have good ideas if you aren't willing to be responsible for them.
102. One can't proceed from the informal to the formal by formal means.
41. Some programming languages manage to absorb change, but withstand progress.
11. If you have a procedure with ten parameters, you probably missed some.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
110. Editing is a rewording activity.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
110. Editing is a rewording activity.
110. Editing is a rewording activity.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
63. When we write programs that "learn", it turns out that we do and they don't.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
43. In software systems, it is often the early bird that makes the worm.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
115. Most people find the concept of programming obvious, but the doing impossible.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
57. It is easier to change the specification to fit the program than vice versa.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
57. It is easier to change the specification to fit the program than vice versa.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
3. Syntactic sugar causes cancer of the semicolon.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
17. If a listener nods his head when you're explaining your program, wake him up.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
108. Whenever two programmers meet to criticize their programs, both are silent.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
27. Once you understand how to write a program get someone else to write it.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
21. Optimization hinders evolution.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
96. Computers don't introduce order anywhere as much as they expose opportunities.
105. You can't communicate complexity, only an awareness of it.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
62. In computing, invariants are ephemeral.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
23. To understand a program you must become both the machine and the program.
12. Recursion is the root of computation since it trades description for time.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
76. It is the user who should parameterize procedures, not their creators.
63. When we write programs that "learn", it turns out that we do and they don't.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
1. One man's constant is another man's variable.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
63. When we write programs that "learn", it turns out that we do and they don't.
72. An adequate bootstrap is a contradiction in terms.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
111. Why did the Roman Empire collapse? What is Latin for office automation?
108. Whenever two programmers meet to criticize their programs, both are silent.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
40. There are two ways to write error-free programs; only the third one works.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
103. Purely applicative languages are poorly applicable.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
100. We will never run out of things to program as long as there is a single program around.
17. If a listener nods his head when you're explaining your program, wake him up.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
115. Most people find the concept of programming obvious, but the doing impossible.
103. Purely applicative languages are poorly applicable.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
40. There are two ways to write error-free programs; only the third one works.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
55. A LISP programmer knows the value of everything, but the cost of nothing.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
90. Computation has made the tree flower.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
78. If your computer speaks English, it was probably made in Japan.
47. As Will Rogers would have said, "There is no such thing as a free variable."
11. If you have a procedure with ten parameters, you probably missed some.
102. One can't proceed from the informal to the formal by formal means.
40. There are two ways to write error-free programs; only the third one works.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
23. To understand a program you must become both the machine and the program.
4. Every program is a part of some other program and rarely fits.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
18. A program without a loop and a structured variable isn't worth writing.
104. The proof of a system's value is its existence.
17. If a listener nods his head when you're explaining your program, wake him up.
55. A LISP programmer knows the value of everything, but the cost of nothing.
31. Simplicity does not precede complexity, but follows it.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
104. The proof of a system's value is its existence.
62. In computing, invariants are ephemeral.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
72. An adequate bootstrap is a contradiction in terms.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
8. A programming language is low level when its programs require attention to the irrelevant.
47. As Will Rogers would have said, "There is no such thing as a free variable."
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
108. Whenever two programmers meet to criticize their programs, both are silent.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
23. To understand a program you must become both the machine and the program.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
108. Whenever two programmers meet to criticize their programs, both are silent.
78. If your computer speaks English, it was probably made in Japan.
108. Whenever two programmers meet to criticize their programs, both are silent.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
3. Syntactic sugar causes cancer of the semicolon.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
119. Programming is an unnatural act.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
4. Every program is a part of some other program and rarely fits.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
12. Recursion is the root of computation since it trades description for time.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
4. Every program is a part of some other program and rarely fits.
112. Computer Science is embarrassed by the computer.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
21. Optimization hinders evolution.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
15. Everything should be built top-down, except the first time.
105. You can't communicate complexity, only an awareness of it.
72. An adequate bootstrap is a contradiction in terms.
22. A good system can't have a weak command language.
62. In computing, invariants are ephemeral.
60. In seeking the unattainable, simplicity only gets in the way.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
38. Structured Programming supports the law of the excluded middle.
40. There are two ways to write error-free programs; only the third one works.
3. Syntactic sugar causes cancer of the semicolon.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
98. In computing, the mean time to failure keeps getting shorter.
96. Computers don't introduce order anywhere as much as they expose opportunities.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
105. You can't communicate complexity, only an awareness of it.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
79. A year spent in artificial intelligence is enough to make one believe in God.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
95. Don't have good ideas if you aren't willing to be responsible for them.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
22. A good system can't have a weak command language.
7. It is easier to write an incorrect program than understand a correct one.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
21. Optimization hinders evolution.
111. Why did the Roman Empire collapse? What is Latin for office automation?
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
23. To understand a program you must become both the machine and the program.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
3. Syntactic sugar causes cancer of the semicolon.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
60. In seeking the unattainable, simplicity only gets in the way.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
62. In computing, invariants are ephemeral.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
12. Recursion is the root of computation since it trades description for time.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
1. One man's constant is another man's variable.
108. Whenever two programmers meet to criticize their programs, both are silent.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
15. Everything should be built top-down, except the first time.
114. Within a computer natural language is unnatural.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
23. To understand a program you must become both the machine and the program.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
63. When we write programs that "learn", it turns out that we do and they don't.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
8. A programming language is low level when its programs require attention to the irrelevant.
105. You can't communicate complexity, only an awareness of it.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
100. We will never run out of things to program as long as there is a single program around.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
21. Optimization hinders evolution.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
17. If a listener nods his head when you're explaining your program, wake him up.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
23. To understand a program you must become both the machine and the program.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
105. You can't communicate complexity, only an awareness of it.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
31. Simplicity does not precede complexity, but follows it.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
15. Everything should be built top-down, except the first time.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
110. Editing is a rewording activity.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
1. One man's constant is another man's variable.
27. Once you understand how to write a program get someone else to write it.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
108. Whenever two programmers meet to criticize their programs, both are silent.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
57. It is easier to change the specification to fit the program than vice versa.
1. One man's constant is another man's variable.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
21. Optimization hinders evolution.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
3. Syntactic sugar causes cancer of the semicolon.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
115. Most people find the concept of programming obvious, but the doing impossible.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
98. In computing, the mean time to failure keeps getting shorter.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
110. Editing is a rewording activity.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
98. In computing, the mean time to failure keeps getting shorter.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
63. When we write programs that "learn", it turns out that we do and they don't.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
27. Once you understand how to write a program get someone else to write it.
103. Purely applicative languages are poorly applicable.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
76. It is the user who should parameterize procedures, not their creators.
90. Computation has made the tree flower.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
95. Don't have good ideas if you aren't willing to be responsible for them.
1. One man's constant is another man's variable.
1. One man's constant is another man's variable.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
95. Don't have good ideas if you aren't willing to be responsible for them.
62. In computing, invariants are ephemeral.
1. One man's constant is another man's variable.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
102. One can't proceed from the informal to the formal by formal means.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
107. The debate rages on: is PL/I Bachtrian or Dromedary?
114. Within a computer natural language is unnatural.
103. Purely applicative languages are poorly applicable.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
22. A good system can't have a weak command language.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
19. A language that doesn't affect the way you think about programming, is not worth knowing.
102. One can't proceed from the informal to the formal by formal means.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
8. A programming language is low level when its programs require attention to the irrelevant.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
79. A year spent in artificial intelligence is enough to make one believe in God.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
15. Everything should be built top-down, except the first time.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
8. A programming language is low level when its programs require attention to the irrelevant.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
43. In software systems, it is often the early bird that makes the worm.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
1. One man's constant is another man's variable.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
1. One man's constant is another man's variable.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
21. Optimization hinders evolution.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
57. It is easier to change the specification to fit the program than vice versa.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
22. A good system can't have a weak command language.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
102. One can't proceed from the informal to the formal by formal means.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
110. Editing is a rewording activity.
38. Structured Programming supports the law of the excluded middle.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
4. Every program is a part of some other program and rarely fits.
119. Programming is an unnatural act.
46. Like punning, programming is a play on words.
55. A LISP programmer knows the value of everything, but the cost of nothing.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
63. When we write programs that "learn", it turns out that we do and they don't.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
8. A programming language is low level when its programs require attention to the irrelevant.
100. We will never run out of things to program as long as there is a single program around.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
22. A good system can't have a weak command language.
1. One man's constant is another man's variable.
105. You can't communicate complexity, only an awareness of it.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
46. Like punning, programming is a play on words.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
100. We will never run out of things to program as long as there is a single program around.
7. It is easier to write an incorrect program than understand a correct one.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
95. Don't have good ideas if you aren't willing to be responsible for them.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
66. Making something variable is easy. Controlling duration of constancy is the trick.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
62. In computing, invariants are ephemeral.
112. Computer Science is embarrassed by the computer.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
63. When we write programs that "learn", it turns out that we do and they don't.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
111. Why did the Roman Empire collapse? What is Latin for office automation?
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
112. Computer Science is embarrassed by the computer.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
15. Everything should be built top-down, except the first time.
112. Computer Science is embarrassed by the computer.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
15. Everything should be built top-down, except the first time.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
95. Don't have good ideas if you aren't willing to be responsible for them.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
110. Editing is a rewording activity.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
100. We will never run out of things to program as long as there is a single program around.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
41. Some programming languages manage to absorb change, but withstand progress.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
61. In programming, as in everything else, to be in error is to be reborn.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
5. If a program manipulates a large amount of data, it does so in a small number of ways.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
112. Computer Science is embarrassed by the computer.
112. Computer Science is embarrassed by the computer.
43. In software systems, it is often the early bird that makes the worm.
102. One can't proceed from the informal to the formal by formal means.
47. As Will Rogers would have said, "There is no such thing as a free variable."
18. A program without a loop and a structured variable isn't worth writing.
27. Once you understand how to write a program get someone else to write it.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
61. In programming, as in everything else, to be in error is to be reborn.
38. Structured Programming supports the law of the excluded middle.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
18. A program without a loop and a structured variable isn't worth writing.
96. Computers don't introduce order anywhere as much as they expose opportunities.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
60. In seeking the unattainable, simplicity only gets in the way.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
98. In computing, the mean time to failure keeps getting shorter.
7. It is easier to write an incorrect program than understand a correct one.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
98. In computing, the mean time to failure keeps getting shorter.
59. In English every word can be verbed. Would that it were so in our programming languages.
103. Purely applicative languages are poorly applicable.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
62. In computing, invariants are ephemeral.
79. A year spent in artificial intelligence is enough to make one believe in God.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
11. If you have a procedure with ten parameters, you probably missed some.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
17. If a listener nods his head when you're explaining your program, wake him up.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
60. In seeking the unattainable, simplicity only gets in the way.
60. In seeking the unattainable, simplicity only gets in the way.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
22. A good system can't have a weak command language.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
104. The proof of a system's value is its existence.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
46. Like punning, programming is a play on words.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
79. A year spent in artificial intelligence is enough to make one believe in God.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
63. When we write programs that "learn", it turns out that we do and they don't.
21. Optimization hinders evolution.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
46. Like punning, programming is a play on words.
11. If you have a procedure with ten parameters, you probably missed some.
23. To understand a program you must become both the machine and the program.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
102. One can't proceed from the informal to the formal by formal means.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
57. It is easier to change the specification to fit the program than vice versa.
90. Computation has made the tree flower.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
78. If your computer speaks English, it was probably made in Japan.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
17. If a listener nods his head when you're explaining your program, wake him up.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
76. It is the user who should parameterize procedures, not their creators.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
22. A good system can't have a weak command language.
59. In English every word can be verbed. Would that it were so in our programming languages.
27. Once you understand how to write a program get someone else to write it.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
12. Recursion is the root of computation since it trades description for time.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
4. Every program is a part of some other program and rarely fits.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
112. Computer Science is embarrassed by the computer.
43. In software systems, it is often the early bird that makes the worm.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
90. Computation has made the tree flower.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
23. To understand a program you must become both the machine and the program.
7. It is easier to write an incorrect program than understand a correct one.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
112. Computer Science is embarrassed by the computer.
100. We will never run out of things to program as long as there is a single program around.
79. A year spent in artificial intelligence is enough to make one believe in God.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
40. There are two ways to write error-free programs; only the third one works.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
27. Once you understand how to write a program get someone else to write it.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
62. In computing, invariants are ephemeral.
7. It is easier to write an incorrect program than understand a correct one.
103. Purely applicative languages are poorly applicable.
3. Syntactic sugar causes cancer of the semicolon.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
60. In seeking the unattainable, simplicity only gets in the way.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
90. Computation has made the tree flower.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
46. Like punning, programming is a play on words.
66. Making something variable is easy. Controlling duration of constancy is the trick.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
115. Most people find the concept of programming obvious, but the doing impossible.
66. Making something variable is easy. Controlling duration of constancy is the trick.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
57. It is easier to change the specification to fit the program than vice versa.
14. In the long run every program becomes rococo - then rubble.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
72. An adequate bootstrap is a contradiction in terms.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
110. Editing is a rewording activity.
90. Computation has made the tree flower.
114. Within a computer natural language is unnatural.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
8. A programming language is low level when its programs require attention to the irrelevant.
79. A year spent in artificial intelligence is enough to make one believe in God.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
43. In software systems, it is often the early bird that makes the worm.
46. Like punning, programming is a play on words.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
110. Editing is a rewording activity.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
22. A good system can't have a weak command language.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
78. If your computer speaks English, it was probably made in Japan.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
22. A good system can't have a weak command language.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
115. Most people find the concept of programming obvious, but the doing impossible.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
59. In English every word can be verbed. Would that it were so in our programming languages.
1. One man's constant is another man's variable.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
72. An adequate bootstrap is a contradiction in terms.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
63. When we write programs that "learn", it turns out that we do and they don't.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
43. In software systems, it is often the early bird that makes the worm.
38. Structured Programming supports the law of the excluded middle.
47. As Will Rogers would have said, "There is no such thing as a free variable."
19. A language that doesn't affect the way you think about programming, is not worth knowing.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
105. You can't communicate complexity, only an awareness of it.
63. When we write programs that "learn", it turns out that we do and they don't.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
104. The proof of a system's value is its existence.
105. You can't communicate complexity, only an awareness of it.
60. In seeking the unattainable, simplicity only gets in the way.
95. Don't have good ideas if you aren't willing to be responsible for them.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
11. If you have a procedure with ten parameters, you probably missed some.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
46. Like punning, programming is a play on words.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
22. A good system can't have a weak command language.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
102. One can't proceed from the informal to the formal by formal means.
18. A program without a loop and a structured variable isn't worth writing.
11. If you have a procedure with ten parameters, you probably missed some.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
105. You can't communicate complexity, only an awareness of it.
79. A year spent in artificial intelligence is enough to make one believe in God.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
111. Why did the Roman Empire collapse? What is Latin for office automation?
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
31. Simplicity does not precede complexity, but follows it.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
62. In computing, invariants are ephemeral.
17. If a listener nods his head when you're explaining your program, wake him up.
22. A good system can't have a weak command language.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
47. As Will Rogers would have said, "There is no such thing as a free variable."
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
43. In software systems, it is often the early bird that makes the worm.
115. Most people find the concept of programming obvious, but the doing impossible.
102. One can't proceed from the informal to the formal by formal means.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
119. Programming is an unnatural act.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
47. As Will Rogers would have said, "There is no such thing as a free variable."
72. An adequate bootstrap is a contradiction in terms.
41. Some programming languages manage to absorb change, but withstand progress.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
41. Some programming languages manage to absorb change, but withstand progress.
1. One man's constant is another man's variable.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
57. It is easier to change the specification to fit the program than vice versa.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
96. Computers don't introduce order anywhere as much as they expose opportunities.
61. In programming, as in everything else, to be in error is to be reborn.
40. There are two ways to write error-free programs; only the third one works.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
41. Some programming languages manage to absorb change, but withstand progress.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
66. Making something variable is easy. Controlling duration of constancy is the trick.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
7. It is easier to write an incorrect program than understand a correct one.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
57. It is easier to change the specification to fit the program than vice versa.
23. To understand a program you must become both the machine and the program.
15. Everything should be built top-down, except the first time.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
1. One man's constant is another man's variable.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
103. Purely applicative languages are poorly applicable.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
112. Computer Science is embarrassed by the computer.
17. If a listener nods his head when you're explaining your program, wake him up.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
103. Purely applicative languages are poorly applicable.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
76. It is the user who should parameterize procedures, not their creators.
112. Computer Science is embarrassed by the computer.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
112. Computer Science is embarrassed by the computer.
43. In software systems, it is often the early bird that makes the worm.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
72. An adequate bootstrap is a contradiction in terms.
47. As Will Rogers would have said, "There is no such thing as a free variable."
114. Within a computer natural language is unnatural.
40. There are two ways to write error-free programs; only the third one works.
111. Why did the Roman Empire collapse? What is Latin for office automation?
12. Recursion is the root of computation since it trades description for time.
40. There are two ways to write error-free programs; only the third one works.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
90. Computation has made the tree flower.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
111. Why did the Roman Empire collapse? What is Latin for office automation?
63. When we write programs that "learn", it turns out that we do and they don't.
55. A LISP programmer knows the value of everything, but the cost of nothing.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
3. Syntactic sugar causes cancer of the semicolon.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
3. Syntactic sugar causes cancer of the semicolon.
59. In English every word can be verbed. Would that it were so in our programming languages.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
112. Computer Science is embarrassed by the computer.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
62. In computing, invariants are ephemeral.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
46. Like punning, programming is a play on words.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
79. A year spent in artificial intelligence is enough to make one believe in God.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
31. Simplicity does not precede complexity, but follows it.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
27. Once you understand how to write a program get someone else to write it.
114. Within a computer natural language is unnatural.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
63. When we write programs that "learn", it turns out that we do and they don't.
108. Whenever two programmers meet to criticize their programs, both are silent.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
110. Editing is a rewording activity.
103. Purely applicative languages are poorly applicable.
66. Making something variable is easy. Controlling duration of constancy is the trick.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
17. If a listener nods his head when you're explaining your program, wake him up.
108. Whenever two programmers meet to criticize their programs, both are silent.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
105. You can't communicate complexity, only an awareness of it.
119. Programming is an unnatural act.
4. Every program is a part of some other program and rarely fits.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
102. One can't proceed from the informal to the formal by formal means.
115. Most people find the concept of programming obvious, but the doing impossible.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
18. A program without a loop and a structured variable isn't worth writing.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
43. In software systems, it is often the early bird that makes the worm.
62. In computing, invariants are ephemeral.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
41. Some programming languages manage to absorb change, but withstand progress.
95. Don't have good ideas if you aren't willing to be responsible for them.
63. When we write programs that "learn", it turns out that we do and they don't.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
96. Computers don't introduce order anywhere as much as they expose opportunities.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
8. A programming language is low level when its programs require attention to the irrelevant.
46. Like punning, programming is a play on words.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
112. Computer Science is embarrassed by the computer.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
96. Computers don't introduce order anywhere as much as they expose opportunities.
60. In seeking the unattainable, simplicity only gets in the way.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
90. Computation has made the tree flower.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
112. Computer Science is embarrassed by the computer.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
57. It is easier to change the specification to fit the program than vice versa.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
55. A LISP programmer knows the value of everything, but the cost of nothing.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
17. If a listener nods his head when you're explaining your program, wake him up.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
61. In programming, as in everything else, to be in error is to be reborn.
103. Purely applicative languages are poorly applicable.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
114. Within a computer natural language is unnatural.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
62. In computing, invariants are ephemeral.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
14. In the long run every program becomes rococo - then rubble.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
21. Optimization hinders evolution.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
41. Some programming languages manage to absorb change, but withstand progress.
21. Optimization hinders evolution.
60. In seeking the unattainable, simplicity only gets in the way.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
31. Simplicity does not precede complexity, but follows it.
63. When we write programs that "learn", it turns out that we do and they don't.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
57. It is easier to change the specification to fit the program than vice versa.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
107. The debate rages on: is PL/I Bachtrian or Dromedary?
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
61. In programming, as in everything else, to be in error is to be reborn.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
59. In English every word can be verbed. Would that it were so in our programming languages.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
72. An adequate bootstrap is a contradiction in terms.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
38. Structured Programming supports the law of the excluded middle.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
112. Computer Science is embarrassed by the computer.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
111. Why did the Roman Empire collapse? What is Latin for office automation?
108. Whenever two programmers meet to criticize their programs, both are silent.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
27. Once you understand how to write a program get someone else to write it.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
60. In seeking the unattainable, simplicity only gets in the way.
78. If your computer speaks English, it was probably made in Japan.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
114. Within a computer natural language is unnatural.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
114. Within a computer natural language is unnatural.
46. Like punning, programming is a play on words.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
61. In programming, as in everything else, to be in error is to be reborn.
78. If your computer speaks English, it was probably made in Japan.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
8. A programming language is low level when its programs require attention to the irrelevant.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
1. One man's constant is another man's variable.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
105. You can't communicate complexity, only an awareness of it.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
111. Why did the Roman Empire collapse? What is Latin for office automation?
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
98. In computing, the mean time to failure keeps getting shorter.
43. In software systems, it is often the early bird that makes the worm.
96. Computers don't introduce order anywhere as much as they expose opportunities.
104. The proof of a system's value is its existence.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
62. In computing, invariants are ephemeral.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
22. A good system can't have a weak command language.
23. To understand a program you must become both the machine and the program.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
57. It is easier to change the specification to fit the program than vice versa.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
98. In computing, the mean time to failure keeps getting shorter.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
14. In the long run every program becomes rococo - then rubble.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
79. A year spent in artificial intelligence is enough to make one believe in God.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
107. The debate rages on: is PL/I Bachtrian or Dromedary?
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
95. Don't have good ideas if you aren't willing to be responsible for them.
78. If your computer speaks English, it was probably made in Japan.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
98. In computing, the mean time to failure keeps getting shorter.
98. In computing, the mean time to failure keeps getting shorter.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
105. You can't communicate complexity, only an awareness of it.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
59. In English every word can be verbed. Would that it were so in our programming languages.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
110. Editing is a rewording activity.
119. Programming is an unnatural act.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
108. Whenever two programmers meet to criticize their programs, both are silent.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
23. To understand a program you must become both the machine and the program.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
78. If your computer speaks English, it was probably made in Japan.
4. Every program is a part of some other program and rarely fits.
76. It is the user who should parameterize procedures, not their creators.
38. Structured Programming supports the law of the excluded middle.
41. Some programming languages manage to absorb change, but withstand progress.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
11. If you have a procedure with ten parameters, you probably missed some.
43. In software systems, it is often the early bird that makes the worm.
22. A good system can't have a weak command language.
95. Don't have good ideas if you aren't willing to be responsible for them.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
96. Computers don't introduce order anywhere as much as they expose opportunities.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
12. Recursion is the root of computation since it trades description for time.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
7. It is easier to write an incorrect program than understand a correct one.
4. Every program is a part of some other program and rarely fits.
57. It is easier to change the specification to fit the program than vice versa.
15. Everything should be built top-down, except the first time.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
38. Structured Programming supports the law of the excluded middle.
22. A good system can't have a weak command language.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
15. Everything should be built top-down, except the first time.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
47. As Will Rogers would have said, "There is no such thing as a free variable."
40. There are two ways to write error-free programs; only the third one works.
63. When we write programs that "learn", it turns out that we do and they don't.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
7. It is easier to write an incorrect program than understand a correct one.
14. In the long run every program becomes rococo - then rubble.
7. It is easier to write an incorrect program than understand a correct one.
108. Whenever two programmers meet to criticize their programs, both are silent.
72. An adequate bootstrap is a contradiction in terms.
95. Don't have good ideas if you aren't willing to be responsible for them.
66. Making something variable is easy. Controlling duration of constancy is the trick.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
12. Recursion is the root of computation since it trades description for time.
47. As Will Rogers would have said, "There is no such thing as a free variable."
90. Computation has made the tree flower.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
14. In the long run every program becomes rococo - then rubble.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
4. Every program is a part of some other program and rarely fits.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
60. In seeking the unattainable, simplicity only gets in the way.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
119. Programming is an unnatural act.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
4. Every program is a part of some other program and rarely fits.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
46. Like punning, programming is a play on words.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
12. Recursion is the root of computation since it trades description for time.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
100. We will never run out of things to program as long as there is a single program around.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
27. Once you understand how to write a program get someone else to write it.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
79. A year spent in artificial intelligence is enough to make one believe in God.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
3. Syntactic sugar causes cancer of the semicolon.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
40. There are two ways to write error-free programs; only the third one works.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
21. Optimization hinders evolution.
47. As Will Rogers would have said, "There is no such thing as a free variable."
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
14. In the long run every program becomes rococo - then rubble.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
8. A programming language is low level when its programs require attention to the irrelevant.
11. If you have a procedure with ten parameters, you probably missed some.
22. A good system can't have a weak command language.
79. A year spent in artificial intelligence is enough to make one believe in God.
43. In software systems, it is often the early bird that makes the worm.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
100. We will never run out of things to program as long as there is a single program around.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
18. A program without a loop and a structured variable isn't worth writing.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
47. As Will Rogers would have said, "There is no such thing as a free variable."
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
46. Like punning, programming is a play on words.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
23. To understand a program you must become both the machine and the program.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
98. In computing, the mean time to failure keeps getting shorter.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
111. Why did the Roman Empire collapse? What is Latin for office automation?
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
79. A year spent in artificial intelligence is enough to make one believe in God.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
79. A year spent in artificial intelligence is enough to make one believe in God.
38. Structured Programming supports the law of the excluded middle.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
22. A good system can't have a weak command language.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
102. One can't proceed from the informal to the formal by formal means.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
8. A programming language is low level when its programs require attention to the irrelevant.
4. Every program is a part of some other program and rarely fits.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
22. A good system can't have a weak command language.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
108. Whenever two programmers meet to criticize their programs, both are silent.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
76. It is the user who should parameterize procedures, not their creators.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
57. It is easier to change the specification to fit the program than vice versa.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
11. If you have a procedure with ten parameters, you probably missed some.
62. In computing, invariants are ephemeral.
119. Programming is an unnatural act.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
98. In computing, the mean time to failure keeps getting shorter.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
61. In programming, as in everything else, to be in error is to be reborn.
31. Simplicity does not precede complexity, but follows it.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
23. To understand a program you must become both the machine and the program.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
76. It is the user who should parameterize procedures, not their creators.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
103. Purely applicative languages are poorly applicable.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
12. Recursion is the root of computation since it trades description for time.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
1. One man's constant is another man's variable.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
119. Programming is an unnatural act.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
110. Editing is a rewording activity.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
60. In seeking the unattainable, simplicity only gets in the way.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
15. Everything should be built top-down, except the first time.
46. Like punning, programming is a play on words.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
40. There are two ways to write error-free programs; only the third one works.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
119. Programming is an unnatural act.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
14. In the long run every program becomes rococo - then rubble.
105. You can't communicate complexity, only an awareness of it.
21. Optimization hinders evolution.
23. To understand a program you must become both the machine and the program.
8. A programming language is low level when its programs require attention to the irrelevant.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
66. Making something variable is easy. Controlling duration of constancy is the trick.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
105. You can't communicate complexity, only an awareness of it.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
14. In the long run every program becomes rococo - then rubble.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
31. Simplicity does not precede complexity, but follows it.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
114. Within a computer natural language is unnatural.
3. Syntactic sugar causes cancer of the semicolon.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
8. A programming language is low level when its programs require attention to the irrelevant.
12. Recursion is the root of computation since it trades description for time.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
21. Optimization hinders evolution.
72. An adequate bootstrap is a contradiction in terms.
105. You can't communicate complexity, only an awareness of it.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
12. Recursion is the root of computation since it trades description for time.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
12. Recursion is the root of computation since it trades description for time.
105. You can't communicate complexity, only an awareness of it.
112. Computer Science is embarrassed by the computer.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
3. Syntactic sugar causes cancer of the semicolon.
102. One can't proceed from the informal to the formal by formal means.
100. We will never run out of things to program as long as there is a single program around.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
110. Editing is a rewording activity.
95. Don't have good ideas if you aren't willing to be responsible for them.
95. Don't have good ideas if you aren't willing to be responsible for them.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
96. Computers don't introduce order anywhere as much as they expose opportunities.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
95. Don't have good ideas if you aren't willing to be responsible for them.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
18. A program without a loop and a structured variable isn't worth writing.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
115. Most people find the concept of programming obvious, but the doing impossible.
102. One can't proceed from the informal to the formal by formal means.
47. As Will Rogers would have said, "There is no such thing as a free variable."
57. It is easier to change the specification to fit the program than vice versa.
60. In seeking the unattainable, simplicity only gets in the way.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
66. Making something variable is easy. Controlling duration of constancy is the trick.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
59. In English every word can be verbed. Would that it were so in our programming languages.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
8. A programming language is low level when its programs require attention to the irrelevant.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
98. In computing, the mean time to failure keeps getting shorter.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
17. If a listener nods his head when you're explaining your program, wake him up.
17. If a listener nods his head when you're explaining your program, wake him up.
57. It is easier to change the specification to fit the program than vice versa.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
105. You can't communicate complexity, only an awareness of it.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
78. If your computer speaks English, it was probably made in Japan.
72. An adequate bootstrap is a contradiction in terms.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
59. In English every word can be verbed. Would that it were so in our programming languages.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
61. In programming, as in everything else, to be in error is to be reborn.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
62. In computing, invariants are ephemeral.
11. If you have a procedure with ten parameters, you probably missed some.
3. Syntactic sugar causes cancer of the semicolon.
22. A good system can't have a weak command language.
31. Simplicity does not precede complexity, but follows it.
76. It is the user who should parameterize procedures, not their creators.
78. If your computer speaks English, it was probably made in Japan.
14. In the long run every program becomes rococo - then rubble.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
23. To understand a program you must become both the machine and the program.
119. Programming is an unnatural act.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
23. To understand a program you must become both the machine and the program.
100. We will never run out of things to program as long as there is a single program around.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
90. Computation has made the tree flower.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
8. A programming language is low level when its programs require attention to the irrelevant.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
60. In seeking the unattainable, simplicity only gets in the way.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
8. A programming language is low level when its programs require attention to the irrelevant.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
1. One man's constant is another man's variable.
76. It is the user who should parameterize procedures, not their creators.
72. An adequate bootstrap is a contradiction in terms.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
102. One can't proceed from the informal to the formal by formal means.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
11. If you have a procedure with ten parameters, you probably missed some.
79. A year spent in artificial intelligence is enough to make one believe in God.
108. Whenever two programmers meet to criticize their programs, both are silent.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
78. If your computer speaks English, it was probably made in Japan.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
22. A good system can't have a weak command language.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
14. In the long run every program becomes rococo - then rubble.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
55. A LISP programmer knows the value of everything, but the cost of nothing.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
102. One can't proceed from the informal to the formal by formal means.
14. In the long run every program becomes rococo - then rubble.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
47. As Will Rogers would have said, "There is no such thing as a free variable."
107. The debate rages on: is PL/I Bachtrian or Dromedary?
38. Structured Programming supports the law of the excluded middle.
4. Every program is a part of some other program and rarely fits.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
1. One man's constant is another man's variable.
41. Some programming languages manage to absorb change, but withstand progress.
43. In software systems, it is often the early bird that makes the worm.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
63. When we write programs that "learn", it turns out that we do and they don't.
17. If a listener nods his head when you're explaining your program, wake him up.
12. Recursion is the root of computation since it trades description for time.
11. If you have a procedure with ten parameters, you probably missed some.
90. Computation has made the tree flower.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
96. Computers don't introduce order anywhere as much as they expose opportunities.
55. A LISP programmer knows the value of everything, but the cost of nothing.
43. In software systems, it is often the early bird that makes the worm.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
17. If a listener nods his head when you're explaining your program, wake him up.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
22. A good system can't have a weak command language.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
27. Once you understand how to write a program get someone else to write it.
41. Some programming languages manage to absorb change, but withstand progress.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
104. The proof of a system's value is its existence.
119. Programming is an unnatural act.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
11. If you have a procedure with ten parameters, you probably missed some.
55. A LISP programmer knows the value of everything, but the cost of nothing.
90. Computation has made the tree flower.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
8. A programming language is low level when its programs require attention to the irrelevant.
47. As Will Rogers would have said, "There is no such thing as a free variable."
114. Within a computer natural language is unnatural.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
43. In software systems, it is often the early bird that makes the worm.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
59. In English every word can be verbed. Would that it were so in our programming languages.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
103. Purely applicative languages are poorly applicable.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
119. Programming is an unnatural act.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
63. When we write programs that "learn", it turns out that we do and they don't.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
78. If your computer speaks English, it was probably made in Japan.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
11. If you have a procedure with ten parameters, you probably missed some.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
100. We will never run out of things to program as long as there is a single program around.
59. In English every word can be verbed. Would that it were so in our programming languages.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
43. In software systems, it is often the early bird that makes the worm.
76. It is the user who should parameterize procedures, not their creators.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
7. It is easier to write an incorrect program than understand a correct one.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
66. Making something variable is easy. Controlling duration of constancy is the trick.
105. You can't communicate complexity, only an awareness of it.
114. Within a computer natural language is unnatural.
105. You can't communicate complexity, only an awareness of it.
115. Most people find the concept of programming obvious, but the doing impossible.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
21. Optimization hinders evolution.
4. Every program is a part of some other program and rarely fits.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
47. As Will Rogers would have said, "There is no such thing as a free variable."
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
78. If your computer speaks English, it was probably made in Japan.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
22. A good system can't have a weak command language.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
14. In the long run every program becomes rococo - then rubble.
11. If you have a procedure with ten parameters, you probably missed some.
55. A LISP programmer knows the value of everything, but the cost of nothing.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
41. Some programming languages manage to absorb change, but withstand progress.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
63. When we write programs that "learn", it turns out that we do and they don't.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
119. Programming is an unnatural act.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
14. In the long run every program becomes rococo - then rubble.
96. Computers don't introduce order anywhere as much as they expose opportunities.
47. As Will Rogers would have said, "There is no such thing as a free variable."
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
79. A year spent in artificial intelligence is enough to make one believe in God.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
105. You can't communicate complexity, only an awareness of it.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
63. When we write programs that "learn", it turns out that we do and they don't.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
41. Some programming languages manage to absorb change, but withstand progress.
102. One can't proceed from the informal to the formal by formal means.
55. A LISP programmer knows the value of everything, but the cost of nothing.
61. In programming, as in everything else, to be in error is to be reborn.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
12. Recursion is the root of computation since it trades description for time.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
4. Every program is a part of some other program and rarely fits.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
114. Within a computer natural language is unnatural.
90. Computation has made the tree flower.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
46. Like punning, programming is a play on words.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
102. One can't proceed from the informal to the formal by formal means.
15. Everything should be built top-down, except the first time.
63. When we write programs that "learn", it turns out that we do and they don't.
41. Some programming languages manage to absorb change, but withstand progress.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
47. As Will Rogers would have said, "There is no such thing as a free variable."
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
96. Computers don't introduce order anywhere as much as they expose opportunities.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
3. Syntactic sugar causes cancer of the semicolon.
17. If a listener nods his head when you're explaining your program, wake him up.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
102. One can't proceed from the informal to the formal by formal means.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
78. If your computer speaks English, it was probably made in Japan.
57. It is easier to change the specification to fit the program than vice versa.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
104. The proof of a system's value is its existence.
95. Don't have good ideas if you aren't willing to be responsible for them.
46. Like punning, programming is a play on words.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
38. Structured Programming supports the law of the excluded middle.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
95. Don't have good ideas if you aren't willing to be responsible for them.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
60. In seeking the unattainable, simplicity only gets in the way.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
90. Computation has made the tree flower.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
11. If you have a procedure with ten parameters, you probably missed some.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
61. In programming, as in everything else, to be in error is to be reborn.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
31. Simplicity does not precede complexity, but follows it.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
110. Editing is a rewording activity.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
90. Computation has made the tree flower.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
12. Recursion is the root of computation since it trades description for time.
55. A LISP programmer knows the value of everything, but the cost of nothing.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
1. One man's constant is another man's variable.
76. It is the user who should parameterize procedures, not their creators.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
78. If your computer speaks English, it was probably made in Japan.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
112. Computer Science is embarrassed by the computer.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
8. A programming language is low level when its programs require attention to the irrelevant.
110. Editing is a rewording activity.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
40. There are two ways to write error-free programs; only the third one works.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
105. You can't communicate complexity, only an awareness of it.
104. The proof of a system's value is its existence.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
40. There are two ways to write error-free programs; only the third one works.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
100. We will never run out of things to program as long as there is a single program around.
111. Why did the Roman Empire collapse? What is Latin for office automation?
78. If your computer speaks English, it was probably made in Japan.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
8. A programming language is low level when its programs require attention to the irrelevant.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
100. We will never run out of things to program as long as there is a single program around.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
55. A LISP programmer knows the value of everything, but the cost of nothing.
11. If you have a procedure with ten parameters, you probably missed some.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
1. One man's constant is another man's variable.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
76. It is the user who should parameterize procedures, not their creators.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
62. In computing, invariants are ephemeral.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
3. Syntactic sugar causes cancer of the semicolon.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
43. In software systems, it is often the early bird that makes the worm.
12. Recursion is the root of computation since it trades description for time.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
114. Within a computer natural language is unnatural.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
72. An adequate bootstrap is a contradiction in terms.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
110. Editing is a rewording activity.
79. A year spent in artificial intelligence is enough to make one believe in God.
41. Some programming languages manage to absorb change, but withstand progress.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
14. In the long run every program becomes rococo - then rubble.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
15. Everything should be built top-down, except the first time.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
23. To understand a program you must become both the machine and the program.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
17. If a listener nods his head when you're explaining your program, wake him up.
23. To understand a program you must become both the machine and the program.
17. If a listener nods his head when you're explaining your program, wake him up.
46. Like punning, programming is a play on words.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
15. Everything should be built top-down, except the first time.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
72. An adequate bootstrap is a contradiction in terms.
119. Programming is an unnatural act.
96. Computers don't introduce order anywhere as much as they expose opportunities.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
27. Once you understand how to write a program get someone else to write it.
104. The proof of a system's value is its existence.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
55. A LISP programmer knows the value of everything, but the cost of nothing.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
105. You can't communicate complexity, only an awareness of it.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
115. Most people find the concept of programming obvious, but the doing impossible.
115. Most people find the concept of programming obvious, but the doing impossible.
108. Whenever two programmers meet to criticize their programs, both are silent.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
55. A LISP programmer knows the value of everything, but the cost of nothing.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
1. One man's constant is another man's variable.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
12. Recursion is the root of computation since it trades description for time.
98. In computing, the mean time to failure keeps getting shorter.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
96. Computers don't introduce order anywhere as much as they expose opportunities.
4. Every program is a part of some other program and rarely fits.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
18. A program without a loop and a structured variable isn't worth writing.
90. Computation has made the tree flower.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
102. One can't proceed from the informal to the formal by formal means.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
76. It is the user who should parameterize procedures, not their creators.
7. It is easier to write an incorrect program than understand a correct one.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
66. Making something variable is easy. Controlling duration of constancy is the trick.
59. In English every word can be verbed. Would that it were so in our programming languages.
12. Recursion is the root of computation since it trades description for time.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
114. Within a computer natural language is unnatural.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
72. An adequate bootstrap is a contradiction in terms.
3. Syntactic sugar causes cancer of the semicolon.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
57. It is easier to change the specification to fit the program than vice versa.
23. To understand a program you must become both the machine and the program.
1. One man's constant is another man's variable.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
12. Recursion is the root of computation since it trades description for time.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
90. Computation has made the tree flower.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
78. If your computer speaks English, it was probably made in Japan.
15. Everything should be built top-down, except the first time.
43. In software systems, it is often the early bird that makes the worm.
31. Simplicity does not precede complexity, but follows it.
43. In software systems, it is often the early bird that makes the worm.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
103. Purely applicative languages are poorly applicable.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
62. In computing, invariants are ephemeral.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
27. Once you understand how to write a program get someone else to write it.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
63. When we write programs that "learn", it turns out that we do and they don't.
115. Most people find the concept of programming obvious, but the doing impossible.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
43. In software systems, it is often the early bird that makes the worm.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
22. A good system can't have a weak command language.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
66. Making something variable is easy. Controlling duration of constancy is the trick.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
12. Recursion is the root of computation since it trades description for time.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
21. Optimization hinders evolution.
115. Most people find the concept of programming obvious, but the doing impossible.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
100. We will never run out of things to program as long as there is a single program around.
1. One man's constant is another man's variable.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
23. To understand a program you must become both the machine and the program.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
55. A LISP programmer knows the value of everything, but the cost of nothing.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
104. The proof of a system's value is its existence.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
114. Within a computer natural language is unnatural.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
105. You can't communicate complexity, only an awareness of it.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
40. There are two ways to write error-free programs; only the third one works.
40. There are two ways to write error-free programs; only the third one works.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
72. An adequate bootstrap is a contradiction in terms.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
38. Structured Programming supports the law of the excluded middle.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
57. It is easier to change the specification to fit the program than vice versa.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
76. It is the user who should parameterize procedures, not their creators.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
12. Recursion is the root of computation since it trades description for time.
108. Whenever two programmers meet to criticize their programs, both are silent.
3. Syntactic sugar causes cancer of the semicolon.
17. If a listener nods his head when you're explaining your program, wake him up.
61. In programming, as in everything else, to be in error is to be reborn.
11. If you have a procedure with ten parameters, you probably missed some.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
40. There are two ways to write error-free programs; only the third one works.
79. A year spent in artificial intelligence is enough to make one believe in God.
110. Editing is a rewording activity.
46. Like punning, programming is a play on words.
18. A program without a loop and a structured variable isn't worth writing.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
11. If you have a procedure with ten parameters, you probably missed some.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
95. Don't have good ideas if you aren't willing to be responsible for them.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
111. Why did the Roman Empire collapse? What is Latin for office automation?
63. When we write programs that "learn", it turns out that we do and they don't.
114. Within a computer natural language is unnatural.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
18. A program without a loop and a structured variable isn't worth writing.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
108. Whenever two programmers meet to criticize their programs, both are silent.
114. Within a computer natural language is unnatural.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
40. There are two ways to write error-free programs; only the third one works.
95. Don't have good ideas if you aren't willing to be responsible for them.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
76. It is the user who should parameterize procedures, not their creators.
66. Making something variable is easy. Controlling duration of constancy is the trick.
63. When we write programs that "learn", it turns out that we do and they don't.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
104. The proof of a system's value is its existence.
100. We will never run out of things to program as long as there is a single program around.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
76. It is the user who should parameterize procedures, not their creators.
76. It is the user who should parameterize procedures, not their creators.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
63. When we write programs that "learn", it turns out that we do and they don't.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
63. When we write programs that "learn", it turns out that we do and they don't.
1. One man's constant is another man's variable.
102. One can't proceed from the informal to the formal by formal means.
27. Once you understand how to write a program get someone else to write it.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
55. A LISP programmer knows the value of everything, but the cost of nothing.
23. To understand a program you must become both the machine and the program.
43. In software systems, it is often the early bird that makes the worm.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
46. Like punning, programming is a play on words.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
108. Whenever two programmers meet to criticize their programs, both are silent.
23. To understand a program you must become both the machine and the program.
108. Whenever two programmers meet to criticize their programs, both are silent.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
59. In English every word can be verbed. Would that it were so in our programming languages.
78. If your computer speaks English, it was probably made in Japan.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
105. You can't communicate complexity, only an awareness of it.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
27. Once you understand how to write a program get someone else to write it.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
27. Once you understand how to write a program get someone else to write it.
100. We will never run out of things to program as long as there is a single program around.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
79. A year spent in artificial intelligence is enough to make one believe in God.
103. Purely applicative languages are poorly applicable.
12. Recursion is the root of computation since it trades description for time.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
95. Don't have good ideas if you aren't willing to be responsible for them.
114. Within a computer natural language is unnatural.
1. One man's constant is another man's variable.
62. In computing, invariants are ephemeral.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
119. Programming is an unnatural act.
66. Making something variable is easy. Controlling duration of constancy is the trick.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
59. In English every word can be verbed. Would that it were so in our programming languages.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
105. You can't communicate complexity, only an awareness of it.
112. Computer Science is embarrassed by the computer.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
95. Don't have good ideas if you aren't willing to be responsible for them.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
21. Optimization hinders evolution.
38. Structured Programming supports the law of the excluded middle.
90. Computation has made the tree flower.
95. Don't have good ideas if you aren't willing to be responsible for them.
11. If you have a procedure with ten parameters, you probably missed some.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
60. In seeking the unattainable, simplicity only gets in the way.
103. Purely applicative languages are poorly applicable.
110. Editing is a rewording activity.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
46. Like punning, programming is a play on words.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
78. If your computer speaks English, it was probably made in Japan.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
108. Whenever two programmers meet to criticize their programs, both are silent.
31. Simplicity does not precede complexity, but follows it.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
47. As Will Rogers would have said, "There is no such thing as a free variable."
1. One man's constant is another man's variable.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
63. When we write programs that "learn", it turns out that we do and they don't.
27. Once you understand how to write a program get someone else to write it.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
22. A good system can't have a weak command language.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
111. Why did the Roman Empire collapse? What is Latin for office automation?
72. An adequate bootstrap is a contradiction in terms.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
14. In the long run every program becomes rococo - then rubble.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
111. Why did the Roman Empire collapse? What is Latin for office automation?
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
66. Making something variable is easy. Controlling duration of constancy is the trick.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
40. There are two ways to write error-free programs; only the third one works.
21. Optimization hinders evolution.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
12. Recursion is the root of computation since it trades description for time.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
96. Computers don't introduce order anywhere as much as they expose opportunities.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
61. In programming, as in everything else, to be in error is to be reborn.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
55. A LISP programmer knows the value of everything, but the cost of nothing.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
43. In software systems, it is often the early bird that makes the worm.
57. It is easier to change the specification to fit the program than vice versa.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
3. Syntactic sugar causes cancer of the semicolon.
23. To understand a program you must become both the machine and the program.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
47. As Will Rogers would have said, "There is no such thing as a free variable."
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
18. A program without a loop and a structured variable isn't worth writing.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
41. Some programming languages manage to absorb change, but withstand progress.
4. Every program is a part of some other program and rarely fits.
21. Optimization hinders evolution.
66. Making something variable is easy. Controlling duration of constancy is the trick.
119. Programming is an unnatural act.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
7. It is easier to write an incorrect program than understand a correct one.
98. In computing, the mean time to failure keeps getting shorter.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
119. Programming is an unnatural act.
57. It is easier to change the specification to fit the program than vice versa.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
57. It is easier to change the specification to fit the program than vice versa.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
14. In the long run every program becomes rococo - then rubble.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
95. Don't have good ideas if you aren't willing to be responsible for them.
55. A LISP programmer knows the value of everything, but the cost of nothing.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
23. To understand a program you must become both the machine and the program.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
66. Making something variable is easy. Controlling duration of constancy is the trick.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
96. Computers don't introduce order anywhere as much as they expose opportunities.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
90. Computation has made the tree flower.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
17. If a listener nods his head when you're explaining your program, wake him up.
11. If you have a procedure with ten parameters, you probably missed some.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
8. A programming language is low level when its programs require attention to the irrelevant.
4. Every program is a part of some other program and rarely fits.
11. If you have a procedure with ten parameters, you probably missed some.
21. Optimization hinders evolution.
27. Once you understand how to write a program get someone else to write it.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
100. We will never run out of things to program as long as there is a single program around.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
27. Once you understand how to write a program get someone else to write it.
27. Once you understand how to write a program get someone else to write it.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
4. Every program is a part of some other program and rarely fits.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
62. In computing, invariants are ephemeral.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
111. Why did the Roman Empire collapse? What is Latin for office automation?
105. You can't communicate complexity, only an awareness of it.
47. As Will Rogers would have said, "There is no such thing as a free variable."
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
38. Structured Programming supports the law of the excluded middle.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
4. Every program is a part of some other program and rarely fits.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
11. If you have a procedure with ten parameters, you probably missed some.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
55. A LISP programmer knows the value of everything, but the cost of nothing.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
18. A program without a loop and a structured variable isn't worth writing.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
41. Some programming languages manage to absorb change, but withstand progress.
12. Recursion is the root of computation since it trades description for time.
63. When we write programs that "learn", it turns out that we do and they don't.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
57. It is easier to change the specification to fit the program than vice versa.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
43. In software systems, it is often the early bird that makes the worm.
31. Simplicity does not precede complexity, but follows it.
22. A good system can't have a weak command language.
72. An adequate bootstrap is a contradiction in terms.
79. A year spent in artificial intelligence is enough to make one believe in God.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
38. Structured Programming supports the law of the excluded middle.
98. In computing, the mean time to failure keeps getting shorter.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
110. Editing is a rewording activity.
23. To understand a program you must become both the machine and the program.
57. It is easier to change the specification to fit the program than vice versa.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
103. Purely applicative languages are poorly applicable.
46. Like punning, programming is a play on words.
59. In English every word can be verbed. Would that it were so in our programming languages.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
27. Once you understand how to write a program get someone else to write it.
46. Like punning, programming is a play on words.
41. Some programming languages manage to absorb change, but withstand progress.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
102. One can't proceed from the informal to the formal by formal means.
31. Simplicity does not precede complexity, but follows it.
40. There are two ways to write error-free programs; only the third one works.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
21. Optimization hinders evolution.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
63. When we write programs that "learn", it turns out that we do and they don't.
1. One man's constant is another man's variable.
76. It is the user who should parameterize procedures, not their creators.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
11. If you have a procedure with ten parameters, you probably missed some.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
59. In English every word can be verbed. Would that it were so in our programming languages.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
22. A good system can't have a weak command language.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
61. In programming, as in everything else, to be in error is to be reborn.
21. Optimization hinders evolution.
22. A good system can't have a weak command language.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
31. Simplicity does not precede complexity, but follows it.
23. To understand a program you must become both the machine and the program.
110. Editing is a rewording activity.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
111. Why did the Roman Empire collapse? What is Latin for office automation?
102. One can't proceed from the informal to the formal by formal means.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
72. An adequate bootstrap is a contradiction in terms.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
98. In computing, the mean time to failure keeps getting shorter.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
41. Some programming languages manage to absorb change, but withstand progress.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
103. Purely applicative languages are poorly applicable.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
3. Syntactic sugar causes cancer of the semicolon.
78. If your computer speaks English, it was probably made in Japan.
60. In seeking the unattainable, simplicity only gets in the way.
78. If your computer speaks English, it was probably made in Japan.
119. Programming is an unnatural act.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
98. In computing, the mean time to failure keeps getting shorter.
102. One can't proceed from the informal to the formal by formal means.
27. Once you understand how to write a program get someone else to write it.
11. If you have a procedure with ten parameters, you probably missed some.
22. A good system can't have a weak command language.
119. Programming is an unnatural act.
63. When we write programs that "learn", it turns out that we do and they don't.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
31. Simplicity does not precede complexity, but follows it.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
57. It is easier to change the specification to fit the program than vice versa.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
38. Structured Programming supports the law of the excluded middle.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
119. Programming is an unnatural act.
66. Making something variable is easy. Controlling duration of constancy is the trick.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
27. Once you understand how to write a program get someone else to write it.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
23. To understand a program you must become both the machine and the program.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
12. Recursion is the root of computation since it trades description for time.
114. Within a computer natural language is unnatural.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
12. Recursion is the root of computation since it trades description for time.
43. In software systems, it is often the early bird that makes the worm.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
17. If a listener nods his head when you're explaining your program, wake him up.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
76. It is the user who should parameterize procedures, not their creators.
110. Editing is a rewording activity.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
12. Recursion is the root of computation since it trades description for time.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
115. Most people find the concept of programming obvious, but the doing impossible.
18. A program without a loop and a structured variable isn't worth writing.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
15. Everything should be built top-down, except the first time.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
23. To understand a program you must become both the machine and the program.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
114. Within a computer natural language is unnatural.
96. Computers don't introduce order anywhere as much as they expose opportunities.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
21. Optimization hinders evolution.
7. It is easier to write an incorrect program than understand a correct one.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
15. Everything should be built top-down, except the first time.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
61. In programming, as in everything else, to be in error is to be reborn.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
8. A programming language is low level when its programs require attention to the irrelevant.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
59. In English every word can be verbed. Would that it were so in our programming languages.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
105. You can't communicate complexity, only an awareness of it.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
100. We will never run out of things to program as long as there is a single program around.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
66. Making something variable is easy. Controlling duration of constancy is the trick.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
19. A language that doesn't affect the way you think about programming, is not worth knowing.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
4. Every program is a part of some other program and rarely fits.
112. Computer Science is embarrassed by the computer.
95. Don't have good ideas if you aren't willing to be responsible for them.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
62. In computing, invariants are ephemeral.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
17. If a listener nods his head when you're explaining your program, wake him up.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
57. It is easier to change the specification to fit the program than vice versa.
114. Within a computer natural language is unnatural.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
61. In programming, as in everything else, to be in error is to be reborn.
78. If your computer speaks English, it was probably made in Japan.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
8. A programming language is low level when its programs require attention to the irrelevant.
110. Editing is a rewording activity.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
61. In programming, as in everything else, to be in error is to be reborn.
96. Computers don't introduce order anywhere as much as they expose opportunities.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
98. In computing, the mean time to failure keeps getting shorter.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
14. In the long run every program becomes rococo - then rubble.
103. Purely applicative languages are poorly applicable.
61. In programming, as in everything else, to be in error is to be reborn.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
15. Everything should be built top-down, except the first time.
66. Making something variable is easy. Controlling duration of constancy is the trick.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
38. Structured Programming supports the law of the excluded middle.
8. A programming language is low level when its programs require attention to the irrelevant.
102. One can't proceed from the informal to the formal by formal means.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
108. Whenever two programmers meet to criticize their programs, both are silent.
8. A programming language is low level when its programs require attention to the irrelevant.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
62. In computing, invariants are ephemeral.
31. Simplicity does not precede complexity, but follows it.
27. Once you understand how to write a program get someone else to write it.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
104. The proof of a system's value is its existence.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
66. Making something variable is easy. Controlling duration of constancy is the trick.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
119. Programming is an unnatural act.
1. One man's constant is another man's variable.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
96. Computers don't introduce order anywhere as much as they expose opportunities.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
103. Purely applicative languages are poorly applicable.
111. Why did the Roman Empire collapse? What is Latin for office automation?
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
104. The proof of a system's value is its existence.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
46. Like punning, programming is a play on words.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
60. In seeking the unattainable, simplicity only gets in the way.
47. As Will Rogers would have said, "There is no such thing as a free variable."
21. Optimization hinders evolution.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
110. Editing is a rewording activity.
96. Computers don't introduce order anywhere as much as they expose opportunities.
14. In the long run every program becomes rococo - then rubble.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
57. It is easier to change the specification to fit the program than vice versa.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
100. We will never run out of things to program as long as there is a single program around.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
57. It is easier to change the specification to fit the program than vice versa.
1. One man's constant is another man's variable.
98. In computing, the mean time to failure keeps getting shorter.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
98. In computing, the mean time to failure keeps getting shorter.
40. There are two ways to write error-free programs; only the third one works.
100. We will never run out of things to program as long as there is a single program around.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
4. Every program is a part of some other program and rarely fits.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
27. Once you understand how to write a program get someone else to write it.
63. When we write programs that "learn", it turns out that we do and they don't.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
12. Recursion is the root of computation since it trades description for time.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
104. The proof of a system's value is its existence.
55. A LISP programmer knows the value of everything, but the cost of nothing.
96. Computers don't introduce order anywhere as much as they expose opportunities.
40. There are two ways to write error-free programs; only the third one works.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
47. As Will Rogers would have said, "There is no such thing as a free variable."
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
55. A LISP programmer knows the value of everything, but the cost of nothing.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
102. One can't proceed from the informal to the formal by formal means.
7. It is easier to write an incorrect program than understand a correct one.
114. Within a computer natural language is unnatural.
60. In seeking the unattainable, simplicity only gets in the way.
119. Programming is an unnatural act.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
23. To understand a program you must become both the machine and the program.
31. Simplicity does not precede complexity, but follows it.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
1. One man's constant is another man's variable.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
8. A programming language is low level when its programs require attention to the irrelevant.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
114. Within a computer natural language is unnatural.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
108. Whenever two programmers meet to criticize their programs, both are silent.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
62. In computing, invariants are ephemeral.
18. A program without a loop and a structured variable isn't worth writing.
40. There are two ways to write error-free programs; only the third one works.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
23. To understand a program you must become both the machine and the program.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
7. It is easier to write an incorrect program than understand a correct one.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
96. Computers don't introduce order anywhere as much as they expose opportunities.
79. A year spent in artificial intelligence is enough to make one believe in God.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
108. Whenever two programmers meet to criticize their programs, both are silent.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
110. Editing is a rewording activity.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
38. Structured Programming supports the law of the excluded middle.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
98. In computing, the mean time to failure keeps getting shorter.
40. There are two ways to write error-free programs; only the third one works.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
112. Computer Science is embarrassed by the computer.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
62. In computing, invariants are ephemeral.
46. Like punning, programming is a play on words.
119. Programming is an unnatural act.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
18. A program without a loop and a structured variable isn't worth writing.
22. A good system can't have a weak command language.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
61. In programming, as in everything else, to be in error is to be reborn.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
72. An adequate bootstrap is a contradiction in terms.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
4. Every program is a part of some other program and rarely fits.
72. An adequate bootstrap is a contradiction in terms.
57. It is easier to change the specification to fit the program than vice versa.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
63. When we write programs that "learn", it turns out that we do and they don't.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
15. Everything should be built top-down, except the first time.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
55. A LISP programmer knows the value of everything, but the cost of nothing.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
40. There are two ways to write error-free programs; only the third one works.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
55. A LISP programmer knows the value of everything, but the cost of nothing.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
31. Simplicity does not precede complexity, but follows it.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
31. Simplicity does not precede complexity, but follows it.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
100. We will never run out of things to program as long as there is a single program around.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
62. In computing, invariants are ephemeral.
27. Once you understand how to write a program get someone else to write it.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
111. Why did the Roman Empire collapse? What is Latin for office automation?
47. As Will Rogers would have said, "There is no such thing as a free variable."
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
111. Why did the Roman Empire collapse? What is Latin for office automation?
102. One can't proceed from the informal to the formal by formal means.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
104. The proof of a system's value is its existence.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
59. In English every word can be verbed. Would that it were so in our programming languages.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
112. Computer Science is embarrassed by the computer.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
27. Once you understand how to write a program get someone else to write it.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
22. A good system can't have a weak command language.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
14. In the long run every program becomes rococo - then rubble.
59. In English every word can be verbed. Would that it were so in our programming languages.
38. Structured Programming supports the law of the excluded middle.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
55. A LISP programmer knows the value of everything, but the cost of nothing.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
76. It is the user who should parameterize procedures, not their creators.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
108. Whenever two programmers meet to criticize their programs, both are silent.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
95. Don't have good ideas if you aren't willing to be responsible for them.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
111. Why did the Roman Empire collapse? What is Latin for office automation?
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
96. Computers don't introduce order anywhere as much as they expose opportunities.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
90. Computation has made the tree flower.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
3. Syntactic sugar causes cancer of the semicolon.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
61. In programming, as in everything else, to be in error is to be reborn.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
7. It is easier to write an incorrect program than understand a correct one.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
90. Computation has made the tree flower.
60. In seeking the unattainable, simplicity only gets in the way.
12. Recursion is the root of computation since it trades description for time.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
57. It is easier to change the specification to fit the program than vice versa.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
114. Within a computer natural language is unnatural.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
8. A programming language is low level when its programs require attention to the irrelevant.
22. A good system can't have a weak command language.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
1. One man's constant is another man's variable.
55. A LISP programmer knows the value of everything, but the cost of nothing.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
27. Once you understand how to write a program get someone else to write it.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
103. Purely applicative languages are poorly applicable.
38. Structured Programming supports the law of the excluded middle.
1. One man's constant is another man's variable.
95. Don't have good ideas if you aren't willing to be responsible for them.
103. Purely applicative languages are poorly applicable.
38. Structured Programming supports the law of the excluded middle.
108. Whenever two programmers meet to criticize their programs, both are silent.
79. A year spent in artificial intelligence is enough to make one believe in God.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
61. In programming, as in everything else, to be in error is to be reborn.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
11. If you have a procedure with ten parameters, you probably missed some.
12. Recursion is the root of computation since it trades description for time.
46. Like punning, programming is a play on words.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
103. Purely applicative languages are poorly applicable.
72. An adequate bootstrap is a contradiction in terms.
31. Simplicity does not precede complexity, but follows it.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
103. Purely applicative languages are poorly applicable.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
102. One can't proceed from the informal to the formal by formal means.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
46. Like punning, programming is a play on words.
46. Like punning, programming is a play on words.
105. You can't communicate complexity, only an awareness of it.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
119. Programming is an unnatural act.
96. Computers don't introduce order anywhere as much as they expose opportunities.
15. Everything should be built top-down, except the first time.
76. It is the user who should parameterize procedures, not their creators.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
46. Like punning, programming is a play on words.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
61. In programming, as in everything else, to be in error is to be reborn.
95. Don't have good ideas if you aren't willing to be responsible for them.
3. Syntactic sugar causes cancer of the semicolon.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
15. Everything should be built top-down, except the first time.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
1. One man's constant is another man's variable.
79. A year spent in artificial intelligence is enough to make one believe in God.
62. In computing, invariants are ephemeral.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
55. A LISP programmer knows the value of everything, but the cost of nothing.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
59. In English every word can be verbed. Would that it were so in our programming languages.
18. A program without a loop and a structured variable isn't worth writing.
72. An adequate bootstrap is a contradiction in terms.
21. Optimization hinders evolution.
119. Programming is an unnatural act.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
76. It is the user who should parameterize procedures, not their creators.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
22. A good system can't have a weak command language.
95. Don't have good ideas if you aren't willing to be responsible for them.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
12. Recursion is the root of computation since it trades description for time.
90. Computation has made the tree flower.
55. A LISP programmer knows the value of everything, but the cost of nothing.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
112. Computer Science is embarrassed by the computer.
112. Computer Science is embarrassed by the computer.
1. One man's constant is another man's variable.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
43. In software systems, it is often the early bird that makes the worm.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
40. There are two ways to write error-free programs; only the third one works.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
43. In software systems, it is often the early bird that makes the worm.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
63. When we write programs that "learn", it turns out that we do and they don't.
105. You can't communicate complexity, only an awareness of it.
8. A programming language is low level when its programs require attention to the irrelevant.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
60. In seeking the unattainable, simplicity only gets in the way.
40. There are two ways to write error-free programs; only the third one works.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
105. You can't communicate complexity, only an awareness of it.
7. It is easier to write an incorrect program than understand a correct one.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
103. Purely applicative languages are poorly applicable.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
114. Within a computer natural language is unnatural.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
43. In software systems, it is often the early bird that makes the worm.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
112. Computer Science is embarrassed by the computer.
8. A programming language is low level when its programs require attention to the irrelevant.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
18. A program without a loop and a structured variable isn't worth writing.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
114. Within a computer natural language is unnatural.
47. As Will Rogers would have said, "There is no such thing as a free variable."
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
4. Every program is a part of some other program and rarely fits.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
102. One can't proceed from the informal to the formal by formal means.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
41. Some programming languages manage to absorb change, but withstand progress.
63. When we write programs that "learn", it turns out that we do and they don't.
119. Programming is an unnatural act.
108. Whenever two programmers meet to criticize their programs, both are silent.
96. Computers don't introduce order anywhere as much as they expose opportunities.
114. Within a computer natural language is unnatural.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
3. Syntactic sugar causes cancer of the semicolon.
96. Computers don't introduce order anywhere as much as they expose opportunities.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
43. In software systems, it is often the early bird that makes the worm.
119. Programming is an unnatural act.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
22. A good system can't have a weak command language.
22. A good system can't have a weak command language.
100. We will never run out of things to program as long as there is a single program around.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
104. The proof of a system's value is its existence.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
46. Like punning, programming is a play on words.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
105. You can't communicate complexity, only an awareness of it.
110. Editing is a rewording activity.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
38. Structured Programming supports the law of the excluded middle.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
114. Within a computer natural language is unnatural.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
40. There are two ways to write error-free programs; only the third one works.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
12. Recursion is the root of computation since it trades description for time.
17. If a listener nods his head when you're explaining your program, wake him up.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
47. As Will Rogers would have said, "There is no such thing as a free variable."
59. In English every word can be verbed. Would that it were so in our programming languages.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
22. A good system can't have a weak command language.
15. Everything should be built top-down, except the first time.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
47. As Will Rogers would have said, "There is no such thing as a free variable."
40. There are two ways to write error-free programs; only the third one works.
4. Every program is a part of some other program and rarely fits.
115. Most people find the concept of programming obvious, but the doing impossible.
62. In computing, invariants are ephemeral.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
110. Editing is a rewording activity.
115. Most people find the concept of programming obvious, but the doing impossible.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
102. One can't proceed from the informal to the formal by formal means.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
60. In seeking the unattainable, simplicity only gets in the way.
108. Whenever two programmers meet to criticize their programs, both are silent.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
40. There are two ways to write error-free programs; only the third one works.
102. One can't proceed from the informal to the formal by formal means.
63. When we write programs that "learn", it turns out that we do and they don't.
104. The proof of a system's value is its existence.
102. One can't proceed from the informal to the formal by formal means.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
8. A programming language is low level when its programs require attention to the irrelevant.
11. If you have a procedure with ten parameters, you probably missed some.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
17. If a listener nods his head when you're explaining your program, wake him up.
66. Making something variable is easy. Controlling duration of constancy is the trick.
111. Why did the Roman Empire collapse? What is Latin for office automation?
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
61. In programming, as in everything else, to be in error is to be reborn.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
15. Everything should be built top-down, except the first time.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
63. When we write programs that "learn", it turns out that we do and they don't.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
61. In programming, as in everything else, to be in error is to be reborn.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
18. A program without a loop and a structured variable isn't worth writing.
104. The proof of a system's value is its existence.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
119. Programming is an unnatural act.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
76. It is the user who should parameterize procedures, not their creators.
43. In software systems, it is often the early bird that makes the worm.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
102. One can't proceed from the informal to the formal by formal means.
27. Once you understand how to write a program get someone else to write it.
115. Most people find the concept of programming obvious, but the doing impossible.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
47. As Will Rogers would have said, "There is no such thing as a free variable."
119. Programming is an unnatural act.
95. Don't have good ideas if you aren't willing to be responsible for them.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
47. As Will Rogers would have said, "There is no such thing as a free variable."
72. An adequate bootstrap is a contradiction in terms.
78. If your computer speaks English, it was probably made in Japan.
103. Purely applicative languages are poorly applicable.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
40. There are two ways to write error-free programs; only the third one works.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
47. As Will Rogers would have said, "There is no such thing as a free variable."
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
8. A programming language is low level when its programs require attention to the irrelevant.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
115. Most people find the concept of programming obvious, but the doing impossible.
115. Most people find the concept of programming obvious, but the doing impossible.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
96. Computers don't introduce order anywhere as much as they expose opportunities.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
98. In computing, the mean time to failure keeps getting shorter.
72. An adequate bootstrap is a contradiction in terms.
31. Simplicity does not precede complexity, but follows it.
76. It is the user who should parameterize procedures, not their creators.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
17. If a listener nods his head when you're explaining your program, wake him up.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
112. Computer Science is embarrassed by the computer.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
63. When we write programs that "learn", it turns out that we do and they don't.
15. Everything should be built top-down, except the first time.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
112. Computer Science is embarrassed by the computer.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
98. In computing, the mean time to failure keeps getting shorter.
60. In seeking the unattainable, simplicity only gets in the way.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
55. A LISP programmer knows the value of everything, but the cost of nothing.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
62. In computing, invariants are ephemeral.
59. In English every word can be verbed. Would that it were so in our programming languages.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
47. As Will Rogers would have said, "There is no such thing as a free variable."
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
23. To understand a program you must become both the machine and the program.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
63. When we write programs that "learn", it turns out that we do and they don't.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
119. Programming is an unnatural act.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
96. Computers don't introduce order anywhere as much as they expose opportunities.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
59. In English every word can be verbed. Would that it were so in our programming languages.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
23. To understand a program you must become both the machine and the program.
98. In computing, the mean time to failure keeps getting shorter.
60. In seeking the unattainable, simplicity only gets in the way.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
3. Syntactic sugar causes cancer of the semicolon.
21. Optimization hinders evolution.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
4. Every program is a part of some other program and rarely fits.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
31. Simplicity does not precede complexity, but follows it.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
38. Structured Programming supports the law of the excluded middle.
100. We will never run out of things to program as long as there is a single program around.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
18. A program without a loop and a structured variable isn't worth writing.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
18. A program without a loop and a structured variable isn't worth writing.
66. Making something variable is easy. Controlling duration of constancy is the trick.
111. Why did the Roman Empire collapse? What is Latin for office automation?
21. Optimization hinders evolution.
79. A year spent in artificial intelligence is enough to make one believe in God.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
31. Simplicity does not precede complexity, but follows it.
111. Why did the Roman Empire collapse? What is Latin for office automation?
114. Within a computer natural language is unnatural.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
23. To understand a program you must become both the machine and the program.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
90. Computation has made the tree flower.
110. Editing is a rewording activity.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
66. Making something variable is easy. Controlling duration of constancy is the trick.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
17. If a listener nods his head when you're explaining your program, wake him up.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
102. One can't proceed from the informal to the formal by formal means.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
55. A LISP programmer knows the value of everything, but the cost of nothing.
41. Some programming languages manage to absorb change, but withstand progress.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
15. Everything should be built top-down, except the first time.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
66. Making something variable is easy. Controlling duration of constancy is the trick.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
27. Once you understand how to write a program get someone else to write it.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
103. Purely applicative languages are poorly applicable.
62. In computing, invariants are ephemeral.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
21. Optimization hinders evolution.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
31. Simplicity does not precede complexity, but follows it.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
23. To understand a program you must become both the machine and the program.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
46. Like punning, programming is a play on words.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
115. Most people find the concept of programming obvious, but the doing impossible.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
59. In English every word can be verbed. Would that it were so in our programming languages.
96. Computers don't introduce order anywhere as much as they expose opportunities.
22. A good system can't have a weak command language.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
79. A year spent in artificial intelligence is enough to make one believe in God.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
12. Recursion is the root of computation since it trades description for time.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
43. In software systems, it is often the early bird that makes the worm.
103. Purely applicative languages are poorly applicable.
66. Making something variable is easy. Controlling duration of constancy is the trick.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
23. To understand a program you must become both the machine and the program.
66. Making something variable is easy. Controlling duration of constancy is the trick.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
95. Don't have good ideas if you aren't willing to be responsible for them.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
62. In computing, invariants are ephemeral.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
5. If a program manipulates a large amount of data, it does so in a small number of ways.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
102. One can't proceed from the informal to the formal by formal means.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
90. Computation has made the tree flower.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
115. Most people find the concept of programming obvious, but the doing impossible.
100. We will never run out of things to program as long as there is a single program around.
115. Most people find the concept of programming obvious, but the doing impossible.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
63. When we write programs that "learn", it turns out that we do and they don't.
110. Editing is a rewording activity.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
57. It is easier to change the specification to fit the program than vice versa.
79. A year spent in artificial intelligence is enough to make one believe in God.
66. Making something variable is easy. Controlling duration of constancy is the trick.
115. Most people find the concept of programming obvious, but the doing impossible.
12. Recursion is the root of computation since it trades description for time.
7. It is easier to write an incorrect program than understand a correct one.
112. Computer Science is embarrassed by the computer.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
23. To understand a program you must become both the machine and the program.
119. Programming is an unnatural act.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
4. Every program is a part of some other program and rarely fits.
103. Purely applicative languages are poorly applicable.
38. Structured Programming supports the law of the excluded middle.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
66. Making something variable is easy. Controlling duration of constancy is the trick.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
55. A LISP programmer knows the value of everything, but the cost of nothing.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
110. Editing is a rewording activity.
100. We will never run out of things to program as long as there is a single program around.
63. When we write programs that "learn", it turns out that we do and they don't.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
38. Structured Programming supports the law of the excluded middle.
38. Structured Programming supports the law of the excluded middle.
111. Why did the Roman Empire collapse? What is Latin for office automation?
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
115. Most people find the concept of programming obvious, but the doing impossible.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
11. If you have a procedure with ten parameters, you probably missed some.
11. If you have a procedure with ten parameters, you probably missed some.
4. Every program is a part of some other program and rarely fits.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
3. Syntactic sugar causes cancer of the semicolon.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
55. A LISP programmer knows the value of everything, but the cost of nothing.
15. Everything should be built top-down, except the first time.
112. Computer Science is embarrassed by the computer.
100. We will never run out of things to program as long as there is a single program around.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
21. Optimization hinders evolution.
66. Making something variable is easy. Controlling duration of constancy is the trick.
8. A programming language is low level when its programs require attention to the irrelevant.
111. Why did the Roman Empire collapse? What is Latin for office automation?
114. Within a computer natural language is unnatural.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
38. Structured Programming supports the law of the excluded middle.
46. Like punning, programming is a play on words.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
18. A program without a loop and a structured variable isn't worth writing.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
11. If you have a procedure with ten parameters, you probably missed some.
27. Once you understand how to write a program get someone else to write it.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
98. In computing, the mean time to failure keeps getting shorter.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
43. In software systems, it is often the early bird that makes the worm.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
90. Computation has made the tree flower.
21. Optimization hinders evolution.
60. In seeking the unattainable, simplicity only gets in the way.
23. To understand a program you must become both the machine and the program.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
76. It is the user who should parameterize procedures, not their creators.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
31. Simplicity does not precede complexity, but follows it.
105. You can't communicate complexity, only an awareness of it.
96. Computers don't introduce order anywhere as much as they expose opportunities.
115. Most people find the concept of programming obvious, but the doing impossible.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
41. Some programming languages manage to absorb change, but withstand progress.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
98. In computing, the mean time to failure keeps getting shorter.
27. Once you understand how to write a program get someone else to write it.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
102. One can't proceed from the informal to the formal by formal means.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
119. Programming is an unnatural act.
108. Whenever two programmers meet to criticize their programs, both are silent.
3. Syntactic sugar causes cancer of the semicolon.
104. The proof of a system's value is its existence.
7. It is easier to write an incorrect program than understand a correct one.
119. Programming is an unnatural act.
110. Editing is a rewording activity.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
79. A year spent in artificial intelligence is enough to make one believe in God.
47. As Will Rogers would have said, "There is no such thing as a free variable."
11. If you have a procedure with ten parameters, you probably missed some.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
63. When we write programs that "learn", it turns out that we do and they don't.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
27. Once you understand how to write a program get someone else to write it.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
62. In computing, invariants are ephemeral.
59. In English every word can be verbed. Would that it were so in our programming languages.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
1. One man's constant is another man's variable.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
90. Computation has made the tree flower.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
119. Programming is an unnatural act.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
18. A program without a loop and a structured variable isn't worth writing.
110. Editing is a rewording activity.
100. We will never run out of things to program as long as there is a single program around.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
78. If your computer speaks English, it was probably made in Japan.
90. Computation has made the tree flower.
96. Computers don't introduce order anywhere as much as they expose opportunities.
11. If you have a procedure with ten parameters, you probably missed some.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
111. Why did the Roman Empire collapse? What is Latin for office automation?
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
95. Don't have good ideas if you aren't willing to be responsible for them.
96. Computers don't introduce order anywhere as much as they expose opportunities.
14. In the long run every program becomes rococo - then rubble.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
4. Every program is a part of some other program and rarely fits.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
60. In seeking the unattainable, simplicity only gets in the way.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
59. In English every word can be verbed. Would that it were so in our programming languages.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
31. Simplicity does not precede complexity, but follows it.
102. One can't proceed from the informal to the formal by formal means.
7. It is easier to write an incorrect program than understand a correct one.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
60. In seeking the unattainable, simplicity only gets in the way.
63. When we write programs that "learn", it turns out that we do and they don't.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
102. One can't proceed from the informal to the formal by formal means.
18. A program without a loop and a structured variable isn't worth writing.
14. In the long run every program becomes rococo - then rubble.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
61. In programming, as in everything else, to be in error is to be reborn.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
104. The proof of a system's value is its existence.
105. You can't communicate complexity, only an awareness of it.
79. A year spent in artificial intelligence is enough to make one believe in God.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
114. Within a computer natural language is unnatural.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
7. It is easier to write an incorrect program than understand a correct one.
18. A program without a loop and a structured variable isn't worth writing.
115. Most people find the concept of programming obvious, but the doing impossible.
111. Why did the Roman Empire collapse? What is Latin for office automation?
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
38. Structured Programming supports the law of the excluded middle.
115. Most people find the concept of programming obvious, but the doing impossible.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
31. Simplicity does not precede complexity, but follows it.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
43. In software systems, it is often the early bird that makes the worm.
114. Within a computer natural language is unnatural.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
119. Programming is an unnatural act.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
119. Programming is an unnatural act.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
23. To understand a program you must become both the machine and the program.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
38. Structured Programming supports the law of the excluded middle.
55. A LISP programmer knows the value of everything, but the cost of nothing.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
8. A programming language is low level when its programs require attention to the irrelevant.
119. Programming is an unnatural act.
15. Everything should be built top-down, except the first time.
1. One man's constant is another man's variable.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
22. A good system can't have a weak command language.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
22. A good system can't have a weak command language.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
114. Within a computer natural language is unnatural.
104. The proof of a system's value is its existence.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
62. In computing, invariants are ephemeral.
60. In seeking the unattainable, simplicity only gets in the way.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
12. Recursion is the root of computation since it trades description for time.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
38. Structured Programming supports the law of the excluded middle.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
72. An adequate bootstrap is a contradiction in terms.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
18. A program without a loop and a structured variable isn't worth writing.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
40. There are two ways to write error-free programs; only the third one works.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
72. An adequate bootstrap is a contradiction in terms.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
18. A program without a loop and a structured variable isn't worth writing.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
12. Recursion is the root of computation since it trades description for time.
63. When we write programs that "learn", it turns out that we do and they don't.
3. Syntactic sugar causes cancer of the semicolon.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
3. Syntactic sugar causes cancer of the semicolon.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
60. In seeking the unattainable, simplicity only gets in the way.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
31. Simplicity does not precede complexity, but follows it.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
40. There are two ways to write error-free programs; only the third one works.
95. Don't have good ideas if you aren't willing to be responsible for them.
102. One can't proceed from the informal to the formal by formal means.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
18. A program without a loop and a structured variable isn't worth writing.
38. Structured Programming supports the law of the excluded middle.
102. One can't proceed from the informal to the formal by formal means.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
22. A good system can't have a weak command language.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
104. The proof of a system's value is its existence.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
3. Syntactic sugar causes cancer of the semicolon.
31. Simplicity does not precede complexity, but follows it.
21. Optimization hinders evolution.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
108. Whenever two programmers meet to criticize their programs, both are silent.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
40. There are two ways to write error-free programs; only the third one works.
14. In the long run every program becomes rococo - then rubble.
47. As Will Rogers would have said, "There is no such thing as a free variable."
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
114. Within a computer natural language is unnatural.
23. To understand a program you must become both the machine and the program.
61. In programming, as in everything else, to be in error is to be reborn.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
43. In software systems, it is often the early bird that makes the worm.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
43. In software systems, it is often the early bird that makes the worm.
8. A programming language is low level when its programs require attention to the irrelevant.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
59. In English every word can be verbed. Would that it were so in our programming languages.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
8. A programming language is low level when its programs require attention to the irrelevant.
46. Like punning, programming is a play on words.
112. Computer Science is embarrassed by the computer.
17. If a listener nods his head when you're explaining your program, wake him up.
38. Structured Programming supports the law of the excluded middle.
66. Making something variable is easy. Controlling duration of constancy is the trick.
11. If you have a procedure with ten parameters, you probably missed some.
3. Syntactic sugar causes cancer of the semicolon.
112. Computer Science is embarrassed by the computer.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
8. A programming language is low level when its programs require attention to the irrelevant.
59. In English every word can be verbed. Would that it were so in our programming languages.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
15. Everything should be built top-down, except the first time.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
105. You can't communicate complexity, only an awareness of it.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
72. An adequate bootstrap is a contradiction in terms.
100. We will never run out of things to program as long as there is a single program around.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
61. In programming, as in everything else, to be in error is to be reborn.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
12. Recursion is the root of computation since it trades description for time.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
78. If your computer speaks English, it was probably made in Japan.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
59. In English every word can be verbed. Would that it were so in our programming languages.
78. If your computer speaks English, it was probably made in Japan.
11. If you have a procedure with ten parameters, you probably missed some.
95. Don't have good ideas if you aren't willing to be responsible for them.
63. When we write programs that "learn", it turns out that we do and they don't.
79. A year spent in artificial intelligence is enough to make one believe in God.
76. It is the user who should parameterize procedures, not their creators.
112. Computer Science is embarrassed by the computer.
46. Like punning, programming is a play on words.
11. If you have a procedure with ten parameters, you probably missed some.
62. In computing, invariants are ephemeral.
4. Every program is a part of some other program and rarely fits.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
63. When we write programs that "learn", it turns out that we do and they don't.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
3. Syntactic sugar causes cancer of the semicolon.
78. If your computer speaks English, it was probably made in Japan.
7. It is easier to write an incorrect program than understand a correct one.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
14. In the long run every program becomes rococo - then rubble.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
15. Everything should be built top-down, except the first time.
14. In the long run every program becomes rococo - then rubble.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
55. A LISP programmer knows the value of everything, but the cost of nothing.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
105. You can't communicate complexity, only an awareness of it.
43. In software systems, it is often the early bird that makes the worm.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
103. Purely applicative languages are poorly applicable.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
22. A good system can't have a weak command language.
90. Computation has made the tree flower.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
46. Like punning, programming is a play on words.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
110. Editing is a rewording activity.
31. Simplicity does not precede complexity, but follows it.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
55. A LISP programmer knows the value of everything, but the cost of nothing.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
17. If a listener nods his head when you're explaining your program, wake him up.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
27. Once you understand how to write a program get someone else to write it.
95. Don't have good ideas if you aren't willing to be responsible for them.
4. Every program is a part of some other program and rarely fits.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
21. Optimization hinders evolution.
55. A LISP programmer knows the value of everything, but the cost of nothing.
47. As Will Rogers would have said, "There is no such thing as a free variable."
112. Computer Science is embarrassed by the computer.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
114. Within a computer natural language is unnatural.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
3. Syntactic sugar causes cancer of the semicolon.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
108. Whenever two programmers meet to criticize their programs, both are silent.
3. Syntactic sugar causes cancer of the semicolon.
18. A program without a loop and a structured variable isn't worth writing.
72. An adequate bootstrap is a contradiction in terms.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
27. Once you understand how to write a program get someone else to write it.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
96. Computers don't introduce order anywhere as much as they expose opportunities.
3. Syntactic sugar causes cancer of the semicolon.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
103. Purely applicative languages are poorly applicable.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
12. Recursion is the root of computation since it trades description for time.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
114. Within a computer natural language is unnatural.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
18. A program without a loop and a structured variable isn't worth writing.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
103. Purely applicative languages are poorly applicable.
43. In software systems, it is often the early bird that makes the worm.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
8. A programming language is low level when its programs require attention to the irrelevant.
18. A program without a loop and a structured variable isn't worth writing.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
22. A good system can't have a weak command language.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
72. An adequate bootstrap is a contradiction in terms.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
76. It is the user who should parameterize procedures, not their creators.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
111. Why did the Roman Empire collapse? What is Latin for office automation?
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
14. In the long run every program becomes rococo - then rubble.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
72. An adequate bootstrap is a contradiction in terms.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
95. Don't have good ideas if you aren't willing to be responsible for them.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
40. There are two ways to write error-free programs; only the third one works.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
4. Every program is a part of some other program and rarely fits.
61. In programming, as in everything else, to be in error is to be reborn.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
31. Simplicity does not precede complexity, but follows it.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
55. A LISP programmer knows the value of everything, but the cost of nothing.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
112. Computer Science is embarrassed by the computer.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
66. Making something variable is easy. Controlling duration of constancy is the trick.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
111. Why did the Roman Empire collapse? What is Latin for office automation?
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
4. Every program is a part of some other program and rarely fits.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
27. Once you understand how to write a program get someone else to write it.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
110. Editing is a rewording activity.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
78. If your computer speaks English, it was probably made in Japan.
59. In English every word can be verbed. Would that it were so in our programming languages.
90. Computation has made the tree flower.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
7. It is easier to write an incorrect program than understand a correct one.
103. Purely applicative languages are poorly applicable.
66. Making something variable is easy. Controlling duration of constancy is the trick.
100. We will never run out of things to program as long as there is a single program around.
47. As Will Rogers would have said, "There is no such thing as a free variable."
19. A language that doesn't affect the way you think about programming, is not worth knowing.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
27. Once you understand how to write a program get someone else to write it.
60. In seeking the unattainable, simplicity only gets in the way.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
63. When we write programs that "learn", it turns out that we do and they don't.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
102. One can't proceed from the informal to the formal by formal means.
41. Some programming languages manage to absorb change, but withstand progress.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
14. In the long run every program becomes rococo - then rubble.
31. Simplicity does not precede complexity, but follows it.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
57. It is easier to change the specification to fit the program than vice versa.
7. It is easier to write an incorrect program than understand a correct one.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
102. One can't proceed from the informal to the formal by formal means.
12. Recursion is the root of computation since it trades description for time.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
31. Simplicity does not precede complexity, but follows it.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
90. Computation has made the tree flower.
27. Once you understand how to write a program get someone else to write it.
90. Computation has made the tree flower.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
38. Structured Programming supports the law of the excluded middle.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
61. In programming, as in everything else, to be in error is to be reborn.
21. Optimization hinders evolution.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
119. Programming is an unnatural act.
96. Computers don't introduce order anywhere as much as they expose opportunities.
59. In English every word can be verbed. Would that it were so in our programming languages.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
95. Don't have good ideas if you aren't willing to be responsible for them.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
15. Everything should be built top-down, except the first time.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
11. If you have a procedure with ten parameters, you probably missed some.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
115. Most people find the concept of programming obvious, but the doing impossible.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
78. If your computer speaks English, it was probably made in Japan.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
12. Recursion is the root of computation since it trades description for time.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
3. Syntactic sugar causes cancer of the semicolon.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
15. Everything should be built top-down, except the first time.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
3. Syntactic sugar causes cancer of the semicolon.
1. One man's constant is another man's variable.
7. It is easier to write an incorrect program than understand a correct one.
76. It is the user who should parameterize procedures, not their creators.
31. Simplicity does not precede complexity, but follows it.
3. Syntactic sugar causes cancer of the semicolon.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
41. Some programming languages manage to absorb change, but withstand progress.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
7. It is easier to write an incorrect program than understand a correct one.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
17. If a listener nods his head when you're explaining your program, wake him up.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
110. Editing is a rewording activity.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
59. In English every word can be verbed. Would that it were so in our programming languages.
105. You can't communicate complexity, only an awareness of it.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
114. Within a computer natural language is unnatural.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
4. Every program is a part of some other program and rarely fits.
66. Making something variable is easy. Controlling duration of constancy is the trick.
23. To understand a program you must become both the machine and the program.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
8. A programming language is low level when its programs require attention to the irrelevant.
115. Most people find the concept of programming obvious, but the doing impossible.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
12. Recursion is the root of computation since it trades description for time.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
119. Programming is an unnatural act.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
18. A program without a loop and a structured variable isn't worth writing.
4. Every program is a part of some other program and rarely fits.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
55. A LISP programmer knows the value of everything, but the cost of nothing.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
43. In software systems, it is often the early bird that makes the worm.
22. A good system can't have a weak command language.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
12. Recursion is the root of computation since it trades description for time.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
119. Programming is an unnatural act.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
112. Computer Science is embarrassed by the computer.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
7. It is easier to write an incorrect program than understand a correct one.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
105. You can't communicate complexity, only an awareness of it.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
47. As Will Rogers would have said, "There is no such thing as a free variable."
66. Making something variable is easy. Controlling duration of constancy is the trick.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
3. Syntactic sugar causes cancer of the semicolon.
90. Computation has made the tree flower.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
62. In computing, invariants are ephemeral.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
119. Programming is an unnatural act.
112. Computer Science is embarrassed by the computer.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
66. Making something variable is easy. Controlling duration of constancy is the trick.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
43. In software systems, it is often the early bird that makes the worm.
76. It is the user who should parameterize procedures, not their creators.
90. Computation has made the tree flower.
12. Recursion is the root of computation since it trades description for time.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
27. Once you understand how to write a program get someone else to write it.
96. Computers don't introduce order anywhere as much as they expose opportunities.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
60. In seeking the unattainable, simplicity only gets in the way.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
78. If your computer speaks English, it was probably made in Japan.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
40. There are two ways to write error-free programs; only the third one works.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
1. One man's constant is another man's variable.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
55. A LISP programmer knows the value of everything, but the cost of nothing.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
43. In software systems, it is often the early bird that makes the worm.
114. Within a computer natural language is unnatural.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
79. A year spent in artificial intelligence is enough to make one believe in God.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
78. If your computer speaks English, it was probably made in Japan.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
15. Everything should be built top-down, except the first time.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
60. In seeking the unattainable, simplicity only gets in the way.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
5. If a program manipulates a large amount of data, it does so in a small number of ways.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
119. Programming is an unnatural act.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
21. Optimization hinders evolution.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
78. If your computer speaks English, it was probably made in Japan.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
14. In the long run every program becomes rococo - then rubble.
4. Every program is a part of some other program and rarely fits.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
18. A program without a loop and a structured variable isn't worth writing.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
11. If you have a procedure with ten parameters, you probably missed some.
98. In computing, the mean time to failure keeps getting shorter.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
17. If a listener nods his head when you're explaining your program, wake him up.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
8. A programming language is low level when its programs require attention to the irrelevant.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
12. Recursion is the root of computation since it trades description for time.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
43. In software systems, it is often the early bird that makes the worm.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
105. You can't communicate complexity, only an awareness of it.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
1. One man's constant is another man's variable.
8. A programming language is low level when its programs require attention to the irrelevant.
57. It is easier to change the specification to fit the program than vice versa.
46. Like punning, programming is a play on words.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
8. A programming language is low level when its programs require attention to the irrelevant.
76. It is the user who should parameterize procedures, not their creators.
115. Most people find the concept of programming obvious, but the doing impossible.
18. A program without a loop and a structured variable isn't worth writing.
8. A programming language is low level when its programs require attention to the irrelevant.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
59. In English every word can be verbed. Would that it were so in our programming languages.
47. As Will Rogers would have said, "There is no such thing as a free variable."
41. Some programming languages manage to absorb change, but withstand progress.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
27. Once you understand how to write a program get someone else to write it.
11. If you have a procedure with ten parameters, you probably missed some.
17. If a listener nods his head when you're explaining your program, wake him up.
18. A program without a loop and a structured variable isn't worth writing.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
90. Computation has made the tree flower.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
100. We will never run out of things to program as long as there is a single program around.
21. Optimization hinders evolution.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
79. A year spent in artificial intelligence is enough to make one believe in God.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
21. Optimization hinders evolution.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
111. Why did the Roman Empire collapse? What is Latin for office automation?
108. Whenever two programmers meet to criticize their programs, both are silent.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
98. In computing, the mean time to failure keeps getting shorter.
7. It is easier to write an incorrect program than understand a correct one.
108. Whenever two programmers meet to criticize their programs, both are silent.
12. Recursion is the root of computation since it trades description for time.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
119. Programming is an unnatural act.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
62. In computing, invariants are ephemeral.
1. One man's constant is another man's variable.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
79. A year spent in artificial intelligence is enough to make one believe in God.
76. It is the user who should parameterize procedures, not their creators.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
79. A year spent in artificial intelligence is enough to make one believe in God.
17. If a listener nods his head when you're explaining your program, wake him up.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
72. An adequate bootstrap is a contradiction in terms.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
12. Recursion is the root of computation since it trades description for time.
38. Structured Programming supports the law of the excluded middle.
4. Every program is a part of some other program and rarely fits.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
72. An adequate bootstrap is a contradiction in terms.
38. Structured Programming supports the law of the excluded middle.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
60. In seeking the unattainable, simplicity only gets in the way.
23. To understand a program you must become both the machine and the program.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
14. In the long run every program becomes rococo - then rubble.
3. Syntactic sugar causes cancer of the semicolon.
43. In software systems, it is often the early bird that makes the worm.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
17. If a listener nods his head when you're explaining your program, wake him up.
115. Most people find the concept of programming obvious, but the doing impossible.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
40. There are two ways to write error-free programs; only the third one works.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
22. A good system can't have a weak command language.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
40. There are two ways to write error-free programs; only the third one works.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
72. An adequate bootstrap is a contradiction in terms.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
59. In English every word can be verbed. Would that it were so in our programming languages.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
3. Syntactic sugar causes cancer of the semicolon.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
105. You can't communicate complexity, only an awareness of it.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
7. It is easier to write an incorrect program than understand a correct one.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
61. In programming, as in everything else, to be in error is to be reborn.
105. You can't communicate complexity, only an awareness of it.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
61. In programming, as in everything else, to be in error is to be reborn.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
76. It is the user who should parameterize procedures, not their creators.
1. One man's constant is another man's variable.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
111. Why did the Roman Empire collapse? What is Latin for office automation?
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
76. It is the user who should parameterize procedures, not their creators.
21. Optimization hinders evolution.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
119. Programming is an unnatural act.
8. A programming language is low level when its programs require attention to the irrelevant.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
104. The proof of a system's value is its existence.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
18. A program without a loop and a structured variable isn't worth writing.
104. The proof of a system's value is its existence.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
102. One can't proceed from the informal to the formal by formal means.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
46. Like punning, programming is a play on words.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
31. Simplicity does not precede complexity, but follows it.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
98. In computing, the mean time to failure keeps getting shorter.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
102. One can't proceed from the informal to the formal by formal means.
100. We will never run out of things to program as long as there is a single program around.
41. Some programming languages manage to absorb change, but withstand progress.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
15. Everything should be built top-down, except the first time.
57. It is easier to change the specification to fit the program than vice versa.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
8. A programming language is low level when its programs require attention to the irrelevant.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
96. Computers don't introduce order anywhere as much as they expose opportunities.
55. A LISP programmer knows the value of everything, but the cost of nothing.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
60. In seeking the unattainable, simplicity only gets in the way.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
17. If a listener nods his head when you're explaining your program, wake him up.
110. Editing is a rewording activity.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
7. It is easier to write an incorrect program than understand a correct one.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
27. Once you understand how to write a program get someone else to write it.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
23. To understand a program you must become both the machine and the program.
7. It is easier to write an incorrect program than understand a correct one.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
105. You can't communicate complexity, only an awareness of it.
18. A program without a loop and a structured variable isn't worth writing.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
62. In computing, invariants are ephemeral.
105. You can't communicate complexity, only an awareness of it.
11. If you have a procedure with ten parameters, you probably missed some.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
112. Computer Science is embarrassed by the computer.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
43. In software systems, it is often the early bird that makes the worm.
90. Computation has made the tree flower.
12. Recursion is the root of computation since it trades description for time.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
112. Computer Science is embarrassed by the computer.
46. Like punning, programming is a play on words.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
12. Recursion is the root of computation since it trades description for time.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
46. Like punning, programming is a play on words.
76. It is the user who should parameterize procedures, not their creators.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
1. One man's constant is another man's variable.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
8. A programming language is low level when its programs require attention to the irrelevant.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
12. Recursion is the root of computation since it trades description for time.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
78. If your computer speaks English, it was probably made in Japan.
95. Don't have good ideas if you aren't willing to be responsible for them.
22. A good system can't have a weak command language.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
21. Optimization hinders evolution.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
95. Don't have good ideas if you aren't willing to be responsible for them.
59. In English every word can be verbed. Would that it were so in our programming languages.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
78. If your computer speaks English, it was probably made in Japan.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
96. Computers don't introduce order anywhere as much as they expose opportunities.
31. Simplicity does not precede complexity, but follows it.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
3. Syntactic sugar causes cancer of the semicolon.
17. If a listener nods his head when you're explaining your program, wake him up.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
4. Every program is a part of some other program and rarely fits.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
1. One man's constant is another man's variable.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
57. It is easier to change the specification to fit the program than vice versa.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
1. One man's constant is another man's variable.
98. In computing, the mean time to failure keeps getting shorter.
96. Computers don't introduce order anywhere as much as they expose opportunities.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
12. Recursion is the root of computation since it trades description for time.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
100. We will never run out of things to program as long as there is a single program around.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
21. Optimization hinders evolution.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
61. In programming, as in everything else, to be in error is to be reborn.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
66. Making something variable is easy. Controlling duration of constancy is the trick.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
21. Optimization hinders evolution.
15. Everything should be built top-down, except the first time.
60. In seeking the unattainable, simplicity only gets in the way.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
112. Computer Science is embarrassed by the computer.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
61. In programming, as in everything else, to be in error is to be reborn.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
55. A LISP programmer knows the value of everything, but the cost of nothing.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
27. Once you understand how to write a program get someone else to write it.
55. A LISP programmer knows the value of everything, but the cost of nothing.
61. In programming, as in everything else, to be in error is to be reborn.
115. Most people find the concept of programming obvious, but the doing impossible.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
40. There are two ways to write error-free programs; only the third one works.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
104. The proof of a system's value is its existence.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
46. Like punning, programming is a play on words.
59. In English every word can be verbed. Would that it were so in our programming languages.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
115. Most people find the concept of programming obvious, but the doing impossible.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
12. Recursion is the root of computation since it trades description for time.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
47. As Will Rogers would have said, "There is no such thing as a free variable."
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
7. It is easier to write an incorrect program than understand a correct one.
105. You can't communicate complexity, only an awareness of it.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
107. The debate rages on: is PL/I Bachtrian or Dromedary?
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
40. There are two ways to write error-free programs; only the third one works.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
100. We will never run out of things to program as long as there is a single program around.
110. Editing is a rewording activity.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
79. A year spent in artificial intelligence is enough to make one believe in God.
96. Computers don't introduce order anywhere as much as they expose opportunities.
46. Like punning, programming is a play on words.
90. Computation has made the tree flower.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
23. To understand a program you must become both the machine and the program.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
4. Every program is a part of some other program and rarely fits.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
57. It is easier to change the specification to fit the program than vice versa.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
4. Every program is a part of some other program and rarely fits.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
98. In computing, the mean time to failure keeps getting shorter.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
114. Within a computer natural language is unnatural.
61. In programming, as in everything else, to be in error is to be reborn.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
78. If your computer speaks English, it was probably made in Japan.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
98. In computing, the mean time to failure keeps getting shorter.
22. A good system can't have a weak command language.
57. It is easier to change the specification to fit the program than vice versa.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
62. In computing, invariants are ephemeral.
76. It is the user who should parameterize procedures, not their creators.
14. In the long run every program becomes rococo - then rubble.
43. In software systems, it is often the early bird that makes the worm.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
12. Recursion is the root of computation since it trades description for time.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
46. Like punning, programming is a play on words.
14. In the long run every program becomes rococo - then rubble.
40. There are two ways to write error-free programs; only the third one works.
40. There are two ways to write error-free programs; only the third one works.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
79. A year spent in artificial intelligence is enough to make one believe in God.
27. Once you understand how to write a program get someone else to write it.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
3. Syntactic sugar causes cancer of the semicolon.
78. If your computer speaks English, it was probably made in Japan.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
11. If you have a procedure with ten parameters, you probably missed some.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
15. Everything should be built top-down, except the first time.
55. A LISP programmer knows the value of everything, but the cost of nothing.
105. You can't communicate complexity, only an awareness of it.
18. A program without a loop and a structured variable isn't worth writing.
108. Whenever two programmers meet to criticize their programs, both are silent.
41. Some programming languages manage to absorb change, but withstand progress.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
112. Computer Science is embarrassed by the computer.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
22. A good system can't have a weak command language.
12. Recursion is the root of computation since it trades description for time.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
115. Most people find the concept of programming obvious, but the doing impossible.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
111. Why did the Roman Empire collapse? What is Latin for office automation?
100. We will never run out of things to program as long as there is a single program around.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
60. In seeking the unattainable, simplicity only gets in the way.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
5. If a program manipulates a large amount of data, it does so in a small number of ways.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
43. In software systems, it is often the early bird that makes the worm.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
60. In seeking the unattainable, simplicity only gets in the way.
66. Making something variable is easy. Controlling duration of constancy is the trick.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
102. One can't proceed from the informal to the formal by formal means.
104. The proof of a system's value is its existence.
108. Whenever two programmers meet to criticize their programs, both are silent.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
4. Every program is a part of some other program and rarely fits.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
115. Most people find the concept of programming obvious, but the doing impossible.
115. Most people find the concept of programming obvious, but the doing impossible.
11. If you have a procedure with ten parameters, you probably missed some.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
105. You can't communicate complexity, only an awareness of it.
21. Optimization hinders evolution.
114. Within a computer natural language is unnatural.
63. When we write programs that "learn", it turns out that we do and they don't.
3. Syntactic sugar causes cancer of the semicolon.
115. Most people find the concept of programming obvious, but the doing impossible.
103. Purely applicative languages are poorly applicable.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
76. It is the user who should parameterize procedures, not their creators.
27. Once you understand how to write a program get someone else to write it.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
79. A year spent in artificial intelligence is enough to make one believe in God.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
76. It is the user who should parameterize procedures, not their creators.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
60. In seeking the unattainable, simplicity only gets in the way.
62. In computing, invariants are ephemeral.
98. In computing, the mean time to failure keeps getting shorter.
62. In computing, invariants are ephemeral.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
18. A program without a loop and a structured variable isn't worth writing.
55. A LISP programmer knows the value of everything, but the cost of nothing.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
46. Like punning, programming is a play on words.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
31. Simplicity does not precede complexity, but follows it.
62. In computing, invariants are ephemeral.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
108. Whenever two programmers meet to criticize their programs, both are silent.
8. A programming language is low level when its programs require attention to the irrelevant.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
7. It is easier to write an incorrect program than understand a correct one.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
72. An adequate bootstrap is a contradiction in terms.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
79. A year spent in artificial intelligence is enough to make one believe in God.
96. Computers don't introduce order anywhere as much as they expose opportunities.
66. Making something variable is easy. Controlling duration of constancy is the trick.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
19. A language that doesn't affect the way you think about programming, is not worth knowing.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
22. A good system can't have a weak command language.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
17. If a listener nods his head when you're explaining your program, wake him up.
17. If a listener nods his head when you're explaining your program, wake him up.
114. Within a computer natural language is unnatural.
17. If a listener nods his head when you're explaining your program, wake him up.
104. The proof of a system's value is its existence.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
78. If your computer speaks English, it was probably made in Japan.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
38. Structured Programming supports the law of the excluded middle.
15. Everything should be built top-down, except the first time.
7. It is easier to write an incorrect program than understand a correct one.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
23. To understand a program you must become both the machine and the program.
108. Whenever two programmers meet to criticize their programs, both are silent.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
98. In computing, the mean time to failure keeps getting shorter.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
60. In seeking the unattainable, simplicity only gets in the way.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
115. Most people find the concept of programming obvious, but the doing impossible.
22. A good system can't have a weak command language.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
114. Within a computer natural language is unnatural.
103. Purely applicative languages are poorly applicable.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
40. There are two ways to write error-free programs; only the third one works.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
43. In software systems, it is often the early bird that makes the worm.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
61. In programming, as in everything else, to be in error is to be reborn.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
76. It is the user who should parameterize procedures, not their creators.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
40. There are two ways to write error-free programs; only the third one works.
108. Whenever two programmers meet to criticize their programs, both are silent.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
95. Don't have good ideas if you aren't willing to be responsible for them.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
102. One can't proceed from the informal to the formal by formal means.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
96. Computers don't introduce order anywhere as much as they expose opportunities.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
31. Simplicity does not precede complexity, but follows it.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
112. Computer Science is embarrassed by the computer.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
105. You can't communicate complexity, only an awareness of it.
78. If your computer speaks English, it was probably made in Japan.
100. We will never run out of things to program as long as there is a single program around.
110. Editing is a rewording activity.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
102. One can't proceed from the informal to the formal by formal means.
15. Everything should be built top-down, except the first time.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
114. Within a computer natural language is unnatural.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
96. Computers don't introduce order anywhere as much as they expose opportunities.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
55. A LISP programmer knows the value of everything, but the cost of nothing.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
110. Editing is a rewording activity.
15. Everything should be built top-down, except the first time.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
66. Making something variable is easy. Controlling duration of constancy is the trick.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
115. Most people find the concept of programming obvious, but the doing impossible.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
1. One man's constant is another man's variable.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
43. In software systems, it is often the early bird that makes the worm.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
1. One man's constant is another man's variable.
57. It is easier to change the specification to fit the program than vice versa.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
76. It is the user who should parameterize procedures, not their creators.
4. Every program is a part of some other program and rarely fits.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
4. Every program is a part of some other program and rarely fits.
17. If a listener nods his head when you're explaining your program, wake him up.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
76. It is the user who should parameterize procedures, not their creators.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
105. You can't communicate complexity, only an awareness of it.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
95. Don't have good ideas if you aren't willing to be responsible for them.
105. You can't communicate complexity, only an awareness of it.
62. In computing, invariants are ephemeral.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
90. Computation has made the tree flower.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
79. A year spent in artificial intelligence is enough to make one believe in God.
66. Making something variable is easy. Controlling duration of constancy is the trick.
22. A good system can't have a weak command language.
95. Don't have good ideas if you aren't willing to be responsible for them.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
8. A programming language is low level when its programs require attention to the irrelevant.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
27. Once you understand how to write a program get someone else to write it.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
115. Most people find the concept of programming obvious, but the doing impossible.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
47. As Will Rogers would have said, "There is no such thing as a free variable."
60. In seeking the unattainable, simplicity only gets in the way.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
112. Computer Science is embarrassed by the computer.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
112. Computer Science is embarrassed by the computer.
62. In computing, invariants are ephemeral.
23. To understand a program you must become both the machine and the program.
55. A LISP programmer knows the value of everything, but the cost of nothing.
40. There are two ways to write error-free programs; only the third one works.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
112. Computer Science is embarrassed by the computer.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
31. Simplicity does not precede complexity, but follows it.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
21. Optimization hinders evolution.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
7. It is easier to write an incorrect program than understand a correct one.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
7. It is easier to write an incorrect program than understand a correct one.
22. A good system can't have a weak command language.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
23. To understand a program you must become both the machine and the program.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
66. Making something variable is easy. Controlling duration of constancy is the trick.
12. Recursion is the root of computation since it trades description for time.
4. Every program is a part of some other program and rarely fits.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
104. The proof of a system's value is its existence.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
112. Computer Science is embarrassed by the computer.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
18. A program without a loop and a structured variable isn't worth writing.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
18. A program without a loop and a structured variable isn't worth writing.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
111. Why did the Roman Empire collapse? What is Latin for office automation?
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
60. In seeking the unattainable, simplicity only gets in the way.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
98. In computing, the mean time to failure keeps getting shorter.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
102. One can't proceed from the informal to the formal by formal means.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
108. Whenever two programmers meet to criticize their programs, both are silent.
55. A LISP programmer knows the value of everything, but the cost of nothing.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
61. In programming, as in everything else, to be in error is to be reborn.
98. In computing, the mean time to failure keeps getting shorter.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
47. As Will Rogers would have said, "There is no such thing as a free variable."
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
40. There are two ways to write error-free programs; only the third one works.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
60. In seeking the unattainable, simplicity only gets in the way.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
119. Programming is an unnatural act.
110. Editing is a rewording activity.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
41. Some programming languages manage to absorb change, but withstand progress.
11. If you have a procedure with ten parameters, you probably missed some.
15. Everything should be built top-down, except the first time.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
102. One can't proceed from the informal to the formal by formal means.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
100. We will never run out of things to program as long as there is a single program around.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
17. If a listener nods his head when you're explaining your program, wake him up.
18. A program without a loop and a structured variable isn't worth writing.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
104. The proof of a system's value is its existence.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
112. Computer Science is embarrassed by the computer.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
66. Making something variable is easy. Controlling duration of constancy is the trick.
14. In the long run every program becomes rococo - then rubble.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
55. A LISP programmer knows the value of everything, but the cost of nothing.
63. When we write programs that "learn", it turns out that we do and they don't.
63. When we write programs that "learn", it turns out that we do and they don't.
119. Programming is an unnatural act.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
95. Don't have good ideas if you aren't willing to be responsible for them.
110. Editing is a rewording activity.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
38. Structured Programming supports the law of the excluded middle.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
55. A LISP programmer knows the value of everything, but the cost of nothing.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
66. Making something variable is easy. Controlling duration of constancy is the trick.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
38. Structured Programming supports the law of the excluded middle.
3. Syntactic sugar causes cancer of the semicolon.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
41. Some programming languages manage to absorb change, but withstand progress.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
100. We will never run out of things to program as long as there is a single program around.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
7. It is easier to write an incorrect program than understand a correct one.
41. Some programming languages manage to absorb change, but withstand progress.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
62. In computing, invariants are ephemeral.
96. Computers don't introduce order anywhere as much as they expose opportunities.
47. As Will Rogers would have said, "There is no such thing as a free variable."
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
4. Every program is a part of some other program and rarely fits.
115. Most people find the concept of programming obvious, but the doing impossible.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
38. Structured Programming supports the law of the excluded middle.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
3. Syntactic sugar causes cancer of the semicolon.
41. Some programming languages manage to absorb change, but withstand progress.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
62. In computing, invariants are ephemeral.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
102. One can't proceed from the informal to the formal by formal means.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
7. It is easier to write an incorrect program than understand a correct one.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
119. Programming is an unnatural act.
60. In seeking the unattainable, simplicity only gets in the way.
31. Simplicity does not precede complexity, but follows it.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
47. As Will Rogers would have said, "There is no such thing as a free variable."
79. A year spent in artificial intelligence is enough to make one believe in God.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
55. A LISP programmer knows the value of everything, but the cost of nothing.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
43. In software systems, it is often the early bird that makes the worm.
66. Making something variable is easy. Controlling duration of constancy is the trick.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
38. Structured Programming supports the law of the excluded middle.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
43. In software systems, it is often the early bird that makes the worm.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
22. A good system can't have a weak command language.
100. We will never run out of things to program as long as there is a single program around.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
12. Recursion is the root of computation since it trades description for time.
8. A programming language is low level when its programs require attention to the irrelevant.
102. One can't proceed from the informal to the formal by formal means.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
55. A LISP programmer knows the value of everything, but the cost of nothing.
60. In seeking the unattainable, simplicity only gets in the way.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
60. In seeking the unattainable, simplicity only gets in the way.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
90. Computation has made the tree flower.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
4. Every program is a part of some other program and rarely fits.
110. Editing is a rewording activity.
103. Purely applicative languages are poorly applicable.
23. To understand a program you must become both the machine and the program.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
111. Why did the Roman Empire collapse? What is Latin for office automation?
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
98. In computing, the mean time to failure keeps getting shorter.
38. Structured Programming supports the law of the excluded middle.
90. Computation has made the tree flower.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
95. Don't have good ideas if you aren't willing to be responsible for them.
17. If a listener nods his head when you're explaining your program, wake him up.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
55. A LISP programmer knows the value of everything, but the cost of nothing.
23. To understand a program you must become both the machine and the program.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
104. The proof of a system's value is its existence.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
1. One man's constant is another man's variable.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
105. You can't communicate complexity, only an awareness of it.
95. Don't have good ideas if you aren't willing to be responsible for them.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
76. It is the user who should parameterize procedures, not their creators.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
27. Once you understand how to write a program get someone else to write it.
31. Simplicity does not precede complexity, but follows it.
114. Within a computer natural language is unnatural.
23. To understand a program you must become both the machine and the program.
112. Computer Science is embarrassed by the computer.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
78. If your computer speaks English, it was probably made in Japan.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
78. If your computer speaks English, it was probably made in Japan.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
114. Within a computer natural language is unnatural.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
31. Simplicity does not precede complexity, but follows it.
114. Within a computer natural language is unnatural.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
100. We will never run out of things to program as long as there is a single program around.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
23. To understand a program you must become both the machine and the program.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
102. One can't proceed from the informal to the formal by formal means.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
98. In computing, the mean time to failure keeps getting shorter.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
114. Within a computer natural language is unnatural.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
4. Every program is a part of some other program and rarely fits.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
1. One man's constant is another man's variable.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
72. An adequate bootstrap is a contradiction in terms.
4. Every program is a part of some other program and rarely fits.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
15. Everything should be built top-down, except the first time.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
98. In computing, the mean time to failure keeps getting shorter.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
66. Making something variable is easy. Controlling duration of constancy is the trick.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
1. One man's constant is another man's variable.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
110. Editing is a rewording activity.
31. Simplicity does not precede complexity, but follows it.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
19. A language that doesn't affect the way you think about programming, is not worth knowing.
17. If a listener nods his head when you're explaining your program, wake him up.
108. Whenever two programmers meet to criticize their programs, both are silent.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
79. A year spent in artificial intelligence is enough to make one believe in God.
62. In computing, invariants are ephemeral.
76. It is the user who should parameterize procedures, not their creators.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
60. In seeking the unattainable, simplicity only gets in the way.
21. Optimization hinders evolution.
11. If you have a procedure with ten parameters, you probably missed some.
4. Every program is a part of some other program and rarely fits.
115. Most people find the concept of programming obvious, but the doing impossible.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
3. Syntactic sugar causes cancer of the semicolon.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
60. In seeking the unattainable, simplicity only gets in the way.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
112. Computer Science is embarrassed by the computer.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
7. It is easier to write an incorrect program than understand a correct one.
95. Don't have good ideas if you aren't willing to be responsible for them.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
40. There are two ways to write error-free programs; only the third one works.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
3. Syntactic sugar causes cancer of the semicolon.
61. In programming, as in everything else, to be in error is to be reborn.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
15. Everything should be built top-down, except the first time.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
112. Computer Science is embarrassed by the computer.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
14. In the long run every program becomes rococo - then rubble.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
17. If a listener nods his head when you're explaining your program, wake him up.
15. Everything should be built top-down, except the first time.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
111. Why did the Roman Empire collapse? What is Latin for office automation?
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
79. A year spent in artificial intelligence is enough to make one believe in God.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
119. Programming is an unnatural act.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
12. Recursion is the root of computation since it trades description for time.
38. Structured Programming supports the law of the excluded middle.
61. In programming, as in everything else, to be in error is to be reborn.
90. Computation has made the tree flower.
114. Within a computer natural language is unnatural.
104. The proof of a system's value is its existence.
31. Simplicity does not precede complexity, but follows it.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
119. Programming is an unnatural act.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
63. When we write programs that "learn", it turns out that we do and they don't.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
17. If a listener nods his head when you're explaining your program, wake him up.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
7. It is easier to write an incorrect program than understand a correct one.
66. Making something variable is easy. Controlling duration of constancy is the trick.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
23. To understand a program you must become both the machine and the program.
7. It is easier to write an incorrect program than understand a correct one.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
61. In programming, as in everything else, to be in error is to be reborn.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
104. The proof of a system's value is its existence.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
108. Whenever two programmers meet to criticize their programs, both are silent.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
43. In software systems, it is often the early bird that makes the worm.
4. Every program is a part of some other program and rarely fits.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
40. There are two ways to write error-free programs; only the third one works.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
76. It is the user who should parameterize procedures, not their creators.
90. Computation has made the tree flower.
108. Whenever two programmers meet to criticize their programs, both are silent.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
41. Some programming languages manage to absorb change, but withstand progress.
90. Computation has made the tree flower.
108. Whenever two programmers meet to criticize their programs, both are silent.
100. We will never run out of things to program as long as there is a single program around.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
7. It is easier to write an incorrect program than understand a correct one.
103. Purely applicative languages are poorly applicable.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
79. A year spent in artificial intelligence is enough to make one believe in God.
27. Once you understand how to write a program get someone else to write it.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
57. It is easier to change the specification to fit the program than vice versa.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
115. Most people find the concept of programming obvious, but the doing impossible.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
112. Computer Science is embarrassed by the computer.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
60. In seeking the unattainable, simplicity only gets in the way.
3. Syntactic sugar causes cancer of the semicolon.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
38. Structured Programming supports the law of the excluded middle.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
41. Some programming languages manage to absorb change, but withstand progress.
55. A LISP programmer knows the value of everything, but the cost of nothing.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
15. Everything should be built top-down, except the first time.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
100. We will never run out of things to program as long as there is a single program around.
15. Everything should be built top-down, except the first time.
55. A LISP programmer knows the value of everything, but the cost of nothing.
72. An adequate bootstrap is a contradiction in terms.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
110. Editing is a rewording activity.
23. To understand a program you must become both the machine and the program.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
46. Like punning, programming is a play on words.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
47. As Will Rogers would have said, "There is no such thing as a free variable."
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
46. Like punning, programming is a play on words.
43. In software systems, it is often the early bird that makes the worm.
108. Whenever two programmers meet to criticize their programs, both are silent.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
41. Some programming languages manage to absorb change, but withstand progress.
62. In computing, invariants are ephemeral.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
96. Computers don't introduce order anywhere as much as they expose opportunities.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
22. A good system can't have a weak command language.
41. Some programming languages manage to absorb change, but withstand progress.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
27. Once you understand how to write a program get someone else to write it.
14. In the long run every program becomes rococo - then rubble.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
3. Syntactic sugar causes cancer of the semicolon.
3. Syntactic sugar causes cancer of the semicolon.
111. Why did the Roman Empire collapse? What is Latin for office automation?
78. If your computer speaks English, it was probably made in Japan.
18. A program without a loop and a structured variable isn't worth writing.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
103. Purely applicative languages are poorly applicable.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
31. Simplicity does not precede complexity, but follows it.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
14. In the long run every program becomes rococo - then rubble.
110. Editing is a rewording activity.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
3. Syntactic sugar causes cancer of the semicolon.
7. It is easier to write an incorrect program than understand a correct one.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
105. You can't communicate complexity, only an awareness of it.
79. A year spent in artificial intelligence is enough to make one believe in God.
78. If your computer speaks English, it was probably made in Japan.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
76. It is the user who should parameterize procedures, not their creators.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
41. Some programming languages manage to absorb change, but withstand progress.
22. A good system can't have a weak command language.
18. A program without a loop and a structured variable isn't worth writing.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
27. Once you understand how to write a program get someone else to write it.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
110. Editing is a rewording activity.
72. An adequate bootstrap is a contradiction in terms.
14. In the long run every program becomes rococo - then rubble.
66. Making something variable is easy. Controlling duration of constancy is the trick.
100. We will never run out of things to program as long as there is a single program around.
66. Making something variable is easy. Controlling duration of constancy is the trick.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
90. Computation has made the tree flower.
18. A program without a loop and a structured variable isn't worth writing.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
110. Editing is a rewording activity.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
60. In seeking the unattainable, simplicity only gets in the way.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
104. The proof of a system's value is its existence.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
17. If a listener nods his head when you're explaining your program, wake him up.
78. If your computer speaks English, it was probably made in Japan.
110. Editing is a rewording activity.
111. Why did the Roman Empire collapse? What is Latin for office automation?
100. We will never run out of things to program as long as there is a single program around.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
105. You can't communicate complexity, only an awareness of it.
114. Within a computer natural language is unnatural.
43. In software systems, it is often the early bird that makes the worm.
17. If a listener nods his head when you're explaining your program, wake him up.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
102. One can't proceed from the informal to the formal by formal means.
23. To understand a program you must become both the machine and the program.
79. A year spent in artificial intelligence is enough to make one believe in God.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
63. When we write programs that "learn", it turns out that we do and they don't.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
78. If your computer speaks English, it was probably made in Japan.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
3. Syntactic sugar causes cancer of the semicolon.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
55. A LISP programmer knows the value of everything, but the cost of nothing.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
47. As Will Rogers would have said, "There is no such thing as a free variable."
47. As Will Rogers would have said, "There is no such thing as a free variable."
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
114. Within a computer natural language is unnatural.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
79. A year spent in artificial intelligence is enough to make one believe in God.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
11. If you have a procedure with ten parameters, you probably missed some.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
95. Don't have good ideas if you aren't willing to be responsible for them.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
41. Some programming languages manage to absorb change, but withstand progress.
98. In computing, the mean time to failure keeps getting shorter.
47. As Will Rogers would have said, "There is no such thing as a free variable."
3. Syntactic sugar causes cancer of the semicolon.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
31. Simplicity does not precede complexity, but follows it.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
79. A year spent in artificial intelligence is enough to make one believe in God.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
72. An adequate bootstrap is a contradiction in terms.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
14. In the long run every program becomes rococo - then rubble.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
3. Syntactic sugar causes cancer of the semicolon.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
23. To understand a program you must become both the machine and the program.
111. Why did the Roman Empire collapse? What is Latin for office automation?
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
90. Computation has made the tree flower.
23. To understand a program you must become both the machine and the program.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
14. In the long run every program becomes rococo - then rubble.
108. Whenever two programmers meet to criticize their programs, both are silent.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
38. Structured Programming supports the law of the excluded middle.
66. Making something variable is easy. Controlling duration of constancy is the trick.
79. A year spent in artificial intelligence is enough to make one believe in God.
38. Structured Programming supports the law of the excluded middle.
100. We will never run out of things to program as long as there is a single program around.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
102. One can't proceed from the informal to the formal by formal means.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
104. The proof of a system's value is its existence.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
11. If you have a procedure with ten parameters, you probably missed some.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
27. Once you understand how to write a program get someone else to write it.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
114. Within a computer natural language is unnatural.
59. In English every word can be verbed. Would that it were so in our programming languages.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
59. In English every word can be verbed. Would that it were so in our programming languages.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
14. In the long run every program becomes rococo - then rubble.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
111. Why did the Roman Empire collapse? What is Latin for office automation?
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
12. Recursion is the root of computation since it trades description for time.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
76. It is the user who should parameterize procedures, not their creators.
4. Every program is a part of some other program and rarely fits.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
105. You can't communicate complexity, only an awareness of it.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
72. An adequate bootstrap is a contradiction in terms.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
104. The proof of a system's value is its existence.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
55. A LISP programmer knows the value of everything, but the cost of nothing.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
40. There are two ways to write error-free programs; only the third one works.
100. We will never run out of things to program as long as there is a single program around.
59. In English every word can be verbed. Would that it were so in our programming languages.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
22. A good system can't have a weak command language.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
1. One man's constant is another man's variable.
114. Within a computer natural language is unnatural.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
103. Purely applicative languages are poorly applicable.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
23. To understand a program you must become both the machine and the program.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
7. It is easier to write an incorrect program than understand a correct one.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
8. A programming language is low level when its programs require attention to the irrelevant.
55. A LISP programmer knows the value of everything, but the cost of nothing.
105. You can't communicate complexity, only an awareness of it.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
59. In English every word can be verbed. Would that it were so in our programming languages.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
60. In seeking the unattainable, simplicity only gets in the way.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
61. In programming, as in everything else, to be in error is to be reborn.
111. Why did the Roman Empire collapse? What is Latin for office automation?
40. There are two ways to write error-free programs; only the third one works.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
4. Every program is a part of some other program and rarely fits.
110. Editing is a rewording activity.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
108. Whenever two programmers meet to criticize their programs, both are silent.
104. The proof of a system's value is its existence.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
1. One man's constant is another man's variable.
78. If your computer speaks English, it was probably made in Japan.
38. Structured Programming supports the law of the excluded middle.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
12. Recursion is the root of computation since it trades description for time.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
79. A year spent in artificial intelligence is enough to make one believe in God.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
47. As Will Rogers would have said, "There is no such thing as a free variable."
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
59. In English every word can be verbed. Would that it were so in our programming languages.
95. Don't have good ideas if you aren't willing to be responsible for them.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
38. Structured Programming supports the law of the excluded middle.
98. In computing, the mean time to failure keeps getting shorter.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
79. A year spent in artificial intelligence is enough to make one believe in God.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
7. It is easier to write an incorrect program than understand a correct one.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
55. A LISP programmer knows the value of everything, but the cost of nothing.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
119. Programming is an unnatural act.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
18. A program without a loop and a structured variable isn't worth writing.
41. Some programming languages manage to absorb change, but withstand progress.
21. Optimization hinders evolution.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
18. A program without a loop and a structured variable isn't worth writing.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
43. In software systems, it is often the early bird that makes the worm.
57. It is easier to change the specification to fit the program than vice versa.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
55. A LISP programmer knows the value of everything, but the cost of nothing.
22. A good system can't have a weak command language.
110. Editing is a rewording activity.
105. You can't communicate complexity, only an awareness of it.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
31. Simplicity does not precede complexity, but follows it.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
103. Purely applicative languages are poorly applicable.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
15. Everything should be built top-down, except the first time.
21. Optimization hinders evolution.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
66. Making something variable is easy. Controlling duration of constancy is the trick.
78. If your computer speaks English, it was probably made in Japan.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
4. Every program is a part of some other program and rarely fits.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
41. Some programming languages manage to absorb change, but withstand progress.
21. Optimization hinders evolution.
23. To understand a program you must become both the machine and the program.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
57. It is easier to change the specification to fit the program than vice versa.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
110. Editing is a rewording activity.
43. In software systems, it is often the early bird that makes the worm.
46. Like punning, programming is a play on words.
110. Editing is a rewording activity.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
4. Every program is a part of some other program and rarely fits.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
41. Some programming languages manage to absorb change, but withstand progress.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
21. Optimization hinders evolution.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
98. In computing, the mean time to failure keeps getting shorter.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
79. A year spent in artificial intelligence is enough to make one believe in God.
1. One man's constant is another man's variable.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
59. In English every word can be verbed. Would that it were so in our programming languages.
22. A good system can't have a weak command language.
114. Within a computer natural language is unnatural.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
4. Every program is a part of some other program and rarely fits.
105. You can't communicate complexity, only an awareness of it.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
111. Why did the Roman Empire collapse? What is Latin for office automation?
41. Some programming languages manage to absorb change, but withstand progress.
38. Structured Programming supports the law of the excluded middle.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
96. Computers don't introduce order anywhere as much as they expose opportunities.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
8. A programming language is low level when its programs require attention to the irrelevant.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
98. In computing, the mean time to failure keeps getting shorter.
63. When we write programs that "learn", it turns out that we do and they don't.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
38. Structured Programming supports the law of the excluded middle.
95. Don't have good ideas if you aren't willing to be responsible for them.
72. An adequate bootstrap is a contradiction in terms.
72. An adequate bootstrap is a contradiction in terms.
4. Every program is a part of some other program and rarely fits.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
31. Simplicity does not precede complexity, but follows it.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
119. Programming is an unnatural act.
110. Editing is a rewording activity.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
22. A good system can't have a weak command language.
27. Once you understand how to write a program get someone else to write it.
8. A programming language is low level when its programs require attention to the irrelevant.
15. Everything should be built top-down, except the first time.
55. A LISP programmer knows the value of everything, but the cost of nothing.
62. In computing, invariants are ephemeral.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
103. Purely applicative languages are poorly applicable.
55. A LISP programmer knows the value of everything, but the cost of nothing.
98. In computing, the mean time to failure keeps getting shorter.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
59. In English every word can be verbed. Would that it were so in our programming languages.
60. In seeking the unattainable, simplicity only gets in the way.
17. If a listener nods his head when you're explaining your program, wake him up.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
60. In seeking the unattainable, simplicity only gets in the way.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
103. Purely applicative languages are poorly applicable.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
41. Some programming languages manage to absorb change, but withstand progress.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
105. You can't communicate complexity, only an awareness of it.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
105. You can't communicate complexity, only an awareness of it.
3. Syntactic sugar causes cancer of the semicolon.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
61. In programming, as in everything else, to be in error is to be reborn.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
104. The proof of a system's value is its existence.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
111. Why did the Roman Empire collapse? What is Latin for office automation?
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
21. Optimization hinders evolution.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
46. Like punning, programming is a play on words.
105. You can't communicate complexity, only an awareness of it.
59. In English every word can be verbed. Would that it were so in our programming languages.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
62. In computing, invariants are ephemeral.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
23. To understand a program you must become both the machine and the program.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
22. A good system can't have a weak command language.
108. Whenever two programmers meet to criticize their programs, both are silent.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
11. If you have a procedure with ten parameters, you probably missed some.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
8. A programming language is low level when its programs require attention to the irrelevant.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
15. Everything should be built top-down, except the first time.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
15. Everything should be built top-down, except the first time.
55. A LISP programmer knows the value of everything, but the cost of nothing.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
18. A program without a loop and a structured variable isn't worth writing.
110. Editing is a rewording activity.
41. Some programming languages manage to absorb change, but withstand progress.
8. A programming language is low level when its programs require attention to the irrelevant.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
11. If you have a procedure with ten parameters, you probably missed some.
119. Programming is an unnatural act.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
43. In software systems, it is often the early bird that makes the worm.
114. Within a computer natural language is unnatural.
78. If your computer speaks English, it was probably made in Japan.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
40. There are two ways to write error-free programs; only the third one works.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
22. A good system can't have a weak command language.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
96. Computers don't introduce order anywhere as much as they expose opportunities.
110. Editing is a rewording activity.
114. Within a computer natural language is unnatural.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
100. We will never run out of things to program as long as there is a single program around.
7. It is easier to write an incorrect program than understand a correct one.
21. Optimization hinders evolution.
23. To understand a program you must become both the machine and the program.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
47. As Will Rogers would have said, "There is no such thing as a free variable."
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
112. Computer Science is embarrassed by the computer.
96. Computers don't introduce order anywhere as much as they expose opportunities.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
103. Purely applicative languages are poorly applicable.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
108. Whenever two programmers meet to criticize their programs, both are silent.
12. Recursion is the root of computation since it trades description for time.
60. In seeking the unattainable, simplicity only gets in the way.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
43. In software systems, it is often the early bird that makes the worm.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
76. It is the user who should parameterize procedures, not their creators.
12. Recursion is the root of computation since it trades description for time.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
55. A LISP programmer knows the value of everything, but the cost of nothing.
17. If a listener nods his head when you're explaining your program, wake him up.
7. It is easier to write an incorrect program than understand a correct one.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
55. A LISP programmer knows the value of everything, but the cost of nothing.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
17. If a listener nods his head when you're explaining your program, wake him up.
112. Computer Science is embarrassed by the computer.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
63. When we write programs that "learn", it turns out that we do and they don't.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
66. Making something variable is easy. Controlling duration of constancy is the trick.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
8. A programming language is low level when its programs require attention to the irrelevant.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
72. An adequate bootstrap is a contradiction in terms.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
22. A good system can't have a weak command language.
38. Structured Programming supports the law of the excluded middle.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
63. When we write programs that "learn", it turns out that we do and they don't.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
114. Within a computer natural language is unnatural.
76. It is the user who should parameterize procedures, not their creators.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
112. Computer Science is embarrassed by the computer.
31. Simplicity does not precede complexity, but follows it.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
115. Most people find the concept of programming obvious, but the doing impossible.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
14. In the long run every program becomes rococo - then rubble.
96. Computers don't introduce order anywhere as much as they expose opportunities.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
104. The proof of a system's value is its existence.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
111. Why did the Roman Empire collapse? What is Latin for office automation?
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
104. The proof of a system's value is its existence.
119. Programming is an unnatural act.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
31. Simplicity does not precede complexity, but follows it.
90. Computation has made the tree flower.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
17. If a listener nods his head when you're explaining your program, wake him up.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
22. A good system can't have a weak command language.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
100. We will never run out of things to program as long as there is a single program around.
12. Recursion is the root of computation since it trades description for time.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
105. You can't communicate complexity, only an awareness of it.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
22. A good system can't have a weak command language.
7. It is easier to write an incorrect program than understand a correct one.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
119. Programming is an unnatural act.
105. You can't communicate complexity, only an awareness of it.
41. Some programming languages manage to absorb change, but withstand progress.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
31. Simplicity does not precede complexity, but follows it.
18. A program without a loop and a structured variable isn't worth writing.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
105. You can't communicate complexity, only an awareness of it.
15. Everything should be built top-down, except the first time.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
18. A program without a loop and a structured variable isn't worth writing.
102. One can't proceed from the informal to the formal by formal means.
105. You can't communicate complexity, only an awareness of it.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
31. Simplicity does not precede complexity, but follows it.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
17. If a listener nods his head when you're explaining your program, wake him up.
102. One can't proceed from the informal to the formal by formal means.
3. Syntactic sugar causes cancer of the semicolon.
108. Whenever two programmers meet to criticize their programs, both are silent.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
105. You can't communicate complexity, only an awareness of it.
103. Purely applicative languages are poorly applicable.
55. A LISP programmer knows the value of everything, but the cost of nothing.
103. Purely applicative languages are poorly applicable.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
59. In English every word can be verbed. Would that it were so in our programming languages.
95. Don't have good ideas if you aren't willing to be responsible for them.
66. Making something variable is easy. Controlling duration of constancy is the trick.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
66. Making something variable is easy. Controlling duration of constancy is the trick.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
1. One man's constant is another man's variable.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
90. Computation has made the tree flower.
17. If a listener nods his head when you're explaining your program, wake him up.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
38. Structured Programming supports the law of the excluded middle.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
100. We will never run out of things to program as long as there is a single program around.
12. Recursion is the root of computation since it trades description for time.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
95. Don't have good ideas if you aren't willing to be responsible for them.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
27. Once you understand how to write a program get someone else to write it.
60. In seeking the unattainable, simplicity only gets in the way.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
102. One can't proceed from the informal to the formal by formal means.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
63. When we write programs that "learn", it turns out that we do and they don't.
55. A LISP programmer knows the value of everything, but the cost of nothing.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
3. Syntactic sugar causes cancer of the semicolon.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
40. There are two ways to write error-free programs; only the third one works.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
108. Whenever two programmers meet to criticize their programs, both are silent.
114. Within a computer natural language is unnatural.
90. Computation has made the tree flower.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
43. In software systems, it is often the early bird that makes the worm.
27. Once you understand how to write a program get someone else to write it.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
7. It is easier to write an incorrect program than understand a correct one.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
41. Some programming languages manage to absorb change, but withstand progress.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
47. As Will Rogers would have said, "There is no such thing as a free variable."
23. To understand a program you must become both the machine and the program.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
1. One man's constant is another man's variable.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
112. Computer Science is embarrassed by the computer.
102. One can't proceed from the informal to the formal by formal means.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
4. Every program is a part of some other program and rarely fits.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
104. The proof of a system's value is its existence.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
3. Syntactic sugar causes cancer of the semicolon.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
18. A program without a loop and a structured variable isn't worth writing.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
61. In programming, as in everything else, to be in error is to be reborn.
18. A program without a loop and a structured variable isn't worth writing.
22. A good system can't have a weak command language.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
31. Simplicity does not precede complexity, but follows it.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
95. Don't have good ideas if you aren't willing to be responsible for them.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
104. The proof of a system's value is its existence.
60. In seeking the unattainable, simplicity only gets in the way.
79. A year spent in artificial intelligence is enough to make one believe in God.
100. We will never run out of things to program as long as there is a single program around.
12. Recursion is the root of computation since it trades description for time.
111. Why did the Roman Empire collapse? What is Latin for office automation?
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
14. In the long run every program becomes rococo - then rubble.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
115. Most people find the concept of programming obvious, but the doing impossible.
119. Programming is an unnatural act.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
112. Computer Science is embarrassed by the computer.
17. If a listener nods his head when you're explaining your program, wake him up.
66. Making something variable is easy. Controlling duration of constancy is the trick.
100. We will never run out of things to program as long as there is a single program around.
8. A programming language is low level when its programs require attention to the irrelevant.
78. If your computer speaks English, it was probably made in Japan.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
104. The proof of a system's value is its existence.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
72. An adequate bootstrap is a contradiction in terms.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
38. Structured Programming supports the law of the excluded middle.
3. Syntactic sugar causes cancer of the semicolon.
111. Why did the Roman Empire collapse? What is Latin for office automation?
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
60. In seeking the unattainable, simplicity only gets in the way.
60. In seeking the unattainable, simplicity only gets in the way.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
105. You can't communicate complexity, only an awareness of it.
43. In software systems, it is often the early bird that makes the worm.
43. In software systems, it is often the early bird that makes the worm.
115. Most people find the concept of programming obvious, but the doing impossible.
112. Computer Science is embarrassed by the computer.
27. Once you understand how to write a program get someone else to write it.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
78. If your computer speaks English, it was probably made in Japan.
8. A programming language is low level when its programs require attention to the irrelevant.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
61. In programming, as in everything else, to be in error is to be reborn.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
55. A LISP programmer knows the value of everything, but the cost of nothing.
47. As Will Rogers would have said, "There is no such thing as a free variable."
19. A language that doesn't affect the way you think about programming, is not worth knowing.
119. Programming is an unnatural act.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
38. Structured Programming supports the law of the excluded middle.
108. Whenever two programmers meet to criticize their programs, both are silent.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
38. Structured Programming supports the law of the excluded middle.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
66. Making something variable is easy. Controlling duration of constancy is the trick.
110. Editing is a rewording activity.
111. Why did the Roman Empire collapse? What is Latin for office automation?
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
22. A good system can't have a weak command language.
55. A LISP programmer knows the value of everything, but the cost of nothing.
43. In software systems, it is often the early bird that makes the worm.
110. Editing is a rewording activity.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
90. Computation has made the tree flower.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
43. In software systems, it is often the early bird that makes the worm.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
103. Purely applicative languages are poorly applicable.
21. Optimization hinders evolution.
3. Syntactic sugar causes cancer of the semicolon.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
47. As Will Rogers would have said, "There is no such thing as a free variable."
96. Computers don't introduce order anywhere as much as they expose opportunities.
7. It is easier to write an incorrect program than understand a correct one.
17. If a listener nods his head when you're explaining your program, wake him up.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
8. A programming language is low level when its programs require attention to the irrelevant.
102. One can't proceed from the informal to the formal by formal means.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
78. If your computer speaks English, it was probably made in Japan.
38. Structured Programming supports the law of the excluded middle.
112. Computer Science is embarrassed by the computer.
112. Computer Science is embarrassed by the computer.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
98. In computing, the mean time to failure keeps getting shorter.
102. One can't proceed from the informal to the formal by formal means.
108. Whenever two programmers meet to criticize their programs, both are silent.
119. Programming is an unnatural act.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
21. Optimization hinders evolution.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
18. A program without a loop and a structured variable isn't worth writing.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
8. A programming language is low level when its programs require attention to the irrelevant.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
96. Computers don't introduce order anywhere as much as they expose opportunities.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
112. Computer Science is embarrassed by the computer.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
96. Computers don't introduce order anywhere as much as they expose opportunities.
11. If you have a procedure with ten parameters, you probably missed some.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
78. If your computer speaks English, it was probably made in Japan.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
8. A programming language is low level when its programs require attention to the irrelevant.
79. A year spent in artificial intelligence is enough to make one believe in God.
41. Some programming languages manage to absorb change, but withstand progress.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
112. Computer Science is embarrassed by the computer.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
96. Computers don't introduce order anywhere as much as they expose opportunities.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
11. If you have a procedure with ten parameters, you probably missed some.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
4. Every program is a part of some other program and rarely fits.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
108. Whenever two programmers meet to criticize their programs, both are silent.
27. Once you understand how to write a program get someone else to write it.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
63. When we write programs that "learn", it turns out that we do and they don't.
114. Within a computer natural language is unnatural.
105. You can't communicate complexity, only an awareness of it.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
15. Everything should be built top-down, except the first time.
63. When we write programs that "learn", it turns out that we do and they don't.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
47. As Will Rogers would have said, "There is no such thing as a free variable."
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
95. Don't have good ideas if you aren't willing to be responsible for them.
15. Everything should be built top-down, except the first time.
78. If your computer speaks English, it was probably made in Japan.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
95. Don't have good ideas if you aren't willing to be responsible for them.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
96. Computers don't introduce order anywhere as much as they expose opportunities.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
96. Computers don't introduce order anywhere as much as they expose opportunities.
112. Computer Science is embarrassed by the computer.
105. You can't communicate complexity, only an awareness of it.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
60. In seeking the unattainable, simplicity only gets in the way.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
31. Simplicity does not precede complexity, but follows it.
119. Programming is an unnatural act.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
72. An adequate bootstrap is a contradiction in terms.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
57. It is easier to change the specification to fit the program than vice versa.
14. In the long run every program becomes rococo - then rubble.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
110. Editing is a rewording activity.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
78. If your computer speaks English, it was probably made in Japan.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
119. Programming is an unnatural act.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
43. In software systems, it is often the early bird that makes the worm.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
59. In English every word can be verbed. Would that it were so in our programming languages.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
102. One can't proceed from the informal to the formal by formal means.
112. Computer Science is embarrassed by the computer.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
96. Computers don't introduce order anywhere as much as they expose opportunities.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
43. In software systems, it is often the early bird that makes the worm.
55. A LISP programmer knows the value of everything, but the cost of nothing.
112. Computer Science is embarrassed by the computer.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
104. The proof of a system's value is its existence.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
103. Purely applicative languages are poorly applicable.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
15. Everything should be built top-down, except the first time.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
57. It is easier to change the specification to fit the program than vice versa.
60. In seeking the unattainable, simplicity only gets in the way.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
103. Purely applicative languages are poorly applicable.
119. Programming is an unnatural act.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
104. The proof of a system's value is its existence.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
17. If a listener nods his head when you're explaining your program, wake him up.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
96. Computers don't introduce order anywhere as much as they expose opportunities.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
18. A program without a loop and a structured variable isn't worth writing.
7. It is easier to write an incorrect program than understand a correct one.
104. The proof of a system's value is its existence.
98. In computing, the mean time to failure keeps getting shorter.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
104. The proof of a system's value is its existence.
40. There are two ways to write error-free programs; only the third one works.
95. Don't have good ideas if you aren't willing to be responsible for them.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
14. In the long run every program becomes rococo - then rubble.
103. Purely applicative languages are poorly applicable.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
78. If your computer speaks English, it was probably made in Japan.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
27. Once you understand how to write a program get someone else to write it.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
115. Most people find the concept of programming obvious, but the doing impossible.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
95. Don't have good ideas if you aren't willing to be responsible for them.
78. If your computer speaks English, it was probably made in Japan.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
7. It is easier to write an incorrect program than understand a correct one.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
66. Making something variable is easy. Controlling duration of constancy is the trick.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
12. Recursion is the root of computation since it trades description for time.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
43. In software systems, it is often the early bird that makes the worm.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
62. In computing, invariants are ephemeral.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
11. If you have a procedure with ten parameters, you probably missed some.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
103. Purely applicative languages are poorly applicable.
40. There are two ways to write error-free programs; only the third one works.
76. It is the user who should parameterize procedures, not their creators.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
79. A year spent in artificial intelligence is enough to make one believe in God.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
18. A program without a loop and a structured variable isn't worth writing.
114. Within a computer natural language is unnatural.
72. An adequate bootstrap is a contradiction in terms.
98. In computing, the mean time to failure keeps getting shorter.
111. Why did the Roman Empire collapse? What is Latin for office automation?
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
55. A LISP programmer knows the value of everything, but the cost of nothing.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
4. Every program is a part of some other program and rarely fits.
55. A LISP programmer knows the value of everything, but the cost of nothing.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
105. You can't communicate complexity, only an awareness of it.
59. In English every word can be verbed. Would that it were so in our programming languages.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
62. In computing, invariants are ephemeral.
8. A programming language is low level when its programs require attention to the irrelevant.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
55. A LISP programmer knows the value of everything, but the cost of nothing.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
63. When we write programs that "learn", it turns out that we do and they don't.
12. Recursion is the root of computation since it trades description for time.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
61. In programming, as in everything else, to be in error is to be reborn.
105. You can't communicate complexity, only an awareness of it.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
102. One can't proceed from the informal to the formal by formal means.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
90. Computation has made the tree flower.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
104. The proof of a system's value is its existence.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
43. In software systems, it is often the early bird that makes the worm.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
57. It is easier to change the specification to fit the program than vice versa.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
21. Optimization hinders evolution.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
27. Once you understand how to write a program get someone else to write it.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
43. In software systems, it is often the early bird that makes the worm.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
96. Computers don't introduce order anywhere as much as they expose opportunities.
60. In seeking the unattainable, simplicity only gets in the way.
8. A programming language is low level when its programs require attention to the irrelevant.
102. One can't proceed from the informal to the formal by formal means.
119. Programming is an unnatural act.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
72. An adequate bootstrap is a contradiction in terms.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
79. A year spent in artificial intelligence is enough to make one believe in God.
31. Simplicity does not precede complexity, but follows it.
46. Like punning, programming is a play on words.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
102. One can't proceed from the informal to the formal by formal means.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
47. As Will Rogers would have said, "There is no such thing as a free variable."
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
4. Every program is a part of some other program and rarely fits.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
98. In computing, the mean time to failure keeps getting shorter.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
4. Every program is a part of some other program and rarely fits.
115. Most people find the concept of programming obvious, but the doing impossible.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
23. To understand a program you must become both the machine and the program.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
79. A year spent in artificial intelligence is enough to make one believe in God.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
38. Structured Programming supports the law of the excluded middle.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
62. In computing, invariants are ephemeral.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
78. If your computer speaks English, it was probably made in Japan.
4. Every program is a part of some other program and rarely fits.
112. Computer Science is embarrassed by the computer.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
115. Most people find the concept of programming obvious, but the doing impossible.
18. A program without a loop and a structured variable isn't worth writing.
78. If your computer speaks English, it was probably made in Japan.
8. A programming language is low level when its programs require attention to the irrelevant.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
23. To understand a program you must become both the machine and the program.
59. In English every word can be verbed. Would that it were so in our programming languages.
7. It is easier to write an incorrect program than understand a correct one.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
102. One can't proceed from the informal to the formal by formal means.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
47. As Will Rogers would have said, "There is no such thing as a free variable."
76. It is the user who should parameterize procedures, not their creators.
15. Everything should be built top-down, except the first time.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
18. A program without a loop and a structured variable isn't worth writing.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
3. Syntactic sugar causes cancer of the semicolon.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
43. In software systems, it is often the early bird that makes the worm.
47. As Will Rogers would have said, "There is no such thing as a free variable."
31. Simplicity does not precede complexity, but follows it.
4. Every program is a part of some other program and rarely fits.
41. Some programming languages manage to absorb change, but withstand progress.
47. As Will Rogers would have said, "There is no such thing as a free variable."
55. A LISP programmer knows the value of everything, but the cost of nothing.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
1. One man's constant is another man's variable.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
27. Once you understand how to write a program get someone else to write it.
79. A year spent in artificial intelligence is enough to make one believe in God.
114. Within a computer natural language is unnatural.
57. It is easier to change the specification to fit the program than vice versa.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
4. Every program is a part of some other program and rarely fits.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
103. Purely applicative languages are poorly applicable.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
96. Computers don't introduce order anywhere as much as they expose opportunities.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
41. Some programming languages manage to absorb change, but withstand progress.
12. Recursion is the root of computation since it trades description for time.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
78. If your computer speaks English, it was probably made in Japan.
96. Computers don't introduce order anywhere as much as they expose opportunities.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
8. A programming language is low level when its programs require attention to the irrelevant.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
1. One man's constant is another man's variable.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
104. The proof of a system's value is its existence.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
21. Optimization hinders evolution.
41. Some programming languages manage to absorb change, but withstand progress.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
115. Most people find the concept of programming obvious, but the doing impossible.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
72. An adequate bootstrap is a contradiction in terms.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
7. It is easier to write an incorrect program than understand a correct one.
46. Like punning, programming is a play on words.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
90. Computation has made the tree flower.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
76. It is the user who should parameterize procedures, not their creators.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
105. You can't communicate complexity, only an awareness of it.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
102. One can't proceed from the informal to the formal by formal means.
21. Optimization hinders evolution.
111. Why did the Roman Empire collapse? What is Latin for office automation?
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
27. Once you understand how to write a program get someone else to write it.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
47. As Will Rogers would have said, "There is no such thing as a free variable."
23. To understand a program you must become both the machine and the program.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
22. A good system can't have a weak command language.
72. An adequate bootstrap is a contradiction in terms.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
98. In computing, the mean time to failure keeps getting shorter.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
119. Programming is an unnatural act.
111. Why did the Roman Empire collapse? What is Latin for office automation?
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
3. Syntactic sugar causes cancer of the semicolon.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
46. Like punning, programming is a play on words.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
102. One can't proceed from the informal to the formal by formal means.
4. Every program is a part of some other program and rarely fits.
108. Whenever two programmers meet to criticize their programs, both are silent.
63. When we write programs that "learn", it turns out that we do and they don't.
98. In computing, the mean time to failure keeps getting shorter.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
95. Don't have good ideas if you aren't willing to be responsible for them.
38. Structured Programming supports the law of the excluded middle.
55. A LISP programmer knows the value of everything, but the cost of nothing.
103. Purely applicative languages are poorly applicable.
31. Simplicity does not precede complexity, but follows it.
63. When we write programs that "learn", it turns out that we do and they don't.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
46. Like punning, programming is a play on words.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
4. Every program is a part of some other program and rarely fits.
38. Structured Programming supports the law of the excluded middle.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
78. If your computer speaks English, it was probably made in Japan.
60. In seeking the unattainable, simplicity only gets in the way.
21. Optimization hinders evolution.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
27. Once you understand how to write a program get someone else to write it.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
17. If a listener nods his head when you're explaining your program, wake him up.
17. If a listener nods his head when you're explaining your program, wake him up.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
79. A year spent in artificial intelligence is enough to make one believe in God.
103. Purely applicative languages are poorly applicable.
11. If you have a procedure with ten parameters, you probably missed some.
66. Making something variable is easy. Controlling duration of constancy is the trick.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
55. A LISP programmer knows the value of everything, but the cost of nothing.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
90. Computation has made the tree flower.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
105. You can't communicate complexity, only an awareness of it.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
104. The proof of a system's value is its existence.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
43. In software systems, it is often the early bird that makes the worm.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
103. Purely applicative languages are poorly applicable.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
55. A LISP programmer knows the value of everything, but the cost of nothing.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
59. In English every word can be verbed. Would that it were so in our programming languages.
103. Purely applicative languages are poorly applicable.
100. We will never run out of things to program as long as there is a single program around.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
119. Programming is an unnatural act.
105. You can't communicate complexity, only an awareness of it.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
59. In English every word can be verbed. Would that it were so in our programming languages.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
90. Computation has made the tree flower.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
3. Syntactic sugar causes cancer of the semicolon.
11. If you have a procedure with ten parameters, you probably missed some.
11. If you have a procedure with ten parameters, you probably missed some.
105. You can't communicate complexity, only an awareness of it.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
31. Simplicity does not precede complexity, but follows it.
95. Don't have good ideas if you aren't willing to be responsible for them.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
27. Once you understand how to write a program get someone else to write it.
3. Syntactic sugar causes cancer of the semicolon.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
78. If your computer speaks English, it was probably made in Japan.
21. Optimization hinders evolution.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
59. In English every word can be verbed. Would that it were so in our programming languages.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
41. Some programming languages manage to absorb change, but withstand progress.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
72. An adequate bootstrap is a contradiction in terms.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
105. You can't communicate complexity, only an awareness of it.
104. The proof of a system's value is its existence.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
104. The proof of a system's value is its existence.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
66. Making something variable is easy. Controlling duration of constancy is the trick.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
111. Why did the Roman Empire collapse? What is Latin for office automation?
40. There are two ways to write error-free programs; only the third one works.
60. In seeking the unattainable, simplicity only gets in the way.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
11. If you have a procedure with ten parameters, you probably missed some.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
57. It is easier to change the specification to fit the program than vice versa.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
105. You can't communicate complexity, only an awareness of it.
43. In software systems, it is often the early bird that makes the worm.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
61. In programming, as in everything else, to be in error is to be reborn.
15. Everything should be built top-down, except the first time.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
1. One man's constant is another man's variable.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
63. When we write programs that "learn", it turns out that we do and they don't.
22. A good system can't have a weak command language.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
119. Programming is an unnatural act.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
104. The proof of a system's value is its existence.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
66. Making something variable is easy. Controlling duration of constancy is the trick.
43. In software systems, it is often the early bird that makes the worm.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
63. When we write programs that "learn", it turns out that we do and they don't.
90. Computation has made the tree flower.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
79. A year spent in artificial intelligence is enough to make one believe in God.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
78. If your computer speaks English, it was probably made in Japan.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
46. Like punning, programming is a play on words.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
8. A programming language is low level when its programs require attention to the irrelevant.
90. Computation has made the tree flower.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
76. It is the user who should parameterize procedures, not their creators.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
27. Once you understand how to write a program get someone else to write it.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
12. Recursion is the root of computation since it trades description for time.
103. Purely applicative languages are poorly applicable.
61. In programming, as in everything else, to be in error is to be reborn.
98. In computing, the mean time to failure keeps getting shorter.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
79. A year spent in artificial intelligence is enough to make one believe in God.
66. Making something variable is easy. Controlling duration of constancy is the trick.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
46. Like punning, programming is a play on words.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
7. It is easier to write an incorrect program than understand a correct one.
78. If your computer speaks English, it was probably made in Japan.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
76. It is the user who should parameterize procedures, not their creators.
104. The proof of a system's value is its existence.
79. A year spent in artificial intelligence is enough to make one believe in God.
8. A programming language is low level when its programs require attention to the irrelevant.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
40. There are two ways to write error-free programs; only the third one works.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
103. Purely applicative languages are poorly applicable.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
66. Making something variable is easy. Controlling duration of constancy is the trick.
61. In programming, as in everything else, to be in error is to be reborn.
11. If you have a procedure with ten parameters, you probably missed some.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
46. Like punning, programming is a play on words.
66. Making something variable is easy. Controlling duration of constancy is the trick.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
112. Computer Science is embarrassed by the computer.
95. Don't have good ideas if you aren't willing to be responsible for them.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
114. Within a computer natural language is unnatural.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
22. A good system can't have a weak command language.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
46. Like punning, programming is a play on words.
14. In the long run every program becomes rococo - then rubble.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
4. Every program is a part of some other program and rarely fits.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
22. A good system can't have a weak command language.
102. One can't proceed from the informal to the formal by formal means.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
105. You can't communicate complexity, only an awareness of it.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
100. We will never run out of things to program as long as there is a single program around.
38. Structured Programming supports the law of the excluded middle.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
111. Why did the Roman Empire collapse? What is Latin for office automation?
21. Optimization hinders evolution.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
22. A good system can't have a weak command language.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
78. If your computer speaks English, it was probably made in Japan.
14. In the long run every program becomes rococo - then rubble.
3. Syntactic sugar causes cancer of the semicolon.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
22. A good system can't have a weak command language.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
72. An adequate bootstrap is a contradiction in terms.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
112. Computer Science is embarrassed by the computer.
114. Within a computer natural language is unnatural.
105. You can't communicate complexity, only an awareness of it.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
98. In computing, the mean time to failure keeps getting shorter.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
102. One can't proceed from the informal to the formal by formal means.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
102. One can't proceed from the informal to the formal by formal means.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
14. In the long run every program becomes rococo - then rubble.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
60. In seeking the unattainable, simplicity only gets in the way.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
79. A year spent in artificial intelligence is enough to make one believe in God.
63. When we write programs that "learn", it turns out that we do and they don't.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
3. Syntactic sugar causes cancer of the semicolon.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
102. One can't proceed from the informal to the formal by formal means.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
115. Most people find the concept of programming obvious, but the doing impossible.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
8. A programming language is low level when its programs require attention to the irrelevant.
103. Purely applicative languages are poorly applicable.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
22. A good system can't have a weak command language.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
3. Syntactic sugar causes cancer of the semicolon.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
100. We will never run out of things to program as long as there is a single program around.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
119. Programming is an unnatural act.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
103. Purely applicative languages are poorly applicable.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
112. Computer Science is embarrassed by the computer.
79. A year spent in artificial intelligence is enough to make one believe in God.
100. We will never run out of things to program as long as there is a single program around.
57. It is easier to change the specification to fit the program than vice versa.
14. In the long run every program becomes rococo - then rubble.
95. Don't have good ideas if you aren't willing to be responsible for them.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
79. A year spent in artificial intelligence is enough to make one believe in God.
22. A good system can't have a weak command language.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
66. Making something variable is easy. Controlling duration of constancy is the trick.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
79. A year spent in artificial intelligence is enough to make one believe in God.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
119. Programming is an unnatural act.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
4. Every program is a part of some other program and rarely fits.
79. A year spent in artificial intelligence is enough to make one believe in God.
31. Simplicity does not precede complexity, but follows it.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
17. If a listener nods his head when you're explaining your program, wake him up.
43. In software systems, it is often the early bird that makes the worm.
40. There are two ways to write error-free programs; only the third one works.
17. If a listener nods his head when you're explaining your program, wake him up.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
105. You can't communicate complexity, only an awareness of it.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
79. A year spent in artificial intelligence is enough to make one believe in God.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
21. Optimization hinders evolution.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
110. Editing is a rewording activity.
61. In programming, as in everything else, to be in error is to be reborn.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
4. Every program is a part of some other program and rarely fits.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
4. Every program is a part of some other program and rarely fits.
79. A year spent in artificial intelligence is enough to make one believe in God.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
95. Don't have good ideas if you aren't willing to be responsible for them.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
104. The proof of a system's value is its existence.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
57. It is easier to change the specification to fit the program than vice versa.
96. Computers don't introduce order anywhere as much as they expose opportunities.
66. Making something variable is easy. Controlling duration of constancy is the trick.
8. A programming language is low level when its programs require attention to the irrelevant.
61. In programming, as in everything else, to be in error is to be reborn.
12. Recursion is the root of computation since it trades description for time.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
11. If you have a procedure with ten parameters, you probably missed some.
4. Every program is a part of some other program and rarely fits.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
22. A good system can't have a weak command language.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
103. Purely applicative languages are poorly applicable.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
79. A year spent in artificial intelligence is enough to make one believe in God.
76. It is the user who should parameterize procedures, not their creators.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
79. A year spent in artificial intelligence is enough to make one believe in God.
41. Some programming languages manage to absorb change, but withstand progress.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
46. Like punning, programming is a play on words.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
114. Within a computer natural language is unnatural.
7. It is easier to write an incorrect program than understand a correct one.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
17. If a listener nods his head when you're explaining your program, wake him up.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
114. Within a computer natural language is unnatural.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
104. The proof of a system's value is its existence.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
15. Everything should be built top-down, except the first time.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
31. Simplicity does not precede complexity, but follows it.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
31. Simplicity does not precede complexity, but follows it.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
59. In English every word can be verbed. Would that it were so in our programming languages.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
110. Editing is a rewording activity.
46. Like punning, programming is a play on words.
96. Computers don't introduce order anywhere as much as they expose opportunities.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
38. Structured Programming supports the law of the excluded middle.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
40. There are two ways to write error-free programs; only the third one works.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
17. If a listener nods his head when you're explaining your program, wake him up.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
61. In programming, as in everything else, to be in error is to be reborn.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
17. If a listener nods his head when you're explaining your program, wake him up.
15. Everything should be built top-down, except the first time.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
98. In computing, the mean time to failure keeps getting shorter.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
111. Why did the Roman Empire collapse? What is Latin for office automation?
72. An adequate bootstrap is a contradiction in terms.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
18. A program without a loop and a structured variable isn't worth writing.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
43. In software systems, it is often the early bird that makes the worm.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
104. The proof of a system's value is its existence.
98. In computing, the mean time to failure keeps getting shorter.
46. Like punning, programming is a play on words.
17. If a listener nods his head when you're explaining your program, wake him up.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
47. As Will Rogers would have said, "There is no such thing as a free variable."
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
90. Computation has made the tree flower.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
17. If a listener nods his head when you're explaining your program, wake him up.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
23. To understand a program you must become both the machine and the program.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
27. Once you understand how to write a program get someone else to write it.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
22. A good system can't have a weak command language.
59. In English every word can be verbed. Would that it were so in our programming languages.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
46. Like punning, programming is a play on words.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
114. Within a computer natural language is unnatural.
96. Computers don't introduce order anywhere as much as they expose opportunities.
23. To understand a program you must become both the machine and the program.
27. Once you understand how to write a program get someone else to write it.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
108. Whenever two programmers meet to criticize their programs, both are silent.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
61. In programming, as in everything else, to be in error is to be reborn.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
112. Computer Science is embarrassed by the computer.
103. Purely applicative languages are poorly applicable.
18. A program without a loop and a structured variable isn't worth writing.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
79. A year spent in artificial intelligence is enough to make one believe in God.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
15. Everything should be built top-down, except the first time.
14. In the long run every program becomes rococo - then rubble.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
98. In computing, the mean time to failure keeps getting shorter.
3. Syntactic sugar causes cancer of the semicolon.
46. Like punning, programming is a play on words.
114. Within a computer natural language is unnatural.
22. A good system can't have a weak command language.
95. Don't have good ideas if you aren't willing to be responsible for them.
57. It is easier to change the specification to fit the program than vice versa.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
119. Programming is an unnatural act.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
46. Like punning, programming is a play on words.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
111. Why did the Roman Empire collapse? What is Latin for office automation?
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
57. It is easier to change the specification to fit the program than vice versa.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
61. In programming, as in everything else, to be in error is to be reborn.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
72. An adequate bootstrap is a contradiction in terms.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
78. If your computer speaks English, it was probably made in Japan.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
27. Once you understand how to write a program get someone else to write it.
100. We will never run out of things to program as long as there is a single program around.
38. Structured Programming supports the law of the excluded middle.
23. To understand a program you must become both the machine and the program.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
115. Most people find the concept of programming obvious, but the doing impossible.
114. Within a computer natural language is unnatural.
111. Why did the Roman Empire collapse? What is Latin for office automation?
78. If your computer speaks English, it was probably made in Japan.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
119. Programming is an unnatural act.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
21. Optimization hinders evolution.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
63. When we write programs that "learn", it turns out that we do and they don't.
104. The proof of a system's value is its existence.
27. Once you understand how to write a program get someone else to write it.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
38. Structured Programming supports the law of the excluded middle.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
11. If you have a procedure with ten parameters, you probably missed some.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
11. If you have a procedure with ten parameters, you probably missed some.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
23. To understand a program you must become both the machine and the program.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
31. Simplicity does not precede complexity, but follows it.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
5. If a program manipulates a large amount of data, it does so in a small number of ways.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
100. We will never run out of things to program as long as there is a single program around.
79. A year spent in artificial intelligence is enough to make one believe in God.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
115. Most people find the concept of programming obvious, but the doing impossible.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
55. A LISP programmer knows the value of everything, but the cost of nothing.
12. Recursion is the root of computation since it trades description for time.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
41. Some programming languages manage to absorb change, but withstand progress.
47. As Will Rogers would have said, "There is no such thing as a free variable."
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
3. Syntactic sugar causes cancer of the semicolon.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
119. Programming is an unnatural act.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
15. Everything should be built top-down, except the first time.
60. In seeking the unattainable, simplicity only gets in the way.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
103. Purely applicative languages are poorly applicable.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
22. A good system can't have a weak command language.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
41. Some programming languages manage to absorb change, but withstand progress.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
102. One can't proceed from the informal to the formal by formal means.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
3. Syntactic sugar causes cancer of the semicolon.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
110. Editing is a rewording activity.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
57. It is easier to change the specification to fit the program than vice versa.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
66. Making something variable is easy. Controlling duration of constancy is the trick.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
55. A LISP programmer knows the value of everything, but the cost of nothing.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
115. Most people find the concept of programming obvious, but the doing impossible.
119. Programming is an unnatural act.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
96. Computers don't introduce order anywhere as much as they expose opportunities.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
63. When we write programs that "learn", it turns out that we do and they don't.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
3. Syntactic sugar causes cancer of the semicolon.
66. Making something variable is easy. Controlling duration of constancy is the trick.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
46. Like punning, programming is a play on words.
95. Don't have good ideas if you aren't willing to be responsible for them.
23. To understand a program you must become both the machine and the program.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
14. In the long run every program becomes rococo - then rubble.
46. Like punning, programming is a play on words.
61. In programming, as in everything else, to be in error is to be reborn.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
18. A program without a loop and a structured variable isn't worth writing.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
46. Like punning, programming is a play on words.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
15. Everything should be built top-down, except the first time.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
115. Most people find the concept of programming obvious, but the doing impossible.
59. In English every word can be verbed. Would that it were so in our programming languages.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
95. Don't have good ideas if you aren't willing to be responsible for them.
78. If your computer speaks English, it was probably made in Japan.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
47. As Will Rogers would have said, "There is no such thing as a free variable."
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
78. If your computer speaks English, it was probably made in Japan.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
18. A program without a loop and a structured variable isn't worth writing.
18. A program without a loop and a structured variable isn't worth writing.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
90. Computation has made the tree flower.
21. Optimization hinders evolution.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
40. There are two ways to write error-free programs; only the third one works.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
41. Some programming languages manage to absorb change, but withstand progress.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
98. In computing, the mean time to failure keeps getting shorter.
100. We will never run out of things to program as long as there is a single program around.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
3. Syntactic sugar causes cancer of the semicolon.
112. Computer Science is embarrassed by the computer.
59. In English every word can be verbed. Would that it were so in our programming languages.
103. Purely applicative languages are poorly applicable.
102. One can't proceed from the informal to the formal by formal means.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
22. A good system can't have a weak command language.
61. In programming, as in everything else, to be in error is to be reborn.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
110. Editing is a rewording activity.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
23. To understand a program you must become both the machine and the program.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
105. You can't communicate complexity, only an awareness of it.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
18. A program without a loop and a structured variable isn't worth writing.
96. Computers don't introduce order anywhere as much as they expose opportunities.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
102. One can't proceed from the informal to the formal by formal means.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
98. In computing, the mean time to failure keeps getting shorter.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
46. Like punning, programming is a play on words.
102. One can't proceed from the informal to the formal by formal means.
31. Simplicity does not precede complexity, but follows it.
21. Optimization hinders evolution.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
100. We will never run out of things to program as long as there is a single program around.
17. If a listener nods his head when you're explaining your program, wake him up.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
46. Like punning, programming is a play on words.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
98. In computing, the mean time to failure keeps getting shorter.
104. The proof of a system's value is its existence.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
7. It is easier to write an incorrect program than understand a correct one.
105. You can't communicate complexity, only an awareness of it.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
31. Simplicity does not precede complexity, but follows it.
14. In the long run every program becomes rococo - then rubble.
4. Every program is a part of some other program and rarely fits.
112. Computer Science is embarrassed by the computer.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
96. Computers don't introduce order anywhere as much as they expose opportunities.
57. It is easier to change the specification to fit the program than vice versa.
78. If your computer speaks English, it was probably made in Japan.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
104. The proof of a system's value is its existence.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
14. In the long run every program becomes rococo - then rubble.
31. Simplicity does not precede complexity, but follows it.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
11. If you have a procedure with ten parameters, you probably missed some.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
4. Every program is a part of some other program and rarely fits.
119. Programming is an unnatural act.
108. Whenever two programmers meet to criticize their programs, both are silent.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
108. Whenever two programmers meet to criticize their programs, both are silent.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
114. Within a computer natural language is unnatural.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
22. A good system can't have a weak command language.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
40. There are two ways to write error-free programs; only the third one works.
100. We will never run out of things to program as long as there is a single program around.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
76. It is the user who should parameterize procedures, not their creators.
8. A programming language is low level when its programs require attention to the irrelevant.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
72. An adequate bootstrap is a contradiction in terms.
40. There are two ways to write error-free programs; only the third one works.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
55. A LISP programmer knows the value of everything, but the cost of nothing.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
102. One can't proceed from the informal to the formal by formal means.
43. In software systems, it is often the early bird that makes the worm.
78. If your computer speaks English, it was probably made in Japan.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
22. A good system can't have a weak command language.
112. Computer Science is embarrassed by the computer.
114. Within a computer natural language is unnatural.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
3. Syntactic sugar causes cancer of the semicolon.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
18. A program without a loop and a structured variable isn't worth writing.
98. In computing, the mean time to failure keeps getting shorter.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
17. If a listener nods his head when you're explaining your program, wake him up.
62. In computing, invariants are ephemeral.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
62. In computing, invariants are ephemeral.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
12. Recursion is the root of computation since it trades description for time.
102. One can't proceed from the informal to the formal by formal means.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
12. Recursion is the root of computation since it trades description for time.
43. In software systems, it is often the early bird that makes the worm.
4. Every program is a part of some other program and rarely fits.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
115. Most people find the concept of programming obvious, but the doing impossible.
111. Why did the Roman Empire collapse? What is Latin for office automation?
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
23. To understand a program you must become both the machine and the program.
114. Within a computer natural language is unnatural.
40. There are two ways to write error-free programs; only the third one works.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
47. As Will Rogers would have said, "There is no such thing as a free variable."
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
27. Once you understand how to write a program get someone else to write it.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
40. There are two ways to write error-free programs; only the third one works.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
60. In seeking the unattainable, simplicity only gets in the way.
1. One man's constant is another man's variable.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
41. Some programming languages manage to absorb change, but withstand progress.
38. Structured Programming supports the law of the excluded middle.
95. Don't have good ideas if you aren't willing to be responsible for them.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
61. In programming, as in everything else, to be in error is to be reborn.
4. Every program is a part of some other program and rarely fits.
108. Whenever two programmers meet to criticize their programs, both are silent.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
61. In programming, as in everything else, to be in error is to be reborn.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
108. Whenever two programmers meet to criticize their programs, both are silent.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
15. Everything should be built top-down, except the first time.
15. Everything should be built top-down, except the first time.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
43. In software systems, it is often the early bird that makes the worm.
23. To understand a program you must become both the machine and the program.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
63. When we write programs that "learn", it turns out that we do and they don't.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
61. In programming, as in everything else, to be in error is to be reborn.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
60. In seeking the unattainable, simplicity only gets in the way.
15. Everything should be built top-down, except the first time.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
119. Programming is an unnatural act.
78. If your computer speaks English, it was probably made in Japan.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
62. In computing, invariants are ephemeral.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
59. In English every word can be verbed. Would that it were so in our programming languages.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
72. An adequate bootstrap is a contradiction in terms.
110. Editing is a rewording activity.
119. Programming is an unnatural act.
23. To understand a program you must become both the machine and the program.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
108. Whenever two programmers meet to criticize their programs, both are silent.
103. Purely applicative languages are poorly applicable.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
46. Like punning, programming is a play on words.
78. If your computer speaks English, it was probably made in Japan.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
66. Making something variable is easy. Controlling duration of constancy is the trick.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
3. Syntactic sugar causes cancer of the semicolon.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
47. As Will Rogers would have said, "There is no such thing as a free variable."
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
17. If a listener nods his head when you're explaining your program, wake him up.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
119. Programming is an unnatural act.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
108. Whenever two programmers meet to criticize their programs, both are silent.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
108. Whenever two programmers meet to criticize their programs, both are silent.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
72. An adequate bootstrap is a contradiction in terms.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
62. In computing, invariants are ephemeral.
23. To understand a program you must become both the machine and the program.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
115. Most people find the concept of programming obvious, but the doing impossible.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
66. Making something variable is easy. Controlling duration of constancy is the trick.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
21. Optimization hinders evolution.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
46. Like punning, programming is a play on words.
7. It is easier to write an incorrect program than understand a correct one.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
47. As Will Rogers would have said, "There is no such thing as a free variable."
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
3. Syntactic sugar causes cancer of the semicolon.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
110. Editing is a rewording activity.
72. An adequate bootstrap is a contradiction in terms.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
102. One can't proceed from the informal to the formal by formal means.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
21. Optimization hinders evolution.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
78. If your computer speaks English, it was probably made in Japan.
23. To understand a program you must become both the machine and the program.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
14. In the long run every program becomes rococo - then rubble.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
63. When we write programs that "learn", it turns out that we do and they don't.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
47. As Will Rogers would have said, "There is no such thing as a free variable."
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
18. A program without a loop and a structured variable isn't worth writing.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
111. Why did the Roman Empire collapse? What is Latin for office automation?
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
61. In programming, as in everything else, to be in error is to be reborn.
110. Editing is a rewording activity.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
3. Syntactic sugar causes cancer of the semicolon.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
57. It is easier to change the specification to fit the program than vice versa.
72. An adequate bootstrap is a contradiction in terms.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
46. Like punning, programming is a play on words.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
1. One man's constant is another man's variable.
4. Every program is a part of some other program and rarely fits.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
78. If your computer speaks English, it was probably made in Japan.
23. To understand a program you must become both the machine and the program.
1. One man's constant is another man's variable.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
60. In seeking the unattainable, simplicity only gets in the way.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
79. A year spent in artificial intelligence is enough to make one believe in God.
111. Why did the Roman Empire collapse? What is Latin for office automation?
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
110. Editing is a rewording activity.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
95. Don't have good ideas if you aren't willing to be responsible for them.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
11. If you have a procedure with ten parameters, you probably missed some.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
22. A good system can't have a weak command language.
90. Computation has made the tree flower.
31. Simplicity does not precede complexity, but follows it.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
61. In programming, as in everything else, to be in error is to be reborn.
76. It is the user who should parameterize procedures, not their creators.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
103. Purely applicative languages are poorly applicable.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
1. One man's constant is another man's variable.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
22. A good system can't have a weak command language.
76. It is the user who should parameterize procedures, not their creators.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
95. Don't have good ideas if you aren't willing to be responsible for them.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
46. Like punning, programming is a play on words.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
59. In English every word can be verbed. Would that it were so in our programming languages.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
43. In software systems, it is often the early bird that makes the worm.
115. Most people find the concept of programming obvious, but the doing impossible.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
8. A programming language is low level when its programs require attention to the irrelevant.
79. A year spent in artificial intelligence is enough to make one believe in God.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
55. A LISP programmer knows the value of everything, but the cost of nothing.
11. If you have a procedure with ten parameters, you probably missed some.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
23. To understand a program you must become both the machine and the program.
62. In computing, invariants are ephemeral.
105. You can't communicate complexity, only an awareness of it.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
47. As Will Rogers would have said, "There is no such thing as a free variable."
14. In the long run every program becomes rococo - then rubble.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
7. It is easier to write an incorrect program than understand a correct one.
103. Purely applicative languages are poorly applicable.
38. Structured Programming supports the law of the excluded middle.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
119. Programming is an unnatural act.
104. The proof of a system's value is its existence.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
111. Why did the Roman Empire collapse? What is Latin for office automation?
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
108. Whenever two programmers meet to criticize their programs, both are silent.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
98. In computing, the mean time to failure keeps getting shorter.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
38. Structured Programming supports the law of the excluded middle.
119. Programming is an unnatural act.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
114. Within a computer natural language is unnatural.
60. In seeking the unattainable, simplicity only gets in the way.
79. A year spent in artificial intelligence is enough to make one believe in God.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
102. One can't proceed from the informal to the formal by formal means.
96. Computers don't introduce order anywhere as much as they expose opportunities.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
21. Optimization hinders evolution.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
57. It is easier to change the specification to fit the program than vice versa.
15. Everything should be built top-down, except the first time.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
78. If your computer speaks English, it was probably made in Japan.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
63. When we write programs that "learn", it turns out that we do and they don't.
72. An adequate bootstrap is a contradiction in terms.
41. Some programming languages manage to absorb change, but withstand progress.
105. You can't communicate complexity, only an awareness of it.
112. Computer Science is embarrassed by the computer.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
78. If your computer speaks English, it was probably made in Japan.
12. Recursion is the root of computation since it trades description for time.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
62. In computing, invariants are ephemeral.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
105. You can't communicate complexity, only an awareness of it.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
12. Recursion is the root of computation since it trades description for time.
46. Like punning, programming is a play on words.
40. There are two ways to write error-free programs; only the third one works.
112. Computer Science is embarrassed by the computer.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
14. In the long run every program becomes rococo - then rubble.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
31. Simplicity does not precede complexity, but follows it.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
11. If you have a procedure with ten parameters, you probably missed some.
110. Editing is a rewording activity.
21. Optimization hinders evolution.
18. A program without a loop and a structured variable isn't worth writing.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
23. To understand a program you must become both the machine and the program.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
60. In seeking the unattainable, simplicity only gets in the way.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
103. Purely applicative languages are poorly applicable.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
11. If you have a procedure with ten parameters, you probably missed some.
95. Don't have good ideas if you aren't willing to be responsible for them.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
100. We will never run out of things to program as long as there is a single program around.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
14. In the long run every program becomes rococo - then rubble.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
103. Purely applicative languages are poorly applicable.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
110. Editing is a rewording activity.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
46. Like punning, programming is a play on words.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
43. In software systems, it is often the early bird that makes the worm.
103. Purely applicative languages are poorly applicable.
76. It is the user who should parameterize procedures, not their creators.
12. Recursion is the root of computation since it trades description for time.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
19. A language that doesn't affect the way you think about programming, is not worth knowing.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
103. Purely applicative languages are poorly applicable.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
102. One can't proceed from the informal to the formal by formal means.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
96. Computers don't introduce order anywhere as much as they expose opportunities.
61. In programming, as in everything else, to be in error is to be reborn.
46. Like punning, programming is a play on words.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
18. A program without a loop and a structured variable isn't worth writing.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
38. Structured Programming supports the law of the excluded middle.
7. It is easier to write an incorrect program than understand a correct one.
61. In programming, as in everything else, to be in error is to be reborn.
63. When we write programs that "learn", it turns out that we do and they don't.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
38. Structured Programming supports the law of the excluded middle.
90. Computation has made the tree flower.
23. To understand a program you must become both the machine and the program.
105. You can't communicate complexity, only an awareness of it.
7. It is easier to write an incorrect program than understand a correct one.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
61. In programming, as in everything else, to be in error is to be reborn.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
100. We will never run out of things to program as long as there is a single program around.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
18. A program without a loop and a structured variable isn't worth writing.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
90. Computation has made the tree flower.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
15. Everything should be built top-down, except the first time.
23. To understand a program you must become both the machine and the program.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
40. There are two ways to write error-free programs; only the third one works.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
21. Optimization hinders evolution.
17. If a listener nods his head when you're explaining your program, wake him up.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
59. In English every word can be verbed. Would that it were so in our programming languages.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
18. A program without a loop and a structured variable isn't worth writing.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
76. It is the user who should parameterize procedures, not their creators.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
27. Once you understand how to write a program get someone else to write it.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
23. To understand a program you must become both the machine and the program.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
98. In computing, the mean time to failure keeps getting shorter.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
119. Programming is an unnatural act.
11. If you have a procedure with ten parameters, you probably missed some.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
72. An adequate bootstrap is a contradiction in terms.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
31. Simplicity does not precede complexity, but follows it.
21. Optimization hinders evolution.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
78. If your computer speaks English, it was probably made in Japan.
40. There are two ways to write error-free programs; only the third one works.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
23. To understand a program you must become both the machine and the program.
98. In computing, the mean time to failure keeps getting shorter.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
3. Syntactic sugar causes cancer of the semicolon.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
7. It is easier to write an incorrect program than understand a correct one.
47. As Will Rogers would have said, "There is no such thing as a free variable."
110. Editing is a rewording activity.
21. Optimization hinders evolution.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
103. Purely applicative languages are poorly applicable.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
78. If your computer speaks English, it was probably made in Japan.
111. Why did the Roman Empire collapse? What is Latin for office automation?
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
95. Don't have good ideas if you aren't willing to be responsible for them.
47. As Will Rogers would have said, "There is no such thing as a free variable."
38. Structured Programming supports the law of the excluded middle.
46. Like punning, programming is a play on words.
103. Purely applicative languages are poorly applicable.
14. In the long run every program becomes rococo - then rubble.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
105. You can't communicate complexity, only an awareness of it.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
43. In software systems, it is often the early bird that makes the worm.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
38. Structured Programming supports the law of the excluded middle.
22. A good system can't have a weak command language.
1. One man's constant is another man's variable.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
1. One man's constant is another man's variable.
46. Like punning, programming is a play on words.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
55. A LISP programmer knows the value of everything, but the cost of nothing.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
40. There are two ways to write error-free programs; only the third one works.
17. If a listener nods his head when you're explaining your program, wake him up.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
111. Why did the Roman Empire collapse? What is Latin for office automation?
57. It is easier to change the specification to fit the program than vice versa.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
63. When we write programs that "learn", it turns out that we do and they don't.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
15. Everything should be built top-down, except the first time.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
61. In programming, as in everything else, to be in error is to be reborn.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
59. In English every word can be verbed. Would that it were so in our programming languages.
66. Making something variable is easy. Controlling duration of constancy is the trick.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
43. In software systems, it is often the early bird that makes the worm.
46. Like punning, programming is a play on words.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
61. In programming, as in everything else, to be in error is to be reborn.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
78. If your computer speaks English, it was probably made in Japan.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
14. In the long run every program becomes rococo - then rubble.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
60. In seeking the unattainable, simplicity only gets in the way.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
100. We will never run out of things to program as long as there is a single program around.
8. A programming language is low level when its programs require attention to the irrelevant.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
63. When we write programs that "learn", it turns out that we do and they don't.
119. Programming is an unnatural act.
4. Every program is a part of some other program and rarely fits.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
108. Whenever two programmers meet to criticize their programs, both are silent.
61. In programming, as in everything else, to be in error is to be reborn.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
47. As Will Rogers would have said, "There is no such thing as a free variable."
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
90. Computation has made the tree flower.
105. You can't communicate complexity, only an awareness of it.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
3. Syntactic sugar causes cancer of the semicolon.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
21. Optimization hinders evolution.
103. Purely applicative languages are poorly applicable.
3. Syntactic sugar causes cancer of the semicolon.
79. A year spent in artificial intelligence is enough to make one believe in God.
4. Every program is a part of some other program and rarely fits.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
18. A program without a loop and a structured variable isn't worth writing.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
57. It is easier to change the specification to fit the program than vice versa.
1. One man's constant is another man's variable.
41. Some programming languages manage to absorb change, but withstand progress.
41. Some programming languages manage to absorb change, but withstand progress.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
78. If your computer speaks English, it was probably made in Japan.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
41. Some programming languages manage to absorb change, but withstand progress.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
47. As Will Rogers would have said, "There is no such thing as a free variable."
46. Like punning, programming is a play on words.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
66. Making something variable is easy. Controlling duration of constancy is the trick.
59. In English every word can be verbed. Would that it were so in our programming languages.
21. Optimization hinders evolution.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
11. If you have a procedure with ten parameters, you probably missed some.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
55. A LISP programmer knows the value of everything, but the cost of nothing.
31. Simplicity does not precede complexity, but follows it.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
57. It is easier to change the specification to fit the program than vice versa.
78. If your computer speaks English, it was probably made in Japan.
103. Purely applicative languages are poorly applicable.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
103. Purely applicative languages are poorly applicable.
100. We will never run out of things to program as long as there is a single program around.
4. Every program is a part of some other program and rarely fits.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
41. Some programming languages manage to absorb change, but withstand progress.
110. Editing is a rewording activity.
115. Most people find the concept of programming obvious, but the doing impossible.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
15. Everything should be built top-down, except the first time.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
102. One can't proceed from the informal to the formal by formal means.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
4. Every program is a part of some other program and rarely fits.
7. It is easier to write an incorrect program than understand a correct one.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
8. A programming language is low level when its programs require attention to the irrelevant.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
76. It is the user who should parameterize procedures, not their creators.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
11. If you have a procedure with ten parameters, you probably missed some.
3. Syntactic sugar causes cancer of the semicolon.
96. Computers don't introduce order anywhere as much as they expose opportunities.
103. Purely applicative languages are poorly applicable.
1. One man's constant is another man's variable.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
17. If a listener nods his head when you're explaining your program, wake him up.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
55. A LISP programmer knows the value of everything, but the cost of nothing.
119. Programming is an unnatural act.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
12. Recursion is the root of computation since it trades description for time.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
62. In computing, invariants are ephemeral.
46. Like punning, programming is a play on words.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
46. Like punning, programming is a play on words.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
57. It is easier to change the specification to fit the program than vice versa.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
11. If you have a procedure with ten parameters, you probably missed some.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
90. Computation has made the tree flower.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
103. Purely applicative languages are poorly applicable.
102. One can't proceed from the informal to the formal by formal means.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
41. Some programming languages manage to absorb change, but withstand progress.
78. If your computer speaks English, it was probably made in Japan.
95. Don't have good ideas if you aren't willing to be responsible for them.
96. Computers don't introduce order anywhere as much as they expose opportunities.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
98. In computing, the mean time to failure keeps getting shorter.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
55. A LISP programmer knows the value of everything, but the cost of nothing.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
47. As Will Rogers would have said, "There is no such thing as a free variable."
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
27. Once you understand how to write a program get someone else to write it.
17. If a listener nods his head when you're explaining your program, wake him up.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
27. Once you understand how to write a program get someone else to write it.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
7. It is easier to write an incorrect program than understand a correct one.
59. In English every word can be verbed. Would that it were so in our programming languages.
14. In the long run every program becomes rococo - then rubble.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
112. Computer Science is embarrassed by the computer.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
72. An adequate bootstrap is a contradiction in terms.
59. In English every word can be verbed. Would that it were so in our programming languages.
112. Computer Science is embarrassed by the computer.
7. It is easier to write an incorrect program than understand a correct one.
111. Why did the Roman Empire collapse? What is Latin for office automation?
100. We will never run out of things to program as long as there is a single program around.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
61. In programming, as in everything else, to be in error is to be reborn.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
17. If a listener nods his head when you're explaining your program, wake him up.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
14. In the long run every program becomes rococo - then rubble.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
63. When we write programs that "learn", it turns out that we do and they don't.
47. As Will Rogers would have said, "There is no such thing as a free variable."
57. It is easier to change the specification to fit the program than vice versa.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
108. Whenever two programmers meet to criticize their programs, both are silent.
3. Syntactic sugar causes cancer of the semicolon.
98. In computing, the mean time to failure keeps getting shorter.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
78. If your computer speaks English, it was probably made in Japan.
100. We will never run out of things to program as long as there is a single program around.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
100. We will never run out of things to program as long as there is a single program around.
46. Like punning, programming is a play on words.
111. Why did the Roman Empire collapse? What is Latin for office automation?
79. A year spent in artificial intelligence is enough to make one believe in God.
66. Making something variable is easy. Controlling duration of constancy is the trick.
78. If your computer speaks English, it was probably made in Japan.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
119. Programming is an unnatural act.
15. Everything should be built top-down, except the first time.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
17. If a listener nods his head when you're explaining your program, wake him up.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
38. Structured Programming supports the law of the excluded middle.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
59. In English every word can be verbed. Would that it were so in our programming languages.
111. Why did the Roman Empire collapse? What is Latin for office automation?
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
66. Making something variable is easy. Controlling duration of constancy is the trick.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
46. Like punning, programming is a play on words.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
4. Every program is a part of some other program and rarely fits.
55. A LISP programmer knows the value of everything, but the cost of nothing.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
96. Computers don't introduce order anywhere as much as they expose opportunities.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
66. Making something variable is easy. Controlling duration of constancy is the trick.
22. A good system can't have a weak command language.
66. Making something variable is easy. Controlling duration of constancy is the trick.
27. Once you understand how to write a program get someone else to write it.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
60. In seeking the unattainable, simplicity only gets in the way.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
14. In the long run every program becomes rococo - then rubble.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
14. In the long run every program becomes rococo - then rubble.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
14. In the long run every program becomes rococo - then rubble.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
4. Every program is a part of some other program and rarely fits.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
41. Some programming languages manage to absorb change, but withstand progress.
7. It is easier to write an incorrect program than understand a correct one.
95. Don't have good ideas if you aren't willing to be responsible for them.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
110. Editing is a rewording activity.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
1. One man's constant is another man's variable.
60. In seeking the unattainable, simplicity only gets in the way.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
78. If your computer speaks English, it was probably made in Japan.
8. A programming language is low level when its programs require attention to the irrelevant.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
108. Whenever two programmers meet to criticize their programs, both are silent.
72. An adequate bootstrap is a contradiction in terms.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
47. As Will Rogers would have said, "There is no such thing as a free variable."
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
4. Every program is a part of some other program and rarely fits.
22. A good system can't have a weak command language.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
12. Recursion is the root of computation since it trades description for time.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
15. Everything should be built top-down, except the first time.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
108. Whenever two programmers meet to criticize their programs, both are silent.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
103. Purely applicative languages are poorly applicable.
100. We will never run out of things to program as long as there is a single program around.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
41. Some programming languages manage to absorb change, but withstand progress.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
15. Everything should be built top-down, except the first time.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
72. An adequate bootstrap is a contradiction in terms.
59. In English every word can be verbed. Would that it were so in our programming languages.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
43. In software systems, it is often the early bird that makes the worm.
27. Once you understand how to write a program get someone else to write it.
63. When we write programs that "learn", it turns out that we do and they don't.
7. It is easier to write an incorrect program than understand a correct one.
62. In computing, invariants are ephemeral.
22. A good system can't have a weak command language.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
31. Simplicity does not precede complexity, but follows it.
76. It is the user who should parameterize procedures, not their creators.
95. Don't have good ideas if you aren't willing to be responsible for them.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
114. Within a computer natural language is unnatural.
17. If a listener nods his head when you're explaining your program, wake him up.
100. We will never run out of things to program as long as there is a single program around.
1. One man's constant is another man's variable.
112. Computer Science is embarrassed by the computer.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
47. As Will Rogers would have said, "There is no such thing as a free variable."
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
98. In computing, the mean time to failure keeps getting shorter.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
11. If you have a procedure with ten parameters, you probably missed some.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
76. It is the user who should parameterize procedures, not their creators.
59. In English every word can be verbed. Would that it were so in our programming languages.
79. A year spent in artificial intelligence is enough to make one believe in God.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
12. Recursion is the root of computation since it trades description for time.
102. One can't proceed from the informal to the formal by formal means.
78. If your computer speaks English, it was probably made in Japan.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
78. If your computer speaks English, it was probably made in Japan.
111. Why did the Roman Empire collapse? What is Latin for office automation?
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
47. As Will Rogers would have said, "There is no such thing as a free variable."
104. The proof of a system's value is its existence.
7. It is easier to write an incorrect program than understand a correct one.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
22. A good system can't have a weak command language.
98. In computing, the mean time to failure keeps getting shorter.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
114. Within a computer natural language is unnatural.
108. Whenever two programmers meet to criticize their programs, both are silent.
23. To understand a program you must become both the machine and the program.
57. It is easier to change the specification to fit the program than vice versa.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
46. Like punning, programming is a play on words.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
111. Why did the Roman Empire collapse? What is Latin for office automation?
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
3. Syntactic sugar causes cancer of the semicolon.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
12. Recursion is the root of computation since it trades description for time.
41. Some programming languages manage to absorb change, but withstand progress.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
14. In the long run every program becomes rococo - then rubble.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
100. We will never run out of things to program as long as there is a single program around.
41. Some programming languages manage to absorb change, but withstand progress.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
11. If you have a procedure with ten parameters, you probably missed some.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
115. Most people find the concept of programming obvious, but the doing impossible.
110. Editing is a rewording activity.
103. Purely applicative languages are poorly applicable.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
15. Everything should be built top-down, except the first time.
111. Why did the Roman Empire collapse? What is Latin for office automation?
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
78. If your computer speaks English, it was probably made in Japan.
111. Why did the Roman Empire collapse? What is Latin for office automation?
72. An adequate bootstrap is a contradiction in terms.
22. A good system can't have a weak command language.
59. In English every word can be verbed. Would that it were so in our programming languages.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
107. The debate rages on: is PL/I Bachtrian or Dromedary?
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
31. Simplicity does not precede complexity, but follows it.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
78. If your computer speaks English, it was probably made in Japan.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
78. If your computer speaks English, it was probably made in Japan.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
11. If you have a procedure with ten parameters, you probably missed some.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
1. One man's constant is another man's variable.
63. When we write programs that "learn", it turns out that we do and they don't.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
90. Computation has made the tree flower.
59. In English every word can be verbed. Would that it were so in our programming languages.
112. Computer Science is embarrassed by the computer.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
8. A programming language is low level when its programs require attention to the irrelevant.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
31. Simplicity does not precede complexity, but follows it.
22. A good system can't have a weak command language.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
40. There are two ways to write error-free programs; only the third one works.
111. Why did the Roman Empire collapse? What is Latin for office automation?
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
90. Computation has made the tree flower.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
7. It is easier to write an incorrect program than understand a correct one.
115. Most people find the concept of programming obvious, but the doing impossible.
55. A LISP programmer knows the value of everything, but the cost of nothing.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
59. In English every word can be verbed. Would that it were so in our programming languages.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
55. A LISP programmer knows the value of everything, but the cost of nothing.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
114. Within a computer natural language is unnatural.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
12. Recursion is the root of computation since it trades description for time.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
119. Programming is an unnatural act.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
18. A program without a loop and a structured variable isn't worth writing.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
104. The proof of a system's value is its existence.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
66. Making something variable is easy. Controlling duration of constancy is the trick.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
4. Every program is a part of some other program and rarely fits.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
46. Like punning, programming is a play on words.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
21. Optimization hinders evolution.
4. Every program is a part of some other program and rarely fits.
100. We will never run out of things to program as long as there is a single program around.
96. Computers don't introduce order anywhere as much as they expose opportunities.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
7. It is easier to write an incorrect program than understand a correct one.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
78. If your computer speaks English, it was probably made in Japan.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
4. Every program is a part of some other program and rarely fits.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
7. It is easier to write an incorrect program than understand a correct one.
76. It is the user who should parameterize procedures, not their creators.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
11. If you have a procedure with ten parameters, you probably missed some.
4. Every program is a part of some other program and rarely fits.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
60. In seeking the unattainable, simplicity only gets in the way.
102. One can't proceed from the informal to the formal by formal means.
59. In English every word can be verbed. Would that it were so in our programming languages.
90. Computation has made the tree flower.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
108. Whenever two programmers meet to criticize their programs, both are silent.
105. You can't communicate complexity, only an awareness of it.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
98. In computing, the mean time to failure keeps getting shorter.
100. We will never run out of things to program as long as there is a single program around.
55. A LISP programmer knows the value of everything, but the cost of nothing.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
43. In software systems, it is often the early bird that makes the worm.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
112. Computer Science is embarrassed by the computer.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
31. Simplicity does not precede complexity, but follows it.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
76. It is the user who should parameterize procedures, not their creators.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
14. In the long run every program becomes rococo - then rubble.
11. If you have a procedure with ten parameters, you probably missed some.
104. The proof of a system's value is its existence.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
18. A program without a loop and a structured variable isn't worth writing.
114. Within a computer natural language is unnatural.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
115. Most people find the concept of programming obvious, but the doing impossible.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
61. In programming, as in everything else, to be in error is to be reborn.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
7. It is easier to write an incorrect program than understand a correct one.
27. Once you understand how to write a program get someone else to write it.
96. Computers don't introduce order anywhere as much as they expose opportunities.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
102. One can't proceed from the informal to the formal by formal means.
100. We will never run out of things to program as long as there is a single program around.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
15. Everything should be built top-down, except the first time.
55. A LISP programmer knows the value of everything, but the cost of nothing.
115. Most people find the concept of programming obvious, but the doing impossible.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
114. Within a computer natural language is unnatural.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
46. Like punning, programming is a play on words.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
100. We will never run out of things to program as long as there is a single program around.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
63. When we write programs that "learn", it turns out that we do and they don't.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
63. When we write programs that "learn", it turns out that we do and they don't.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
23. To understand a program you must become both the machine and the program.
11. If you have a procedure with ten parameters, you probably missed some.
23. To understand a program you must become both the machine and the program.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
60. In seeking the unattainable, simplicity only gets in the way.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
3. Syntactic sugar causes cancer of the semicolon.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
95. Don't have good ideas if you aren't willing to be responsible for them.
38. Structured Programming supports the law of the excluded middle.
15. Everything should be built top-down, except the first time.
17. If a listener nods his head when you're explaining your program, wake him up.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
119. Programming is an unnatural act.
115. Most people find the concept of programming obvious, but the doing impossible.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
61. In programming, as in everything else, to be in error is to be reborn.
1. One man's constant is another man's variable.
61. In programming, as in everything else, to be in error is to be reborn.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
4. Every program is a part of some other program and rarely fits.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
11. If you have a procedure with ten parameters, you probably missed some.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
47. As Will Rogers would have said, "There is no such thing as a free variable."
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
21. Optimization hinders evolution.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
76. It is the user who should parameterize procedures, not their creators.
31. Simplicity does not precede complexity, but follows it.
3. Syntactic sugar causes cancer of the semicolon.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
111. Why did the Roman Empire collapse? What is Latin for office automation?
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
55. A LISP programmer knows the value of everything, but the cost of nothing.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
98. In computing, the mean time to failure keeps getting shorter.
111. Why did the Roman Empire collapse? What is Latin for office automation?
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
95. Don't have good ideas if you aren't willing to be responsible for them.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
110. Editing is a rewording activity.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
108. Whenever two programmers meet to criticize their programs, both are silent.
27. Once you understand how to write a program get someone else to write it.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
104. The proof of a system's value is its existence.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
17. If a listener nods his head when you're explaining your program, wake him up.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
46. Like punning, programming is a play on words.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
59. In English every word can be verbed. Would that it were so in our programming languages.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
4. Every program is a part of some other program and rarely fits.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
108. Whenever two programmers meet to criticize their programs, both are silent.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
3. Syntactic sugar causes cancer of the semicolon.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
14. In the long run every program becomes rococo - then rubble.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
98. In computing, the mean time to failure keeps getting shorter.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
18. A program without a loop and a structured variable isn't worth writing.
59. In English every word can be verbed. Would that it were so in our programming languages.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
105. You can't communicate complexity, only an awareness of it.
46. Like punning, programming is a play on words.
59. In English every word can be verbed. Would that it were so in our programming languages.
7. It is easier to write an incorrect program than understand a correct one.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
114. Within a computer natural language is unnatural.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
17. If a listener nods his head when you're explaining your program, wake him up.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
76. It is the user who should parameterize procedures, not their creators.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
23. To understand a program you must become both the machine and the program.
27. Once you understand how to write a program get someone else to write it.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
46. Like punning, programming is a play on words.
1. One man's constant is another man's variable.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
43. In software systems, it is often the early bird that makes the worm.
114. Within a computer natural language is unnatural.
59. In English every word can be verbed. Would that it were so in our programming languages.
96. Computers don't introduce order anywhere as much as they expose opportunities.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
63. When we write programs that "learn", it turns out that we do and they don't.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
40. There are two ways to write error-free programs; only the third one works.
55. A LISP programmer knows the value of everything, but the cost of nothing.
22. A good system can't have a weak command language.
114. Within a computer natural language is unnatural.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
112. Computer Science is embarrassed by the computer.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
57. It is easier to change the specification to fit the program than vice versa.
1. One man's constant is another man's variable.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
11. If you have a procedure with ten parameters, you probably missed some.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
95. Don't have good ideas if you aren't willing to be responsible for them.
21. Optimization hinders evolution.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
57. It is easier to change the specification to fit the program than vice versa.
112. Computer Science is embarrassed by the computer.
11. If you have a procedure with ten parameters, you probably missed some.
78. If your computer speaks English, it was probably made in Japan.
27. Once you understand how to write a program get someone else to write it.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
14. In the long run every program becomes rococo - then rubble.
95. Don't have good ideas if you aren't willing to be responsible for them.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
96. Computers don't introduce order anywhere as much as they expose opportunities.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
38. Structured Programming supports the law of the excluded middle.
23. To understand a program you must become both the machine and the program.
3. Syntactic sugar causes cancer of the semicolon.
102. One can't proceed from the informal to the formal by formal means.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
103. Purely applicative languages are poorly applicable.
104. The proof of a system's value is its existence.
18. A program without a loop and a structured variable isn't worth writing.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
46. Like punning, programming is a play on words.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
78. If your computer speaks English, it was probably made in Japan.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
79. A year spent in artificial intelligence is enough to make one believe in God.
102. One can't proceed from the informal to the formal by formal means.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
46. Like punning, programming is a play on words.
115. Most people find the concept of programming obvious, but the doing impossible.
103. Purely applicative languages are poorly applicable.
79. A year spent in artificial intelligence is enough to make one believe in God.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
11. If you have a procedure with ten parameters, you probably missed some.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
111. Why did the Roman Empire collapse? What is Latin for office automation?
43. In software systems, it is often the early bird that makes the worm.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
57. It is easier to change the specification to fit the program than vice versa.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
102. One can't proceed from the informal to the formal by formal means.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
59. In English every word can be verbed. Would that it were so in our programming languages.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
23. To understand a program you must become both the machine and the program.
105. You can't communicate complexity, only an awareness of it.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
104. The proof of a system's value is its existence.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
8. A programming language is low level when its programs require attention to the irrelevant.
66. Making something variable is easy. Controlling duration of constancy is the trick.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
66. Making something variable is easy. Controlling duration of constancy is the trick.
31. Simplicity does not precede complexity, but follows it.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
8. A programming language is low level when its programs require attention to the irrelevant.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
40. There are two ways to write error-free programs; only the third one works.
8. A programming language is low level when its programs require attention to the irrelevant.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
46. Like punning, programming is a play on words.
17. If a listener nods his head when you're explaining your program, wake him up.
27. Once you understand how to write a program get someone else to write it.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
59. In English every word can be verbed. Would that it were so in our programming languages.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
104. The proof of a system's value is its existence.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
78. If your computer speaks English, it was probably made in Japan.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
108. Whenever two programmers meet to criticize their programs, both are silent.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
23. To understand a program you must become both the machine and the program.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
41. Some programming languages manage to absorb change, but withstand progress.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
43. In software systems, it is often the early bird that makes the worm.
47. As Will Rogers would have said, "There is no such thing as a free variable."
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
22. A good system can't have a weak command language.
102. One can't proceed from the informal to the formal by formal means.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
72. An adequate bootstrap is a contradiction in terms.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
21. Optimization hinders evolution.
43. In software systems, it is often the early bird that makes the worm.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
95. Don't have good ideas if you aren't willing to be responsible for them.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
96. Computers don't introduce order anywhere as much as they expose opportunities.
18. A program without a loop and a structured variable isn't worth writing.
110. Editing is a rewording activity.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
43. In software systems, it is often the early bird that makes the worm.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
104. The proof of a system's value is its existence.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
105. You can't communicate complexity, only an awareness of it.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
63. When we write programs that "learn", it turns out that we do and they don't.
104. The proof of a system's value is its existence.
8. A programming language is low level when its programs require attention to the irrelevant.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
100. We will never run out of things to program as long as there is a single program around.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
72. An adequate bootstrap is a contradiction in terms.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
23. To understand a program you must become both the machine and the program.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
47. As Will Rogers would have said, "There is no such thing as a free variable."
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
112. Computer Science is embarrassed by the computer.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
98. In computing, the mean time to failure keeps getting shorter.
12. Recursion is the root of computation since it trades description for time.
98. In computing, the mean time to failure keeps getting shorter.
104. The proof of a system's value is its existence.
57. It is easier to change the specification to fit the program than vice versa.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
4. Every program is a part of some other program and rarely fits.
55. A LISP programmer knows the value of everything, but the cost of nothing.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
115. Most people find the concept of programming obvious, but the doing impossible.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
59. In English every word can be verbed. Would that it were so in our programming languages.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
78. If your computer speaks English, it was probably made in Japan.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
14. In the long run every program becomes rococo - then rubble.
47. As Will Rogers would have said, "There is no such thing as a free variable."
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
21. Optimization hinders evolution.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
57. It is easier to change the specification to fit the program than vice versa.
111. Why did the Roman Empire collapse? What is Latin for office automation?
3. Syntactic sugar causes cancer of the semicolon.
110. Editing is a rewording activity.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
96. Computers don't introduce order anywhere as much as they expose opportunities.
4. Every program is a part of some other program and rarely fits.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
8. A programming language is low level when its programs require attention to the irrelevant.
55. A LISP programmer knows the value of everything, but the cost of nothing.
14. In the long run every program becomes rococo - then rubble.
46. Like punning, programming is a play on words.
112. Computer Science is embarrassed by the computer.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
61. In programming, as in everything else, to be in error is to be reborn.
119. Programming is an unnatural act.
1. One man's constant is another man's variable.
76. It is the user who should parameterize procedures, not their creators.
57. It is easier to change the specification to fit the program than vice versa.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
17. If a listener nods his head when you're explaining your program, wake him up.
104. The proof of a system's value is its existence.
103. Purely applicative languages are poorly applicable.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
90. Computation has made the tree flower.
7. It is easier to write an incorrect program than understand a correct one.
90. Computation has made the tree flower.
76. It is the user who should parameterize procedures, not their creators.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
11. If you have a procedure with ten parameters, you probably missed some.
14. In the long run every program becomes rococo - then rubble.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
66. Making something variable is easy. Controlling duration of constancy is the trick.
17. If a listener nods his head when you're explaining your program, wake him up.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
112. Computer Science is embarrassed by the computer.
79. A year spent in artificial intelligence is enough to make one believe in God.
119. Programming is an unnatural act.
55. A LISP programmer knows the value of everything, but the cost of nothing.
115. Most people find the concept of programming obvious, but the doing impossible.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
57. It is easier to change the specification to fit the program than vice versa.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
47. As Will Rogers would have said, "There is no such thing as a free variable."
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
23. To understand a program you must become both the machine and the program.
31. Simplicity does not precede complexity, but follows it.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
23. To understand a program you must become both the machine and the program.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
21. Optimization hinders evolution.
60. In seeking the unattainable, simplicity only gets in the way.
14. In the long run every program becomes rococo - then rubble.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
21. Optimization hinders evolution.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
22. A good system can't have a weak command language.
38. Structured Programming supports the law of the excluded middle.
79. A year spent in artificial intelligence is enough to make one believe in God.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
15. Everything should be built top-down, except the first time.
12. Recursion is the root of computation since it trades description for time.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
31. Simplicity does not precede complexity, but follows it.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
61. In programming, as in everything else, to be in error is to be reborn.
119. Programming is an unnatural act.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
112. Computer Science is embarrassed by the computer.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
66. Making something variable is easy. Controlling duration of constancy is the trick.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
119. Programming is an unnatural act.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
111. Why did the Roman Empire collapse? What is Latin for office automation?
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
21. Optimization hinders evolution.
90. Computation has made the tree flower.
55. A LISP programmer knows the value of everything, but the cost of nothing.
104. The proof of a system's value is its existence.
18. A program without a loop and a structured variable isn't worth writing.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
104. The proof of a system's value is its existence.
90. Computation has made the tree flower.
102. One can't proceed from the informal to the formal by formal means.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
17. If a listener nods his head when you're explaining your program, wake him up.
18. A program without a loop and a structured variable isn't worth writing.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
110. Editing is a rewording activity.
100. We will never run out of things to program as long as there is a single program around.
112. Computer Science is embarrassed by the computer.
104. The proof of a system's value is its existence.
21. Optimization hinders evolution.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
55. A LISP programmer knows the value of everything, but the cost of nothing.
46. Like punning, programming is a play on words.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
108. Whenever two programmers meet to criticize their programs, both are silent.
115. Most people find the concept of programming obvious, but the doing impossible.
14. In the long run every program becomes rococo - then rubble.
23. To understand a program you must become both the machine and the program.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
21. Optimization hinders evolution.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
21. Optimization hinders evolution.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
21. Optimization hinders evolution.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
112. Computer Science is embarrassed by the computer.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
1. One man's constant is another man's variable.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
111. Why did the Roman Empire collapse? What is Latin for office automation?
114. Within a computer natural language is unnatural.
62. In computing, invariants are ephemeral.
63. When we write programs that "learn", it turns out that we do and they don't.
115. Most people find the concept of programming obvious, but the doing impossible.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
11. If you have a procedure with ten parameters, you probably missed some.
63. When we write programs that "learn", it turns out that we do and they don't.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
55. A LISP programmer knows the value of everything, but the cost of nothing.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
79. A year spent in artificial intelligence is enough to make one believe in God.
23. To understand a program you must become both the machine and the program.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
111. Why did the Roman Empire collapse? What is Latin for office automation?
79. A year spent in artificial intelligence is enough to make one believe in God.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
90. Computation has made the tree flower.
102. One can't proceed from the informal to the formal by formal means.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
12. Recursion is the root of computation since it trades description for time.
79. A year spent in artificial intelligence is enough to make one believe in God.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
108. Whenever two programmers meet to criticize their programs, both are silent.
98. In computing, the mean time to failure keeps getting shorter.
31. Simplicity does not precede complexity, but follows it.
46. Like punning, programming is a play on words.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
18. A program without a loop and a structured variable isn't worth writing.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
3. Syntactic sugar causes cancer of the semicolon.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
111. Why did the Roman Empire collapse? What is Latin for office automation?
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
14. In the long run every program becomes rococo - then rubble.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
104. The proof of a system's value is its existence.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
27. Once you understand how to write a program get someone else to write it.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
76. It is the user who should parameterize procedures, not their creators.
59. In English every word can be verbed. Would that it were so in our programming languages.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
18. A program without a loop and a structured variable isn't worth writing.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
4. Every program is a part of some other program and rarely fits.
114. Within a computer natural language is unnatural.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
104. The proof of a system's value is its existence.
23. To understand a program you must become both the machine and the program.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
114. Within a computer natural language is unnatural.
55. A LISP programmer knows the value of everything, but the cost of nothing.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
41. Some programming languages manage to absorb change, but withstand progress.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
46. Like punning, programming is a play on words.
27. Once you understand how to write a program get someone else to write it.
111. Why did the Roman Empire collapse? What is Latin for office automation?
66. Making something variable is easy. Controlling duration of constancy is the trick.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
59. In English every word can be verbed. Would that it were so in our programming languages.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
112. Computer Science is embarrassed by the computer.
47. As Will Rogers would have said, "There is no such thing as a free variable."
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
60. In seeking the unattainable, simplicity only gets in the way.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
38. Structured Programming supports the law of the excluded middle.
18. A program without a loop and a structured variable isn't worth writing.
11. If you have a procedure with ten parameters, you probably missed some.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
46. Like punning, programming is a play on words.
12. Recursion is the root of computation since it trades description for time.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
57. It is easier to change the specification to fit the program than vice versa.
115. Most people find the concept of programming obvious, but the doing impossible.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
4. Every program is a part of some other program and rarely fits.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
98. In computing, the mean time to failure keeps getting shorter.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
11. If you have a procedure with ten parameters, you probably missed some.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
43. In software systems, it is often the early bird that makes the worm.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
38. Structured Programming supports the law of the excluded middle.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
105. You can't communicate complexity, only an awareness of it.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
111. Why did the Roman Empire collapse? What is Latin for office automation?
111. Why did the Roman Empire collapse? What is Latin for office automation?
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
27. Once you understand how to write a program get someone else to write it.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
15. Everything should be built top-down, except the first time.
100. We will never run out of things to program as long as there is a single program around.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
4. Every program is a part of some other program and rarely fits.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
103. Purely applicative languages are poorly applicable.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
76. It is the user who should parameterize procedures, not their creators.
76. It is the user who should parameterize procedures, not their creators.
61. In programming, as in everything else, to be in error is to be reborn.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
105. You can't communicate complexity, only an awareness of it.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
17. If a listener nods his head when you're explaining your program, wake him up.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
1. One man's constant is another man's variable.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
63. When we write programs that "learn", it turns out that we do and they don't.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
66. Making something variable is easy. Controlling duration of constancy is the trick.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
14. In the long run every program becomes rococo - then rubble.
55. A LISP programmer knows the value of everything, but the cost of nothing.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
46. Like punning, programming is a play on words.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
79. A year spent in artificial intelligence is enough to make one believe in God.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
59. In English every word can be verbed. Would that it were so in our programming languages.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
108. Whenever two programmers meet to criticize their programs, both are silent.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
103. Purely applicative languages are poorly applicable.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
78. If your computer speaks English, it was probably made in Japan.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
17. If a listener nods his head when you're explaining your program, wake him up.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
60. In seeking the unattainable, simplicity only gets in the way.
110. Editing is a rewording activity.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
17. If a listener nods his head when you're explaining your program, wake him up.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
63. When we write programs that "learn", it turns out that we do and they don't.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
41. Some programming languages manage to absorb change, but withstand progress.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
59. In English every word can be verbed. Would that it were so in our programming languages.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
112. Computer Science is embarrassed by the computer.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
104. The proof of a system's value is its existence.
60. In seeking the unattainable, simplicity only gets in the way.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
22. A good system can't have a weak command language.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
102. One can't proceed from the informal to the formal by formal means.
7. It is easier to write an incorrect program than understand a correct one.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
78. If your computer speaks English, it was probably made in Japan.
57. It is easier to change the specification to fit the program than vice versa.
61. In programming, as in everything else, to be in error is to be reborn.
111. Why did the Roman Empire collapse? What is Latin for office automation?
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
55. A LISP programmer knows the value of everything, but the cost of nothing.
59. In English every word can be verbed. Would that it were so in our programming languages.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
40. There are two ways to write error-free programs; only the third one works.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
47. As Will Rogers would have said, "There is no such thing as a free variable."
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
119. Programming is an unnatural act.
3. Syntactic sugar causes cancer of the semicolon.
4. Every program is a part of some other program and rarely fits.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
23. To understand a program you must become both the machine and the program.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
8. A programming language is low level when its programs require attention to the irrelevant.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
112. Computer Science is embarrassed by the computer.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
102. One can't proceed from the informal to the formal by formal means.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
96. Computers don't introduce order anywhere as much as they expose opportunities.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
95. Don't have good ideas if you aren't willing to be responsible for them.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
60. In seeking the unattainable, simplicity only gets in the way.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
103. Purely applicative languages are poorly applicable.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
3. Syntactic sugar causes cancer of the semicolon.
96. Computers don't introduce order anywhere as much as they expose opportunities.
14. In the long run every program becomes rococo - then rubble.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
61. In programming, as in everything else, to be in error is to be reborn.
18. A program without a loop and a structured variable isn't worth writing.
18. A program without a loop and a structured variable isn't worth writing.
47. As Will Rogers would have said, "There is no such thing as a free variable."
4. Every program is a part of some other program and rarely fits.
55. A LISP programmer knows the value of everything, but the cost of nothing.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
57. It is easier to change the specification to fit the program than vice versa.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
21. Optimization hinders evolution.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
22. A good system can't have a weak command language.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
59. In English every word can be verbed. Would that it were so in our programming languages.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
47. As Will Rogers would have said, "There is no such thing as a free variable."
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
31. Simplicity does not precede complexity, but follows it.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
17. If a listener nods his head when you're explaining your program, wake him up.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
90. Computation has made the tree flower.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
108. Whenever two programmers meet to criticize their programs, both are silent.
108. Whenever two programmers meet to criticize their programs, both are silent.
60. In seeking the unattainable, simplicity only gets in the way.
14. In the long run every program becomes rococo - then rubble.
63. When we write programs that "learn", it turns out that we do and they don't.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
98. In computing, the mean time to failure keeps getting shorter.
108. Whenever two programmers meet to criticize their programs, both are silent.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
78. If your computer speaks English, it was probably made in Japan.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
40. There are two ways to write error-free programs; only the third one works.
100. We will never run out of things to program as long as there is a single program around.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
55. A LISP programmer knows the value of everything, but the cost of nothing.
60. In seeking the unattainable, simplicity only gets in the way.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
79. A year spent in artificial intelligence is enough to make one believe in God.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
17. If a listener nods his head when you're explaining your program, wake him up.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
66. Making something variable is easy. Controlling duration of constancy is the trick.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
66. Making something variable is easy. Controlling duration of constancy is the trick.
115. Most people find the concept of programming obvious, but the doing impossible.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
98. In computing, the mean time to failure keeps getting shorter.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
23. To understand a program you must become both the machine and the program.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
112. Computer Science is embarrassed by the computer.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
96. Computers don't introduce order anywhere as much as they expose opportunities.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
115. Most people find the concept of programming obvious, but the doing impossible.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
17. If a listener nods his head when you're explaining your program, wake him up.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
18. A program without a loop and a structured variable isn't worth writing.
7. It is easier to write an incorrect program than understand a correct one.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
115. Most people find the concept of programming obvious, but the doing impossible.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
23. To understand a program you must become both the machine and the program.
78. If your computer speaks English, it was probably made in Japan.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
90. Computation has made the tree flower.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
55. A LISP programmer knows the value of everything, but the cost of nothing.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
11. If you have a procedure with ten parameters, you probably missed some.
62. In computing, invariants are ephemeral.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
79. A year spent in artificial intelligence is enough to make one believe in God.
105. You can't communicate complexity, only an awareness of it.
46. Like punning, programming is a play on words.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
61. In programming, as in everything else, to be in error is to be reborn.
18. A program without a loop and a structured variable isn't worth writing.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
78. If your computer speaks English, it was probably made in Japan.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
105. You can't communicate complexity, only an awareness of it.
47. As Will Rogers would have said, "There is no such thing as a free variable."
17. If a listener nods his head when you're explaining your program, wake him up.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
100. We will never run out of things to program as long as there is a single program around.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
55. A LISP programmer knows the value of everything, but the cost of nothing.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
100. We will never run out of things to program as long as there is a single program around.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
119. Programming is an unnatural act.
119. Programming is an unnatural act.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
59. In English every word can be verbed. Would that it were so in our programming languages.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
23. To understand a program you must become both the machine and the program.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
61. In programming, as in everything else, to be in error is to be reborn.
76. It is the user who should parameterize procedures, not their creators.
22. A good system can't have a weak command language.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
115. Most people find the concept of programming obvious, but the doing impossible.
23. To understand a program you must become both the machine and the program.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
108. Whenever two programmers meet to criticize their programs, both are silent.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
60. In seeking the unattainable, simplicity only gets in the way.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
100. We will never run out of things to program as long as there is a single program around.
21. Optimization hinders evolution.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
110. Editing is a rewording activity.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
110. Editing is a rewording activity.
105. You can't communicate complexity, only an awareness of it.
108. Whenever two programmers meet to criticize their programs, both are silent.
60. In seeking the unattainable, simplicity only gets in the way.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
60. In seeking the unattainable, simplicity only gets in the way.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
108. Whenever two programmers meet to criticize their programs, both are silent.
61. In programming, as in everything else, to be in error is to be reborn.
60. In seeking the unattainable, simplicity only gets in the way.
57. It is easier to change the specification to fit the program than vice versa.
104. The proof of a system's value is its existence.
27. Once you understand how to write a program get someone else to write it.
102. One can't proceed from the informal to the formal by formal means.
108. Whenever two programmers meet to criticize their programs, both are silent.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
7. It is easier to write an incorrect program than understand a correct one.
76. It is the user who should parameterize procedures, not their creators.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
21. Optimization hinders evolution.
21. Optimization hinders evolution.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
59. In English every word can be verbed. Would that it were so in our programming languages.
102. One can't proceed from the informal to the formal by formal means.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
103. Purely applicative languages are poorly applicable.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
31. Simplicity does not precede complexity, but follows it.
31. Simplicity does not precede complexity, but follows it.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
3. Syntactic sugar causes cancer of the semicolon.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
60. In seeking the unattainable, simplicity only gets in the way.
78. If your computer speaks English, it was probably made in Japan.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
95. Don't have good ideas if you aren't willing to be responsible for them.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
76. It is the user who should parameterize procedures, not their creators.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
115. Most people find the concept of programming obvious, but the doing impossible.
27. Once you understand how to write a program get someone else to write it.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
12. Recursion is the root of computation since it trades description for time.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
47. As Will Rogers would have said, "There is no such thing as a free variable."
112. Computer Science is embarrassed by the computer.
105. You can't communicate complexity, only an awareness of it.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
21. Optimization hinders evolution.
103. Purely applicative languages are poorly applicable.
14. In the long run every program becomes rococo - then rubble.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
61. In programming, as in everything else, to be in error is to be reborn.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
40. There are two ways to write error-free programs; only the third one works.
111. Why did the Roman Empire collapse? What is Latin for office automation?
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
60. In seeking the unattainable, simplicity only gets in the way.
41. Some programming languages manage to absorb change, but withstand progress.
55. A LISP programmer knows the value of everything, but the cost of nothing.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
21. Optimization hinders evolution.
4. Every program is a part of some other program and rarely fits.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
47. As Will Rogers would have said, "There is no such thing as a free variable."
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
4. Every program is a part of some other program and rarely fits.
7. It is easier to write an incorrect program than understand a correct one.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
102. One can't proceed from the informal to the formal by formal means.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
41. Some programming languages manage to absorb change, but withstand progress.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
57. It is easier to change the specification to fit the program than vice versa.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
112. Computer Science is embarrassed by the computer.
18. A program without a loop and a structured variable isn't worth writing.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
78. If your computer speaks English, it was probably made in Japan.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
4. Every program is a part of some other program and rarely fits.
8. A programming language is low level when its programs require attention to the irrelevant.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
12. Recursion is the root of computation since it trades description for time.
57. It is easier to change the specification to fit the program than vice versa.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
15. Everything should be built top-down, except the first time.
1. One man's constant is another man's variable.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
104. The proof of a system's value is its existence.
40. There are two ways to write error-free programs; only the third one works.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
12. Recursion is the root of computation since it trades description for time.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
78. If your computer speaks English, it was probably made in Japan.
15. Everything should be built top-down, except the first time.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
105. You can't communicate complexity, only an awareness of it.
115. Most people find the concept of programming obvious, but the doing impossible.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
103. Purely applicative languages are poorly applicable.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
47. As Will Rogers would have said, "There is no such thing as a free variable."
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
104. The proof of a system's value is its existence.
7. It is easier to write an incorrect program than understand a correct one.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
41. Some programming languages manage to absorb change, but withstand progress.
3. Syntactic sugar causes cancer of the semicolon.
57. It is easier to change the specification to fit the program than vice versa.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
100. We will never run out of things to program as long as there is a single program around.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
57. It is easier to change the specification to fit the program than vice versa.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
23. To understand a program you must become both the machine and the program.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
40. There are two ways to write error-free programs; only the third one works.
22. A good system can't have a weak command language.
110. Editing is a rewording activity.
61. In programming, as in everything else, to be in error is to be reborn.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
105. You can't communicate complexity, only an awareness of it.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
8. A programming language is low level when its programs require attention to the irrelevant.
40. There are two ways to write error-free programs; only the third one works.
112. Computer Science is embarrassed by the computer.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
22. A good system can't have a weak command language.
55. A LISP programmer knows the value of everything, but the cost of nothing.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
11. If you have a procedure with ten parameters, you probably missed some.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
59. In English every word can be verbed. Would that it were so in our programming languages.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
79. A year spent in artificial intelligence is enough to make one believe in God.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
63. When we write programs that "learn", it turns out that we do and they don't.
41. Some programming languages manage to absorb change, but withstand progress.
111. Why did the Roman Empire collapse? What is Latin for office automation?
78. If your computer speaks English, it was probably made in Japan.
61. In programming, as in everything else, to be in error is to be reborn.
60. In seeking the unattainable, simplicity only gets in the way.
31. Simplicity does not precede complexity, but follows it.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
112. Computer Science is embarrassed by the computer.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
110. Editing is a rewording activity.
90. Computation has made the tree flower.
105. You can't communicate complexity, only an awareness of it.
112. Computer Science is embarrassed by the computer.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
23. To understand a program you must become both the machine and the program.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
55. A LISP programmer knows the value of everything, but the cost of nothing.
114. Within a computer natural language is unnatural.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
66. Making something variable is easy. Controlling duration of constancy is the trick.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
23. To understand a program you must become both the machine and the program.
63. When we write programs that "learn", it turns out that we do and they don't.
17. If a listener nods his head when you're explaining your program, wake him up.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
38. Structured Programming supports the law of the excluded middle.
103. Purely applicative languages are poorly applicable.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
105. You can't communicate complexity, only an awareness of it.
111. Why did the Roman Empire collapse? What is Latin for office automation?
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
61. In programming, as in everything else, to be in error is to be reborn.
108. Whenever two programmers meet to criticize their programs, both are silent.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
95. Don't have good ideas if you aren't willing to be responsible for them.
72. An adequate bootstrap is a contradiction in terms.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
15. Everything should be built top-down, except the first time.
108. Whenever two programmers meet to criticize their programs, both are silent.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
22. A good system can't have a weak command language.
3. Syntactic sugar causes cancer of the semicolon.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
40. There are two ways to write error-free programs; only the third one works.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
62. In computing, invariants are ephemeral.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
46. Like punning, programming is a play on words.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
104. The proof of a system's value is its existence.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
79. A year spent in artificial intelligence is enough to make one believe in God.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
78. If your computer speaks English, it was probably made in Japan.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
17. If a listener nods his head when you're explaining your program, wake him up.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
108. Whenever two programmers meet to criticize their programs, both are silent.
119. Programming is an unnatural act.
95. Don't have good ideas if you aren't willing to be responsible for them.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
15. Everything should be built top-down, except the first time.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
1. One man's constant is another man's variable.
111. Why did the Roman Empire collapse? What is Latin for office automation?
60. In seeking the unattainable, simplicity only gets in the way.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
8. A programming language is low level when its programs require attention to the irrelevant.
15. Everything should be built top-down, except the first time.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
119. Programming is an unnatural act.
119. Programming is an unnatural act.
21. Optimization hinders evolution.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
79. A year spent in artificial intelligence is enough to make one believe in God.
114. Within a computer natural language is unnatural.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
23. To understand a program you must become both the machine and the program.
11. If you have a procedure with ten parameters, you probably missed some.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
47. As Will Rogers would have said, "There is no such thing as a free variable."
19. A language that doesn't affect the way you think about programming, is not worth knowing.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
104. The proof of a system's value is its existence.
76. It is the user who should parameterize procedures, not their creators.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
98. In computing, the mean time to failure keeps getting shorter.
43. In software systems, it is often the early bird that makes the worm.
55. A LISP programmer knows the value of everything, but the cost of nothing.
105. You can't communicate complexity, only an awareness of it.
90. Computation has made the tree flower.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
98. In computing, the mean time to failure keeps getting shorter.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
95. Don't have good ideas if you aren't willing to be responsible for them.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
21. Optimization hinders evolution.
15. Everything should be built top-down, except the first time.
11. If you have a procedure with ten parameters, you probably missed some.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
23. To understand a program you must become both the machine and the program.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
115. Most people find the concept of programming obvious, but the doing impossible.
110. Editing is a rewording activity.
46. Like punning, programming is a play on words.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
38. Structured Programming supports the law of the excluded middle.
95. Don't have good ideas if you aren't willing to be responsible for them.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
110. Editing is a rewording activity.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
63. When we write programs that "learn", it turns out that we do and they don't.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
18. A program without a loop and a structured variable isn't worth writing.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
1. One man's constant is another man's variable.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
90. Computation has made the tree flower.
114. Within a computer natural language is unnatural.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
60. In seeking the unattainable, simplicity only gets in the way.
15. Everything should be built top-down, except the first time.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
119. Programming is an unnatural act.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
22. A good system can't have a weak command language.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
95. Don't have good ideas if you aren't willing to be responsible for them.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
63. When we write programs that "learn", it turns out that we do and they don't.
78. If your computer speaks English, it was probably made in Japan.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
27. Once you understand how to write a program get someone else to write it.
38. Structured Programming supports the law of the excluded middle.
41. Some programming languages manage to absorb change, but withstand progress.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
103. Purely applicative languages are poorly applicable.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
90. Computation has made the tree flower.
57. It is easier to change the specification to fit the program than vice versa.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
102. One can't proceed from the informal to the formal by formal means.
60. In seeking the unattainable, simplicity only gets in the way.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
63. When we write programs that "learn", it turns out that we do and they don't.
43. In software systems, it is often the early bird that makes the worm.
.
.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
57. It is easier to change the specification to fit the program than vice versa.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
59. In English every word can be verbed. Would that it were so in our programming languages.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
78. If your computer speaks English, it was probably made in Japan.
62. In computing, invariants are ephemeral.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
111. Why did the Roman Empire collapse? What is Latin for office automation?
96. Computers don't introduce order anywhere as much as they expose opportunities.
59. In English every word can be verbed. Would that it were so in our programming languages.
100. We will never run out of things to program as long as there is a single program around.
103. Purely applicative languages are poorly applicable.
55. A LISP programmer knows the value of everything, but the cost of nothing.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
78. If your computer speaks English, it was probably made in Japan.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
110. Editing is a rewording activity.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
14. In the long run every program becomes rococo - then rubble.
98. In computing, the mean time to failure keeps getting shorter.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
55. A LISP programmer knows the value of everything, but the cost of nothing.
76. It is the user who should parameterize procedures, not their creators.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
76. It is the user who should parameterize procedures, not their creators.
18. A program without a loop and a structured variable isn't worth writing.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
79. A year spent in artificial intelligence is enough to make one believe in God.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
38. Structured Programming supports the law of the excluded middle.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
11. If you have a procedure with ten parameters, you probably missed some.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
119. Programming is an unnatural act.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
11. If you have a procedure with ten parameters, you probably missed some.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
62. In computing, invariants are ephemeral.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
38. Structured Programming supports the law of the excluded middle.
47. As Will Rogers would have said, "There is no such thing as a free variable."
7. It is easier to write an incorrect program than understand a correct one.
15. Everything should be built top-down, except the first time.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
14. In the long run every program becomes rococo - then rubble.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
108. Whenever two programmers meet to criticize their programs, both are silent.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
1. One man's constant is another man's variable.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
95. Don't have good ideas if you aren't willing to be responsible for them.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
79. A year spent in artificial intelligence is enough to make one believe in God.
104. The proof of a system's value is its existence.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
79. A year spent in artificial intelligence is enough to make one believe in God.
12. Recursion is the root of computation since it trades description for time.
104. The proof of a system's value is its existence.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
115. Most people find the concept of programming obvious, but the doing impossible.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
96. Computers don't introduce order anywhere as much as they expose opportunities.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
90. Computation has made the tree flower.
47. As Will Rogers would have said, "There is no such thing as a free variable."
61. In programming, as in everything else, to be in error is to be reborn.
76. It is the user who should parameterize procedures, not their creators.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
62. In computing, invariants are ephemeral.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
72. An adequate bootstrap is a contradiction in terms.
96. Computers don't introduce order anywhere as much as they expose opportunities.
43. In software systems, it is often the early bird that makes the worm.
31. Simplicity does not precede complexity, but follows it.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
43. In software systems, it is often the early bird that makes the worm.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
66. Making something variable is easy. Controlling duration of constancy is the trick.
62. In computing, invariants are ephemeral.
78. If your computer speaks English, it was probably made in Japan.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
79. A year spent in artificial intelligence is enough to make one believe in God.
103. Purely applicative languages are poorly applicable.
17. If a listener nods his head when you're explaining your program, wake him up.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
17. If a listener nods his head when you're explaining your program, wake him up.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
103. Purely applicative languages are poorly applicable.
57. It is easier to change the specification to fit the program than vice versa.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
98. In computing, the mean time to failure keeps getting shorter.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
110. Editing is a rewording activity.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
103. Purely applicative languages are poorly applicable.
61. In programming, as in everything else, to be in error is to be reborn.
22. A good system can't have a weak command language.
110. Editing is a rewording activity.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
111. Why did the Roman Empire collapse? What is Latin for office automation?
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
22. A good system can't have a weak command language.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
22. A good system can't have a weak command language.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
1. One man's constant is another man's variable.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
95. Don't have good ideas if you aren't willing to be responsible for them.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
111. Why did the Roman Empire collapse? What is Latin for office automation?
1. One man's constant is another man's variable.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
21. Optimization hinders evolution.
90. Computation has made the tree flower.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
41. Some programming languages manage to absorb change, but withstand progress.
17. If a listener nods his head when you're explaining your program, wake him up.
114. Within a computer natural language is unnatural.
72. An adequate bootstrap is a contradiction in terms.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
62. In computing, invariants are ephemeral.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
62. In computing, invariants are ephemeral.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
61. In programming, as in everything else, to be in error is to be reborn.
31. Simplicity does not precede complexity, but follows it.
43. In software systems, it is often the early bird that makes the worm.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
76. It is the user who should parameterize procedures, not their creators.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
18. A program without a loop and a structured variable isn't worth writing.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
60. In seeking the unattainable, simplicity only gets in the way.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
115. Most people find the concept of programming obvious, but the doing impossible.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
62. In computing, invariants are ephemeral.
59. In English every word can be verbed. Would that it were so in our programming languages.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
46. Like punning, programming is a play on words.
31. Simplicity does not precede complexity, but follows it.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
43. In software systems, it is often the early bird that makes the worm.
103. Purely applicative languages are poorly applicable.
1. One man's constant is another man's variable.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
15. Everything should be built top-down, except the first time.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
18. A program without a loop and a structured variable isn't worth writing.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
55. A LISP programmer knows the value of everything, but the cost of nothing.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
17. If a listener nods his head when you're explaining your program, wake him up.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
79. A year spent in artificial intelligence is enough to make one believe in God.
61. In programming, as in everything else, to be in error is to be reborn.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
40. There are two ways to write error-free programs; only the third one works.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
104. The proof of a system's value is its existence.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
100. We will never run out of things to program as long as there is a single program around.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
55. A LISP programmer knows the value of everything, but the cost of nothing.
18. A program without a loop and a structured variable isn't worth writing.
115. Most people find the concept of programming obvious, but the doing impossible.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
90. Computation has made the tree flower.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
105. You can't communicate complexity, only an awareness of it.
66. Making something variable is easy. Controlling duration of constancy is the trick.
7. It is easier to write an incorrect program than understand a correct one.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
59. In English every word can be verbed. Would that it were so in our programming languages.
55. A LISP programmer knows the value of everything, but the cost of nothing.
3. Syntactic sugar causes cancer of the semicolon.
1. One man's constant is another man's variable.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
111. Why did the Roman Empire collapse? What is Latin for office automation?
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
63. When we write programs that "learn", it turns out that we do and they don't.
46. Like punning, programming is a play on words.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
110. Editing is a rewording activity.
100. We will never run out of things to program as long as there is a single program around.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
14. In the long run every program becomes rococo - then rubble.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
96. Computers don't introduce order anywhere as much as they expose opportunities.
15. Everything should be built top-down, except the first time.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
41. Some programming languages manage to absorb change, but withstand progress.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
76. It is the user who should parameterize procedures, not their creators.
41. Some programming languages manage to absorb change, but withstand progress.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
27. Once you understand how to write a program get someone else to write it.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
79. A year spent in artificial intelligence is enough to make one believe in God.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
57. It is easier to change the specification to fit the program than vice versa.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
57. It is easier to change the specification to fit the program than vice versa.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
104. The proof of a system's value is its existence.
63. When we write programs that "learn", it turns out that we do and they don't.
3. Syntactic sugar causes cancer of the semicolon.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
3. Syntactic sugar causes cancer of the semicolon.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
100. We will never run out of things to program as long as there is a single program around.
43. In software systems, it is often the early bird that makes the worm.
1. One man's constant is another man's variable.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
15. Everything should be built top-down, except the first time.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
17. If a listener nods his head when you're explaining your program, wake him up.
62. In computing, invariants are ephemeral.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
22. A good system can't have a weak command language.
104. The proof of a system's value is its existence.
21. Optimization hinders evolution.
12. Recursion is the root of computation since it trades description for time.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
22. A good system can't have a weak command language.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
115. Most people find the concept of programming obvious, but the doing impossible.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
14. In the long run every program becomes rococo - then rubble.
98. In computing, the mean time to failure keeps getting shorter.
95. Don't have good ideas if you aren't willing to be responsible for them.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
72. An adequate bootstrap is a contradiction in terms.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
17. If a listener nods his head when you're explaining your program, wake him up.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
55. A LISP programmer knows the value of everything, but the cost of nothing.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
12. Recursion is the root of computation since it trades description for time.
38. Structured Programming supports the law of the excluded middle.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
76. It is the user who should parameterize procedures, not their creators.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
46. Like punning, programming is a play on words.
110. Editing is a rewording activity.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
90. Computation has made the tree flower.
14. In the long run every program becomes rococo - then rubble.
104. The proof of a system's value is its existence.
41. Some programming languages manage to absorb change, but withstand progress.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
78. If your computer speaks English, it was probably made in Japan.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
115. Most people find the concept of programming obvious, but the doing impossible.
47. As Will Rogers would have said, "There is no such thing as a free variable."
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
61. In programming, as in everything else, to be in error is to be reborn.
38. Structured Programming supports the law of the excluded middle.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
96. Computers don't introduce order anywhere as much as they expose opportunities.
14. In the long run every program becomes rococo - then rubble.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
100. We will never run out of things to program as long as there is a single program around.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
4. Every program is a part of some other program and rarely fits.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
76. It is the user who should parameterize procedures, not their creators.
17. If a listener nods his head when you're explaining your program, wake him up.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
79. A year spent in artificial intelligence is enough to make one believe in God.
41. Some programming languages manage to absorb change, but withstand progress.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
8. A programming language is low level when its programs require attention to the irrelevant.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
57. It is easier to change the specification to fit the program than vice versa.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
108. Whenever two programmers meet to criticize their programs, both are silent.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
114. Within a computer natural language is unnatural.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
95. Don't have good ideas if you aren't willing to be responsible for them.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
8. A programming language is low level when its programs require attention to the irrelevant.
60. In seeking the unattainable, simplicity only gets in the way.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
96. Computers don't introduce order anywhere as much as they expose opportunities.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
15. Everything should be built top-down, except the first time.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
112. Computer Science is embarrassed by the computer.
66. Making something variable is easy. Controlling duration of constancy is the trick.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
4. Every program is a part of some other program and rarely fits.
43. In software systems, it is often the early bird that makes the worm.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
55. A LISP programmer knows the value of everything, but the cost of nothing.
119. Programming is an unnatural act.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
100. We will never run out of things to program as long as there is a single program around.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
108. Whenever two programmers meet to criticize their programs, both are silent.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
72. An adequate bootstrap is a contradiction in terms.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
66. Making something variable is easy. Controlling duration of constancy is the trick.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
102. One can't proceed from the informal to the formal by formal means.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
104. The proof of a system's value is its existence.
14. In the long run every program becomes rococo - then rubble.
103. Purely applicative languages are poorly applicable.
59. In English every word can be verbed. Would that it were so in our programming languages.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
7. It is easier to write an incorrect program than understand a correct one.
112. Computer Science is embarrassed by the computer.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
110. Editing is a rewording activity.
3. Syntactic sugar causes cancer of the semicolon.
40. There are two ways to write error-free programs; only the third one works.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
110. Editing is a rewording activity.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
18. A program without a loop and a structured variable isn't worth writing.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
104. The proof of a system's value is its existence.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
72. An adequate bootstrap is a contradiction in terms.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
40. There are two ways to write error-free programs; only the third one works.
38. Structured Programming supports the law of the excluded middle.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
107. The debate rages on: is PL/I Bachtrian or Dromedary?
31. Simplicity does not precede complexity, but follows it.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
102. One can't proceed from the informal to the formal by formal means.
8. A programming language is low level when its programs require attention to the irrelevant.
3. Syntactic sugar causes cancer of the semicolon.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
59. In English every word can be verbed. Would that it were so in our programming languages.
46. Like punning, programming is a play on words.
61. In programming, as in everything else, to be in error is to be reborn.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
63. When we write programs that "learn", it turns out that we do and they don't.
78. If your computer speaks English, it was probably made in Japan.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
96. Computers don't introduce order anywhere as much as they expose opportunities.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
21. Optimization hinders evolution.
108. Whenever two programmers meet to criticize their programs, both are silent.
72. An adequate bootstrap is a contradiction in terms.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
7. It is easier to write an incorrect program than understand a correct one.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
111. Why did the Roman Empire collapse? What is Latin for office automation?
98. In computing, the mean time to failure keeps getting shorter.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
43. In software systems, it is often the early bird that makes the worm.
4. Every program is a part of some other program and rarely fits.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
5. If a program manipulates a large amount of data, it does so in a small number of ways.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
105. You can't communicate complexity, only an awareness of it.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
96. Computers don't introduce order anywhere as much as they expose opportunities.
12. Recursion is the root of computation since it trades description for time.
11. If you have a procedure with ten parameters, you probably missed some.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
3. Syntactic sugar causes cancer of the semicolon.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
95. Don't have good ideas if you aren't willing to be responsible for them.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
8. A programming language is low level when its programs require attention to the irrelevant.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
63. When we write programs that "learn", it turns out that we do and they don't.
22. A good system can't have a weak command language.
112. Computer Science is embarrassed by the computer.
43. In software systems, it is often the early bird that makes the worm.
115. Most people find the concept of programming obvious, but the doing impossible.
95. Don't have good ideas if you aren't willing to be responsible for them.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
22. A good system can't have a weak command language.
15. Everything should be built top-down, except the first time.
15. Everything should be built top-down, except the first time.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
108. Whenever two programmers meet to criticize their programs, both are silent.
111. Why did the Roman Empire collapse? What is Latin for office automation?
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
15. Everything should be built top-down, except the first time.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
17. If a listener nods his head when you're explaining your program, wake him up.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
63. When we write programs that "learn", it turns out that we do and they don't.
40. There are two ways to write error-free programs; only the third one works.
63. When we write programs that "learn", it turns out that we do and they don't.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
14. In the long run every program becomes rococo - then rubble.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
19. A language that doesn't affect the way you think about programming, is not worth knowing.
104. The proof of a system's value is its existence.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
14. In the long run every program becomes rococo - then rubble.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
112. Computer Science is embarrassed by the computer.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
59. In English every word can be verbed. Would that it were so in our programming languages.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
102. One can't proceed from the informal to the formal by formal means.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
22. A good system can't have a weak command language.
103. Purely applicative languages are poorly applicable.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
103. Purely applicative languages are poorly applicable.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
12. Recursion is the root of computation since it trades description for time.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
98. In computing, the mean time to failure keeps getting shorter.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
46. Like punning, programming is a play on words.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
78. If your computer speaks English, it was probably made in Japan.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
66. Making something variable is easy. Controlling duration of constancy is the trick.
112. Computer Science is embarrassed by the computer.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
95. Don't have good ideas if you aren't willing to be responsible for them.
3. Syntactic sugar causes cancer of the semicolon.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
114. Within a computer natural language is unnatural.
1. One man's constant is another man's variable.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
23. To understand a program you must become both the machine and the program.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
107. The debate rages on: is PL/I Bachtrian or Dromedary?
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
115. Most people find the concept of programming obvious, but the doing impossible.
98. In computing, the mean time to failure keeps getting shorter.
57. It is easier to change the specification to fit the program than vice versa.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
78. If your computer speaks English, it was probably made in Japan.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
114. Within a computer natural language is unnatural.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
96. Computers don't introduce order anywhere as much as they expose opportunities.
103. Purely applicative languages are poorly applicable.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
76. It is the user who should parameterize procedures, not their creators.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
119. Programming is an unnatural act.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
17. If a listener nods his head when you're explaining your program, wake him up.
98. In computing, the mean time to failure keeps getting shorter.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
60. In seeking the unattainable, simplicity only gets in the way.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
105. You can't communicate complexity, only an awareness of it.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
55. A LISP programmer knows the value of everything, but the cost of nothing.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
61. In programming, as in everything else, to be in error is to be reborn.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
43. In software systems, it is often the early bird that makes the worm.
111. Why did the Roman Empire collapse? What is Latin for office automation?
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
55. A LISP programmer knows the value of everything, but the cost of nothing.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
11. If you have a procedure with ten parameters, you probably missed some.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
40. There are two ways to write error-free programs; only the third one works.
31. Simplicity does not precede complexity, but follows it.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
102. One can't proceed from the informal to the formal by formal means.
47. As Will Rogers would have said, "There is no such thing as a free variable."
7. It is easier to write an incorrect program than understand a correct one.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
79. A year spent in artificial intelligence is enough to make one believe in God.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
38. Structured Programming supports the law of the excluded middle.
61. In programming, as in everything else, to be in error is to be reborn.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
22. A good system can't have a weak command language.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
7. It is easier to write an incorrect program than understand a correct one.
110. Editing is a rewording activity.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
104. The proof of a system's value is its existence.
7. It is easier to write an incorrect program than understand a correct one.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
47. As Will Rogers would have said, "There is no such thing as a free variable."
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
15. Everything should be built top-down, except the first time.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
90. Computation has made the tree flower.
7. It is easier to write an incorrect program than understand a correct one.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
23. To understand a program you must become both the machine and the program.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
43. In software systems, it is often the early bird that makes the worm.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
95. Don't have good ideas if you aren't willing to be responsible for them.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
102. One can't proceed from the informal to the formal by formal means.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
119. Programming is an unnatural act.
18. A program without a loop and a structured variable isn't worth writing.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
46. Like punning, programming is a play on words.
63. When we write programs that "learn", it turns out that we do and they don't.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
60. In seeking the unattainable, simplicity only gets in the way.
102. One can't proceed from the informal to the formal by formal means.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
105. You can't communicate complexity, only an awareness of it.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
43. In software systems, it is often the early bird that makes the worm.
100. We will never run out of things to program as long as there is a single program around.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
59. In English every word can be verbed. Would that it were so in our programming languages.
72. An adequate bootstrap is a contradiction in terms.
72. An adequate bootstrap is a contradiction in terms.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
41. Some programming languages manage to absorb change, but withstand progress.
76. It is the user who should parameterize procedures, not their creators.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
96. Computers don't introduce order anywhere as much as they expose opportunities.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
108. Whenever two programmers meet to criticize their programs, both are silent.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
62. In computing, invariants are ephemeral.
96. Computers don't introduce order anywhere as much as they expose opportunities.
76. It is the user who should parameterize procedures, not their creators.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
59. In English every word can be verbed. Would that it were so in our programming languages.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
96. Computers don't introduce order anywhere as much as they expose opportunities.
3. Syntactic sugar causes cancer of the semicolon.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
110. Editing is a rewording activity.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
15. Everything should be built top-down, except the first time.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
63. When we write programs that "learn", it turns out that we do and they don't.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
108. Whenever two programmers meet to criticize their programs, both are silent.
103. Purely applicative languages are poorly applicable.
78. If your computer speaks English, it was probably made in Japan.
47. As Will Rogers would have said, "There is no such thing as a free variable."
18. A program without a loop and a structured variable isn't worth writing.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
111. Why did the Roman Empire collapse? What is Latin for office automation?
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
43. In software systems, it is often the early bird that makes the worm.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
57. It is easier to change the specification to fit the program than vice versa.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
3. Syntactic sugar causes cancer of the semicolon.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
115. Most people find the concept of programming obvious, but the doing impossible.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
59. In English every word can be verbed. Would that it were so in our programming languages.
4. Every program is a part of some other program and rarely fits.
23. To understand a program you must become both the machine and the program.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
104. The proof of a system's value is its existence.
14. In the long run every program becomes rococo - then rubble.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
90. Computation has made the tree flower.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
105. You can't communicate complexity, only an awareness of it.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
4. Every program is a part of some other program and rarely fits.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
62. In computing, invariants are ephemeral.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
62. In computing, invariants are ephemeral.
103. Purely applicative languages are poorly applicable.
14. In the long run every program becomes rococo - then rubble.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
110. Editing is a rewording activity.
21. Optimization hinders evolution.
17. If a listener nods his head when you're explaining your program, wake him up.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
8. A programming language is low level when its programs require attention to the irrelevant.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
1. One man's constant is another man's variable.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
110. Editing is a rewording activity.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
3. Syntactic sugar causes cancer of the semicolon.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
23. To understand a program you must become both the machine and the program.
78. If your computer speaks English, it was probably made in Japan.
63. When we write programs that "learn", it turns out that we do and they don't.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
57. It is easier to change the specification to fit the program than vice versa.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
98. In computing, the mean time to failure keeps getting shorter.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
27. Once you understand how to write a program get someone else to write it.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
46. Like punning, programming is a play on words.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
55. A LISP programmer knows the value of everything, but the cost of nothing.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
66. Making something variable is easy. Controlling duration of constancy is the trick.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
27. Once you understand how to write a program get someone else to write it.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
47. As Will Rogers would have said, "There is no such thing as a free variable."
114. Within a computer natural language is unnatural.
115. Most people find the concept of programming obvious, but the doing impossible.
38. Structured Programming supports the law of the excluded middle.
119. Programming is an unnatural act.
103. Purely applicative languages are poorly applicable.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
7. It is easier to write an incorrect program than understand a correct one.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
43. In software systems, it is often the early bird that makes the worm.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
55. A LISP programmer knows the value of everything, but the cost of nothing.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
17. If a listener nods his head when you're explaining your program, wake him up.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
96. Computers don't introduce order anywhere as much as they expose opportunities.
57. It is easier to change the specification to fit the program than vice versa.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
18. A program without a loop and a structured variable isn't worth writing.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
3. Syntactic sugar causes cancer of the semicolon.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
112. Computer Science is embarrassed by the computer.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
96. Computers don't introduce order anywhere as much as they expose opportunities.
96. Computers don't introduce order anywhere as much as they expose opportunities.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
76. It is the user who should parameterize procedures, not their creators.
38. Structured Programming supports the law of the excluded middle.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
1. One man's constant is another man's variable.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
115. Most people find the concept of programming obvious, but the doing impossible.
104. The proof of a system's value is its existence.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
115. Most people find the concept of programming obvious, but the doing impossible.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
55. A LISP programmer knows the value of everything, but the cost of nothing.
12. Recursion is the root of computation since it trades description for time.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
114. Within a computer natural language is unnatural.
3. Syntactic sugar causes cancer of the semicolon.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
8. A programming language is low level when its programs require attention to the irrelevant.
46. Like punning, programming is a play on words.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
21. Optimization hinders evolution.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
104. The proof of a system's value is its existence.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
90. Computation has made the tree flower.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
23. To understand a program you must become both the machine and the program.
41. Some programming languages manage to absorb change, but withstand progress.
7. It is easier to write an incorrect program than understand a correct one.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
96. Computers don't introduce order anywhere as much as they expose opportunities.
103. Purely applicative languages are poorly applicable.
17. If a listener nods his head when you're explaining your program, wake him up.
63. When we write programs that "learn", it turns out that we do and they don't.
14. In the long run every program becomes rococo - then rubble.
11. If you have a procedure with ten parameters, you probably missed some.
18. A program without a loop and a structured variable isn't worth writing.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
76. It is the user who should parameterize procedures, not their creators.
23. To understand a program you must become both the machine and the program.
22. A good system can't have a weak command language.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
76. It is the user who should parameterize procedures, not their creators.
111. Why did the Roman Empire collapse? What is Latin for office automation?
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
79. A year spent in artificial intelligence is enough to make one believe in God.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
7. It is easier to write an incorrect program than understand a correct one.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
17. If a listener nods his head when you're explaining your program, wake him up.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
15. Everything should be built top-down, except the first time.
4. Every program is a part of some other program and rarely fits.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
41. Some programming languages manage to absorb change, but withstand progress.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
47. As Will Rogers would have said, "There is no such thing as a free variable."
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
98. In computing, the mean time to failure keeps getting shorter.
3. Syntactic sugar causes cancer of the semicolon.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
4. Every program is a part of some other program and rarely fits.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
115. Most people find the concept of programming obvious, but the doing impossible.
15. Everything should be built top-down, except the first time.
112. Computer Science is embarrassed by the computer.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
111. Why did the Roman Empire collapse? What is Latin for office automation?
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
78. If your computer speaks English, it was probably made in Japan.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
15. Everything should be built top-down, except the first time.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
103. Purely applicative languages are poorly applicable.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
72. An adequate bootstrap is a contradiction in terms.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
110. Editing is a rewording activity.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
112. Computer Science is embarrassed by the computer.
115. Most people find the concept of programming obvious, but the doing impossible.
103. Purely applicative languages are poorly applicable.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
38. Structured Programming supports the law of the excluded middle.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
21. Optimization hinders evolution.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
76. It is the user who should parameterize procedures, not their creators.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
96. Computers don't introduce order anywhere as much as they expose opportunities.
110. Editing is a rewording activity.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
3. Syntactic sugar causes cancer of the semicolon.
98. In computing, the mean time to failure keeps getting shorter.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
27. Once you understand how to write a program get someone else to write it.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
72. An adequate bootstrap is a contradiction in terms.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
12. Recursion is the root of computation since it trades description for time.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
7. It is easier to write an incorrect program than understand a correct one.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
59. In English every word can be verbed. Would that it were so in our programming languages.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
55. A LISP programmer knows the value of everything, but the cost of nothing.
114. Within a computer natural language is unnatural.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
14. In the long run every program becomes rococo - then rubble.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
112. Computer Science is embarrassed by the computer.
8. A programming language is low level when its programs require attention to the irrelevant.
119. Programming is an unnatural act.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
103. Purely applicative languages are poorly applicable.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
4. Every program is a part of some other program and rarely fits.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
31. Simplicity does not precede complexity, but follows it.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
22. A good system can't have a weak command language.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
14. In the long run every program becomes rococo - then rubble.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
18. A program without a loop and a structured variable isn't worth writing.
79. A year spent in artificial intelligence is enough to make one believe in God.
27. Once you understand how to write a program get someone else to write it.
41. Some programming languages manage to absorb change, but withstand progress.
11. If you have a procedure with ten parameters, you probably missed some.
60. In seeking the unattainable, simplicity only gets in the way.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
96. Computers don't introduce order anywhere as much as they expose opportunities.
7. It is easier to write an incorrect program than understand a correct one.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
110. Editing is a rewording activity.
57. It is easier to change the specification to fit the program than vice versa.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
8. A programming language is low level when its programs require attention to the irrelevant.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
119. Programming is an unnatural act.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
63. When we write programs that "learn", it turns out that we do and they don't.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
111. Why did the Roman Empire collapse? What is Latin for office automation?
7. It is easier to write an incorrect program than understand a correct one.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
76. It is the user who should parameterize procedures, not their creators.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
55. A LISP programmer knows the value of everything, but the cost of nothing.
38. Structured Programming supports the law of the excluded middle.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
41. Some programming languages manage to absorb change, but withstand progress.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
22. A good system can't have a weak command language.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
112. Computer Science is embarrassed by the computer.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
40. There are two ways to write error-free programs; only the third one works.
1. One man's constant is another man's variable.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
98. In computing, the mean time to failure keeps getting shorter.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
17. If a listener nods his head when you're explaining your program, wake him up.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
102. One can't proceed from the informal to the formal by formal means.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
95. Don't have good ideas if you aren't willing to be responsible for them.
57. It is easier to change the specification to fit the program than vice versa.
79. A year spent in artificial intelligence is enough to make one believe in God.
12. Recursion is the root of computation since it trades description for time.
60. In seeking the unattainable, simplicity only gets in the way.
7. It is easier to write an incorrect program than understand a correct one.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
11. If you have a procedure with ten parameters, you probably missed some.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
104. The proof of a system's value is its existence.
90. Computation has made the tree flower.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
63. When we write programs that "learn", it turns out that we do and they don't.
11. If you have a procedure with ten parameters, you probably missed some.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
27. Once you understand how to write a program get someone else to write it.
104. The proof of a system's value is its existence.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
96. Computers don't introduce order anywhere as much as they expose opportunities.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
60. In seeking the unattainable, simplicity only gets in the way.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
18. A program without a loop and a structured variable isn't worth writing.
43. In software systems, it is often the early bird that makes the worm.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
96. Computers don't introduce order anywhere as much as they expose opportunities.
18. A program without a loop and a structured variable isn't worth writing.
63. When we write programs that "learn", it turns out that we do and they don't.
17. If a listener nods his head when you're explaining your program, wake him up.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
72. An adequate bootstrap is a contradiction in terms.
100. We will never run out of things to program as long as there is a single program around.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
47. As Will Rogers would have said, "There is no such thing as a free variable."
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
119. Programming is an unnatural act.
17. If a listener nods his head when you're explaining your program, wake him up.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
72. An adequate bootstrap is a contradiction in terms.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
55. A LISP programmer knows the value of everything, but the cost of nothing.
103. Purely applicative languages are poorly applicable.
115. Most people find the concept of programming obvious, but the doing impossible.
8. A programming language is low level when its programs require attention to the irrelevant.
31. Simplicity does not precede complexity, but follows it.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
12. Recursion is the root of computation since it trades description for time.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
1. One man's constant is another man's variable.
110. Editing is a rewording activity.
66. Making something variable is easy. Controlling duration of constancy is the trick.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
119. Programming is an unnatural act.
114. Within a computer natural language is unnatural.
119. Programming is an unnatural act.
72. An adequate bootstrap is a contradiction in terms.
61. In programming, as in everything else, to be in error is to be reborn.
15. Everything should be built top-down, except the first time.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
15. Everything should be built top-down, except the first time.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
103. Purely applicative languages are poorly applicable.
15. Everything should be built top-down, except the first time.
12. Recursion is the root of computation since it trades description for time.
100. We will never run out of things to program as long as there is a single program around.
108. Whenever two programmers meet to criticize their programs, both are silent.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
90. Computation has made the tree flower.
119. Programming is an unnatural act.
104. The proof of a system's value is its existence.
21. Optimization hinders evolution.
105. You can't communicate complexity, only an awareness of it.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
95. Don't have good ideas if you aren't willing to be responsible for them.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
60. In seeking the unattainable, simplicity only gets in the way.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
61. In programming, as in everything else, to be in error is to be reborn.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
57. It is easier to change the specification to fit the program than vice versa.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
104. The proof of a system's value is its existence.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
115. Most people find the concept of programming obvious, but the doing impossible.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
17. If a listener nods his head when you're explaining your program, wake him up.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
60. In seeking the unattainable, simplicity only gets in the way.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
100. We will never run out of things to program as long as there is a single program around.
60. In seeking the unattainable, simplicity only gets in the way.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
21. Optimization hinders evolution.
104. The proof of a system's value is its existence.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
27. Once you understand how to write a program get someone else to write it.
115. Most people find the concept of programming obvious, but the doing impossible.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
41. Some programming languages manage to absorb change, but withstand progress.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
114. Within a computer natural language is unnatural.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
3. Syntactic sugar causes cancer of the semicolon.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
103. Purely applicative languages are poorly applicable.
115. Most people find the concept of programming obvious, but the doing impossible.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
41. Some programming languages manage to absorb change, but withstand progress.
4. Every program is a part of some other program and rarely fits.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
21. Optimization hinders evolution.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
98. In computing, the mean time to failure keeps getting shorter.
100. We will never run out of things to program as long as there is a single program around.
102. One can't proceed from the informal to the formal by formal means.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
108. Whenever two programmers meet to criticize their programs, both are silent.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
103. Purely applicative languages are poorly applicable.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
72. An adequate bootstrap is a contradiction in terms.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
63. When we write programs that "learn", it turns out that we do and they don't.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
102. One can't proceed from the informal to the formal by formal means.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
107. The debate rages on: is PL/I Bachtrian or Dromedary?
4. Every program is a part of some other program and rarely fits.
108. Whenever two programmers meet to criticize their programs, both are silent.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
31. Simplicity does not precede complexity, but follows it.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
115. Most people find the concept of programming obvious, but the doing impossible.
111. Why did the Roman Empire collapse? What is Latin for office automation?
66. Making something variable is easy. Controlling duration of constancy is the trick.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
31. Simplicity does not precede complexity, but follows it.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
43. In software systems, it is often the early bird that makes the worm.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
108. Whenever two programmers meet to criticize their programs, both are silent.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
100. We will never run out of things to program as long as there is a single program around.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
55. A LISP programmer knows the value of everything, but the cost of nothing.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
11. If you have a procedure with ten parameters, you probably missed some.
108. Whenever two programmers meet to criticize their programs, both are silent.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
60. In seeking the unattainable, simplicity only gets in the way.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
23. To understand a program you must become both the machine and the program.
41. Some programming languages manage to absorb change, but withstand progress.
110. Editing is a rewording activity.
76. It is the user who should parameterize procedures, not their creators.
61. In programming, as in everything else, to be in error is to be reborn.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
96. Computers don't introduce order anywhere as much as they expose opportunities.
104. The proof of a system's value is its existence.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
47. As Will Rogers would have said, "There is no such thing as a free variable."
61. In programming, as in everything else, to be in error is to be reborn.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
23. To understand a program you must become both the machine and the program.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
7. It is easier to write an incorrect program than understand a correct one.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
76. It is the user who should parameterize procedures, not their creators.
96. Computers don't introduce order anywhere as much as they expose opportunities.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
63. When we write programs that "learn", it turns out that we do and they don't.
21. Optimization hinders evolution.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
103. Purely applicative languages are poorly applicable.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
41. Some programming languages manage to absorb change, but withstand progress.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
43. In software systems, it is often the early bird that makes the worm.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
63. When we write programs that "learn", it turns out that we do and they don't.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
40. There are two ways to write error-free programs; only the third one works.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
108. Whenever two programmers meet to criticize their programs, both are silent.
43. In software systems, it is often the early bird that makes the worm.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
112. Computer Science is embarrassed by the computer.
27. Once you understand how to write a program get someone else to write it.
55. A LISP programmer knows the value of everything, but the cost of nothing.
47. As Will Rogers would have said, "There is no such thing as a free variable."
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
22. A good system can't have a weak command language.
22. A good system can't have a weak command language.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
72. An adequate bootstrap is a contradiction in terms.
98. In computing, the mean time to failure keeps getting shorter.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
19. A language that doesn't affect the way you think about programming, is not worth knowing.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
27. Once you understand how to write a program get someone else to write it.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
38. Structured Programming supports the law of the excluded middle.
105. You can't communicate complexity, only an awareness of it.
21. Optimization hinders evolution.
98. In computing, the mean time to failure keeps getting shorter.
11. If you have a procedure with ten parameters, you probably missed some.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
31. Simplicity does not precede complexity, but follows it.
90. Computation has made the tree flower.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
1. One man's constant is another man's variable.
38. Structured Programming supports the law of the excluded middle.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
66. Making something variable is easy. Controlling duration of constancy is the trick.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
17. If a listener nods his head when you're explaining your program, wake him up.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
11. If you have a procedure with ten parameters, you probably missed some.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
15. Everything should be built top-down, except the first time.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
104. The proof of a system's value is its existence.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
63. When we write programs that "learn", it turns out that we do and they don't.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
108. Whenever two programmers meet to criticize their programs, both are silent.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
96. Computers don't introduce order anywhere as much as they expose opportunities.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
66. Making something variable is easy. Controlling duration of constancy is the trick.
72. An adequate bootstrap is a contradiction in terms.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
.
.
.
114. Within a computer natural language is unnatural.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
111. Why did the Roman Empire collapse? What is Latin for office automation?
114. Within a computer natural language is unnatural.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
63. When we write programs that "learn", it turns out that we do and they don't.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
3. Syntactic sugar causes cancer of the semicolon.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
59. In English every word can be verbed. Would that it were so in our programming languages.
78. If your computer speaks English, it was probably made in Japan.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
1. One man's constant is another man's variable.
57. It is easier to change the specification to fit the program than vice versa.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
111. Why did the Roman Empire collapse? What is Latin for office automation?
72. An adequate bootstrap is a contradiction in terms.
27. Once you understand how to write a program get someone else to write it.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
108. Whenever two programmers meet to criticize their programs, both are silent.
3. Syntactic sugar causes cancer of the semicolon.
104. The proof of a system's value is its existence.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
17. If a listener nods his head when you're explaining your program, wake him up.
104. The proof of a system's value is its existence.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
57. It is easier to change the specification to fit the program than vice versa.
41. Some programming languages manage to absorb change, but withstand progress.
31. Simplicity does not precede complexity, but follows it.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
76. It is the user who should parameterize procedures, not their creators.
23. To understand a program you must become both the machine and the program.
104. The proof of a system's value is its existence.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
108. Whenever two programmers meet to criticize their programs, both are silent.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
27. Once you understand how to write a program get someone else to write it.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
40. There are two ways to write error-free programs; only the third one works.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
79. A year spent in artificial intelligence is enough to make one believe in God.
62. In computing, invariants are ephemeral.
90. Computation has made the tree flower.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
60. In seeking the unattainable, simplicity only gets in the way.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
12. Recursion is the root of computation since it trades description for time.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
61. In programming, as in everything else, to be in error is to be reborn.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
96. Computers don't introduce order anywhere as much as they expose opportunities.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
96. Computers don't introduce order anywhere as much as they expose opportunities.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
114. Within a computer natural language is unnatural.
96. Computers don't introduce order anywhere as much as they expose opportunities.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
22. A good system can't have a weak command language.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
95. Don't have good ideas if you aren't willing to be responsible for them.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
95. Don't have good ideas if you aren't willing to be responsible for them.
76. It is the user who should parameterize procedures, not their creators.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
15. Everything should be built top-down, except the first time.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
90. Computation has made the tree flower.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
100. We will never run out of things to program as long as there is a single program around.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
4. Every program is a part of some other program and rarely fits.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
115. Most people find the concept of programming obvious, but the doing impossible.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
95. Don't have good ideas if you aren't willing to be responsible for them.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
72. An adequate bootstrap is a contradiction in terms.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
40. There are two ways to write error-free programs; only the third one works.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
72. An adequate bootstrap is a contradiction in terms.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
57. It is easier to change the specification to fit the program than vice versa.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
12. Recursion is the root of computation since it trades description for time.
119. Programming is an unnatural act.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
21. Optimization hinders evolution.
62. In computing, invariants are ephemeral.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
3. Syntactic sugar causes cancer of the semicolon.
15. Everything should be built top-down, except the first time.
119. Programming is an unnatural act.
61. In programming, as in everything else, to be in error is to be reborn.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
108. Whenever two programmers meet to criticize their programs, both are silent.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
112. Computer Science is embarrassed by the computer.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
21. Optimization hinders evolution.
57. It is easier to change the specification to fit the program than vice versa.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
46. Like punning, programming is a play on words.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
100. We will never run out of things to program as long as there is a single program around.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
79. A year spent in artificial intelligence is enough to make one believe in God.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
104. The proof of a system's value is its existence.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
41. Some programming languages manage to absorb change, but withstand progress.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
63. When we write programs that "learn", it turns out that we do and they don't.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
104. The proof of a system's value is its existence.
61. In programming, as in everything else, to be in error is to be reborn.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
8. A programming language is low level when its programs require attention to the irrelevant.
12. Recursion is the root of computation since it trades description for time.
22. A good system can't have a weak command language.
115. Most people find the concept of programming obvious, but the doing impossible.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
119. Programming is an unnatural act.
61. In programming, as in everything else, to be in error is to be reborn.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
14. In the long run every program becomes rococo - then rubble.
60. In seeking the unattainable, simplicity only gets in the way.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
96. Computers don't introduce order anywhere as much as they expose opportunities.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
114. Within a computer natural language is unnatural.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
41. Some programming languages manage to absorb change, but withstand progress.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
41. Some programming languages manage to absorb change, but withstand progress.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
79. A year spent in artificial intelligence is enough to make one believe in God.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
112. Computer Science is embarrassed by the computer.
8. A programming language is low level when its programs require attention to the irrelevant.
111. Why did the Roman Empire collapse? What is Latin for office automation?
112. Computer Science is embarrassed by the computer.
43. In software systems, it is often the early bird that makes the worm.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
78. If your computer speaks English, it was probably made in Japan.
59. In English every word can be verbed. Would that it were so in our programming languages.
57. It is easier to change the specification to fit the program than vice versa.
112. Computer Science is embarrassed by the computer.
66. Making something variable is easy. Controlling duration of constancy is the trick.
57. It is easier to change the specification to fit the program than vice versa.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
15. Everything should be built top-down, except the first time.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
18. A program without a loop and a structured variable isn't worth writing.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
12. Recursion is the root of computation since it trades description for time.
104. The proof of a system's value is its existence.
38. Structured Programming supports the law of the excluded middle.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
108. Whenever two programmers meet to criticize their programs, both are silent.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
43. In software systems, it is often the early bird that makes the worm.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
119. Programming is an unnatural act.
103. Purely applicative languages are poorly applicable.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
107. The debate rages on: is PL/I Bachtrian or Dromedary?
96. Computers don't introduce order anywhere as much as they expose opportunities.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
8. A programming language is low level when its programs require attention to the irrelevant.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
4. Every program is a part of some other program and rarely fits.
38. Structured Programming supports the law of the excluded middle.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
46. Like punning, programming is a play on words.
63. When we write programs that "learn", it turns out that we do and they don't.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
17. If a listener nods his head when you're explaining your program, wake him up.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
59. In English every word can be verbed. Would that it were so in our programming languages.
61. In programming, as in everything else, to be in error is to be reborn.
114. Within a computer natural language is unnatural.
103. Purely applicative languages are poorly applicable.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
95. Don't have good ideas if you aren't willing to be responsible for them.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
11. If you have a procedure with ten parameters, you probably missed some.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
11. If you have a procedure with ten parameters, you probably missed some.
105. You can't communicate complexity, only an awareness of it.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
22. A good system can't have a weak command language.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
60. In seeking the unattainable, simplicity only gets in the way.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
115. Most people find the concept of programming obvious, but the doing impossible.
110. Editing is a rewording activity.
15. Everything should be built top-down, except the first time.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
43. In software systems, it is often the early bird that makes the worm.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
108. Whenever two programmers meet to criticize their programs, both are silent.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
59. In English every word can be verbed. Would that it were so in our programming languages.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
78. If your computer speaks English, it was probably made in Japan.
95. Don't have good ideas if you aren't willing to be responsible for them.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
95. Don't have good ideas if you aren't willing to be responsible for them.
66. Making something variable is easy. Controlling duration of constancy is the trick.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
18. A program without a loop and a structured variable isn't worth writing.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
95. Don't have good ideas if you aren't willing to be responsible for them.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
96. Computers don't introduce order anywhere as much as they expose opportunities.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
62. In computing, invariants are ephemeral.
57. It is easier to change the specification to fit the program than vice versa.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
95. Don't have good ideas if you aren't willing to be responsible for them.
79. A year spent in artificial intelligence is enough to make one believe in God.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
17. If a listener nods his head when you're explaining your program, wake him up.
38. Structured Programming supports the law of the excluded middle.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
21. Optimization hinders evolution.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
46. Like punning, programming is a play on words.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
3. Syntactic sugar causes cancer of the semicolon.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
27. Once you understand how to write a program get someone else to write it.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
114. Within a computer natural language is unnatural.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
43. In software systems, it is often the early bird that makes the worm.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
46. Like punning, programming is a play on words.
90. Computation has made the tree flower.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
41. Some programming languages manage to absorb change, but withstand progress.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
114. Within a computer natural language is unnatural.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
11. If you have a procedure with ten parameters, you probably missed some.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
108. Whenever two programmers meet to criticize their programs, both are silent.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
21. Optimization hinders evolution.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
61. In programming, as in everything else, to be in error is to be reborn.
102. One can't proceed from the informal to the formal by formal means.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
43. In software systems, it is often the early bird that makes the worm.
115. Most people find the concept of programming obvious, but the doing impossible.
96. Computers don't introduce order anywhere as much as they expose opportunities.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
98. In computing, the mean time to failure keeps getting shorter.
78. If your computer speaks English, it was probably made in Japan.
3. Syntactic sugar causes cancer of the semicolon.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
14. In the long run every program becomes rococo - then rubble.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
38. Structured Programming supports the law of the excluded middle.
21. Optimization hinders evolution.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
63. When we write programs that "learn", it turns out that we do and they don't.
11. If you have a procedure with ten parameters, you probably missed some.
79. A year spent in artificial intelligence is enough to make one believe in God.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
46. Like punning, programming is a play on words.
62. In computing, invariants are ephemeral.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
62. In computing, invariants are ephemeral.
105. You can't communicate complexity, only an awareness of it.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
107. The debate rages on: is PL/I Bachtrian or Dromedary?
3. Syntactic sugar causes cancer of the semicolon.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
96. Computers don't introduce order anywhere as much as they expose opportunities.
23. To understand a program you must become both the machine and the program.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
103. Purely applicative languages are poorly applicable.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
31. Simplicity does not precede complexity, but follows it.
96. Computers don't introduce order anywhere as much as they expose opportunities.
1. One man's constant is another man's variable.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
27. Once you understand how to write a program get someone else to write it.
3. Syntactic sugar causes cancer of the semicolon.
7. It is easier to write an incorrect program than understand a correct one.
12. Recursion is the root of computation since it trades description for time.
119. Programming is an unnatural act.
11. If you have a procedure with ten parameters, you probably missed some.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
100. We will never run out of things to program as long as there is a single program around.
110. Editing is a rewording activity.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
12. Recursion is the root of computation since it trades description for time.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
79. A year spent in artificial intelligence is enough to make one believe in God.
63. When we write programs that "learn", it turns out that we do and they don't.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
55. A LISP programmer knows the value of everything, but the cost of nothing.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
47. As Will Rogers would have said, "There is no such thing as a free variable."
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
59. In English every word can be verbed. Would that it were so in our programming languages.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
95. Don't have good ideas if you aren't willing to be responsible for them.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
59. In English every word can be verbed. Would that it were so in our programming languages.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
55. A LISP programmer knows the value of everything, but the cost of nothing.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
61. In programming, as in everything else, to be in error is to be reborn.
41. Some programming languages manage to absorb change, but withstand progress.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
114. Within a computer natural language is unnatural.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
11. If you have a procedure with ten parameters, you probably missed some.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
15. Everything should be built top-down, except the first time.
12. Recursion is the root of computation since it trades description for time.
108. Whenever two programmers meet to criticize their programs, both are silent.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
112. Computer Science is embarrassed by the computer.
104. The proof of a system's value is its existence.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
103. Purely applicative languages are poorly applicable.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
103. Purely applicative languages are poorly applicable.
90. Computation has made the tree flower.
60. In seeking the unattainable, simplicity only gets in the way.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
57. It is easier to change the specification to fit the program than vice versa.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
22. A good system can't have a weak command language.
66. Making something variable is easy. Controlling duration of constancy is the trick.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
55. A LISP programmer knows the value of everything, but the cost of nothing.
18. A program without a loop and a structured variable isn't worth writing.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
62. In computing, invariants are ephemeral.
76. It is the user who should parameterize procedures, not their creators.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
41. Some programming languages manage to absorb change, but withstand progress.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
22. A good system can't have a weak command language.
95. Don't have good ideas if you aren't willing to be responsible for them.
115. Most people find the concept of programming obvious, but the doing impossible.
14. In the long run every program becomes rococo - then rubble.
98. In computing, the mean time to failure keeps getting shorter.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
62. In computing, invariants are ephemeral.
8. A programming language is low level when its programs require attention to the irrelevant.
22. A good system can't have a weak command language.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
72. An adequate bootstrap is a contradiction in terms.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
95. Don't have good ideas if you aren't willing to be responsible for them.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
104. The proof of a system's value is its existence.
15. Everything should be built top-down, except the first time.
12. Recursion is the root of computation since it trades description for time.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
11. If you have a procedure with ten parameters, you probably missed some.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
60. In seeking the unattainable, simplicity only gets in the way.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
57. It is easier to change the specification to fit the program than vice versa.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
41. Some programming languages manage to absorb change, but withstand progress.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
114. Within a computer natural language is unnatural.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
108. Whenever two programmers meet to criticize their programs, both are silent.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
104. The proof of a system's value is its existence.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
12. Recursion is the root of computation since it trades description for time.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
3. Syntactic sugar causes cancer of the semicolon.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
112. Computer Science is embarrassed by the computer.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
103. Purely applicative languages are poorly applicable.
46. Like punning, programming is a play on words.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
90. Computation has made the tree flower.
103. Purely applicative languages are poorly applicable.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
38. Structured Programming supports the law of the excluded middle.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
17. If a listener nods his head when you're explaining your program, wake him up.
17. If a listener nods his head when you're explaining your program, wake him up.
61. In programming, as in everything else, to be in error is to be reborn.
4. Every program is a part of some other program and rarely fits.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
38. Structured Programming supports the law of the excluded middle.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
60. In seeking the unattainable, simplicity only gets in the way.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
17. If a listener nods his head when you're explaining your program, wake him up.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
46. Like punning, programming is a play on words.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
14. In the long run every program becomes rococo - then rubble.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
43. In software systems, it is often the early bird that makes the worm.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
66. Making something variable is easy. Controlling duration of constancy is the trick.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
7. It is easier to write an incorrect program than understand a correct one.
31. Simplicity does not precede complexity, but follows it.
57. It is easier to change the specification to fit the program than vice versa.
40. There are two ways to write error-free programs; only the third one works.
59. In English every word can be verbed. Would that it were so in our programming languages.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
103. Purely applicative languages are poorly applicable.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
72. An adequate bootstrap is a contradiction in terms.
40. There are two ways to write error-free programs; only the third one works.
103. Purely applicative languages are poorly applicable.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
17. If a listener nods his head when you're explaining your program, wake him up.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
23. To understand a program you must become both the machine and the program.
18. A program without a loop and a structured variable isn't worth writing.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
114. Within a computer natural language is unnatural.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
12. Recursion is the root of computation since it trades description for time.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
108. Whenever two programmers meet to criticize their programs, both are silent.
4. Every program is a part of some other program and rarely fits.
31. Simplicity does not precede complexity, but follows it.
100. We will never run out of things to program as long as there is a single program around.
4. Every program is a part of some other program and rarely fits.
31. Simplicity does not precede complexity, but follows it.
22. A good system can't have a weak command language.
43. In software systems, it is often the early bird that makes the worm.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
4. Every program is a part of some other program and rarely fits.
98. In computing, the mean time to failure keeps getting shorter.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
11. If you have a procedure with ten parameters, you probably missed some.
96. Computers don't introduce order anywhere as much as they expose opportunities.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
72. An adequate bootstrap is a contradiction in terms.
102. One can't proceed from the informal to the formal by formal means.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
110. Editing is a rewording activity.
41. Some programming languages manage to absorb change, but withstand progress.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
72. An adequate bootstrap is a contradiction in terms.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
90. Computation has made the tree flower.
104. The proof of a system's value is its existence.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
22. A good system can't have a weak command language.
8. A programming language is low level when its programs require attention to the irrelevant.
63. When we write programs that "learn", it turns out that we do and they don't.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
41. Some programming languages manage to absorb change, but withstand progress.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
23. To understand a program you must become both the machine and the program.
7. It is easier to write an incorrect program than understand a correct one.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
115. Most people find the concept of programming obvious, but the doing impossible.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
59. In English every word can be verbed. Would that it were so in our programming languages.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
63. When we write programs that "learn", it turns out that we do and they don't.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
63. When we write programs that "learn", it turns out that we do and they don't.
119. Programming is an unnatural act.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
110. Editing is a rewording activity.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
98. In computing, the mean time to failure keeps getting shorter.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
96. Computers don't introduce order anywhere as much as they expose opportunities.
14. In the long run every program becomes rococo - then rubble.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
60. In seeking the unattainable, simplicity only gets in the way.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
108. Whenever two programmers meet to criticize their programs, both are silent.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
96. Computers don't introduce order anywhere as much as they expose opportunities.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
4. Every program is a part of some other program and rarely fits.
110. Editing is a rewording activity.
61. In programming, as in everything else, to be in error is to be reborn.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
103. Purely applicative languages are poorly applicable.
4. Every program is a part of some other program and rarely fits.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
41. Some programming languages manage to absorb change, but withstand progress.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
12. Recursion is the root of computation since it trades description for time.
110. Editing is a rewording activity.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
66. Making something variable is easy. Controlling duration of constancy is the trick.
8. A programming language is low level when its programs require attention to the irrelevant.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
72. An adequate bootstrap is a contradiction in terms.
12. Recursion is the root of computation since it trades description for time.
60. In seeking the unattainable, simplicity only gets in the way.
22. A good system can't have a weak command language.
104. The proof of a system's value is its existence.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
105. You can't communicate complexity, only an awareness of it.
105. You can't communicate complexity, only an awareness of it.
110. Editing is a rewording activity.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
18. A program without a loop and a structured variable isn't worth writing.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
7. It is easier to write an incorrect program than understand a correct one.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
102. One can't proceed from the informal to the formal by formal means.
17. If a listener nods his head when you're explaining your program, wake him up.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
105. You can't communicate complexity, only an awareness of it.
60. In seeking the unattainable, simplicity only gets in the way.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
8. A programming language is low level when its programs require attention to the irrelevant.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
62. In computing, invariants are ephemeral.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
108. Whenever two programmers meet to criticize their programs, both are silent.
114. Within a computer natural language is unnatural.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
4. Every program is a part of some other program and rarely fits.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
115. Most people find the concept of programming obvious, but the doing impossible.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
114. Within a computer natural language is unnatural.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
4. Every program is a part of some other program and rarely fits.
17. If a listener nods his head when you're explaining your program, wake him up.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
59. In English every word can be verbed. Would that it were so in our programming languages.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
23. To understand a program you must become both the machine and the program.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
47. As Will Rogers would have said, "There is no such thing as a free variable."
23. To understand a program you must become both the machine and the program.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
62. In computing, invariants are ephemeral.
3. Syntactic sugar causes cancer of the semicolon.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
110. Editing is a rewording activity.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
40. There are two ways to write error-free programs; only the third one works.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
22. A good system can't have a weak command language.
38. Structured Programming supports the law of the excluded middle.
18. A program without a loop and a structured variable isn't worth writing.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
119. Programming is an unnatural act.
112. Computer Science is embarrassed by the computer.
27. Once you understand how to write a program get someone else to write it.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
76. It is the user who should parameterize procedures, not their creators.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
111. Why did the Roman Empire collapse? What is Latin for office automation?
11. If you have a procedure with ten parameters, you probably missed some.
63. When we write programs that "learn", it turns out that we do and they don't.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
62. In computing, invariants are ephemeral.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
3. Syntactic sugar causes cancer of the semicolon.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
21. Optimization hinders evolution.
1. One man's constant is another man's variable.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
43. In software systems, it is often the early bird that makes the worm.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
102. One can't proceed from the informal to the formal by formal means.
12. Recursion is the root of computation since it trades description for time.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
15. Everything should be built top-down, except the first time.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
59. In English every word can be verbed. Would that it were so in our programming languages.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
11. If you have a procedure with ten parameters, you probably missed some.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
110. Editing is a rewording activity.
1. One man's constant is another man's variable.
12. Recursion is the root of computation since it trades description for time.
46. Like punning, programming is a play on words.
23. To understand a program you must become both the machine and the program.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
90. Computation has made the tree flower.
12. Recursion is the root of computation since it trades description for time.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
14. In the long run every program becomes rococo - then rubble.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
31. Simplicity does not precede complexity, but follows it.
4. Every program is a part of some other program and rarely fits.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
19. A language that doesn't affect the way you think about programming, is not worth knowing.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
27. Once you understand how to write a program get someone else to write it.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
1. One man's constant is another man's variable.
98. In computing, the mean time to failure keeps getting shorter.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
114. Within a computer natural language is unnatural.
55. A LISP programmer knows the value of everything, but the cost of nothing.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
115. Most people find the concept of programming obvious, but the doing impossible.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
3. Syntactic sugar causes cancer of the semicolon.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
43. In software systems, it is often the early bird that makes the worm.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
112. Computer Science is embarrassed by the computer.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
60. In seeking the unattainable, simplicity only gets in the way.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
31. Simplicity does not precede complexity, but follows it.
27. Once you understand how to write a program get someone else to write it.
98. In computing, the mean time to failure keeps getting shorter.
105. You can't communicate complexity, only an awareness of it.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
96. Computers don't introduce order anywhere as much as they expose opportunities.
114. Within a computer natural language is unnatural.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
114. Within a computer natural language is unnatural.
90. Computation has made the tree flower.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
79. A year spent in artificial intelligence is enough to make one believe in God.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
46. Like punning, programming is a play on words.
78. If your computer speaks English, it was probably made in Japan.
40. There are two ways to write error-free programs; only the third one works.
1. One man's constant is another man's variable.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
18. A program without a loop and a structured variable isn't worth writing.
98. In computing, the mean time to failure keeps getting shorter.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
3. Syntactic sugar causes cancer of the semicolon.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
103. Purely applicative languages are poorly applicable.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
14. In the long run every program becomes rococo - then rubble.
96. Computers don't introduce order anywhere as much as they expose opportunities.
111. Why did the Roman Empire collapse? What is Latin for office automation?
79. A year spent in artificial intelligence is enough to make one believe in God.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
23. To understand a program you must become both the machine and the program.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
41. Some programming languages manage to absorb change, but withstand progress.
108. Whenever two programmers meet to criticize their programs, both are silent.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
90. Computation has made the tree flower.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
57. It is easier to change the specification to fit the program than vice versa.
15. Everything should be built top-down, except the first time.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
21. Optimization hinders evolution.
27. Once you understand how to write a program get someone else to write it.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
17. If a listener nods his head when you're explaining your program, wake him up.
46. Like punning, programming is a play on words.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
55. A LISP programmer knows the value of everything, but the cost of nothing.
72. An adequate bootstrap is a contradiction in terms.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
38. Structured Programming supports the law of the excluded middle.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
72. An adequate bootstrap is a contradiction in terms.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
60. In seeking the unattainable, simplicity only gets in the way.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
61. In programming, as in everything else, to be in error is to be reborn.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
119. Programming is an unnatural act.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
14. In the long run every program becomes rococo - then rubble.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
98. In computing, the mean time to failure keeps getting shorter.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
115. Most people find the concept of programming obvious, but the doing impossible.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
90. Computation has made the tree flower.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
102. One can't proceed from the informal to the formal by formal means.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
108. Whenever two programmers meet to criticize their programs, both are silent.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
66. Making something variable is easy. Controlling duration of constancy is the trick.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
21. Optimization hinders evolution.
61. In programming, as in everything else, to be in error is to be reborn.
46. Like punning, programming is a play on words.
61. In programming, as in everything else, to be in error is to be reborn.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
76. It is the user who should parameterize procedures, not their creators.
103. Purely applicative languages are poorly applicable.
114. Within a computer natural language is unnatural.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
31. Simplicity does not precede complexity, but follows it.
22. A good system can't have a weak command language.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
12. Recursion is the root of computation since it trades description for time.
90. Computation has made the tree flower.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
47. As Will Rogers would have said, "There is no such thing as a free variable."
27. Once you understand how to write a program get someone else to write it.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
1. One man's constant is another man's variable.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
41. Some programming languages manage to absorb change, but withstand progress.
119. Programming is an unnatural act.
111. Why did the Roman Empire collapse? What is Latin for office automation?
63. When we write programs that "learn", it turns out that we do and they don't.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
38. Structured Programming supports the law of the excluded middle.
61. In programming, as in everything else, to be in error is to be reborn.
11. If you have a procedure with ten parameters, you probably missed some.
61. In programming, as in everything else, to be in error is to be reborn.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
112. Computer Science is embarrassed by the computer.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
61. In programming, as in everything else, to be in error is to be reborn.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
114. Within a computer natural language is unnatural.
41. Some programming languages manage to absorb change, but withstand progress.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
95. Don't have good ideas if you aren't willing to be responsible for them.
15. Everything should be built top-down, except the first time.
102. One can't proceed from the informal to the formal by formal means.
59. In English every word can be verbed. Would that it were so in our programming languages.
119. Programming is an unnatural act.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
47. As Will Rogers would have said, "There is no such thing as a free variable."
14. In the long run every program becomes rococo - then rubble.
43. In software systems, it is often the early bird that makes the worm.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
62. In computing, invariants are ephemeral.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
98. In computing, the mean time to failure keeps getting shorter.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
57. It is easier to change the specification to fit the program than vice versa.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
38. Structured Programming supports the law of the excluded middle.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
18. A program without a loop and a structured variable isn't worth writing.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
95. Don't have good ideas if you aren't willing to be responsible for them.
3. Syntactic sugar causes cancer of the semicolon.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
23. To understand a program you must become both the machine and the program.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
79. A year spent in artificial intelligence is enough to make one believe in God.
114. Within a computer natural language is unnatural.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
11. If you have a procedure with ten parameters, you probably missed some.
14. In the long run every program becomes rococo - then rubble.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
111. Why did the Roman Empire collapse? What is Latin for office automation?
8. A programming language is low level when its programs require attention to the irrelevant.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
3. Syntactic sugar causes cancer of the semicolon.
102. One can't proceed from the informal to the formal by formal means.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
46. Like punning, programming is a play on words.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
61. In programming, as in everything else, to be in error is to be reborn.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
22. A good system can't have a weak command language.
72. An adequate bootstrap is a contradiction in terms.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
23. To understand a program you must become both the machine and the program.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
43. In software systems, it is often the early bird that makes the worm.
78. If your computer speaks English, it was probably made in Japan.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
79. A year spent in artificial intelligence is enough to make one believe in God.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
105. You can't communicate complexity, only an awareness of it.
104. The proof of a system's value is its existence.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
102. One can't proceed from the informal to the formal by formal means.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
63. When we write programs that "learn", it turns out that we do and they don't.
79. A year spent in artificial intelligence is enough to make one believe in God.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
95. Don't have good ideas if you aren't willing to be responsible for them.
90. Computation has made the tree flower.
23. To understand a program you must become both the machine and the program.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
31. Simplicity does not precede complexity, but follows it.
60. In seeking the unattainable, simplicity only gets in the way.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
38. Structured Programming supports the law of the excluded middle.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
79. A year spent in artificial intelligence is enough to make one believe in God.
46. Like punning, programming is a play on words.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
43. In software systems, it is often the early bird that makes the worm.
102. One can't proceed from the informal to the formal by formal means.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
40. There are two ways to write error-free programs; only the third one works.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
7. It is easier to write an incorrect program than understand a correct one.
1. One man's constant is another man's variable.
17. If a listener nods his head when you're explaining your program, wake him up.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
96. Computers don't introduce order anywhere as much as they expose opportunities.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
7. It is easier to write an incorrect program than understand a correct one.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
55. A LISP programmer knows the value of everything, but the cost of nothing.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
111. Why did the Roman Empire collapse? What is Latin for office automation?
23. To understand a program you must become both the machine and the program.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
18. A program without a loop and a structured variable isn't worth writing.
7. It is easier to write an incorrect program than understand a correct one.
62. In computing, invariants are ephemeral.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
108. Whenever two programmers meet to criticize their programs, both are silent.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
66. Making something variable is easy. Controlling duration of constancy is the trick.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
119. Programming is an unnatural act.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
31. Simplicity does not precede complexity, but follows it.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
15. Everything should be built top-down, except the first time.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
114. Within a computer natural language is unnatural.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
60. In seeking the unattainable, simplicity only gets in the way.
43. In software systems, it is often the early bird that makes the worm.
27. Once you understand how to write a program get someone else to write it.
60. In seeking the unattainable, simplicity only gets in the way.
31. Simplicity does not precede complexity, but follows it.
43. In software systems, it is often the early bird that makes the worm.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
15. Everything should be built top-down, except the first time.
27. Once you understand how to write a program get someone else to write it.
114. Within a computer natural language is unnatural.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
7. It is easier to write an incorrect program than understand a correct one.
98. In computing, the mean time to failure keeps getting shorter.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
46. Like punning, programming is a play on words.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
90. Computation has made the tree flower.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
27. Once you understand how to write a program get someone else to write it.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
19. A language that doesn't affect the way you think about programming, is not worth knowing.
72. An adequate bootstrap is a contradiction in terms.
4. Every program is a part of some other program and rarely fits.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
98. In computing, the mean time to failure keeps getting shorter.
72. An adequate bootstrap is a contradiction in terms.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
41. Some programming languages manage to absorb change, but withstand progress.
38. Structured Programming supports the law of the excluded middle.
95. Don't have good ideas if you aren't willing to be responsible for them.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
61. In programming, as in everything else, to be in error is to be reborn.
4. Every program is a part of some other program and rarely fits.
108. Whenever two programmers meet to criticize their programs, both are silent.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
61. In programming, as in everything else, to be in error is to be reborn.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
108. Whenever two programmers meet to criticize their programs, both are silent.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
15. Everything should be built top-down, except the first time.
15. Everything should be built top-down, except the first time.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
43. In software systems, it is often the early bird that makes the worm.
23. To understand a program you must become both the machine and the program.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
63. When we write programs that "learn", it turns out that we do and they don't.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
61. In programming, as in everything else, to be in error is to be reborn.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
60. In seeking the unattainable, simplicity only gets in the way.
15. Everything should be built top-down, except the first time.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
21. Optimization hinders evolution.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
21. Optimization hinders evolution.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
112. Computer Science is embarrassed by the computer.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
1. One man's constant is another man's variable.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
111. Why did the Roman Empire collapse? What is Latin for office automation?
114. Within a computer natural language is unnatural.
62. In computing, invariants are ephemeral.
63. When we write programs that "learn", it turns out that we do and they don't.
115. Most people find the concept of programming obvious, but the doing impossible.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
11. If you have a procedure with ten parameters, you probably missed some.
63. When we write programs that "learn", it turns out that we do and they don't.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
55. A LISP programmer knows the value of everything, but the cost of nothing.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
17. If a listener nods his head when you're explaining your program, wake him up.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
55. A LISP programmer knows the value of everything, but the cost of nothing.
119. Programming is an unnatural act.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
12. Recursion is the root of computation since it trades description for time.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
62. In computing, invariants are ephemeral.
46. Like punning, programming is a play on words.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
46. Like punning, programming is a play on words.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
57. It is easier to change the specification to fit the program than vice versa.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
11. If you have a procedure with ten parameters, you probably missed some.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
114. Within a computer natural language is unnatural.
55. A LISP programmer knows the value of everything, but the cost of nothing.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
41. Some programming languages manage to absorb change, but withstand progress.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
46. Like punning, programming is a play on words.
27. Once you understand how to write a program get someone else to write it.
111. Why did the Roman Empire collapse? What is Latin for office automation?
66. Making something variable is easy. Controlling duration of constancy is the trick.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
59. In English every word can be verbed. Would that it were so in our programming languages.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
112. Computer Science is embarrassed by the computer.
47. As Will Rogers would have said, "There is no such thing as a free variable."
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
60. In seeking the unattainable, simplicity only gets in the way.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
38. Structured Programming supports the law of the excluded middle.
18. A program without a loop and a structured variable isn't worth writing.
11. If you have a procedure with ten parameters, you probably missed some.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
46. Like punning, programming is a play on words.
12. Recursion is the root of computation since it trades description for time.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
55. A LISP programmer knows the value of everything, but the cost of nothing.
61. In programming, as in everything else, to be in error is to be reborn.
61. In programming, as in everything else, to be in error is to be reborn.
4. Every program is a part of some other program and rarely fits.
119. Programming is an unnatural act.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
31. Simplicity does not precede complexity, but follows it.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
17. If a listener nods his head when you're explaining your program, wake him up.
119. Programming is an unnatural act.
98. In computing, the mean time to failure keeps getting shorter.
76. It is the user who should parameterize procedures, not their creators.
23. To understand a program you must become both the machine and the program.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
96. Computers don't introduce order anywhere as much as they expose opportunities.
23. To understand a program you must become both the machine and the program.
103. Purely applicative languages are poorly applicable.
7. It is easier to write an incorrect program than understand a correct one.
96. Computers don't introduce order anywhere as much as they expose opportunities.
100. We will never run out of things to program as long as there is a single program around.
115. Most people find the concept of programming obvious, but the doing impossible.
63. When we write programs that "learn", it turns out that we do and they don't.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
1. One man's constant is another man's variable.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
76. It is the user who should parameterize procedures, not their creators.
104. The proof of a system's value is its existence.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
7. It is easier to write an incorrect program than understand a correct one.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
22. A good system can't have a weak command language.
98. In computing, the mean time to failure keeps getting shorter.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
11. If you have a procedure with ten parameters, you probably missed some.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
112. Computer Science is embarrassed by the computer.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
90. Computation has made the tree flower.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
103. Purely applicative languages are poorly applicable.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
90. Computation has made the tree flower.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
90. Computation has made the tree flower.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
115. Most people find the concept of programming obvious, but the doing impossible.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
55. A LISP programmer knows the value of everything, but the cost of nothing.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
114. Within a computer natural language is unnatural.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
31. Simplicity does not precede complexity, but follows it.
103. Purely applicative languages are poorly applicable.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
3. Syntactic sugar causes cancer of the semicolon.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
12. Recursion is the root of computation since it trades description for time.
115. Most people find the concept of programming obvious, but the doing impossible.
79. A year spent in artificial intelligence is enough to make one believe in God.
15. Everything should be built top-down, except the first time.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
110. Editing is a rewording activity.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
22. A good system can't have a weak command language.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
14. In the long run every program becomes rococo - then rubble.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
90. Computation has made the tree flower.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
8. A programming language is low level when its programs require attention to the irrelevant.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
63. When we write programs that "learn", it turns out that we do and they don't.
47. As Will Rogers would have said, "There is no such thing as a free variable."
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
38. Structured Programming supports the law of the excluded middle.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
96. Computers don't introduce order anywhere as much as they expose opportunities.
119. Programming is an unnatural act.
115. Most people find the concept of programming obvious, but the doing impossible.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
76. It is the user who should parameterize procedures, not their creators.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
22. A good system can't have a weak command language.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
14. In the long run every program becomes rococo - then rubble.
62. In computing, invariants are ephemeral.
8. A programming language is low level when its programs require attention to the irrelevant.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
114. Within a computer natural language is unnatural.
78. If your computer speaks English, it was probably made in Japan.
102. One can't proceed from the informal to the formal by formal means.
12. Recursion is the root of computation since it trades description for time.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
79. A year spent in artificial intelligence is enough to make one believe in God.
119. Programming is an unnatural act.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
112. Computer Science is embarrassed by the computer.
96. Computers don't introduce order anywhere as much as they expose opportunities.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
79. A year spent in artificial intelligence is enough to make one believe in God.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
18. A program without a loop and a structured variable isn't worth writing.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
43. In software systems, it is often the early bird that makes the worm.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
62. In computing, invariants are ephemeral.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
31. Simplicity does not precede complexity, but follows it.
23. To understand a program you must become both the machine and the program.
96. Computers don't introduce order anywhere as much as they expose opportunities.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
46. Like punning, programming is a play on words.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
17. If a listener nods his head when you're explaining your program, wake him up.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
43. In software systems, it is often the early bird that makes the worm.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
119. Programming is an unnatural act.
60. In seeking the unattainable, simplicity only gets in the way.
47. As Will Rogers would have said, "There is no such thing as a free variable."
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
57. It is easier to change the specification to fit the program than vice versa.
59. In English every word can be verbed. Would that it were so in our programming languages.
104. The proof of a system's value is its existence.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
114. Within a computer natural language is unnatural.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
4. Every program is a part of some other program and rarely fits.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
55. A LISP programmer knows the value of everything, but the cost of nothing.
17. If a listener nods his head when you're explaining your program, wake him up.
100. We will never run out of things to program as long as there is a single program around.
115. Most people find the concept of programming obvious, but the doing impossible.
96. Computers don't introduce order anywhere as much as they expose opportunities.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
8. A programming language is low level when its programs require attention to the irrelevant.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
59. In English every word can be verbed. Would that it were so in our programming languages.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
104. The proof of a system's value is its existence.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
57. It is easier to change the specification to fit the program than vice versa.
38. Structured Programming supports the law of the excluded middle.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
46. Like punning, programming is a play on words.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
18. A program without a loop and a structured variable isn't worth writing.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
110. Editing is a rewording activity.
14. In the long run every program becomes rococo - then rubble.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
63. When we write programs that "learn", it turns out that we do and they don't.
110. Editing is a rewording activity.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
66. Making something variable is easy. Controlling duration of constancy is the trick.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
46. Like punning, programming is a play on words.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
1. One man's constant is another man's variable.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
90. Computation has made the tree flower.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
96. Computers don't introduce order anywhere as much as they expose opportunities.
119. Programming is an unnatural act.
104. The proof of a system's value is its existence.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
41. Some programming languages manage to absorb change, but withstand progress.
38. Structured Programming supports the law of the excluded middle.
95. Don't have good ideas if you aren't willing to be responsible for them.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
61. In programming, as in everything else, to be in error is to be reborn.
4. Every program is a part of some other program and rarely fits.
108. Whenever two programmers meet to criticize their programs, both are silent.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
61. In programming, as in everything else, to be in error is to be reborn.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
108. Whenever two programmers meet to criticize their programs, both are silent.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
15. Everything should be built top-down, except the first time.
15. Everything should be built top-down, except the first time.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
43. In software systems, it is often the early bird that makes the worm.
23. To understand a program you must become both the machine and the program.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
63. When we write programs that "learn", it turns out that we do and they don't.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
61. In programming, as in everything else, to be in error is to be reborn.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
60. In seeking the unattainable, simplicity only gets in the way.
15. Everything should be built top-down, except the first time.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
111. Why did the Roman Empire collapse? What is Latin for office automation?
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
90. Computation has made the tree flower.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
43. In software systems, it is often the early bird that makes the worm.
27. Once you understand how to write a program get someone else to write it.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
110. Editing is a rewording activity.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
110. Editing is a rewording activity.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
112. Computer Science is embarrassed by the computer.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
79. A year spent in artificial intelligence is enough to make one believe in God.
103. Purely applicative languages are poorly applicable.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
63. When we write programs that "learn", it turns out that we do and they don't.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
103. Purely applicative languages are poorly applicable.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
23. To understand a program you must become both the machine and the program.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
21. Optimization hinders evolution.
11. If you have a procedure with ten parameters, you probably missed some.
11. If you have a procedure with ten parameters, you probably missed some.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
59. In English every word can be verbed. Would that it were so in our programming languages.
102. One can't proceed from the informal to the formal by formal means.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
114. Within a computer natural language is unnatural.
1. One man's constant is another man's variable.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
11. If you have a procedure with ten parameters, you probably missed some.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
111. Why did the Roman Empire collapse? What is Latin for office automation?
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
96. Computers don't introduce order anywhere as much as they expose opportunities.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
103. Purely applicative languages are poorly applicable.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
31. Simplicity does not precede complexity, but follows it.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
7. It is easier to write an incorrect program than understand a correct one.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
38. Structured Programming supports the law of the excluded middle.
62. In computing, invariants are ephemeral.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
57. It is easier to change the specification to fit the program than vice versa.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
112. Computer Science is embarrassed by the computer.
8. A programming language is low level when its programs require attention to the irrelevant.
114. Within a computer natural language is unnatural.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
7. It is easier to write an incorrect program than understand a correct one.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
61. In programming, as in everything else, to be in error is to be reborn.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
63. When we write programs that "learn", it turns out that we do and they don't.
62. In computing, invariants are ephemeral.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
11. If you have a procedure with ten parameters, you probably missed some.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
112. Computer Science is embarrassed by the computer.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
43. In software systems, it is often the early bird that makes the worm.
90. Computation has made the tree flower.
12. Recursion is the root of computation since it trades description for time.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
61. In programming, as in everything else, to be in error is to be reborn.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
115. Most people find the concept of programming obvious, but the doing impossible.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
46. Like punning, programming is a play on words.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
66. Making something variable is easy. Controlling duration of constancy is the trick.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
61. In programming, as in everything else, to be in error is to be reborn.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
4. Every program is a part of some other program and rarely fits.
38. Structured Programming supports the law of the excluded middle.
17. If a listener nods his head when you're explaining your program, wake him up.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
72. An adequate bootstrap is a contradiction in terms.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
108. Whenever two programmers meet to criticize their programs, both are silent.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
7. It is easier to write an incorrect program than understand a correct one.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
115. Most people find the concept of programming obvious, but the doing impossible.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
60. In seeking the unattainable, simplicity only gets in the way.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
105. You can't communicate complexity, only an awareness of it.
98. In computing, the mean time to failure keeps getting shorter.
98. In computing, the mean time to failure keeps getting shorter.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
38. Structured Programming supports the law of the excluded middle.
90. Computation has made the tree flower.
55. A LISP programmer knows the value of everything, but the cost of nothing.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
11. If you have a procedure with ten parameters, you probably missed some.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
27. Once you understand how to write a program get someone else to write it.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
114. Within a computer natural language is unnatural.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
43. In software systems, it is often the early bird that makes the worm.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
100. We will never run out of things to program as long as there is a single program around.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
3. Syntactic sugar causes cancer of the semicolon.
119. Programming is an unnatural act.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
114. Within a computer natural language is unnatural.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
59. In English every word can be verbed. Would that it were so in our programming languages.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
23. To understand a program you must become both the machine and the program.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
110. Editing is a rewording activity.
108. Whenever two programmers meet to criticize their programs, both are silent.
15. Everything should be built top-down, except the first time.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
103. Purely applicative languages are poorly applicable.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
59. In English every word can be verbed. Would that it were so in our programming languages.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
98. In computing, the mean time to failure keeps getting shorter.
14. In the long run every program becomes rococo - then rubble.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
72. An adequate bootstrap is a contradiction in terms.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
60. In seeking the unattainable, simplicity only gets in the way.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
11. If you have a procedure with ten parameters, you probably missed some.
112. Computer Science is embarrassed by the computer.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
90. Computation has made the tree flower.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
102. One can't proceed from the informal to the formal by formal means.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
108. Whenever two programmers meet to criticize their programs, both are silent.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
103. Purely applicative languages are poorly applicable.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
114. Within a computer natural language is unnatural.
18. A program without a loop and a structured variable isn't worth writing.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
18. A program without a loop and a structured variable isn't worth writing.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
59. In English every word can be verbed. Would that it were so in our programming languages.
119. Programming is an unnatural act.
61. In programming, as in everything else, to be in error is to be reborn.
60. In seeking the unattainable, simplicity only gets in the way.
112. Computer Science is embarrassed by the computer.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
115. Most people find the concept of programming obvious, but the doing impossible.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
60. In seeking the unattainable, simplicity only gets in the way.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
12. Recursion is the root of computation since it trades description for time.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
4. Every program is a part of some other program and rarely fits.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
8. A programming language is low level when its programs require attention to the irrelevant.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
76. It is the user who should parameterize procedures, not their creators.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
7. It is easier to write an incorrect program than understand a correct one.
43. In software systems, it is often the early bird that makes the worm.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
46. Like punning, programming is a play on words.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
23. To understand a program you must become both the machine and the program.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
111. Why did the Roman Empire collapse? What is Latin for office automation?
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
114. Within a computer natural language is unnatural.
103. Purely applicative languages are poorly applicable.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
31. Simplicity does not precede complexity, but follows it.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
115. Most people find the concept of programming obvious, but the doing impossible.
112. Computer Science is embarrassed by the computer.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
17. If a listener nods his head when you're explaining your program, wake him up.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
11. If you have a procedure with ten parameters, you probably missed some.
7. It is easier to write an incorrect program than understand a correct one.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
27. Once you understand how to write a program get someone else to write it.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
111. Why did the Roman Empire collapse? What is Latin for office automation?
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
41. Some programming languages manage to absorb change, but withstand progress.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
31. Simplicity does not precede complexity, but follows it.
105. You can't communicate complexity, only an awareness of it.
115. Most people find the concept of programming obvious, but the doing impossible.
40. There are two ways to write error-free programs; only the third one works.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
115. Most people find the concept of programming obvious, but the doing impossible.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
72. An adequate bootstrap is a contradiction in terms.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
110. Editing is a rewording activity.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
57. It is easier to change the specification to fit the program than vice versa.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
119. Programming is an unnatural act.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
55. A LISP programmer knows the value of everything, but the cost of nothing.
18. A program without a loop and a structured variable isn't worth writing.
66. Making something variable is easy. Controlling duration of constancy is the trick.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
4. Every program is a part of some other program and rarely fits.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
46. Like punning, programming is a play on words.
31. Simplicity does not precede complexity, but follows it.
62. In computing, invariants are ephemeral.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
95. Don't have good ideas if you aren't willing to be responsible for them.
27. Once you understand how to write a program get someone else to write it.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
43. In software systems, it is often the early bird that makes the worm.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
21. Optimization hinders evolution.
100. We will never run out of things to program as long as there is a single program around.
76. It is the user who should parameterize procedures, not their creators.
40. There are two ways to write error-free programs; only the third one works.
108. Whenever two programmers meet to criticize their programs, both are silent.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
119. Programming is an unnatural act.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
21. Optimization hinders evolution.
43. In software systems, it is often the early bird that makes the worm.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
105. You can't communicate complexity, only an awareness of it.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
41. Some programming languages manage to absorb change, but withstand progress.
14. In the long run every program becomes rococo - then rubble.
100. We will never run out of things to program as long as there is a single program around.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
27. Once you understand how to write a program get someone else to write it.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
72. An adequate bootstrap is a contradiction in terms.
90. Computation has made the tree flower.
23. To understand a program you must become both the machine and the program.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
38. Structured Programming supports the law of the excluded middle.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
23. To understand a program you must become both the machine and the program.
79. A year spent in artificial intelligence is enough to make one believe in God.
46. Like punning, programming is a play on words.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
103. Purely applicative languages are poorly applicable.
61. In programming, as in everything else, to be in error is to be reborn.
72. An adequate bootstrap is a contradiction in terms.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
8. A programming language is low level when its programs require attention to the irrelevant.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
76. It is the user who should parameterize procedures, not their creators.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
4. Every program is a part of some other program and rarely fits.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
47. As Will Rogers would have said, "There is no such thing as a free variable."
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
115. Most people find the concept of programming obvious, but the doing impossible.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
59. In English every word can be verbed. Would that it were so in our programming languages.
47. As Will Rogers would have said, "There is no such thing as a free variable."
40. There are two ways to write error-free programs; only the third one works.
110. Editing is a rewording activity.
100. We will never run out of things to program as long as there is a single program around.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
96. Computers don't introduce order anywhere as much as they expose opportunities.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
105. You can't communicate complexity, only an awareness of it.
78. If your computer speaks English, it was probably made in Japan.
119. Programming is an unnatural act.
79. A year spent in artificial intelligence is enough to make one believe in God.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
63. When we write programs that "learn", it turns out that we do and they don't.
46. Like punning, programming is a play on words.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
78. If your computer speaks English, it was probably made in Japan.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
47. As Will Rogers would have said, "There is no such thing as a free variable."
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
79. A year spent in artificial intelligence is enough to make one believe in God.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
22. A good system can't have a weak command language.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
4. Every program is a part of some other program and rarely fits.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
79. A year spent in artificial intelligence is enough to make one believe in God.
12. Recursion is the root of computation since it trades description for time.
12. Recursion is the root of computation since it trades description for time.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
15. Everything should be built top-down, except the first time.
114. Within a computer natural language is unnatural.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
66. Making something variable is easy. Controlling duration of constancy is the trick.
27. Once you understand how to write a program get someone else to write it.
119. Programming is an unnatural act.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
114. Within a computer natural language is unnatural.
79. A year spent in artificial intelligence is enough to make one believe in God.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
40. There are two ways to write error-free programs; only the third one works.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
112. Computer Science is embarrassed by the computer.
27. Once you understand how to write a program get someone else to write it.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
18. A program without a loop and a structured variable isn't worth writing.
17. If a listener nods his head when you're explaining your program, wake him up.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
57. It is easier to change the specification to fit the program than vice versa.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
76. It is the user who should parameterize procedures, not their creators.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
15. Everything should be built top-down, except the first time.
102. One can't proceed from the informal to the formal by formal means.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
40. There are two ways to write error-free programs; only the third one works.
112. Computer Science is embarrassed by the computer.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
23. To understand a program you must become both the machine and the program.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
79. A year spent in artificial intelligence is enough to make one believe in God.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
60. In seeking the unattainable, simplicity only gets in the way.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
15. Everything should be built top-down, except the first time.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
38. Structured Programming supports the law of the excluded middle.
63. When we write programs that "learn", it turns out that we do and they don't.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
40. There are two ways to write error-free programs; only the third one works.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
103. Purely applicative languages are poorly applicable.
79. A year spent in artificial intelligence is enough to make one believe in God.
102. One can't proceed from the informal to the formal by formal means.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
105. You can't communicate complexity, only an awareness of it.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
98. In computing, the mean time to failure keeps getting shorter.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
78. If your computer speaks English, it was probably made in Japan.
108. Whenever two programmers meet to criticize their programs, both are silent.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
14. In the long run every program becomes rococo - then rubble.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
31. Simplicity does not precede complexity, but follows it.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
63. When we write programs that "learn", it turns out that we do and they don't.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
11. If you have a procedure with ten parameters, you probably missed some.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
27. Once you understand how to write a program get someone else to write it.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
40. There are two ways to write error-free programs; only the third one works.
57. It is easier to change the specification to fit the program than vice versa.
119. Programming is an unnatural act.
27. Once you understand how to write a program get someone else to write it.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
46. Like punning, programming is a play on words.
22. A good system can't have a weak command language.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
98. In computing, the mean time to failure keeps getting shorter.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
17. If a listener nods his head when you're explaining your program, wake him up.
105. You can't communicate complexity, only an awareness of it.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
78. If your computer speaks English, it was probably made in Japan.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
27. Once you understand how to write a program get someone else to write it.
18. A program without a loop and a structured variable isn't worth writing.
110. Editing is a rewording activity.
4. Every program is a part of some other program and rarely fits.
78. If your computer speaks English, it was probably made in Japan.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
23. To understand a program you must become both the machine and the program.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
1. One man's constant is another man's variable.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
55. A LISP programmer knows the value of everything, but the cost of nothing.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
96. Computers don't introduce order anywhere as much as they expose opportunities.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
100. We will never run out of things to program as long as there is a single program around.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
11. If you have a procedure with ten parameters, you probably missed some.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
11. If you have a procedure with ten parameters, you probably missed some.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
102. One can't proceed from the informal to the formal by formal means.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
98. In computing, the mean time to failure keeps getting shorter.
72. An adequate bootstrap is a contradiction in terms.
112. Computer Science is embarrassed by the computer.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
114. Within a computer natural language is unnatural.
61. In programming, as in everything else, to be in error is to be reborn.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
27. Once you understand how to write a program get someone else to write it.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
7. It is easier to write an incorrect program than understand a correct one.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
40. There are two ways to write error-free programs; only the third one works.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
1. One man's constant is another man's variable.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
14. In the long run every program becomes rococo - then rubble.
76. It is the user who should parameterize procedures, not their creators.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
21. Optimization hinders evolution.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
8. A programming language is low level when its programs require attention to the irrelevant.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
114. Within a computer natural language is unnatural.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
40. There are two ways to write error-free programs; only the third one works.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
110. Editing is a rewording activity.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
104. The proof of a system's value is its existence.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
47. As Will Rogers would have said, "There is no such thing as a free variable."
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
76. It is the user who should parameterize procedures, not their creators.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
22. A good system can't have a weak command language.
17. If a listener nods his head when you're explaining your program, wake him up.
98. In computing, the mean time to failure keeps getting shorter.
115. Most people find the concept of programming obvious, but the doing impossible.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
12. Recursion is the root of computation since it trades description for time.
60. In seeking the unattainable, simplicity only gets in the way.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
119. Programming is an unnatural act.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
105. You can't communicate complexity, only an awareness of it.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
76. It is the user who should parameterize procedures, not their creators.
95. Don't have good ideas if you aren't willing to be responsible for them.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
79. A year spent in artificial intelligence is enough to make one believe in God.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
43. In software systems, it is often the early bird that makes the worm.
46. Like punning, programming is a play on words.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
60. In seeking the unattainable, simplicity only gets in the way.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
31. Simplicity does not precede complexity, but follows it.
27. Once you understand how to write a program get someone else to write it.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
14. In the long run every program becomes rococo - then rubble.
18. A program without a loop and a structured variable isn't worth writing.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
110. Editing is a rewording activity.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
31. Simplicity does not precede complexity, but follows it.
43. In software systems, it is often the early bird that makes the worm.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
40. There are two ways to write error-free programs; only the third one works.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
27. Once you understand how to write a program get someone else to write it.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
40. There are two ways to write error-free programs; only the third one works.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
4. Every program is a part of some other program and rarely fits.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
78. If your computer speaks English, it was probably made in Japan.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
23. To understand a program you must become both the machine and the program.
21. Optimization hinders evolution.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
1. One man's constant is another man's variable.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
114. Within a computer natural language is unnatural.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
21. Optimization hinders evolution.
8. A programming language is low level when its programs require attention to the irrelevant.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
61. In programming, as in everything else, to be in error is to be reborn.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
17. If a listener nods his head when you're explaining your program, wake him up.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
60. In seeking the unattainable, simplicity only gets in the way.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
112. Computer Science is embarrassed by the computer.
17. If a listener nods his head when you're explaining your program, wake him up.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
119. Programming is an unnatural act.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
46. Like punning, programming is a play on words.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
41. Some programming languages manage to absorb change, but withstand progress.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
21. Optimization hinders evolution.
57. It is easier to change the specification to fit the program than vice versa.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
72. An adequate bootstrap is a contradiction in terms.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
66. Making something variable is easy. Controlling duration of constancy is the trick.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
41. Some programming languages manage to absorb change, but withstand progress.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
18. A program without a loop and a structured variable isn't worth writing.
96. Computers don't introduce order anywhere as much as they expose opportunities.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
23. To understand a program you must become both the machine and the program.
55. A LISP programmer knows the value of everything, but the cost of nothing.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
103. Purely applicative languages are poorly applicable.
108. Whenever two programmers meet to criticize their programs, both are silent.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
14. In the long run every program becomes rococo - then rubble.
60. In seeking the unattainable, simplicity only gets in the way.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
61. In programming, as in everything else, to be in error is to be reborn.
119. Programming is an unnatural act.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
72. An adequate bootstrap is a contradiction in terms.
108. Whenever two programmers meet to criticize their programs, both are silent.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
62. In computing, invariants are ephemeral.
76. It is the user who should parameterize procedures, not their creators.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
111. Why did the Roman Empire collapse? What is Latin for office automation?
17. If a listener nods his head when you're explaining your program, wake him up.
103. Purely applicative languages are poorly applicable.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
110. Editing is a rewording activity.
66. Making something variable is easy. Controlling duration of constancy is the trick.
108. Whenever two programmers meet to criticize their programs, both are silent.
46. Like punning, programming is a play on words.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
19. A language that doesn't affect the way you think about programming, is not worth knowing.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
66. Making something variable is easy. Controlling duration of constancy is the trick.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
23. To understand a program you must become both the machine and the program.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
47. As Will Rogers would have said, "There is no such thing as a free variable."
100. We will never run out of things to program as long as there is a single program around.
60. In seeking the unattainable, simplicity only gets in the way.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
47. As Will Rogers would have said, "There is no such thing as a free variable."
102. One can't proceed from the informal to the formal by formal means.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
115. Most people find the concept of programming obvious, but the doing impossible.
100. We will never run out of things to program as long as there is a single program around.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
78. If your computer speaks English, it was probably made in Japan.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
21. Optimization hinders evolution.
98. In computing, the mean time to failure keeps getting shorter.
98. In computing, the mean time to failure keeps getting shorter.
60. In seeking the unattainable, simplicity only gets in the way.
4. Every program is a part of some other program and rarely fits.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
40. There are two ways to write error-free programs; only the third one works.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
95. Don't have good ideas if you aren't willing to be responsible for them.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
17. If a listener nods his head when you're explaining your program, wake him up.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
18. A program without a loop and a structured variable isn't worth writing.
108. Whenever two programmers meet to criticize their programs, both are silent.
78. If your computer speaks English, it was probably made in Japan.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
41. Some programming languages manage to absorb change, but withstand progress.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
14. In the long run every program becomes rococo - then rubble.
96. Computers don't introduce order anywhere as much as they expose opportunities.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
110. Editing is a rewording activity.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
102. One can't proceed from the informal to the formal by formal means.
47. As Will Rogers would have said, "There is no such thing as a free variable."
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
95. Don't have good ideas if you aren't willing to be responsible for them.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
38. Structured Programming supports the law of the excluded middle.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
22. A good system can't have a weak command language.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
18. A program without a loop and a structured variable isn't worth writing.
114. Within a computer natural language is unnatural.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
7. It is easier to write an incorrect program than understand a correct one.
14. In the long run every program becomes rococo - then rubble.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
43. In software systems, it is often the early bird that makes the worm.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
15. Everything should be built top-down, except the first time.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
8. A programming language is low level when its programs require attention to the irrelevant.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
115. Most people find the concept of programming obvious, but the doing impossible.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
57. It is easier to change the specification to fit the program than vice versa.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
31. Simplicity does not precede complexity, but follows it.
55. A LISP programmer knows the value of everything, but the cost of nothing.
15. Everything should be built top-down, except the first time.
8. A programming language is low level when its programs require attention to the irrelevant.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
31. Simplicity does not precede complexity, but follows it.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
96. Computers don't introduce order anywhere as much as they expose opportunities.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
41. Some programming languages manage to absorb change, but withstand progress.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
14. In the long run every program becomes rococo - then rubble.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
95. Don't have good ideas if you aren't willing to be responsible for them.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
63. When we write programs that "learn", it turns out that we do and they don't.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
7. It is easier to write an incorrect program than understand a correct one.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
112. Computer Science is embarrassed by the computer.
62. In computing, invariants are ephemeral.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
17. If a listener nods his head when you're explaining your program, wake him up.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
8. A programming language is low level when its programs require attention to the irrelevant.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
57. It is easier to change the specification to fit the program than vice versa.
11. If you have a procedure with ten parameters, you probably missed some.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
119. Programming is an unnatural act.
43. In software systems, it is often the early bird that makes the worm.
119. Programming is an unnatural act.
100. We will never run out of things to program as long as there is a single program around.
43. In software systems, it is often the early bird that makes the worm.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
43. In software systems, it is often the early bird that makes the worm.
114. Within a computer natural language is unnatural.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
119. Programming is an unnatural act.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
76. It is the user who should parameterize procedures, not their creators.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
72. An adequate bootstrap is a contradiction in terms.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
62. In computing, invariants are ephemeral.
14. In the long run every program becomes rococo - then rubble.
1. One man's constant is another man's variable.
90. Computation has made the tree flower.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
15. Everything should be built top-down, except the first time.
12. Recursion is the root of computation since it trades description for time.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
60. In seeking the unattainable, simplicity only gets in the way.
11. If you have a procedure with ten parameters, you probably missed some.
103. Purely applicative languages are poorly applicable.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
102. One can't proceed from the informal to the formal by formal means.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
8. A programming language is low level when its programs require attention to the irrelevant.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
14. In the long run every program becomes rococo - then rubble.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
47. As Will Rogers would have said, "There is no such thing as a free variable."
40. There are two ways to write error-free programs; only the third one works.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
59. In English every word can be verbed. Would that it were so in our programming languages.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
103. Purely applicative languages are poorly applicable.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
72. An adequate bootstrap is a contradiction in terms.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
22. A good system can't have a weak command language.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
119. Programming is an unnatural act.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
72. An adequate bootstrap is a contradiction in terms.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
1. One man's constant is another man's variable.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
96. Computers don't introduce order anywhere as much as they expose opportunities.
14. In the long run every program becomes rococo - then rubble.
40. There are two ways to write error-free programs; only the third one works.
105. You can't communicate complexity, only an awareness of it.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
57. It is easier to change the specification to fit the program than vice versa.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
4. Every program is a part of some other program and rarely fits.
40. There are two ways to write error-free programs; only the third one works.
17. If a listener nods his head when you're explaining your program, wake him up.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
119. Programming is an unnatural act.
60. In seeking the unattainable, simplicity only gets in the way.
23. To understand a program you must become both the machine and the program.
21. Optimization hinders evolution.
90. Computation has made the tree flower.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
17. If a listener nods his head when you're explaining your program, wake him up.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
100. We will never run out of things to program as long as there is a single program around.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
108. Whenever two programmers meet to criticize their programs, both are silent.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
108. Whenever two programmers meet to criticize their programs, both are silent.
78. If your computer speaks English, it was probably made in Japan.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
38. Structured Programming supports the law of the excluded middle.
119. Programming is an unnatural act.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
103. Purely applicative languages are poorly applicable.
119. Programming is an unnatural act.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
18. A program without a loop and a structured variable isn't worth writing.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
41. Some programming languages manage to absorb change, but withstand progress.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
38. Structured Programming supports the law of the excluded middle.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
66. Making something variable is easy. Controlling duration of constancy is the trick.
12. Recursion is the root of computation since it trades description for time.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
95. Don't have good ideas if you aren't willing to be responsible for them.
3. Syntactic sugar causes cancer of the semicolon.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
23. To understand a program you must become both the machine and the program.
78. If your computer speaks English, it was probably made in Japan.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
3. Syntactic sugar causes cancer of the semicolon.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
41. Some programming languages manage to absorb change, but withstand progress.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
38. Structured Programming supports the law of the excluded middle.
62. In computing, invariants are ephemeral.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
62. In computing, invariants are ephemeral.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
21. Optimization hinders evolution.
76. It is the user who should parameterize procedures, not their creators.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
17. If a listener nods his head when you're explaining your program, wake him up.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
119. Programming is an unnatural act.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
47. As Will Rogers would have said, "There is no such thing as a free variable."
46. Like punning, programming is a play on words.
76. It is the user who should parameterize procedures, not their creators.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
90. Computation has made the tree flower.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
102. One can't proceed from the informal to the formal by formal means.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
11. If you have a procedure with ten parameters, you probably missed some.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
4. Every program is a part of some other program and rarely fits.
62. In computing, invariants are ephemeral.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
114. Within a computer natural language is unnatural.
103. Purely applicative languages are poorly applicable.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
114. Within a computer natural language is unnatural.
18. A program without a loop and a structured variable isn't worth writing.
103. Purely applicative languages are poorly applicable.
59. In English every word can be verbed. Would that it were so in our programming languages.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
12. Recursion is the root of computation since it trades description for time.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
60. In seeking the unattainable, simplicity only gets in the way.
38. Structured Programming supports the law of the excluded middle.
31. Simplicity does not precede complexity, but follows it.
90. Computation has made the tree flower.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
102. One can't proceed from the informal to the formal by formal means.
7. It is easier to write an incorrect program than understand a correct one.
47. As Will Rogers would have said, "There is no such thing as a free variable."
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
90. Computation has made the tree flower.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
114. Within a computer natural language is unnatural.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
105. You can't communicate complexity, only an awareness of it.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
78. If your computer speaks English, it was probably made in Japan.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
1. One man's constant is another man's variable.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
96. Computers don't introduce order anywhere as much as they expose opportunities.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
110. Editing is a rewording activity.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
110. Editing is a rewording activity.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
115. Most people find the concept of programming obvious, but the doing impossible.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
111. Why did the Roman Empire collapse? What is Latin for office automation?
102. One can't proceed from the informal to the formal by formal means.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
108. Whenever two programmers meet to criticize their programs, both are silent.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
15. Everything should be built top-down, except the first time.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
59. In English every word can be verbed. Would that it were so in our programming languages.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
96. Computers don't introduce order anywhere as much as they expose opportunities.
62. In computing, invariants are ephemeral.
14. In the long run every program becomes rococo - then rubble.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
4. Every program is a part of some other program and rarely fits.
1. One man's constant is another man's variable.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
111. Why did the Roman Empire collapse? What is Latin for office automation?
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
103. Purely applicative languages are poorly applicable.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
95. Don't have good ideas if you aren't willing to be responsible for them.
105. You can't communicate complexity, only an awareness of it.
1. One man's constant is another man's variable.
21. Optimization hinders evolution.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
4. Every program is a part of some other program and rarely fits.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
111. Why did the Roman Empire collapse? What is Latin for office automation?
95. Don't have good ideas if you aren't willing to be responsible for them.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
1. One man's constant is another man's variable.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
108. Whenever two programmers meet to criticize their programs, both are silent.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
76. It is the user who should parameterize procedures, not their creators.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
43. In software systems, it is often the early bird that makes the worm.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
100. We will never run out of things to program as long as there is a single program around.
78. If your computer speaks English, it was probably made in Japan.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
100. We will never run out of things to program as long as there is a single program around.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
8. A programming language is low level when its programs require attention to the irrelevant.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
111. Why did the Roman Empire collapse? What is Latin for office automation?
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
72. An adequate bootstrap is a contradiction in terms.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
57. It is easier to change the specification to fit the program than vice versa.
22. A good system can't have a weak command language.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
43. In software systems, it is often the early bird that makes the worm.
8. A programming language is low level when its programs require attention to the irrelevant.
61. In programming, as in everything else, to be in error is to be reborn.
3. Syntactic sugar causes cancer of the semicolon.
95. Don't have good ideas if you aren't willing to be responsible for them.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
110. Editing is a rewording activity.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
22. A good system can't have a weak command language.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
38. Structured Programming supports the law of the excluded middle.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
21. Optimization hinders evolution.
95. Don't have good ideas if you aren't willing to be responsible for them.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
76. It is the user who should parameterize procedures, not their creators.
95. Don't have good ideas if you aren't willing to be responsible for them.
31. Simplicity does not precede complexity, but follows it.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
18. A program without a loop and a structured variable isn't worth writing.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
18. A program without a loop and a structured variable isn't worth writing.
76. It is the user who should parameterize procedures, not their creators.
7. It is easier to write an incorrect program than understand a correct one.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
4. Every program is a part of some other program and rarely fits.
46. Like punning, programming is a play on words.
27. Once you understand how to write a program get someone else to write it.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
111. Why did the Roman Empire collapse? What is Latin for office automation?
3. Syntactic sugar causes cancer of the semicolon.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
115. Most people find the concept of programming obvious, but the doing impossible.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
76. It is the user who should parameterize procedures, not their creators.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
100. We will never run out of things to program as long as there is a single program around.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
60. In seeking the unattainable, simplicity only gets in the way.
11. If you have a procedure with ten parameters, you probably missed some.
38. Structured Programming supports the law of the excluded middle.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
66. Making something variable is easy. Controlling duration of constancy is the trick.
40. There are two ways to write error-free programs; only the third one works.
21. Optimization hinders evolution.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
40. There are two ways to write error-free programs; only the third one works.
41. Some programming languages manage to absorb change, but withstand progress.
15. Everything should be built top-down, except the first time.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
41. Some programming languages manage to absorb change, but withstand progress.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
100. We will never run out of things to program as long as there is a single program around.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
78. If your computer speaks English, it was probably made in Japan.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
98. In computing, the mean time to failure keeps getting shorter.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
95. Don't have good ideas if you aren't willing to be responsible for them.
46. Like punning, programming is a play on words.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
79. A year spent in artificial intelligence is enough to make one believe in God.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
46. Like punning, programming is a play on words.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
60. In seeking the unattainable, simplicity only gets in the way.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
100. We will never run out of things to program as long as there is a single program around.
78. If your computer speaks English, it was probably made in Japan.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
98. In computing, the mean time to failure keeps getting shorter.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
95. Don't have good ideas if you aren't willing to be responsible for them.
18. A program without a loop and a structured variable isn't worth writing.
18. A program without a loop and a structured variable isn't worth writing.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
114. Within a computer natural language is unnatural.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
100. We will never run out of things to program as long as there is a single program around.
105. You can't communicate complexity, only an awareness of it.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
1. One man's constant is another man's variable.
3. Syntactic sugar causes cancer of the semicolon.
66. Making something variable is easy. Controlling duration of constancy is the trick.
100. We will never run out of things to program as long as there is a single program around.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
43. In software systems, it is often the early bird that makes the worm.
3. Syntactic sugar causes cancer of the semicolon.
47. As Will Rogers would have said, "There is no such thing as a free variable."
46. Like punning, programming is a play on words.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
43. In software systems, it is often the early bird that makes the worm.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
61. In programming, as in everything else, to be in error is to be reborn.
8. A programming language is low level when its programs require attention to the irrelevant.
96. Computers don't introduce order anywhere as much as they expose opportunities.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
59. In English every word can be verbed. Would that it were so in our programming languages.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
43. In software systems, it is often the early bird that makes the worm.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
76. It is the user who should parameterize procedures, not their creators.
22. A good system can't have a weak command language.
11. If you have a procedure with ten parameters, you probably missed some.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
100. We will never run out of things to program as long as there is a single program around.
90. Computation has made the tree flower.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
5. If a program manipulates a large amount of data, it does so in a small number of ways.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
55. A LISP programmer knows the value of everything, but the cost of nothing.
108. Whenever two programmers meet to criticize their programs, both are silent.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
8. A programming language is low level when its programs require attention to the irrelevant.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
90. Computation has made the tree flower.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
72. An adequate bootstrap is a contradiction in terms.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
96. Computers don't introduce order anywhere as much as they expose opportunities.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
105. You can't communicate complexity, only an awareness of it.
108. Whenever two programmers meet to criticize their programs, both are silent.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
17. If a listener nods his head when you're explaining your program, wake him up.
78. If your computer speaks English, it was probably made in Japan.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
102. One can't proceed from the informal to the formal by formal means.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
108. Whenever two programmers meet to criticize their programs, both are silent.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
78. If your computer speaks English, it was probably made in Japan.
119. Programming is an unnatural act.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
79. A year spent in artificial intelligence is enough to make one believe in God.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
55. A LISP programmer knows the value of everything, but the cost of nothing.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
100. We will never run out of things to program as long as there is a single program around.
41. Some programming languages manage to absorb change, but withstand progress.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
61. In programming, as in everything else, to be in error is to be reborn.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
72. An adequate bootstrap is a contradiction in terms.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
100. We will never run out of things to program as long as there is a single program around.
112. Computer Science is embarrassed by the computer.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
55. A LISP programmer knows the value of everything, but the cost of nothing.
60. In seeking the unattainable, simplicity only gets in the way.
103. Purely applicative languages are poorly applicable.
114. Within a computer natural language is unnatural.
46. Like punning, programming is a play on words.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
119. Programming is an unnatural act.
103. Purely applicative languages are poorly applicable.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
7. It is easier to write an incorrect program than understand a correct one.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
43. In software systems, it is often the early bird that makes the worm.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
55. A LISP programmer knows the value of everything, but the cost of nothing.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
17. If a listener nods his head when you're explaining your program, wake him up.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
96. Computers don't introduce order anywhere as much as they expose opportunities.
57. It is easier to change the specification to fit the program than vice versa.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
18. A program without a loop and a structured variable isn't worth writing.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
3. Syntactic sugar causes cancer of the semicolon.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
112. Computer Science is embarrassed by the computer.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
96. Computers don't introduce order anywhere as much as they expose opportunities.
96. Computers don't introduce order anywhere as much as they expose opportunities.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
76. It is the user who should parameterize procedures, not their creators.
38. Structured Programming supports the law of the excluded middle.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
105. You can't communicate complexity, only an awareness of it.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
27. Once you understand how to write a program get someone else to write it.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
21. Optimization hinders evolution.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
22. A good system can't have a weak command language.
111. Why did the Roman Empire collapse? What is Latin for office automation?
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
21. Optimization hinders evolution.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
3. Syntactic sugar causes cancer of the semicolon.
57. It is easier to change the specification to fit the program than vice versa.
11. If you have a procedure with ten parameters, you probably missed some.
100. We will never run out of things to program as long as there is a single program around.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
21. Optimization hinders evolution.
14. In the long run every program becomes rococo - then rubble.
100. We will never run out of things to program as long as there is a single program around.
119. Programming is an unnatural act.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
60. In seeking the unattainable, simplicity only gets in the way.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
17. If a listener nods his head when you're explaining your program, wake him up.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
21. Optimization hinders evolution.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
14. In the long run every program becomes rococo - then rubble.
112. Computer Science is embarrassed by the computer.
115. Most people find the concept of programming obvious, but the doing impossible.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
43. In software systems, it is often the early bird that makes the worm.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
96. Computers don't introduce order anywhere as much as they expose opportunities.
119. Programming is an unnatural act.
79. A year spent in artificial intelligence is enough to make one believe in God.
111. Why did the Roman Empire collapse? What is Latin for office automation?
111. Why did the Roman Empire collapse? What is Latin for office automation?
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
72. An adequate bootstrap is a contradiction in terms.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
66. Making something variable is easy. Controlling duration of constancy is the trick.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
1. One man's constant is another man's variable.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
103. Purely applicative languages are poorly applicable.
66. Making something variable is easy. Controlling duration of constancy is the trick.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
57. It is easier to change the specification to fit the program than vice versa.
62. In computing, invariants are ephemeral.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
47. As Will Rogers would have said, "There is no such thing as a free variable."
90. Computation has made the tree flower.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
7. It is easier to write an incorrect program than understand a correct one.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
61. In programming, as in everything else, to be in error is to be reborn.
96. Computers don't introduce order anywhere as much as they expose opportunities.
18. A program without a loop and a structured variable isn't worth writing.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
104. The proof of a system's value is its existence.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
21. Optimization hinders evolution.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
112. Computer Science is embarrassed by the computer.
47. As Will Rogers would have said, "There is no such thing as a free variable."
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
57. It is easier to change the specification to fit the program than vice versa.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
79. A year spent in artificial intelligence is enough to make one believe in God.
46. Like punning, programming is a play on words.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
31. Simplicity does not precede complexity, but follows it.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
55. A LISP programmer knows the value of everything, but the cost of nothing.
23. To understand a program you must become both the machine and the program.
21. Optimization hinders evolution.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
66. Making something variable is easy. Controlling duration of constancy is the trick.
59. In English every word can be verbed. Would that it were so in our programming languages.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
114. Within a computer natural language is unnatural.
43. In software systems, it is often the early bird that makes the worm.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
31. Simplicity does not precede complexity, but follows it.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
107. The debate rages on: is PL/I Bachtrian or Dromedary?
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
23. To understand a program you must become both the machine and the program.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
22. A good system can't have a weak command language.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
108. Whenever two programmers meet to criticize their programs, both are silent.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
110. Editing is a rewording activity.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
55. A LISP programmer knows the value of everything, but the cost of nothing.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
31. Simplicity does not precede complexity, but follows it.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
119. Programming is an unnatural act.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
7. It is easier to write an incorrect program than understand a correct one.
102. One can't proceed from the informal to the formal by formal means.
66. Making something variable is easy. Controlling duration of constancy is the trick.
98. In computing, the mean time to failure keeps getting shorter.
78. If your computer speaks English, it was probably made in Japan.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
110. Editing is a rewording activity.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
114. Within a computer natural language is unnatural.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
15. Everything should be built top-down, except the first time.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
8. A programming language is low level when its programs require attention to the irrelevant.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
55. A LISP programmer knows the value of everything, but the cost of nothing.
31. Simplicity does not precede complexity, but follows it.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
23. To understand a program you must become both the machine and the program.
41. Some programming languages manage to absorb change, but withstand progress.
63. When we write programs that "learn", it turns out that we do and they don't.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
46. Like punning, programming is a play on words.
103. Purely applicative languages are poorly applicable.
4. Every program is a part of some other program and rarely fits.
78. If your computer speaks English, it was probably made in Japan.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
105. You can't communicate complexity, only an awareness of it.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
107. The debate rages on: is PL/I Bachtrian or Dromedary?
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
104. The proof of a system's value is its existence.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
40. There are two ways to write error-free programs; only the third one works.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
3. Syntactic sugar causes cancer of the semicolon.
115. Most people find the concept of programming obvious, but the doing impossible.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
12. Recursion is the root of computation since it trades description for time.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
103. Purely applicative languages are poorly applicable.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
111. Why did the Roman Empire collapse? What is Latin for office automation?
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
66. Making something variable is easy. Controlling duration of constancy is the trick.
22. A good system can't have a weak command language.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
15. Everything should be built top-down, except the first time.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
41. Some programming languages manage to absorb change, but withstand progress.
23. To understand a program you must become both the machine and the program.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
66. Making something variable is easy. Controlling duration of constancy is the trick.
47. As Will Rogers would have said, "There is no such thing as a free variable."
27. Once you understand how to write a program get someone else to write it.
31. Simplicity does not precede complexity, but follows it.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
3. Syntactic sugar causes cancer of the semicolon.
11. If you have a procedure with ten parameters, you probably missed some.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
112. Computer Science is embarrassed by the computer.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
114. Within a computer natural language is unnatural.
7. It is easier to write an incorrect program than understand a correct one.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
103. Purely applicative languages are poorly applicable.
27. Once you understand how to write a program get someone else to write it.
72. An adequate bootstrap is a contradiction in terms.
7. It is easier to write an incorrect program than understand a correct one.
103. Purely applicative languages are poorly applicable.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
3. Syntactic sugar causes cancer of the semicolon.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
31. Simplicity does not precede complexity, but follows it.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
40. There are two ways to write error-free programs; only the third one works.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
60. In seeking the unattainable, simplicity only gets in the way.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
12. Recursion is the root of computation since it trades description for time.
78. If your computer speaks English, it was probably made in Japan.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
27. Once you understand how to write a program get someone else to write it.
115. Most people find the concept of programming obvious, but the doing impossible.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
108. Whenever two programmers meet to criticize their programs, both are silent.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
110. Editing is a rewording activity.
62. In computing, invariants are ephemeral.
61. In programming, as in everything else, to be in error is to be reborn.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
103. Purely applicative languages are poorly applicable.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
23. To understand a program you must become both the machine and the program.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
61. In programming, as in everything else, to be in error is to be reborn.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
40. There are two ways to write error-free programs; only the third one works.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
112. Computer Science is embarrassed by the computer.
114. Within a computer natural language is unnatural.
102. One can't proceed from the informal to the formal by formal means.
60. In seeking the unattainable, simplicity only gets in the way.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
1. One man's constant is another man's variable.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
7. It is easier to write an incorrect program than understand a correct one.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
46. Like punning, programming is a play on words.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
23. To understand a program you must become both the machine and the program.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
41. Some programming languages manage to absorb change, but withstand progress.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
41. Some programming languages manage to absorb change, but withstand progress.
8. A programming language is low level when its programs require attention to the irrelevant.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
112. Computer Science is embarrassed by the computer.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
4. Every program is a part of some other program and rarely fits.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
76. It is the user who should parameterize procedures, not their creators.
17. If a listener nods his head when you're explaining your program, wake him up.
61. In programming, as in everything else, to be in error is to be reborn.
43. In software systems, it is often the early bird that makes the worm.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
7. It is easier to write an incorrect program than understand a correct one.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
104. The proof of a system's value is its existence.
38. Structured Programming supports the law of the excluded middle.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
104. The proof of a system's value is its existence.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
104. The proof of a system's value is its existence.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
103. Purely applicative languages are poorly applicable.
62. In computing, invariants are ephemeral.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
61. In programming, as in everything else, to be in error is to be reborn.
4. Every program is a part of some other program and rarely fits.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
102. One can't proceed from the informal to the formal by formal means.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
38. Structured Programming supports the law of the excluded middle.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
1. One man's constant is another man's variable.
43. In software systems, it is often the early bird that makes the worm.
8. A programming language is low level when its programs require attention to the irrelevant.
14. In the long run every program becomes rococo - then rubble.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
66. Making something variable is easy. Controlling duration of constancy is the trick.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
18. A program without a loop and a structured variable isn't worth writing.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
19. A language that doesn't affect the way you think about programming, is not worth knowing.
90. Computation has made the tree flower.
22. A good system can't have a weak command language.
62. In computing, invariants are ephemeral.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
60. In seeking the unattainable, simplicity only gets in the way.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
66. Making something variable is easy. Controlling duration of constancy is the trick.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
79. A year spent in artificial intelligence is enough to make one believe in God.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
31. Simplicity does not precede complexity, but follows it.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
115. Most people find the concept of programming obvious, but the doing impossible.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
3. Syntactic sugar causes cancer of the semicolon.
47. As Will Rogers would have said, "There is no such thing as a free variable."
4. Every program is a part of some other program and rarely fits.
1. One man's constant is another man's variable.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
105. You can't communicate complexity, only an awareness of it.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
108. Whenever two programmers meet to criticize their programs, both are silent.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
41. Some programming languages manage to absorb change, but withstand progress.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
66. Making something variable is easy. Controlling duration of constancy is the trick.
3. Syntactic sugar causes cancer of the semicolon.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
19. A language that doesn't affect the way you think about programming, is not worth knowing.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
3. Syntactic sugar causes cancer of the semicolon.
7. It is easier to write an incorrect program than understand a correct one.
12. Recursion is the root of computation since it trades description for time.
119. Programming is an unnatural act.
11. If you have a procedure with ten parameters, you probably missed some.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
100. We will never run out of things to program as long as there is a single program around.
110. Editing is a rewording activity.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
12. Recursion is the root of computation since it trades description for time.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
79. A year spent in artificial intelligence is enough to make one believe in God.
63. When we write programs that "learn", it turns out that we do and they don't.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
55. A LISP programmer knows the value of everything, but the cost of nothing.
111. Why did the Roman Empire collapse? What is Latin for office automation?
15. Everything should be built top-down, except the first time.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
72. An adequate bootstrap is a contradiction in terms.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
18. A program without a loop and a structured variable isn't worth writing.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
18. A program without a loop and a structured variable isn't worth writing.
15. Everything should be built top-down, except the first time.
62. In computing, invariants are ephemeral.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
102. One can't proceed from the informal to the formal by formal means.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
57. It is easier to change the specification to fit the program than vice versa.
108. Whenever two programmers meet to criticize their programs, both are silent.
78. If your computer speaks English, it was probably made in Japan.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
41. Some programming languages manage to absorb change, but withstand progress.
66. Making something variable is easy. Controlling duration of constancy is the trick.
18. A program without a loop and a structured variable isn't worth writing.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
100. We will never run out of things to program as long as there is a single program around.
90. Computation has made the tree flower.
18. A program without a loop and a structured variable isn't worth writing.
12. Recursion is the root of computation since it trades description for time.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
96. Computers don't introduce order anywhere as much as they expose opportunities.
15. Everything should be built top-down, except the first time.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
115. Most people find the concept of programming obvious, but the doing impossible.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
78. If your computer speaks English, it was probably made in Japan.
112. Computer Science is embarrassed by the computer.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
112. Computer Science is embarrassed by the computer.
63. When we write programs that "learn", it turns out that we do and they don't.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
27. Once you understand how to write a program get someone else to write it.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
61. In programming, as in everything else, to be in error is to be reborn.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
63. When we write programs that "learn", it turns out that we do and they don't.
105. You can't communicate complexity, only an awareness of it.
31. Simplicity does not precede complexity, but follows it.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
60. In seeking the unattainable, simplicity only gets in the way.
112. Computer Science is embarrassed by the computer.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
114. Within a computer natural language is unnatural.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
38. Structured Programming supports the law of the excluded middle.
31. Simplicity does not precede complexity, but follows it.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
21. Optimization hinders evolution.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
22. A good system can't have a weak command language.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
43. In software systems, it is often the early bird that makes the worm.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
111. Why did the Roman Empire collapse? What is Latin for office automation?
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
12. Recursion is the root of computation since it trades description for time.
59. In English every word can be verbed. Would that it were so in our programming languages.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
78. If your computer speaks English, it was probably made in Japan.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
41. Some programming languages manage to absorb change, but withstand progress.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
59. In English every word can be verbed. Would that it were so in our programming languages.
105. You can't communicate complexity, only an awareness of it.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
7. It is easier to write an incorrect program than understand a correct one.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
27. Once you understand how to write a program get someone else to write it.
31. Simplicity does not precede complexity, but follows it.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
7. It is easier to write an incorrect program than understand a correct one.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
59. In English every word can be verbed. Would that it were so in our programming languages.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
17. If a listener nods his head when you're explaining your program, wake him up.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
61. In programming, as in everything else, to be in error is to be reborn.
103. Purely applicative languages are poorly applicable.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
114. Within a computer natural language is unnatural.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
62. In computing, invariants are ephemeral.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
14. In the long run every program becomes rococo - then rubble.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
21. Optimization hinders evolution.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
41. Some programming languages manage to absorb change, but withstand progress.
21. Optimization hinders evolution.
60. In seeking the unattainable, simplicity only gets in the way.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
3. Syntactic sugar causes cancer of the semicolon.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
21. Optimization hinders evolution.
103. Purely applicative languages are poorly applicable.
3. Syntactic sugar causes cancer of the semicolon.
79. A year spent in artificial intelligence is enough to make one believe in God.
4. Every program is a part of some other program and rarely fits.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
18. A program without a loop and a structured variable isn't worth writing.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
57. It is easier to change the specification to fit the program than vice versa.
1. One man's constant is another man's variable.
41. Some programming languages manage to absorb change, but withstand progress.
41. Some programming languages manage to absorb change, but withstand progress.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
78. If your computer speaks English, it was probably made in Japan.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
41. Some programming languages manage to absorb change, but withstand progress.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
47. As Will Rogers would have said, "There is no such thing as a free variable."
46. Like punning, programming is a play on words.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
79. A year spent in artificial intelligence is enough to make one believe in God.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
31. Simplicity does not precede complexity, but follows it.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
62. In computing, invariants are ephemeral.
103. Purely applicative languages are poorly applicable.
38. Structured Programming supports the law of the excluded middle.
40. There are two ways to write error-free programs; only the third one works.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
47. As Will Rogers would have said, "There is no such thing as a free variable."
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
110. Editing is a rewording activity.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
104. The proof of a system's value is its existence.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
102. One can't proceed from the informal to the formal by formal means.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
47. As Will Rogers would have said, "There is no such thing as a free variable."
78. If your computer speaks English, it was probably made in Japan.
111. Why did the Roman Empire collapse? What is Latin for office automation?
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
7. It is easier to write an incorrect program than understand a correct one.
27. Once you understand how to write a program get someone else to write it.
96. Computers don't introduce order anywhere as much as they expose opportunities.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
102. One can't proceed from the informal to the formal by formal means.
100. We will never run out of things to program as long as there is a single program around.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
15. Everything should be built top-down, except the first time.
55. A LISP programmer knows the value of everything, but the cost of nothing.
115. Most people find the concept of programming obvious, but the doing impossible.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
114. Within a computer natural language is unnatural.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
46. Like punning, programming is a play on words.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
100. We will never run out of things to program as long as there is a single program around.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
63. When we write programs that "learn", it turns out that we do and they don't.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
63. When we write programs that "learn", it turns out that we do and they don't.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
90. Computation has made the tree flower.
40. There are two ways to write error-free programs; only the third one works.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
112. Computer Science is embarrassed by the computer.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
12. Recursion is the root of computation since it trades description for time.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
59. In English every word can be verbed. Would that it were so in our programming languages.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
18. A program without a loop and a structured variable isn't worth writing.
102. One can't proceed from the informal to the formal by formal means.
95. Don't have good ideas if you aren't willing to be responsible for them.
18. A program without a loop and a structured variable isn't worth writing.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
14. In the long run every program becomes rococo - then rubble.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
27. Once you understand how to write a program get someone else to write it.
104. The proof of a system's value is its existence.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
100. We will never run out of things to program as long as there is a single program around.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
111. Why did the Roman Empire collapse? What is Latin for office automation?
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
62. In computing, invariants are ephemeral.
102. One can't proceed from the informal to the formal by formal means.
38. Structured Programming supports the law of the excluded middle.
46. Like punning, programming is a play on words.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
59. In English every word can be verbed. Would that it were so in our programming languages.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
47. As Will Rogers would have said, "There is no such thing as a free variable."
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
110. Editing is a rewording activity.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
11. If you have a procedure with ten parameters, you probably missed some.
18. A program without a loop and a structured variable isn't worth writing.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
46. Like punning, programming is a play on words.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
105. You can't communicate complexity, only an awareness of it.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
57. It is easier to change the specification to fit the program than vice versa.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
38. Structured Programming supports the law of the excluded middle.
21. Optimization hinders evolution.
41. Some programming languages manage to absorb change, but withstand progress.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
111. Why did the Roman Empire collapse? What is Latin for office automation?
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
111. Why did the Roman Empire collapse? What is Latin for office automation?
105. You can't communicate complexity, only an awareness of it.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
17. If a listener nods his head when you're explaining your program, wake him up.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
72. An adequate bootstrap is a contradiction in terms.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
23. To understand a program you must become both the machine and the program.
100. We will never run out of things to program as long as there is a single program around.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
12. Recursion is the root of computation since it trades description for time.
3. Syntactic sugar causes cancer of the semicolon.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
100. We will never run out of things to program as long as there is a single program around.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
12. Recursion is the root of computation since it trades description for time.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
11. If you have a procedure with ten parameters, you probably missed some.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
47. As Will Rogers would have said, "There is no such thing as a free variable."
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
119. Programming is an unnatural act.
90. Computation has made the tree flower.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
90. Computation has made the tree flower.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
95. Don't have good ideas if you aren't willing to be responsible for them.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
59. In English every word can be verbed. Would that it were so in our programming languages.
23. To understand a program you must become both the machine and the program.
40. There are two ways to write error-free programs; only the third one works.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
18. A program without a loop and a structured variable isn't worth writing.
22. A good system can't have a weak command language.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
15. Everything should be built top-down, except the first time.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
61. In programming, as in everything else, to be in error is to be reborn.
115. Most people find the concept of programming obvious, but the doing impossible.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
104. The proof of a system's value is its existence.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
62. In computing, invariants are ephemeral.
14. In the long run every program becomes rococo - then rubble.
1. One man's constant is another man's variable.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
102. One can't proceed from the informal to the formal by formal means.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
47. As Will Rogers would have said, "There is no such thing as a free variable."
72. An adequate bootstrap is a contradiction in terms.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
112. Computer Science is embarrassed by the computer.
79. A year spent in artificial intelligence is enough to make one believe in God.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
40. There are two ways to write error-free programs; only the third one works.
110. Editing is a rewording activity.
114. Within a computer natural language is unnatural.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
112. Computer Science is embarrassed by the computer.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
63. When we write programs that "learn", it turns out that we do and they don't.
63. When we write programs that "learn", it turns out that we do and they don't.
102. One can't proceed from the informal to the formal by formal means.
61. In programming, as in everything else, to be in error is to be reborn.
60. In seeking the unattainable, simplicity only gets in the way.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
60. In seeking the unattainable, simplicity only gets in the way.
62. In computing, invariants are ephemeral.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
18. A program without a loop and a structured variable isn't worth writing.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
4. Every program is a part of some other program and rarely fits.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
98. In computing, the mean time to failure keeps getting shorter.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
79. A year spent in artificial intelligence is enough to make one believe in God.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
63. When we write programs that "learn", it turns out that we do and they don't.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
59. In English every word can be verbed. Would that it were so in our programming languages.
90. Computation has made the tree flower.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
63. When we write programs that "learn", it turns out that we do and they don't.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
23. To understand a program you must become both the machine and the program.
14. In the long run every program becomes rococo - then rubble.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
66. Making something variable is easy. Controlling duration of constancy is the trick.
18. A program without a loop and a structured variable isn't worth writing.
104. The proof of a system's value is its existence.
38. Structured Programming supports the law of the excluded middle.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
40. There are two ways to write error-free programs; only the third one works.
22. A good system can't have a weak command language.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
57. It is easier to change the specification to fit the program than vice versa.
43. In software systems, it is often the early bird that makes the worm.
57. It is easier to change the specification to fit the program than vice versa.
115. Most people find the concept of programming obvious, but the doing impossible.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
38. Structured Programming supports the law of the excluded middle.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
104. The proof of a system's value is its existence.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
46. Like punning, programming is a play on words.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
103. Purely applicative languages are poorly applicable.
72. An adequate bootstrap is a contradiction in terms.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
95. Don't have good ideas if you aren't willing to be responsible for them.
63. When we write programs that "learn", it turns out that we do and they don't.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
31. Simplicity does not precede complexity, but follows it.
108. Whenever two programmers meet to criticize their programs, both are silent.
79. A year spent in artificial intelligence is enough to make one believe in God.
8. A programming language is low level when its programs require attention to the irrelevant.
12. Recursion is the root of computation since it trades description for time.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
17. If a listener nods his head when you're explaining your program, wake him up.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
21. Optimization hinders evolution.
108. Whenever two programmers meet to criticize their programs, both are silent.
4. Every program is a part of some other program and rarely fits.
40. There are two ways to write error-free programs; only the third one works.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
1. One man's constant is another man's variable.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
111. Why did the Roman Empire collapse? What is Latin for office automation?
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
55. A LISP programmer knows the value of everything, but the cost of nothing.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
38. Structured Programming supports the law of the excluded middle.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
60. In seeking the unattainable, simplicity only gets in the way.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
3. Syntactic sugar causes cancer of the semicolon.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
63. When we write programs that "learn", it turns out that we do and they don't.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
18. A program without a loop and a structured variable isn't worth writing.
63. When we write programs that "learn", it turns out that we do and they don't.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
100. We will never run out of things to program as long as there is a single program around.
72. An adequate bootstrap is a contradiction in terms.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
63. When we write programs that "learn", it turns out that we do and they don't.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
21. Optimization hinders evolution.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
8. A programming language is low level when its programs require attention to the irrelevant.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
72. An adequate bootstrap is a contradiction in terms.
38. Structured Programming supports the law of the excluded middle.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
8. A programming language is low level when its programs require attention to the irrelevant.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
112. Computer Science is embarrassed by the computer.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
63. When we write programs that "learn", it turns out that we do and they don't.
27. Once you understand how to write a program get someone else to write it.
17. If a listener nods his head when you're explaining your program, wake him up.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
23. To understand a program you must become both the machine and the program.
41. Some programming languages manage to absorb change, but withstand progress.
11. If you have a procedure with ten parameters, you probably missed some.
104. The proof of a system's value is its existence.
79. A year spent in artificial intelligence is enough to make one believe in God.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
110. Editing is a rewording activity.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
1. One man's constant is another man's variable.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
1. One man's constant is another man's variable.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
21. Optimization hinders evolution.
110. Editing is a rewording activity.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
98. In computing, the mean time to failure keeps getting shorter.
27. Once you understand how to write a program get someone else to write it.
95. Don't have good ideas if you aren't willing to be responsible for them.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
4. Every program is a part of some other program and rarely fits.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
72. An adequate bootstrap is a contradiction in terms.
38. Structured Programming supports the law of the excluded middle.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
60. In seeking the unattainable, simplicity only gets in the way.
23. To understand a program you must become both the machine and the program.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
14. In the long run every program becomes rococo - then rubble.
3. Syntactic sugar causes cancer of the semicolon.
43. In software systems, it is often the early bird that makes the worm.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
17. If a listener nods his head when you're explaining your program, wake him up.
115. Most people find the concept of programming obvious, but the doing impossible.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
40. There are two ways to write error-free programs; only the third one works.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
22. A good system can't have a weak command language.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
40. There are two ways to write error-free programs; only the third one works.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
66. Making something variable is easy. Controlling duration of constancy is the trick.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
108. Whenever two programmers meet to criticize their programs, both are silent.
96. Computers don't introduce order anywhere as much as they expose opportunities.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
66. Making something variable is easy. Controlling duration of constancy is the trick.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
96. Computers don't introduce order anywhere as much as they expose opportunities.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
59. In English every word can be verbed. Would that it were so in our programming languages.
66. Making something variable is easy. Controlling duration of constancy is the trick.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
22. A good system can't have a weak command language.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
78. If your computer speaks English, it was probably made in Japan.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
7. It is easier to write an incorrect program than understand a correct one.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
38. Structured Programming supports the law of the excluded middle.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
111. Why did the Roman Empire collapse? What is Latin for office automation?
1. One man's constant is another man's variable.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
110. Editing is a rewording activity.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
40. There are two ways to write error-free programs; only the third one works.
103. Purely applicative languages are poorly applicable.
63. When we write programs that "learn", it turns out that we do and they don't.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
90. Computation has made the tree flower.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
111. Why did the Roman Empire collapse? What is Latin for office automation?
105. You can't communicate complexity, only an awareness of it.
14. In the long run every program becomes rococo - then rubble.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
119. Programming is an unnatural act.
17. If a listener nods his head when you're explaining your program, wake him up.
110. Editing is a rewording activity.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
38. Structured Programming supports the law of the excluded middle.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
11. If you have a procedure with ten parameters, you probably missed some.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
110. Editing is a rewording activity.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
111. Why did the Roman Empire collapse? What is Latin for office automation?
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
107. The debate rages on: is PL/I Bachtrian or Dromedary?
27. Once you understand how to write a program get someone else to write it.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
61. In programming, as in everything else, to be in error is to be reborn.
3. Syntactic sugar causes cancer of the semicolon.
105. You can't communicate complexity, only an awareness of it.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
3. Syntactic sugar causes cancer of the semicolon.
105. You can't communicate complexity, only an awareness of it.
102. One can't proceed from the informal to the formal by formal means.
100. We will never run out of things to program as long as there is a single program around.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
15. Everything should be built top-down, except the first time.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
115. Most people find the concept of programming obvious, but the doing impossible.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
66. Making something variable is easy. Controlling duration of constancy is the trick.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
103. Purely applicative languages are poorly applicable.
114. Within a computer natural language is unnatural.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
18. A program without a loop and a structured variable isn't worth writing.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
108. Whenever two programmers meet to criticize their programs, both are silent.
12. Recursion is the root of computation since it trades description for time.
60. In seeking the unattainable, simplicity only gets in the way.
62. In computing, invariants are ephemeral.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
21. Optimization hinders evolution.
111. Why did the Roman Empire collapse? What is Latin for office automation?
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
23. To understand a program you must become both the machine and the program.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
95. Don't have good ideas if you aren't willing to be responsible for them.
1. One man's constant is another man's variable.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
119. Programming is an unnatural act.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
72. An adequate bootstrap is a contradiction in terms.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
102. One can't proceed from the informal to the formal by formal means.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
61. In programming, as in everything else, to be in error is to be reborn.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
11. If you have a procedure with ten parameters, you probably missed some.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
63. When we write programs that "learn", it turns out that we do and they don't.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
110. Editing is a rewording activity.
100. We will never run out of things to program as long as there is a single program around.
12. Recursion is the root of computation since it trades description for time.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
7. It is easier to write an incorrect program than understand a correct one.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
66. Making something variable is easy. Controlling duration of constancy is the trick.
119. Programming is an unnatural act.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
31. Simplicity does not precede complexity, but follows it.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
31. Simplicity does not precede complexity, but follows it.
90. Computation has made the tree flower.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
96. Computers don't introduce order anywhere as much as they expose opportunities.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
100. We will never run out of things to program as long as there is a single program around.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
57. It is easier to change the specification to fit the program than vice versa.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
31. Simplicity does not precede complexity, but follows it.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
61. In programming, as in everything else, to be in error is to be reborn.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
62. In computing, invariants are ephemeral.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
107. The debate rages on: is PL/I Bachtrian or Dromedary?
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
12. Recursion is the root of computation since it trades description for time.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
55. A LISP programmer knows the value of everything, but the cost of nothing.
90. Computation has made the tree flower.
57. It is easier to change the specification to fit the program than vice versa.
31. Simplicity does not precede complexity, but follows it.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
96. Computers don't introduce order anywhere as much as they expose opportunities.
57. It is easier to change the specification to fit the program than vice versa.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
59. In English every word can be verbed. Would that it were so in our programming languages.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
8. A programming language is low level when its programs require attention to the irrelevant.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
72. An adequate bootstrap is a contradiction in terms.
17. If a listener nods his head when you're explaining your program, wake him up.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
40. There are two ways to write error-free programs; only the third one works.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
76. It is the user who should parameterize procedures, not their creators.
119. Programming is an unnatural act.
57. It is easier to change the specification to fit the program than vice versa.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
119. Programming is an unnatural act.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
119. Programming is an unnatural act.
60. In seeking the unattainable, simplicity only gets in the way.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
7. It is easier to write an incorrect program than understand a correct one.
63. When we write programs that "learn", it turns out that we do and they don't.
110. Editing is a rewording activity.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
100. We will never run out of things to program as long as there is a single program around.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
102. One can't proceed from the informal to the formal by formal means.
3. Syntactic sugar causes cancer of the semicolon.
40. There are two ways to write error-free programs; only the third one works.
100. We will never run out of things to program as long as there is a single program around.
14. In the long run every program becomes rococo - then rubble.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
62. In computing, invariants are ephemeral.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
98. In computing, the mean time to failure keeps getting shorter.
59. In English every word can be verbed. Would that it were so in our programming languages.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
115. Most people find the concept of programming obvious, but the doing impossible.
57. It is easier to change the specification to fit the program than vice versa.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
1. One man's constant is another man's variable.
27. Once you understand how to write a program get someone else to write it.
96. Computers don't introduce order anywhere as much as they expose opportunities.
95. Don't have good ideas if you aren't willing to be responsible for them.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
111. Why did the Roman Empire collapse? What is Latin for office automation?
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
47. As Will Rogers would have said, "There is no such thing as a free variable."
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
61. In programming, as in everything else, to be in error is to be reborn.
110. Editing is a rewording activity.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
108. Whenever two programmers meet to criticize their programs, both are silent.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
55. A LISP programmer knows the value of everything, but the cost of nothing.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
59. In English every word can be verbed. Would that it were so in our programming languages.
103. Purely applicative languages are poorly applicable.
100. We will never run out of things to program as long as there is a single program around.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
119. Programming is an unnatural act.
105. You can't communicate complexity, only an awareness of it.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
59. In English every word can be verbed. Would that it were so in our programming languages.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
90. Computation has made the tree flower.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
3. Syntactic sugar causes cancer of the semicolon.
11. If you have a procedure with ten parameters, you probably missed some.
11. If you have a procedure with ten parameters, you probably missed some.
105. You can't communicate complexity, only an awareness of it.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
31. Simplicity does not precede complexity, but follows it.
95. Don't have good ideas if you aren't willing to be responsible for them.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
57. It is easier to change the specification to fit the program than vice versa.
57. It is easier to change the specification to fit the program than vice versa.
22. A good system can't have a weak command language.
62. In computing, invariants are ephemeral.
12. Recursion is the root of computation since it trades description for time.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
27. Once you understand how to write a program get someone else to write it.
11. If you have a procedure with ten parameters, you probably missed some.
27. Once you understand how to write a program get someone else to write it.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
114. Within a computer natural language is unnatural.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
27. Once you understand how to write a program get someone else to write it.
7. It is easier to write an incorrect program than understand a correct one.
76. It is the user who should parameterize procedures, not their creators.
103. Purely applicative languages are poorly applicable.
43. In software systems, it is often the early bird that makes the worm.
55. A LISP programmer knows the value of everything, but the cost of nothing.
55. A LISP programmer knows the value of everything, but the cost of nothing.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
111. Why did the Roman Empire collapse? What is Latin for office automation?
1. One man's constant is another man's variable.
40. There are two ways to write error-free programs; only the third one works.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
43. In software systems, it is often the early bird that makes the worm.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
78. If your computer speaks English, it was probably made in Japan.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
61. In programming, as in everything else, to be in error is to be reborn.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
103. Purely applicative languages are poorly applicable.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
100. We will never run out of things to program as long as there is a single program around.
11. If you have a procedure with ten parameters, you probably missed some.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
62. In computing, invariants are ephemeral.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
43. In software systems, it is often the early bird that makes the worm.
103. Purely applicative languages are poorly applicable.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
119. Programming is an unnatural act.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
31. Simplicity does not precede complexity, but follows it.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
112. Computer Science is embarrassed by the computer.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
108. Whenever two programmers meet to criticize their programs, both are silent.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
14. In the long run every program becomes rococo - then rubble.
38. Structured Programming supports the law of the excluded middle.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
47. As Will Rogers would have said, "There is no such thing as a free variable."
119. Programming is an unnatural act.
104. The proof of a system's value is its existence.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
18. A program without a loop and a structured variable isn't worth writing.
40. There are two ways to write error-free programs; only the third one works.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
57. It is easier to change the specification to fit the program than vice versa.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
62. In computing, invariants are ephemeral.
112. Computer Science is embarrassed by the computer.
110. Editing is a rewording activity.
40. There are two ways to write error-free programs; only the third one works.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
104. The proof of a system's value is its existence.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
119. Programming is an unnatural act.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
21. Optimization hinders evolution.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
17. If a listener nods his head when you're explaining your program, wake him up.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
62. In computing, invariants are ephemeral.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
115. Most people find the concept of programming obvious, but the doing impossible.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
112. Computer Science is embarrassed by the computer.
22. A good system can't have a weak command language.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
119. Programming is an unnatural act.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
46. Like punning, programming is a play on words.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
90. Computation has made the tree flower.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
15. Everything should be built top-down, except the first time.
115. Most people find the concept of programming obvious, but the doing impossible.
47. As Will Rogers would have said, "There is no such thing as a free variable."
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
22. A good system can't have a weak command language.
79. A year spent in artificial intelligence is enough to make one believe in God.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
59. In English every word can be verbed. Would that it were so in our programming languages.
108. Whenever two programmers meet to criticize their programs, both are silent.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
8. A programming language is low level when its programs require attention to the irrelevant.
100. We will never run out of things to program as long as there is a single program around.
15. Everything should be built top-down, except the first time.
7. It is easier to write an incorrect program than understand a correct one.
61. In programming, as in everything else, to be in error is to be reborn.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
59. In English every word can be verbed. Would that it were so in our programming languages.
18. A program without a loop and a structured variable isn't worth writing.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
115. Most people find the concept of programming obvious, but the doing impossible.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
61. In programming, as in everything else, to be in error is to be reborn.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
38. Structured Programming supports the law of the excluded middle.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
66. Making something variable is easy. Controlling duration of constancy is the trick.
100. We will never run out of things to program as long as there is a single program around.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
111. Why did the Roman Empire collapse? What is Latin for office automation?
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
59. In English every word can be verbed. Would that it were so in our programming languages.
23. To understand a program you must become both the machine and the program.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
60. In seeking the unattainable, simplicity only gets in the way.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
110. Editing is a rewording activity.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
96. Computers don't introduce order anywhere as much as they expose opportunities.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
62. In computing, invariants are ephemeral.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
104. The proof of a system's value is its existence.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
59. In English every word can be verbed. Would that it were so in our programming languages.
79. A year spent in artificial intelligence is enough to make one believe in God.
38. Structured Programming supports the law of the excluded middle.
1. One man's constant is another man's variable.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
111. Why did the Roman Empire collapse? What is Latin for office automation?
38. Structured Programming supports the law of the excluded middle.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
40. There are two ways to write error-free programs; only the third one works.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
100. We will never run out of things to program as long as there is a single program around.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
90. Computation has made the tree flower.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
21. Optimization hinders evolution.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
4. Every program is a part of some other program and rarely fits.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
60. In seeking the unattainable, simplicity only gets in the way.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
15. Everything should be built top-down, except the first time.
18. A program without a loop and a structured variable isn't worth writing.
72. An adequate bootstrap is a contradiction in terms.
96. Computers don't introduce order anywhere as much as they expose opportunities.
66. Making something variable is easy. Controlling duration of constancy is the trick.
115. Most people find the concept of programming obvious, but the doing impossible.
57. It is easier to change the specification to fit the program than vice versa.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
46. Like punning, programming is a play on words.
104. The proof of a system's value is its existence.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
95. Don't have good ideas if you aren't willing to be responsible for them.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
27. Once you understand how to write a program get someone else to write it.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
103. Purely applicative languages are poorly applicable.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
115. Most people find the concept of programming obvious, but the doing impossible.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
66. Making something variable is easy. Controlling duration of constancy is the trick.
27. Once you understand how to write a program get someone else to write it.
78. If your computer speaks English, it was probably made in Japan.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
21. Optimization hinders evolution.
43. In software systems, it is often the early bird that makes the worm.
100. We will never run out of things to program as long as there is a single program around.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
43. In software systems, it is often the early bird that makes the worm.
62. In computing, invariants are ephemeral.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
57. It is easier to change the specification to fit the program than vice versa.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
104. The proof of a system's value is its existence.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
78. If your computer speaks English, it was probably made in Japan.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
60. In seeking the unattainable, simplicity only gets in the way.
8. A programming language is low level when its programs require attention to the irrelevant.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
110. Editing is a rewording activity.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
72. An adequate bootstrap is a contradiction in terms.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
105. You can't communicate complexity, only an awareness of it.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
96. Computers don't introduce order anywhere as much as they expose opportunities.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
7. It is easier to write an incorrect program than understand a correct one.
11. If you have a procedure with ten parameters, you probably missed some.
105. You can't communicate complexity, only an awareness of it.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
43. In software systems, it is often the early bird that makes the worm.
110. Editing is a rewording activity.
47. As Will Rogers would have said, "There is no such thing as a free variable."
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
43. In software systems, it is often the early bird that makes the worm.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
57. It is easier to change the specification to fit the program than vice versa.
4. Every program is a part of some other program and rarely fits.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
17. If a listener nods his head when you're explaining your program, wake him up.
119. Programming is an unnatural act.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
4. Every program is a part of some other program and rarely fits.
119. Programming is an unnatural act.
46. Like punning, programming is a play on words.
41. Some programming languages manage to absorb change, but withstand progress.
46. Like punning, programming is a play on words.
40. There are two ways to write error-free programs; only the third one works.
62. In computing, invariants are ephemeral.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
18. A program without a loop and a structured variable isn't worth writing.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
119. Programming is an unnatural act.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
57. It is easier to change the specification to fit the program than vice versa.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
90. Computation has made the tree flower.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
108. Whenever two programmers meet to criticize their programs, both are silent.
38. Structured Programming supports the law of the excluded middle.
103. Purely applicative languages are poorly applicable.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
96. Computers don't introduce order anywhere as much as they expose opportunities.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
62. In computing, invariants are ephemeral.
8. A programming language is low level when its programs require attention to the irrelevant.
40. There are two ways to write error-free programs; only the third one works.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
3. Syntactic sugar causes cancer of the semicolon.
112. Computer Science is embarrassed by the computer.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
100. We will never run out of things to program as long as there is a single program around.
22. A good system can't have a weak command language.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
102. One can't proceed from the informal to the formal by formal means.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
90. Computation has made the tree flower.
15. Everything should be built top-down, except the first time.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
17. If a listener nods his head when you're explaining your program, wake him up.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
23. To understand a program you must become both the machine and the program.
96. Computers don't introduce order anywhere as much as they expose opportunities.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
112. Computer Science is embarrassed by the computer.
8. A programming language is low level when its programs require attention to the irrelevant.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
96. Computers don't introduce order anywhere as much as they expose opportunities.
4. Every program is a part of some other program and rarely fits.
79. A year spent in artificial intelligence is enough to make one believe in God.
76. It is the user who should parameterize procedures, not their creators.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
114. Within a computer natural language is unnatural.
100. We will never run out of things to program as long as there is a single program around.
119. Programming is an unnatural act.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
102. One can't proceed from the informal to the formal by formal means.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
111. Why did the Roman Empire collapse? What is Latin for office automation?
72. An adequate bootstrap is a contradiction in terms.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
41. Some programming languages manage to absorb change, but withstand progress.
76. It is the user who should parameterize procedures, not their creators.
57. It is easier to change the specification to fit the program than vice versa.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
111. Why did the Roman Empire collapse? What is Latin for office automation?
18. A program without a loop and a structured variable isn't worth writing.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
79. A year spent in artificial intelligence is enough to make one believe in God.
114. Within a computer natural language is unnatural.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
114. Within a computer natural language is unnatural.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
40. There are two ways to write error-free programs; only the third one works.
12. Recursion is the root of computation since it trades description for time.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
47. As Will Rogers would have said, "There is no such thing as a free variable."
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
61. In programming, as in everything else, to be in error is to be reborn.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
76. It is the user who should parameterize procedures, not their creators.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
104. The proof of a system's value is its existence.
21. Optimization hinders evolution.
63. When we write programs that "learn", it turns out that we do and they don't.
112. Computer Science is embarrassed by the computer.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
23. To understand a program you must become both the machine and the program.
38. Structured Programming supports the law of the excluded middle.
15. Everything should be built top-down, except the first time.
103. Purely applicative languages are poorly applicable.
7. It is easier to write an incorrect program than understand a correct one.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
12. Recursion is the root of computation since it trades description for time.
66. Making something variable is easy. Controlling duration of constancy is the trick.
46. Like punning, programming is a play on words.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
78. If your computer speaks English, it was probably made in Japan.
103. Purely applicative languages are poorly applicable.
112. Computer Science is embarrassed by the computer.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
114. Within a computer natural language is unnatural.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
119. Programming is an unnatural act.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
100. We will never run out of things to program as long as there is a single program around.
40. There are two ways to write error-free programs; only the third one works.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
46. Like punning, programming is a play on words.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
1. One man's constant is another man's variable.
110. Editing is a rewording activity.
119. Programming is an unnatural act.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
112. Computer Science is embarrassed by the computer.
78. If your computer speaks English, it was probably made in Japan.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
40. There are two ways to write error-free programs; only the third one works.
3. Syntactic sugar causes cancer of the semicolon.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
23. To understand a program you must become both the machine and the program.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
27. Once you understand how to write a program get someone else to write it.
105. You can't communicate complexity, only an awareness of it.
61. In programming, as in everything else, to be in error is to be reborn.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
55. A LISP programmer knows the value of everything, but the cost of nothing.
11. If you have a procedure with ten parameters, you probably missed some.
100. We will never run out of things to program as long as there is a single program around.
18. A program without a loop and a structured variable isn't worth writing.
23. To understand a program you must become both the machine and the program.
72. An adequate bootstrap is a contradiction in terms.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
3. Syntactic sugar causes cancer of the semicolon.
23. To understand a program you must become both the machine and the program.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
110. Editing is a rewording activity.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
27. Once you understand how to write a program get someone else to write it.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
27. Once you understand how to write a program get someone else to write it.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
112. Computer Science is embarrassed by the computer.
98. In computing, the mean time to failure keeps getting shorter.
105. You can't communicate complexity, only an awareness of it.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
27. Once you understand how to write a program get someone else to write it.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
47. As Will Rogers would have said, "There is no such thing as a free variable."
110. Editing is a rewording activity.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
46. Like punning, programming is a play on words.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
95. Don't have good ideas if you aren't willing to be responsible for them.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
11. If you have a procedure with ten parameters, you probably missed some.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
46. Like punning, programming is a play on words.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
17. If a listener nods his head when you're explaining your program, wake him up.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
95. Don't have good ideas if you aren't willing to be responsible for them.
62. In computing, invariants are ephemeral.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
23. To understand a program you must become both the machine and the program.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
79. A year spent in artificial intelligence is enough to make one believe in God.
72. An adequate bootstrap is a contradiction in terms.
95. Don't have good ideas if you aren't willing to be responsible for them.
79. A year spent in artificial intelligence is enough to make one believe in God.
95. Don't have good ideas if you aren't willing to be responsible for them.
111. Why did the Roman Empire collapse? What is Latin for office automation?
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
7. It is easier to write an incorrect program than understand a correct one.
15. Everything should be built top-down, except the first time.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
102. One can't proceed from the informal to the formal by formal means.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
15. Everything should be built top-down, except the first time.
59. In English every word can be verbed. Would that it were so in our programming languages.
8. A programming language is low level when its programs require attention to the irrelevant.
46. Like punning, programming is a play on words.
59. In English every word can be verbed. Would that it were so in our programming languages.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
119. Programming is an unnatural act.
66. Making something variable is easy. Controlling duration of constancy is the trick.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
7. It is easier to write an incorrect program than understand a correct one.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
47. As Will Rogers would have said, "There is no such thing as a free variable."
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
46. Like punning, programming is a play on words.
11. If you have a procedure with ten parameters, you probably missed some.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
15. Everything should be built top-down, except the first time.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
8. A programming language is low level when its programs require attention to the irrelevant.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
59. In English every word can be verbed. Would that it were so in our programming languages.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
110. Editing is a rewording activity.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
72. An adequate bootstrap is a contradiction in terms.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
40. There are two ways to write error-free programs; only the third one works.
1. One man's constant is another man's variable.
119. Programming is an unnatural act.
102. One can't proceed from the informal to the formal by formal means.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
4. Every program is a part of some other program and rarely fits.
4. Every program is a part of some other program and rarely fits.
46. Like punning, programming is a play on words.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
18. A program without a loop and a structured variable isn't worth writing.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
103. Purely applicative languages are poorly applicable.
12. Recursion is the root of computation since it trades description for time.
76. It is the user who should parameterize procedures, not their creators.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
76. It is the user who should parameterize procedures, not their creators.
57. It is easier to change the specification to fit the program than vice versa.
7. It is easier to write an incorrect program than understand a correct one.
11. If you have a procedure with ten parameters, you probably missed some.
63. When we write programs that "learn", it turns out that we do and they don't.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
95. Don't have good ideas if you aren't willing to be responsible for them.
72. An adequate bootstrap is a contradiction in terms.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
108. Whenever two programmers meet to criticize their programs, both are silent.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
100. We will never run out of things to program as long as there is a single program around.
105. You can't communicate complexity, only an awareness of it.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
22. A good system can't have a weak command language.
115. Most people find the concept of programming obvious, but the doing impossible.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
79. A year spent in artificial intelligence is enough to make one believe in God.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
108. Whenever two programmers meet to criticize their programs, both are silent.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
57. It is easier to change the specification to fit the program than vice versa.
105. You can't communicate complexity, only an awareness of it.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
22. A good system can't have a weak command language.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
31. Simplicity does not precede complexity, but follows it.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
18. A program without a loop and a structured variable isn't worth writing.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
41. Some programming languages manage to absorb change, but withstand progress.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
46. Like punning, programming is a play on words.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
115. Most people find the concept of programming obvious, but the doing impossible.
47. As Will Rogers would have said, "There is no such thing as a free variable."
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
21. Optimization hinders evolution.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
100. We will never run out of things to program as long as there is a single program around.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
55. A LISP programmer knows the value of everything, but the cost of nothing.
63. When we write programs that "learn", it turns out that we do and they don't.
72. An adequate bootstrap is a contradiction in terms.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
27. Once you understand how to write a program get someone else to write it.
79. A year spent in artificial intelligence is enough to make one believe in God.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
63. When we write programs that "learn", it turns out that we do and they don't.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
55. A LISP programmer knows the value of everything, but the cost of nothing.
17. If a listener nods his head when you're explaining your program, wake him up.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
95. Don't have good ideas if you aren't willing to be responsible for them.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
105. You can't communicate complexity, only an awareness of it.
114. Within a computer natural language is unnatural.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
40. There are two ways to write error-free programs; only the third one works.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
62. In computing, invariants are ephemeral.
43. In software systems, it is often the early bird that makes the worm.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
62. In computing, invariants are ephemeral.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
66. Making something variable is easy. Controlling duration of constancy is the trick.
22. A good system can't have a weak command language.
57. It is easier to change the specification to fit the program than vice versa.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
14. In the long run every program becomes rococo - then rubble.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
4. Every program is a part of some other program and rarely fits.
79. A year spent in artificial intelligence is enough to make one believe in God.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
104. The proof of a system's value is its existence.
3. Syntactic sugar causes cancer of the semicolon.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
62. In computing, invariants are ephemeral.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
15. Everything should be built top-down, except the first time.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
8. A programming language is low level when its programs require attention to the irrelevant.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
96. Computers don't introduce order anywhere as much as they expose opportunities.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
4. Every program is a part of some other program and rarely fits.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
61. In programming, as in everything else, to be in error is to be reborn.
17. If a listener nods his head when you're explaining your program, wake him up.
115. Most people find the concept of programming obvious, but the doing impossible.
66. Making something variable is easy. Controlling duration of constancy is the trick.
72. An adequate bootstrap is a contradiction in terms.
66. Making something variable is easy. Controlling duration of constancy is the trick.
1. One man's constant is another man's variable.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
41. Some programming languages manage to absorb change, but withstand progress.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
119. Programming is an unnatural act.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
110. Editing is a rewording activity.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
22. A good system can't have a weak command language.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
96. Computers don't introduce order anywhere as much as they expose opportunities.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
15. Everything should be built top-down, except the first time.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
27. Once you understand how to write a program get someone else to write it.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
46. Like punning, programming is a play on words.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
79. A year spent in artificial intelligence is enough to make one believe in God.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
41. Some programming languages manage to absorb change, but withstand progress.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
95. Don't have good ideas if you aren't willing to be responsible for them.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
21. Optimization hinders evolution.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
115. Most people find the concept of programming obvious, but the doing impossible.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
47. As Will Rogers would have said, "There is no such thing as a free variable."
63. When we write programs that "learn", it turns out that we do and they don't.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
27. Once you understand how to write a program get someone else to write it.
111. Why did the Roman Empire collapse? What is Latin for office automation?
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
59. In English every word can be verbed. Would that it were so in our programming languages.
3. Syntactic sugar causes cancer of the semicolon.
38. Structured Programming supports the law of the excluded middle.
105. You can't communicate complexity, only an awareness of it.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
119. Programming is an unnatural act.
66. Making something variable is easy. Controlling duration of constancy is the trick.
108. Whenever two programmers meet to criticize their programs, both are silent.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
41. Some programming languages manage to absorb change, but withstand progress.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
1. One man's constant is another man's variable.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
60. In seeking the unattainable, simplicity only gets in the way.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
11. If you have a procedure with ten parameters, you probably missed some.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
110. Editing is a rewording activity.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
60. In seeking the unattainable, simplicity only gets in the way.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
103. Purely applicative languages are poorly applicable.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
3. Syntactic sugar causes cancer of the semicolon.
96. Computers don't introduce order anywhere as much as they expose opportunities.
14. In the long run every program becomes rococo - then rubble.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
61. In programming, as in everything else, to be in error is to be reborn.
18. A program without a loop and a structured variable isn't worth writing.
18. A program without a loop and a structured variable isn't worth writing.
47. As Will Rogers would have said, "There is no such thing as a free variable."
4. Every program is a part of some other program and rarely fits.
55. A LISP programmer knows the value of everything, but the cost of nothing.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
57. It is easier to change the specification to fit the program than vice versa.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
21. Optimization hinders evolution.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
22. A good system can't have a weak command language.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
7. It is easier to write an incorrect program than understand a correct one.
112. Computer Science is embarrassed by the computer.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
63. When we write programs that "learn", it turns out that we do and they don't.
105. You can't communicate complexity, only an awareness of it.
112. Computer Science is embarrassed by the computer.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
60. In seeking the unattainable, simplicity only gets in the way.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
14. In the long run every program becomes rococo - then rubble.
40. There are two ways to write error-free programs; only the third one works.
110. Editing is a rewording activity.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
4. Every program is a part of some other program and rarely fits.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
95. Don't have good ideas if you aren't willing to be responsible for them.
27. Once you understand how to write a program get someone else to write it.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
21. Optimization hinders evolution.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
108. Whenever two programmers meet to criticize their programs, both are silent.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
43. In software systems, it is often the early bird that makes the worm.
46. Like punning, programming is a play on words.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
110. Editing is a rewording activity.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
14. In the long run every program becomes rococo - then rubble.
27. Once you understand how to write a program get someone else to write it.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
115. Most people find the concept of programming obvious, but the doing impossible.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
79. A year spent in artificial intelligence is enough to make one believe in God.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
72. An adequate bootstrap is a contradiction in terms.
79. A year spent in artificial intelligence is enough to make one believe in God.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
38. Structured Programming supports the law of the excluded middle.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
19. A language that doesn't affect the way you think about programming, is not worth knowing.
61. In programming, as in everything else, to be in error is to be reborn.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
3. Syntactic sugar causes cancer of the semicolon.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
59. In English every word can be verbed. Would that it were so in our programming languages.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
72. An adequate bootstrap is a contradiction in terms.
72. An adequate bootstrap is a contradiction in terms.
1. One man's constant is another man's variable.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
112. Computer Science is embarrassed by the computer.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
14. In the long run every program becomes rococo - then rubble.
22. A good system can't have a weak command language.
108. Whenever two programmers meet to criticize their programs, both are silent.
41. Some programming languages manage to absorb change, but withstand progress.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
110. Editing is a rewording activity.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
40. There are two ways to write error-free programs; only the third one works.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
31. Simplicity does not precede complexity, but follows it.
63. When we write programs that "learn", it turns out that we do and they don't.
43. In software systems, it is often the early bird that makes the worm.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
27. Once you understand how to write a program get someone else to write it.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
1. One man's constant is another man's variable.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
17. If a listener nods his head when you're explaining your program, wake him up.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
66. Making something variable is easy. Controlling duration of constancy is the trick.
112. Computer Science is embarrassed by the computer.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
108. Whenever two programmers meet to criticize their programs, both are silent.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
7. It is easier to write an incorrect program than understand a correct one.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
96. Computers don't introduce order anywhere as much as they expose opportunities.
38. Structured Programming supports the law of the excluded middle.
8. A programming language is low level when its programs require attention to the irrelevant.
100. We will never run out of things to program as long as there is a single program around.
66. Making something variable is easy. Controlling duration of constancy is the trick.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
38. Structured Programming supports the law of the excluded middle.
111. Why did the Roman Empire collapse? What is Latin for office automation?
46. Like punning, programming is a play on words.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
79. A year spent in artificial intelligence is enough to make one believe in God.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
105. You can't communicate complexity, only an awareness of it.
12. Recursion is the root of computation since it trades description for time.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
108. Whenever two programmers meet to criticize their programs, both are silent.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
105. You can't communicate complexity, only an awareness of it.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
1. One man's constant is another man's variable.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
27. Once you understand how to write a program get someone else to write it.
22. A good system can't have a weak command language.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
57. It is easier to change the specification to fit the program than vice versa.
4. Every program is a part of some other program and rarely fits.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
55. A LISP programmer knows the value of everything, but the cost of nothing.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
46. Like punning, programming is a play on words.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
104. The proof of a system's value is its existence.
100. We will never run out of things to program as long as there is a single program around.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
12. Recursion is the root of computation since it trades description for time.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
103. Purely applicative languages are poorly applicable.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
43. In software systems, it is often the early bird that makes the worm.
102. One can't proceed from the informal to the formal by formal means.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
1. One man's constant is another man's variable.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
112. Computer Science is embarrassed by the computer.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
57. It is easier to change the specification to fit the program than vice versa.
62. In computing, invariants are ephemeral.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
41. Some programming languages manage to absorb change, but withstand progress.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
46. Like punning, programming is a play on words.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
104. The proof of a system's value is its existence.
21. Optimization hinders evolution.
60. In seeking the unattainable, simplicity only gets in the way.
90. Computation has made the tree flower.
43. In software systems, it is often the early bird that makes the worm.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
41. Some programming languages manage to absorb change, but withstand progress.
21. Optimization hinders evolution.
72. An adequate bootstrap is a contradiction in terms.
115. Most people find the concept of programming obvious, but the doing impossible.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
78. If your computer speaks English, it was probably made in Japan.
17. If a listener nods his head when you're explaining your program, wake him up.
27. Once you understand how to write a program get someone else to write it.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
98. In computing, the mean time to failure keeps getting shorter.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
61. In programming, as in everything else, to be in error is to be reborn.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
15. Everything should be built top-down, except the first time.
119. Programming is an unnatural act.
15. Everything should be built top-down, except the first time.
14. In the long run every program becomes rococo - then rubble.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
5. If a program manipulates a large amount of data, it does so in a small number of ways.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
102. One can't proceed from the informal to the formal by formal means.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
96. Computers don't introduce order anywhere as much as they expose opportunities.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
79. A year spent in artificial intelligence is enough to make one believe in God.
111. Why did the Roman Empire collapse? What is Latin for office automation?
23. To understand a program you must become both the machine and the program.
4. Every program is a part of some other program and rarely fits.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
115. Most people find the concept of programming obvious, but the doing impossible.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
41. Some programming languages manage to absorb change, but withstand progress.
41. Some programming languages manage to absorb change, but withstand progress.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
21. Optimization hinders evolution.
57. It is easier to change the specification to fit the program than vice versa.
27. Once you understand how to write a program get someone else to write it.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
1. One man's constant is another man's variable.
14. In the long run every program becomes rococo - then rubble.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
61. In programming, as in everything else, to be in error is to be reborn.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
102. One can't proceed from the informal to the formal by formal means.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
61. In programming, as in everything else, to be in error is to be reborn.
57. It is easier to change the specification to fit the program than vice versa.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
59. In English every word can be verbed. Would that it were so in our programming languages.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
62. In computing, invariants are ephemeral.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
90. Computation has made the tree flower.
7. It is easier to write an incorrect program than understand a correct one.
112. Computer Science is embarrassed by the computer.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
98. In computing, the mean time to failure keeps getting shorter.
14. In the long run every program becomes rococo - then rubble.
38. Structured Programming supports the law of the excluded middle.
46. Like punning, programming is a play on words.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
115. Most people find the concept of programming obvious, but the doing impossible.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
47. As Will Rogers would have said, "There is no such thing as a free variable."
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
98. In computing, the mean time to failure keeps getting shorter.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
104. The proof of a system's value is its existence.
112. Computer Science is embarrassed by the computer.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
114. Within a computer natural language is unnatural.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
23. To understand a program you must become both the machine and the program.
27. Once you understand how to write a program get someone else to write it.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
55. A LISP programmer knows the value of everything, but the cost of nothing.
59. In English every word can be verbed. Would that it were so in our programming languages.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
63. When we write programs that "learn", it turns out that we do and they don't.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
3. Syntactic sugar causes cancer of the semicolon.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
46. Like punning, programming is a play on words.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
111. Why did the Roman Empire collapse? What is Latin for office automation?
41. Some programming languages manage to absorb change, but withstand progress.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
17. If a listener nods his head when you're explaining your program, wake him up.
4. Every program is a part of some other program and rarely fits.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
8. A programming language is low level when its programs require attention to the irrelevant.
17. If a listener nods his head when you're explaining your program, wake him up.
31. Simplicity does not precede complexity, but follows it.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
47. As Will Rogers would have said, "There is no such thing as a free variable."
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
3. Syntactic sugar causes cancer of the semicolon.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
17. If a listener nods his head when you're explaining your program, wake him up.
100. We will never run out of things to program as long as there is a single program around.
4. Every program is a part of some other program and rarely fits.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
31. Simplicity does not precede complexity, but follows it.
59. In English every word can be verbed. Would that it were so in our programming languages.
63. When we write programs that "learn", it turns out that we do and they don't.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
111. Why did the Roman Empire collapse? What is Latin for office automation?
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
41. Some programming languages manage to absorb change, but withstand progress.
38. Structured Programming supports the law of the excluded middle.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
111. Why did the Roman Empire collapse? What is Latin for office automation?
62. In computing, invariants are ephemeral.
111. Why did the Roman Empire collapse? What is Latin for office automation?
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
1. One man's constant is another man's variable.
57. It is easier to change the specification to fit the program than vice versa.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
66. Making something variable is easy. Controlling duration of constancy is the trick.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
110. Editing is a rewording activity.
40. There are two ways to write error-free programs; only the third one works.
90. Computation has made the tree flower.
110. Editing is a rewording activity.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
40. There are two ways to write error-free programs; only the third one works.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
96. Computers don't introduce order anywhere as much as they expose opportunities.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
14. In the long run every program becomes rococo - then rubble.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
72. An adequate bootstrap is a contradiction in terms.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
41. Some programming languages manage to absorb change, but withstand progress.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
47. As Will Rogers would have said, "There is no such thing as a free variable."
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
8. A programming language is low level when its programs require attention to the irrelevant.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
100. We will never run out of things to program as long as there is a single program around.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
31. Simplicity does not precede complexity, but follows it.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
15. Everything should be built top-down, except the first time.
115. Most people find the concept of programming obvious, but the doing impossible.
95. Don't have good ideas if you aren't willing to be responsible for them.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
46. Like punning, programming is a play on words.
1. One man's constant is another man's variable.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
110. Editing is a rewording activity.
23. To understand a program you must become both the machine and the program.
96. Computers don't introduce order anywhere as much as they expose opportunities.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
79. A year spent in artificial intelligence is enough to make one believe in God.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
14. In the long run every program becomes rococo - then rubble.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
63. When we write programs that "learn", it turns out that we do and they don't.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
15. Everything should be built top-down, except the first time.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
72. An adequate bootstrap is a contradiction in terms.
103. Purely applicative languages are poorly applicable.
17. If a listener nods his head when you're explaining your program, wake him up.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
7. It is easier to write an incorrect program than understand a correct one.
108. Whenever two programmers meet to criticize their programs, both are silent.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
21. Optimization hinders evolution.
79. A year spent in artificial intelligence is enough to make one believe in God.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
100. We will never run out of things to program as long as there is a single program around.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
40. There are two ways to write error-free programs; only the third one works.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
76. It is the user who should parameterize procedures, not their creators.
61. In programming, as in everything else, to be in error is to be reborn.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
21. Optimization hinders evolution.
43. In software systems, it is often the early bird that makes the worm.
17. If a listener nods his head when you're explaining your program, wake him up.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
27. Once you understand how to write a program get someone else to write it.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
119. Programming is an unnatural act.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
40. There are two ways to write error-free programs; only the third one works.
95. Don't have good ideas if you aren't willing to be responsible for them.
40. There are two ways to write error-free programs; only the third one works.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
114. Within a computer natural language is unnatural.
17. If a listener nods his head when you're explaining your program, wake him up.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
90. Computation has made the tree flower.
112. Computer Science is embarrassed by the computer.
14. In the long run every program becomes rococo - then rubble.
100. We will never run out of things to program as long as there is a single program around.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
27. Once you understand how to write a program get someone else to write it.
78. If your computer speaks English, it was probably made in Japan.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
79. A year spent in artificial intelligence is enough to make one believe in God.
115. Most people find the concept of programming obvious, but the doing impossible.
111. Why did the Roman Empire collapse? What is Latin for office automation?
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
95. Don't have good ideas if you aren't willing to be responsible for them.
12. Recursion is the root of computation since it trades description for time.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
103. Purely applicative languages are poorly applicable.
79. A year spent in artificial intelligence is enough to make one believe in God.
31. Simplicity does not precede complexity, but follows it.
22. A good system can't have a weak command language.
98. In computing, the mean time to failure keeps getting shorter.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
115. Most people find the concept of programming obvious, but the doing impossible.
96. Computers don't introduce order anywhere as much as they expose opportunities.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
7. It is easier to write an incorrect program than understand a correct one.
31. Simplicity does not precede complexity, but follows it.
22. A good system can't have a weak command language.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
18. A program without a loop and a structured variable isn't worth writing.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
110. Editing is a rewording activity.
108. Whenever two programmers meet to criticize their programs, both are silent.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
103. Purely applicative languages are poorly applicable.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
62. In computing, invariants are ephemeral.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
62. In computing, invariants are ephemeral.
3. Syntactic sugar causes cancer of the semicolon.
21. Optimization hinders evolution.
90. Computation has made the tree flower.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
105. You can't communicate complexity, only an awareness of it.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
12. Recursion is the root of computation since it trades description for time.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
95. Don't have good ideas if you aren't willing to be responsible for them.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
43. In software systems, it is often the early bird that makes the worm.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
27. Once you understand how to write a program get someone else to write it.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
27. Once you understand how to write a program get someone else to write it.
47. As Will Rogers would have said, "There is no such thing as a free variable."
17. If a listener nods his head when you're explaining your program, wake him up.
110. Editing is a rewording activity.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
105. You can't communicate complexity, only an awareness of it.
59. In English every word can be verbed. Would that it were so in our programming languages.
23. To understand a program you must become both the machine and the program.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
114. Within a computer natural language is unnatural.
115. Most people find the concept of programming obvious, but the doing impossible.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
108. Whenever two programmers meet to criticize their programs, both are silent.
90. Computation has made the tree flower.
7. It is easier to write an incorrect program than understand a correct one.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
17. If a listener nods his head when you're explaining your program, wake him up.
38. Structured Programming supports the law of the excluded middle.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
76. It is the user who should parameterize procedures, not their creators.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
96. Computers don't introduce order anywhere as much as they expose opportunities.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
1. One man's constant is another man's variable.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
110. Editing is a rewording activity.
38. Structured Programming supports the law of the excluded middle.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
66. Making something variable is easy. Controlling duration of constancy is the trick.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
62. In computing, invariants are ephemeral.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
100. We will never run out of things to program as long as there is a single program around.
21. Optimization hinders evolution.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
105. You can't communicate complexity, only an awareness of it.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
3. Syntactic sugar causes cancer of the semicolon.
76. It is the user who should parameterize procedures, not their creators.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
1. One man's constant is another man's variable.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
12. Recursion is the root of computation since it trades description for time.
98. In computing, the mean time to failure keeps getting shorter.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
96. Computers don't introduce order anywhere as much as they expose opportunities.
4. Every program is a part of some other program and rarely fits.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
18. A program without a loop and a structured variable isn't worth writing.
90. Computation has made the tree flower.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
43. In software systems, it is often the early bird that makes the worm.
90. Computation has made the tree flower.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
57. It is easier to change the specification to fit the program than vice versa.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
4. Every program is a part of some other program and rarely fits.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
95. Don't have good ideas if you aren't willing to be responsible for them.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
105. You can't communicate complexity, only an awareness of it.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
110. Editing is a rewording activity.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
47. As Will Rogers would have said, "There is no such thing as a free variable."
43. In software systems, it is often the early bird that makes the worm.
8. A programming language is low level when its programs require attention to the irrelevant.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
111. Why did the Roman Empire collapse? What is Latin for office automation?
14. In the long run every program becomes rococo - then rubble.
78. If your computer speaks English, it was probably made in Japan.
41. Some programming languages manage to absorb change, but withstand progress.
96. Computers don't introduce order anywhere as much as they expose opportunities.
104. The proof of a system's value is its existence.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
11. If you have a procedure with ten parameters, you probably missed some.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
95. Don't have good ideas if you aren't willing to be responsible for them.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
119. Programming is an unnatural act.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
40. There are two ways to write error-free programs; only the third one works.
90. Computation has made the tree flower.
41. Some programming languages manage to absorb change, but withstand progress.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
46. Like punning, programming is a play on words.
105. You can't communicate complexity, only an awareness of it.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
21. Optimization hinders evolution.
17. If a listener nods his head when you're explaining your program, wake him up.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
104. The proof of a system's value is its existence.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
108. Whenever two programmers meet to criticize their programs, both are silent.
79. A year spent in artificial intelligence is enough to make one believe in God.
103. Purely applicative languages are poorly applicable.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
72. An adequate bootstrap is a contradiction in terms.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
17. If a listener nods his head when you're explaining your program, wake him up.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
104. The proof of a system's value is its existence.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
72. An adequate bootstrap is a contradiction in terms.
22. A good system can't have a weak command language.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
21. Optimization hinders evolution.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
47. As Will Rogers would have said, "There is no such thing as a free variable."
8. A programming language is low level when its programs require attention to the irrelevant.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
100. We will never run out of things to program as long as there is a single program around.
21. Optimization hinders evolution.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
46. Like punning, programming is a play on words.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
108. Whenever two programmers meet to criticize their programs, both are silent.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
17. If a listener nods his head when you're explaining your program, wake him up.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
31. Simplicity does not precede complexity, but follows it.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
115. Most people find the concept of programming obvious, but the doing impossible.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
79. A year spent in artificial intelligence is enough to make one believe in God.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
72. An adequate bootstrap is a contradiction in terms.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
62. In computing, invariants are ephemeral.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
103. Purely applicative languages are poorly applicable.
14. In the long run every program becomes rococo - then rubble.
8. A programming language is low level when its programs require attention to the irrelevant.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
90. Computation has made the tree flower.
62. In computing, invariants are ephemeral.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
12. Recursion is the root of computation since it trades description for time.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
103. Purely applicative languages are poorly applicable.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
12. Recursion is the root of computation since it trades description for time.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
18. A program without a loop and a structured variable isn't worth writing.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
66. Making something variable is easy. Controlling duration of constancy is the trick.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
15. Everything should be built top-down, except the first time.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
115. Most people find the concept of programming obvious, but the doing impossible.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
59. In English every word can be verbed. Would that it were so in our programming languages.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
95. Don't have good ideas if you aren't willing to be responsible for them.
115. Most people find the concept of programming obvious, but the doing impossible.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
61. In programming, as in everything else, to be in error is to be reborn.
23. To understand a program you must become both the machine and the program.
79. A year spent in artificial intelligence is enough to make one believe in God.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
14. In the long run every program becomes rococo - then rubble.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
8. A programming language is low level when its programs require attention to the irrelevant.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
1. One man's constant is another man's variable.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
61. In programming, as in everything else, to be in error is to be reborn.
15. Everything should be built top-down, except the first time.
90. Computation has made the tree flower.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
98. In computing, the mean time to failure keeps getting shorter.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
43. In software systems, it is often the early bird that makes the worm.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
41. Some programming languages manage to absorb change, but withstand progress.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
47. As Will Rogers would have said, "There is no such thing as a free variable."
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
22. A good system can't have a weak command language.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
115. Most people find the concept of programming obvious, but the doing impossible.
105. You can't communicate complexity, only an awareness of it.
7. It is easier to write an incorrect program than understand a correct one.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
4. Every program is a part of some other program and rarely fits.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
114. Within a computer natural language is unnatural.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
31. Simplicity does not precede complexity, but follows it.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
47. As Will Rogers would have said, "There is no such thing as a free variable."
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
114. Within a computer natural language is unnatural.
11. If you have a procedure with ten parameters, you probably missed some.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
62. In computing, invariants are ephemeral.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
8. A programming language is low level when its programs require attention to the irrelevant.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
60. In seeking the unattainable, simplicity only gets in the way.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
79. A year spent in artificial intelligence is enough to make one believe in God.
4. Every program is a part of some other program and rarely fits.
3. Syntactic sugar causes cancer of the semicolon.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
47. As Will Rogers would have said, "There is no such thing as a free variable."
90. Computation has made the tree flower.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
119. Programming is an unnatural act.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
4. Every program is a part of some other program and rarely fits.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
27. Once you understand how to write a program get someone else to write it.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
43. In software systems, it is often the early bird that makes the worm.
7. It is easier to write an incorrect program than understand a correct one.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
95. Don't have good ideas if you aren't willing to be responsible for them.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
103. Purely applicative languages are poorly applicable.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
17. If a listener nods his head when you're explaining your program, wake him up.
98. In computing, the mean time to failure keeps getting shorter.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
11. If you have a procedure with ten parameters, you probably missed some.
3. Syntactic sugar causes cancer of the semicolon.
21. Optimization hinders evolution.
114. Within a computer natural language is unnatural.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
63. When we write programs that "learn", it turns out that we do and they don't.
100. We will never run out of things to program as long as there is a single program around.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
95. Don't have good ideas if you aren't willing to be responsible for them.
115. Most people find the concept of programming obvious, but the doing impossible.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
95. Don't have good ideas if you aren't willing to be responsible for them.
105. You can't communicate complexity, only an awareness of it.
11. If you have a procedure with ten parameters, you probably missed some.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
103. Purely applicative languages are poorly applicable.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
102. One can't proceed from the informal to the formal by formal means.
3. Syntactic sugar causes cancer of the semicolon.
11. If you have a procedure with ten parameters, you probably missed some.
31. Simplicity does not precede complexity, but follows it.
102. One can't proceed from the informal to the formal by formal means.
61. In programming, as in everything else, to be in error is to be reborn.
18. A program without a loop and a structured variable isn't worth writing.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
55. A LISP programmer knows the value of everything, but the cost of nothing.
4. Every program is a part of some other program and rarely fits.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
57. It is easier to change the specification to fit the program than vice versa.
17. If a listener nods his head when you're explaining your program, wake him up.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
38. Structured Programming supports the law of the excluded middle.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
17. If a listener nods his head when you're explaining your program, wake him up.
22. A good system can't have a weak command language.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
115. Most people find the concept of programming obvious, but the doing impossible.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
14. In the long run every program becomes rococo - then rubble.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
110. Editing is a rewording activity.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
62. In computing, invariants are ephemeral.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
78. If your computer speaks English, it was probably made in Japan.
4. Every program is a part of some other program and rarely fits.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
102. One can't proceed from the informal to the formal by formal means.
110. Editing is a rewording activity.
21. Optimization hinders evolution.
115. Most people find the concept of programming obvious, but the doing impossible.
41. Some programming languages manage to absorb change, but withstand progress.
72. An adequate bootstrap is a contradiction in terms.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
47. As Will Rogers would have said, "There is no such thing as a free variable."
27. Once you understand how to write a program get someone else to write it.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
46. Like punning, programming is a play on words.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
79. A year spent in artificial intelligence is enough to make one believe in God.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
38. Structured Programming supports the law of the excluded middle.
114. Within a computer natural language is unnatural.
104. The proof of a system's value is its existence.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
57. It is easier to change the specification to fit the program than vice versa.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
27. Once you understand how to write a program get someone else to write it.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
108. Whenever two programmers meet to criticize their programs, both are silent.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
47. As Will Rogers would have said, "There is no such thing as a free variable."
60. In seeking the unattainable, simplicity only gets in the way.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
90. Computation has made the tree flower.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
60. In seeking the unattainable, simplicity only gets in the way.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
119. Programming is an unnatural act.
57. It is easier to change the specification to fit the program than vice versa.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
40. There are two ways to write error-free programs; only the third one works.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
102. One can't proceed from the informal to the formal by formal means.
66. Making something variable is easy. Controlling duration of constancy is the trick.
105. You can't communicate complexity, only an awareness of it.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
61. In programming, as in everything else, to be in error is to be reborn.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
115. Most people find the concept of programming obvious, but the doing impossible.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
104. The proof of a system's value is its existence.
3. Syntactic sugar causes cancer of the semicolon.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
66. Making something variable is easy. Controlling duration of constancy is the trick.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
76. It is the user who should parameterize procedures, not their creators.
62. In computing, invariants are ephemeral.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
38. Structured Programming supports the law of the excluded middle.
104. The proof of a system's value is its existence.
62. In computing, invariants are ephemeral.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
102. One can't proceed from the informal to the formal by formal means.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
108. Whenever two programmers meet to criticize their programs, both are silent.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
104. The proof of a system's value is its existence.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
60. In seeking the unattainable, simplicity only gets in the way.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
23. To understand a program you must become both the machine and the program.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
115. Most people find the concept of programming obvious, but the doing impossible.
105. You can't communicate complexity, only an awareness of it.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
3. Syntactic sugar causes cancer of the semicolon.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
46. Like punning, programming is a play on words.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
112. Computer Science is embarrassed by the computer.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
114. Within a computer natural language is unnatural.
1. One man's constant is another man's variable.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
3. Syntactic sugar causes cancer of the semicolon.
7. It is easier to write an incorrect program than understand a correct one.
59. In English every word can be verbed. Would that it were so in our programming languages.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
8. A programming language is low level when its programs require attention to the irrelevant.
111. Why did the Roman Empire collapse? What is Latin for office automation?
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
11. If you have a procedure with ten parameters, you probably missed some.
14. In the long run every program becomes rococo - then rubble.
38. Structured Programming supports the law of the excluded middle.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
112. Computer Science is embarrassed by the computer.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
60. In seeking the unattainable, simplicity only gets in the way.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
27. Once you understand how to write a program get someone else to write it.
90. Computation has made the tree flower.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
66. Making something variable is easy. Controlling duration of constancy is the trick.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
55. A LISP programmer knows the value of everything, but the cost of nothing.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
78. If your computer speaks English, it was probably made in Japan.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
76. It is the user who should parameterize procedures, not their creators.
105. You can't communicate complexity, only an awareness of it.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
76. It is the user who should parameterize procedures, not their creators.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
18. A program without a loop and a structured variable isn't worth writing.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
102. One can't proceed from the informal to the formal by formal means.
3. Syntactic sugar causes cancer of the semicolon.
79. A year spent in artificial intelligence is enough to make one believe in God.
66. Making something variable is easy. Controlling duration of constancy is the trick.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
96. Computers don't introduce order anywhere as much as they expose opportunities.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
11. If you have a procedure with ten parameters, you probably missed some.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
4. Every program is a part of some other program and rarely fits.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
108. Whenever two programmers meet to criticize their programs, both are silent.
27. Once you understand how to write a program get someone else to write it.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
63. When we write programs that "learn", it turns out that we do and they don't.
114. Within a computer natural language is unnatural.
105. You can't communicate complexity, only an awareness of it.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
15. Everything should be built top-down, except the first time.
63. When we write programs that "learn", it turns out that we do and they don't.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
40. There are two ways to write error-free programs; only the third one works.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
4. Every program is a part of some other program and rarely fits.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
46. Like punning, programming is a play on words.
1. One man's constant is another man's variable.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
40. There are two ways to write error-free programs; only the third one works.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
23. To understand a program you must become both the machine and the program.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
104. The proof of a system's value is its existence.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
18. A program without a loop and a structured variable isn't worth writing.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
78. If your computer speaks English, it was probably made in Japan.
12. Recursion is the root of computation since it trades description for time.
62. In computing, invariants are ephemeral.
60. In seeking the unattainable, simplicity only gets in the way.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
100. We will never run out of things to program as long as there is a single program around.
59. In English every word can be verbed. Would that it were so in our programming languages.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
12. Recursion is the root of computation since it trades description for time.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
59. In English every word can be verbed. Would that it were so in our programming languages.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
38. Structured Programming supports the law of the excluded middle.
47. As Will Rogers would have said, "There is no such thing as a free variable."
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
3. Syntactic sugar causes cancer of the semicolon.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
12. Recursion is the root of computation since it trades description for time.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
59. In English every word can be verbed. Would that it were so in our programming languages.
12. Recursion is the root of computation since it trades description for time.
1. One man's constant is another man's variable.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
59. In English every word can be verbed. Would that it were so in our programming languages.
76. It is the user who should parameterize procedures, not their creators.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
55. A LISP programmer knows the value of everything, but the cost of nothing.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
43. In software systems, it is often the early bird that makes the worm.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
115. Most people find the concept of programming obvious, but the doing impossible.
110. Editing is a rewording activity.
23. To understand a program you must become both the machine and the program.
55. A LISP programmer knows the value of everything, but the cost of nothing.
4. Every program is a part of some other program and rarely fits.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
103. Purely applicative languages are poorly applicable.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
63. When we write programs that "learn", it turns out that we do and they don't.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
79. A year spent in artificial intelligence is enough to make one believe in God.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
47. As Will Rogers would have said, "There is no such thing as a free variable."
76. It is the user who should parameterize procedures, not their creators.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
114. Within a computer natural language is unnatural.
21. Optimization hinders evolution.
12. Recursion is the root of computation since it trades description for time.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
11. If you have a procedure with ten parameters, you probably missed some.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
76. It is the user who should parameterize procedures, not their creators.
17. If a listener nods his head when you're explaining your program, wake him up.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
104. The proof of a system's value is its existence.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
4. Every program is a part of some other program and rarely fits.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
90. Computation has made the tree flower.
11. If you have a procedure with ten parameters, you probably missed some.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
61. In programming, as in everything else, to be in error is to be reborn.
12. Recursion is the root of computation since it trades description for time.
31. Simplicity does not precede complexity, but follows it.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
15. Everything should be built top-down, except the first time.
27. Once you understand how to write a program get someone else to write it.
38. Structured Programming supports the law of the excluded middle.
115. Most people find the concept of programming obvious, but the doing impossible.
46. Like punning, programming is a play on words.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
21. Optimization hinders evolution.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
11. If you have a procedure with ten parameters, you probably missed some.
61. In programming, as in everything else, to be in error is to be reborn.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
66. Making something variable is easy. Controlling duration of constancy is the trick.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
78. If your computer speaks English, it was probably made in Japan.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
3. Syntactic sugar causes cancer of the semicolon.
11. If you have a procedure with ten parameters, you probably missed some.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
105. You can't communicate complexity, only an awareness of it.
102. One can't proceed from the informal to the formal by formal means.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
63. When we write programs that "learn", it turns out that we do and they don't.
7. It is easier to write an incorrect program than understand a correct one.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
21. Optimization hinders evolution.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
115. Most people find the concept of programming obvious, but the doing impossible.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
43. In software systems, it is often the early bird that makes the worm.
57. It is easier to change the specification to fit the program than vice versa.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
60. In seeking the unattainable, simplicity only gets in the way.
8. A programming language is low level when its programs require attention to the irrelevant.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
17. If a listener nods his head when you're explaining your program, wake him up.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
40. There are two ways to write error-free programs; only the third one works.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
72. An adequate bootstrap is a contradiction in terms.
110. Editing is a rewording activity.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
43. In software systems, it is often the early bird that makes the worm.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
27. Once you understand how to write a program get someone else to write it.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
8. A programming language is low level when its programs require attention to the irrelevant.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
8. A programming language is low level when its programs require attention to the irrelevant.
31. Simplicity does not precede complexity, but follows it.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
66. Making something variable is easy. Controlling duration of constancy is the trick.
18. A program without a loop and a structured variable isn't worth writing.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
110. Editing is a rewording activity.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
47. As Will Rogers would have said, "There is no such thing as a free variable."
78. If your computer speaks English, it was probably made in Japan.
114. Within a computer natural language is unnatural.
4. Every program is a part of some other program and rarely fits.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
8. A programming language is low level when its programs require attention to the irrelevant.
111. Why did the Roman Empire collapse? What is Latin for office automation?
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
55. A LISP programmer knows the value of everything, but the cost of nothing.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
12. Recursion is the root of computation since it trades description for time.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
55. A LISP programmer knows the value of everything, but the cost of nothing.
102. One can't proceed from the informal to the formal by formal means.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
115. Most people find the concept of programming obvious, but the doing impossible.
59. In English every word can be verbed. Would that it were so in our programming languages.
46. Like punning, programming is a play on words.
55. A LISP programmer knows the value of everything, but the cost of nothing.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
119. Programming is an unnatural act.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
23. To understand a program you must become both the machine and the program.
60. In seeking the unattainable, simplicity only gets in the way.
40. There are two ways to write error-free programs; only the third one works.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
23. To understand a program you must become both the machine and the program.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
17. If a listener nods his head when you're explaining your program, wake him up.
43. In software systems, it is often the early bird that makes the worm.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
43. In software systems, it is often the early bird that makes the worm.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
61. In programming, as in everything else, to be in error is to be reborn.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
96. Computers don't introduce order anywhere as much as they expose opportunities.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
60. In seeking the unattainable, simplicity only gets in the way.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
17. If a listener nods his head when you're explaining your program, wake him up.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
11. If you have a procedure with ten parameters, you probably missed some.
27. Once you understand how to write a program get someone else to write it.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
63. When we write programs that "learn", it turns out that we do and they don't.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
21. Optimization hinders evolution.
40. There are two ways to write error-free programs; only the third one works.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
105. You can't communicate complexity, only an awareness of it.
60. In seeking the unattainable, simplicity only gets in the way.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
11. If you have a procedure with ten parameters, you probably missed some.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
3. Syntactic sugar causes cancer of the semicolon.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
103. Purely applicative languages are poorly applicable.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
4. Every program is a part of some other program and rarely fits.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
72. An adequate bootstrap is a contradiction in terms.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
12. Recursion is the root of computation since it trades description for time.
47. As Will Rogers would have said, "There is no such thing as a free variable."
7. It is easier to write an incorrect program than understand a correct one.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
61. In programming, as in everything else, to be in error is to be reborn.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
46. Like punning, programming is a play on words.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
3. Syntactic sugar causes cancer of the semicolon.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
66. Making something variable is easy. Controlling duration of constancy is the trick.
115. Most people find the concept of programming obvious, but the doing impossible.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
108. Whenever two programmers meet to criticize their programs, both are silent.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
79. A year spent in artificial intelligence is enough to make one believe in God.
3. Syntactic sugar causes cancer of the semicolon.
114. Within a computer natural language is unnatural.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
59. In English every word can be verbed. Would that it were so in our programming languages.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
78. If your computer speaks English, it was probably made in Japan.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
57. It is easier to change the specification to fit the program than vice versa.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
115. Most people find the concept of programming obvious, but the doing impossible.
61. In programming, as in everything else, to be in error is to be reborn.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
8. A programming language is low level when its programs require attention to the irrelevant.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
79. A year spent in artificial intelligence is enough to make one believe in God.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
107. The debate rages on: is PL/I Bachtrian or Dromedary?
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
114. Within a computer natural language is unnatural.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
62. In computing, invariants are ephemeral.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
63. When we write programs that "learn", it turns out that we do and they don't.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
90. Computation has made the tree flower.
103. Purely applicative languages are poorly applicable.
40. There are two ways to write error-free programs; only the third one works.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
103. Purely applicative languages are poorly applicable.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
62. In computing, invariants are ephemeral.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
98. In computing, the mean time to failure keeps getting shorter.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
11. If you have a procedure with ten parameters, you probably missed some.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
62. In computing, invariants are ephemeral.
23. To understand a program you must become both the machine and the program.
63. When we write programs that "learn", it turns out that we do and they don't.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
7. It is easier to write an incorrect program than understand a correct one.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
60. In seeking the unattainable, simplicity only gets in the way.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
90. Computation has made the tree flower.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
38. Structured Programming supports the law of the excluded middle.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
1. One man's constant is another man's variable.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
100. We will never run out of things to program as long as there is a single program around.
14. In the long run every program becomes rococo - then rubble.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
27. Once you understand how to write a program get someone else to write it.
3. Syntactic sugar causes cancer of the semicolon.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
119. Programming is an unnatural act.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
112. Computer Science is embarrassed by the computer.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
62. In computing, invariants are ephemeral.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
8. A programming language is low level when its programs require attention to the irrelevant.
43. In software systems, it is often the early bird that makes the worm.
57. It is easier to change the specification to fit the program than vice versa.
31. Simplicity does not precede complexity, but follows it.
14. In the long run every program becomes rococo - then rubble.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
61. In programming, as in everything else, to be in error is to be reborn.
119. Programming is an unnatural act.
61. In programming, as in everything else, to be in error is to be reborn.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
114. Within a computer natural language is unnatural.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
41. Some programming languages manage to absorb change, but withstand progress.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
46. Like punning, programming is a play on words.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
72. An adequate bootstrap is a contradiction in terms.
108. Whenever two programmers meet to criticize their programs, both are silent.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
27. Once you understand how to write a program get someone else to write it.
14. In the long run every program becomes rococo - then rubble.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
111. Why did the Roman Empire collapse? What is Latin for office automation?
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
3. Syntactic sugar causes cancer of the semicolon.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
72. An adequate bootstrap is a contradiction in terms.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
112. Computer Science is embarrassed by the computer.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
102. One can't proceed from the informal to the formal by formal means.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
1. One man's constant is another man's variable.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
11. If you have a procedure with ten parameters, you probably missed some.
112. Computer Science is embarrassed by the computer.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
8. A programming language is low level when its programs require attention to the irrelevant.
96. Computers don't introduce order anywhere as much as they expose opportunities.
66. Making something variable is easy. Controlling duration of constancy is the trick.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
12. Recursion is the root of computation since it trades description for time.
15. Everything should be built top-down, except the first time.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
98. In computing, the mean time to failure keeps getting shorter.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
114. Within a computer natural language is unnatural.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
55. A LISP programmer knows the value of everything, but the cost of nothing.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
23. To understand a program you must become both the machine and the program.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
115. Most people find the concept of programming obvious, but the doing impossible.
18. A program without a loop and a structured variable isn't worth writing.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
8. A programming language is low level when its programs require attention to the irrelevant.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
57. It is easier to change the specification to fit the program than vice versa.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
31. Simplicity does not precede complexity, but follows it.
98. In computing, the mean time to failure keeps getting shorter.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
76. It is the user who should parameterize procedures, not their creators.
11. If you have a procedure with ten parameters, you probably missed some.
112. Computer Science is embarrassed by the computer.
72. An adequate bootstrap is a contradiction in terms.
41. Some programming languages manage to absorb change, but withstand progress.
60. In seeking the unattainable, simplicity only gets in the way.
11. If you have a procedure with ten parameters, you probably missed some.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
7. It is easier to write an incorrect program than understand a correct one.
108. Whenever two programmers meet to criticize their programs, both are silent.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
57. It is easier to change the specification to fit the program than vice versa.
103. Purely applicative languages are poorly applicable.
98. In computing, the mean time to failure keeps getting shorter.
60. In seeking the unattainable, simplicity only gets in the way.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
104. The proof of a system's value is its existence.
59. In English every word can be verbed. Would that it were so in our programming languages.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
111. Why did the Roman Empire collapse? What is Latin for office automation?
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
57. It is easier to change the specification to fit the program than vice versa.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
110. Editing is a rewording activity.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
8. A programming language is low level when its programs require attention to the irrelevant.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
119. Programming is an unnatural act.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
23. To understand a program you must become both the machine and the program.
46. Like punning, programming is a play on words.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
21. Optimization hinders evolution.
105. You can't communicate complexity, only an awareness of it.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
90. Computation has made the tree flower.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
110. Editing is a rewording activity.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
78. If your computer speaks English, it was probably made in Japan.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
115. Most people find the concept of programming obvious, but the doing impossible.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
96. Computers don't introduce order anywhere as much as they expose opportunities.
15. Everything should be built top-down, except the first time.
62. In computing, invariants are ephemeral.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
43. In software systems, it is often the early bird that makes the worm.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
55. A LISP programmer knows the value of everything, but the cost of nothing.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
3. Syntactic sugar causes cancer of the semicolon.
15. Everything should be built top-down, except the first time.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
62. In computing, invariants are ephemeral.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
90. Computation has made the tree flower.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
22. A good system can't have a weak command language.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
47. As Will Rogers would have said, "There is no such thing as a free variable."
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
115. Most people find the concept of programming obvious, but the doing impossible.
12. Recursion is the root of computation since it trades description for time.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
63. When we write programs that "learn", it turns out that we do and they don't.
27. Once you understand how to write a program get someone else to write it.
40. There are two ways to write error-free programs; only the third one works.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
66. Making something variable is easy. Controlling duration of constancy is the trick.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
21. Optimization hinders evolution.
23. To understand a program you must become both the machine and the program.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
47. As Will Rogers would have said, "There is no such thing as a free variable."
14. In the long run every program becomes rococo - then rubble.
61. In programming, as in everything else, to be in error is to be reborn.
43. In software systems, it is often the early bird that makes the worm.
79. A year spent in artificial intelligence is enough to make one believe in God.
108. Whenever two programmers meet to criticize their programs, both are silent.
11. If you have a procedure with ten parameters, you probably missed some.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
40. There are two ways to write error-free programs; only the third one works.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
21. Optimization hinders evolution.
21. Optimization hinders evolution.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
11. If you have a procedure with ten parameters, you probably missed some.
62. In computing, invariants are ephemeral.
7. It is easier to write an incorrect program than understand a correct one.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
62. In computing, invariants are ephemeral.
22. A good system can't have a weak command language.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
47. As Will Rogers would have said, "There is no such thing as a free variable."
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
14. In the long run every program becomes rococo - then rubble.
59. In English every word can be verbed. Would that it were so in our programming languages.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
114. Within a computer natural language is unnatural.
95. Don't have good ideas if you aren't willing to be responsible for them.
79. A year spent in artificial intelligence is enough to make one believe in God.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
40. There are two ways to write error-free programs; only the third one works.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
95. Don't have good ideas if you aren't willing to be responsible for them.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
11. If you have a procedure with ten parameters, you probably missed some.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
111. Why did the Roman Empire collapse? What is Latin for office automation?
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
103. Purely applicative languages are poorly applicable.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
105. You can't communicate complexity, only an awareness of it.
63. When we write programs that "learn", it turns out that we do and they don't.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
105. You can't communicate complexity, only an awareness of it.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
78. If your computer speaks English, it was probably made in Japan.
41. Some programming languages manage to absorb change, but withstand progress.
62. In computing, invariants are ephemeral.
22. A good system can't have a weak command language.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
108. Whenever two programmers meet to criticize their programs, both are silent.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
12. Recursion is the root of computation since it trades description for time.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
108. Whenever two programmers meet to criticize their programs, both are silent.
111. Why did the Roman Empire collapse? What is Latin for office automation?
57. It is easier to change the specification to fit the program than vice versa.
22. A good system can't have a weak command language.
103. Purely applicative languages are poorly applicable.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
17. If a listener nods his head when you're explaining your program, wake him up.
18. A program without a loop and a structured variable isn't worth writing.
27. Once you understand how to write a program get someone else to write it.
18. A program without a loop and a structured variable isn't worth writing.
111. Why did the Roman Empire collapse? What is Latin for office automation?
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
103. Purely applicative languages are poorly applicable.
78. If your computer speaks English, it was probably made in Japan.
14. In the long run every program becomes rococo - then rubble.
40. There are two ways to write error-free programs; only the third one works.
114. Within a computer natural language is unnatural.
11. If you have a procedure with ten parameters, you probably missed some.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
31. Simplicity does not precede complexity, but follows it.
110. Editing is a rewording activity.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
79. A year spent in artificial intelligence is enough to make one believe in God.
96. Computers don't introduce order anywhere as much as they expose opportunities.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
104. The proof of a system's value is its existence.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
95. Don't have good ideas if you aren't willing to be responsible for them.
79. A year spent in artificial intelligence is enough to make one believe in God.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
11. If you have a procedure with ten parameters, you probably missed some.
63. When we write programs that "learn", it turns out that we do and they don't.
46. Like punning, programming is a play on words.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
3. Syntactic sugar causes cancer of the semicolon.
111. Why did the Roman Empire collapse? What is Latin for office automation?
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
46. Like punning, programming is a play on words.
96. Computers don't introduce order anywhere as much as they expose opportunities.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
7. It is easier to write an incorrect program than understand a correct one.
18. A program without a loop and a structured variable isn't worth writing.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
31. Simplicity does not precede complexity, but follows it.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
41. Some programming languages manage to absorb change, but withstand progress.
47. As Will Rogers would have said, "There is no such thing as a free variable."
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
103. Purely applicative languages are poorly applicable.
76. It is the user who should parameterize procedures, not their creators.
21. Optimization hinders evolution.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
111. Why did the Roman Empire collapse? What is Latin for office automation?
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
3. Syntactic sugar causes cancer of the semicolon.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
17. If a listener nods his head when you're explaining your program, wake him up.
46. Like punning, programming is a play on words.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
38. Structured Programming supports the law of the excluded middle.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
40. There are two ways to write error-free programs; only the third one works.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
61. In programming, as in everything else, to be in error is to be reborn.
62. In computing, invariants are ephemeral.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
55. A LISP programmer knows the value of everything, but the cost of nothing.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
111. Why did the Roman Empire collapse? What is Latin for office automation?
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
95. Don't have good ideas if you aren't willing to be responsible for them.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
7. It is easier to write an incorrect program than understand a correct one.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
46. Like punning, programming is a play on words.
110. Editing is a rewording activity.
18. A program without a loop and a structured variable isn't worth writing.
31. Simplicity does not precede complexity, but follows it.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
15. Everything should be built top-down, except the first time.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
104. The proof of a system's value is its existence.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
100. We will never run out of things to program as long as there is a single program around.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
61. In programming, as in everything else, to be in error is to be reborn.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
31. Simplicity does not precede complexity, but follows it.
108. Whenever two programmers meet to criticize their programs, both are silent.
21. Optimization hinders evolution.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
90. Computation has made the tree flower.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
96. Computers don't introduce order anywhere as much as they expose opportunities.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
8. A programming language is low level when its programs require attention to the irrelevant.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
3. Syntactic sugar causes cancer of the semicolon.
23. To understand a program you must become both the machine and the program.
100. We will never run out of things to program as long as there is a single program around.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
62. In computing, invariants are ephemeral.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
7. It is easier to write an incorrect program than understand a correct one.
76. It is the user who should parameterize procedures, not their creators.
14. In the long run every program becomes rococo - then rubble.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
102. One can't proceed from the informal to the formal by formal means.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
22. A good system can't have a weak command language.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
79. A year spent in artificial intelligence is enough to make one believe in God.
72. An adequate bootstrap is a contradiction in terms.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
3. Syntactic sugar causes cancer of the semicolon.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
95. Don't have good ideas if you aren't willing to be responsible for them.
78. If your computer speaks English, it was probably made in Japan.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
17. If a listener nods his head when you're explaining your program, wake him up.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
46. Like punning, programming is a play on words.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
17. If a listener nods his head when you're explaining your program, wake him up.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
14. In the long run every program becomes rococo - then rubble.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
23. To understand a program you must become both the machine and the program.
15. Everything should be built top-down, except the first time.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
62. In computing, invariants are ephemeral.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
55. A LISP programmer knows the value of everything, but the cost of nothing.
18. A program without a loop and a structured variable isn't worth writing.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
14. In the long run every program becomes rococo - then rubble.
103. Purely applicative languages are poorly applicable.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
43. In software systems, it is often the early bird that makes the worm.
22. A good system can't have a weak command language.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
12. Recursion is the root of computation since it trades description for time.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
119. Programming is an unnatural act.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
112. Computer Science is embarrassed by the computer.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
7. It is easier to write an incorrect program than understand a correct one.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
105. You can't communicate complexity, only an awareness of it.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
47. As Will Rogers would have said, "There is no such thing as a free variable."
66. Making something variable is easy. Controlling duration of constancy is the trick.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
3. Syntactic sugar causes cancer of the semicolon.
90. Computation has made the tree flower.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
19. A language that doesn't affect the way you think about programming, is not worth knowing.
40. There are two ways to write error-free programs; only the third one works.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
90. Computation has made the tree flower.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
108. Whenever two programmers meet to criticize their programs, both are silent.
114. Within a computer natural language is unnatural.
46. Like punning, programming is a play on words.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
114. Within a computer natural language is unnatural.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
61. In programming, as in everything else, to be in error is to be reborn.
115. Most people find the concept of programming obvious, but the doing impossible.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
57. It is easier to change the specification to fit the program than vice versa.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
8. A programming language is low level when its programs require attention to the irrelevant.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
115. Most people find the concept of programming obvious, but the doing impossible.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
18. A program without a loop and a structured variable isn't worth writing.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
55. A LISP programmer knows the value of everything, but the cost of nothing.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
47. As Will Rogers would have said, "There is no such thing as a free variable."
55. A LISP programmer knows the value of everything, but the cost of nothing.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
12. Recursion is the root of computation since it trades description for time.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
17. If a listener nods his head when you're explaining your program, wake him up.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
27. Once you understand how to write a program get someone else to write it.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
27. Once you understand how to write a program get someone else to write it.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
40. There are two ways to write error-free programs; only the third one works.
27. Once you understand how to write a program get someone else to write it.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
100. We will never run out of things to program as long as there is a single program around.
119. Programming is an unnatural act.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
66. Making something variable is easy. Controlling duration of constancy is the trick.
78. If your computer speaks English, it was probably made in Japan.
31. Simplicity does not precede complexity, but follows it.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
22. A good system can't have a weak command language.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
1. One man's constant is another man's variable.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
1. One man's constant is another man's variable.
55. A LISP programmer knows the value of everything, but the cost of nothing.
96. Computers don't introduce order anywhere as much as they expose opportunities.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
90. Computation has made the tree flower.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
105. You can't communicate complexity, only an awareness of it.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
1. One man's constant is another man's variable.
14. In the long run every program becomes rococo - then rubble.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
4. Every program is a part of some other program and rarely fits.
62. In computing, invariants are ephemeral.
111. Why did the Roman Empire collapse? What is Latin for office automation?
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
62. In computing, invariants are ephemeral.
104. The proof of a system's value is its existence.
57. It is easier to change the specification to fit the program than vice versa.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
66. Making something variable is easy. Controlling duration of constancy is the trick.
38. Structured Programming supports the law of the excluded middle.
95. Don't have good ideas if you aren't willing to be responsible for them.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
40. There are two ways to write error-free programs; only the third one works.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
103. Purely applicative languages are poorly applicable.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
62. In computing, invariants are ephemeral.
.
.
.
.
.
.
.
40. There are two ways to write error-free programs; only the third one works.
102. One can't proceed from the informal to the formal by formal means.
103. Purely applicative languages are poorly applicable.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
119. Programming is an unnatural act.
55. A LISP programmer knows the value of everything, but the cost of nothing.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
18. A program without a loop and a structured variable isn't worth writing.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
59. In English every word can be verbed. Would that it were so in our programming languages.
104. The proof of a system's value is its existence.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
8. A programming language is low level when its programs require attention to the irrelevant.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
95. Don't have good ideas if you aren't willing to be responsible for them.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
38. Structured Programming supports the law of the excluded middle.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
95. Don't have good ideas if you aren't willing to be responsible for them.
102. One can't proceed from the informal to the formal by formal means.
105. You can't communicate complexity, only an awareness of it.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
21. Optimization hinders evolution.
14. In the long run every program becomes rococo - then rubble.
17. If a listener nods his head when you're explaining your program, wake him up.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
41. Some programming languages manage to absorb change, but withstand progress.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
4. Every program is a part of some other program and rarely fits.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
19. A language that doesn't affect the way you think about programming, is not worth knowing.
31. Simplicity does not precede complexity, but follows it.
96. Computers don't introduce order anywhere as much as they expose opportunities.
57. It is easier to change the specification to fit the program than vice versa.
43. In software systems, it is often the early bird that makes the worm.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
112. Computer Science is embarrassed by the computer.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
47. As Will Rogers would have said, "There is no such thing as a free variable."
1. One man's constant is another man's variable.
23. To understand a program you must become both the machine and the program.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
22. A good system can't have a weak command language.
78. If your computer speaks English, it was probably made in Japan.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
90. Computation has made the tree flower.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
41. Some programming languages manage to absorb change, but withstand progress.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
46. Like punning, programming is a play on words.
78. If your computer speaks English, it was probably made in Japan.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
12. Recursion is the root of computation since it trades description for time.
110. Editing is a rewording activity.
46. Like punning, programming is a play on words.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
21. Optimization hinders evolution.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
119. Programming is an unnatural act.
114. Within a computer natural language is unnatural.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
61. In programming, as in everything else, to be in error is to be reborn.
63. When we write programs that "learn", it turns out that we do and they don't.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
8. A programming language is low level when its programs require attention to the irrelevant.
22. A good system can't have a weak command language.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
8. A programming language is low level when its programs require attention to the irrelevant.
41. Some programming languages manage to absorb change, but withstand progress.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
40. There are two ways to write error-free programs; only the third one works.
63. When we write programs that "learn", it turns out that we do and they don't.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
60. In seeking the unattainable, simplicity only gets in the way.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
76. It is the user who should parameterize procedures, not their creators.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
17. If a listener nods his head when you're explaining your program, wake him up.
46. Like punning, programming is a play on words.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
3. Syntactic sugar causes cancer of the semicolon.
78. If your computer speaks English, it was probably made in Japan.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
66. Making something variable is easy. Controlling duration of constancy is the trick.
59. In English every word can be verbed. Would that it were so in our programming languages.
22. A good system can't have a weak command language.
76. It is the user who should parameterize procedures, not their creators.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
79. A year spent in artificial intelligence is enough to make one believe in God.
15. Everything should be built top-down, except the first time.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
96. Computers don't introduce order anywhere as much as they expose opportunities.
112. Computer Science is embarrassed by the computer.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
1. One man's constant is another man's variable.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
31. Simplicity does not precede complexity, but follows it.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
98. In computing, the mean time to failure keeps getting shorter.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
40. There are two ways to write error-free programs; only the third one works.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
105. You can't communicate complexity, only an awareness of it.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
4. Every program is a part of some other program and rarely fits.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
43. In software systems, it is often the early bird that makes the worm.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
31. Simplicity does not precede complexity, but follows it.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
108. Whenever two programmers meet to criticize their programs, both are silent.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
40. There are two ways to write error-free programs; only the third one works.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
46. Like punning, programming is a play on words.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
61. In programming, as in everything else, to be in error is to be reborn.
57. It is easier to change the specification to fit the program than vice versa.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
63. When we write programs that "learn", it turns out that we do and they don't.
62. In computing, invariants are ephemeral.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
23. To understand a program you must become both the machine and the program.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
59. In English every word can be verbed. Would that it were so in our programming languages.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
18. A program without a loop and a structured variable isn't worth writing.
47. As Will Rogers would have said, "There is no such thing as a free variable."
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
96. Computers don't introduce order anywhere as much as they expose opportunities.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
111. Why did the Roman Empire collapse? What is Latin for office automation?
76. It is the user who should parameterize procedures, not their creators.
17. If a listener nods his head when you're explaining your program, wake him up.
61. In programming, as in everything else, to be in error is to be reborn.
43. In software systems, it is often the early bird that makes the worm.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
7. It is easier to write an incorrect program than understand a correct one.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
104. The proof of a system's value is its existence.
38. Structured Programming supports the law of the excluded middle.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
104. The proof of a system's value is its existence.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
104. The proof of a system's value is its existence.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
103. Purely applicative languages are poorly applicable.
62. In computing, invariants are ephemeral.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
61. In programming, as in everything else, to be in error is to be reborn.
4. Every program is a part of some other program and rarely fits.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
18. A program without a loop and a structured variable isn't worth writing.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
43. In software systems, it is often the early bird that makes the worm.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
40. There are two ways to write error-free programs; only the third one works.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
61. In programming, as in everything else, to be in error is to be reborn.
102. One can't proceed from the informal to the formal by formal means.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
62. In computing, invariants are ephemeral.
115. Most people find the concept of programming obvious, but the doing impossible.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
66. Making something variable is easy. Controlling duration of constancy is the trick.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
1. One man's constant is another man's variable.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
60. In seeking the unattainable, simplicity only gets in the way.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
90. Computation has made the tree flower.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
8. A programming language is low level when its programs require attention to the irrelevant.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
76. It is the user who should parameterize procedures, not their creators.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
38. Structured Programming supports the law of the excluded middle.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
63. When we write programs that "learn", it turns out that we do and they don't.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
114. Within a computer natural language is unnatural.
95. Don't have good ideas if you aren't willing to be responsible for them.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
8. A programming language is low level when its programs require attention to the irrelevant.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
72. An adequate bootstrap is a contradiction in terms.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
27. Once you understand how to write a program get someone else to write it.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
1. One man's constant is another man's variable.
1. One man's constant is another man's variable.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
47. As Will Rogers would have said, "There is no such thing as a free variable."
5. If a program manipulates a large amount of data, it does so in a small number of ways.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
43. In software systems, it is often the early bird that makes the worm.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
1. One man's constant is another man's variable.
103. Purely applicative languages are poorly applicable.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
14. In the long run every program becomes rococo - then rubble.
105. You can't communicate complexity, only an awareness of it.
111. Why did the Roman Empire collapse? What is Latin for office automation?
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
66. Making something variable is easy. Controlling duration of constancy is the trick.
11. If you have a procedure with ten parameters, you probably missed some.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
72. An adequate bootstrap is a contradiction in terms.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
62. In computing, invariants are ephemeral.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
119. Programming is an unnatural act.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
7. It is easier to write an incorrect program than understand a correct one.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
112. Computer Science is embarrassed by the computer.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
115. Most people find the concept of programming obvious, but the doing impossible.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
61. In programming, as in everything else, to be in error is to be reborn.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
27. Once you understand how to write a program get someone else to write it.
1. One man's constant is another man's variable.
3. Syntactic sugar causes cancer of the semicolon.
105. You can't communicate complexity, only an awareness of it.
8. A programming language is low level when its programs require attention to the irrelevant.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
59. In English every word can be verbed. Would that it were so in our programming languages.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
110. Editing is a rewording activity.
47. As Will Rogers would have said, "There is no such thing as a free variable."
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
62. In computing, invariants are ephemeral.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
59. In English every word can be verbed. Would that it were so in our programming languages.
96. Computers don't introduce order anywhere as much as they expose opportunities.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
31. Simplicity does not precede complexity, but follows it.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
110. Editing is a rewording activity.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
108. Whenever two programmers meet to criticize their programs, both are silent.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
23. To understand a program you must become both the machine and the program.
41. Some programming languages manage to absorb change, but withstand progress.
18. A program without a loop and a structured variable isn't worth writing.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
98. In computing, the mean time to failure keeps getting shorter.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
104. The proof of a system's value is its existence.
47. As Will Rogers would have said, "There is no such thing as a free variable."
76. It is the user who should parameterize procedures, not their creators.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
60. In seeking the unattainable, simplicity only gets in the way.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
90. Computation has made the tree flower.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
115. Most people find the concept of programming obvious, but the doing impossible.
12. Recursion is the root of computation since it trades description for time.
90. Computation has made the tree flower.
90. Computation has made the tree flower.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
59. In English every word can be verbed. Would that it were so in our programming languages.
63. When we write programs that "learn", it turns out that we do and they don't.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
38. Structured Programming supports the law of the excluded middle.
96. Computers don't introduce order anywhere as much as they expose opportunities.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
107. The debate rages on: is PL/I Bachtrian or Dromedary?
59. In English every word can be verbed. Would that it were so in our programming languages.
100. We will never run out of things to program as long as there is a single program around.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
102. One can't proceed from the informal to the formal by formal means.
110. Editing is a rewording activity.
119. Programming is an unnatural act.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
72. An adequate bootstrap is a contradiction in terms.
60. In seeking the unattainable, simplicity only gets in the way.
110. Editing is a rewording activity.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
104. The proof of a system's value is its existence.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
104. The proof of a system's value is its existence.
18. A program without a loop and a structured variable isn't worth writing.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
61. In programming, as in everything else, to be in error is to be reborn.
41. Some programming languages manage to absorb change, but withstand progress.
60. In seeking the unattainable, simplicity only gets in the way.
63. When we write programs that "learn", it turns out that we do and they don't.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
61. In programming, as in everything else, to be in error is to be reborn.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
114. Within a computer natural language is unnatural.
119. Programming is an unnatural act.
57. It is easier to change the specification to fit the program than vice versa.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
108. Whenever two programmers meet to criticize their programs, both are silent.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
12. Recursion is the root of computation since it trades description for time.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
111. Why did the Roman Empire collapse? What is Latin for office automation?
7. It is easier to write an incorrect program than understand a correct one.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
98. In computing, the mean time to failure keeps getting shorter.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
12. Recursion is the root of computation since it trades description for time.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
3. Syntactic sugar causes cancer of the semicolon.
114. Within a computer natural language is unnatural.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
12. Recursion is the root of computation since it trades description for time.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
38. Structured Programming supports the law of the excluded middle.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
12. Recursion is the root of computation since it trades description for time.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
111. Why did the Roman Empire collapse? What is Latin for office automation?
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
12. Recursion is the root of computation since it trades description for time.
3. Syntactic sugar causes cancer of the semicolon.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
63. When we write programs that "learn", it turns out that we do and they don't.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
95. Don't have good ideas if you aren't willing to be responsible for them.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
100. We will never run out of things to program as long as there is a single program around.
78. If your computer speaks English, it was probably made in Japan.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
90. Computation has made the tree flower.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
60. In seeking the unattainable, simplicity only gets in the way.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
8. A programming language is low level when its programs require attention to the irrelevant.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
63. When we write programs that "learn", it turns out that we do and they don't.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
27. Once you understand how to write a program get someone else to write it.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
78. If your computer speaks English, it was probably made in Japan.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
105. You can't communicate complexity, only an awareness of it.
11. If you have a procedure with ten parameters, you probably missed some.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
105. You can't communicate complexity, only an awareness of it.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
14. In the long run every program becomes rococo - then rubble.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
115. Most people find the concept of programming obvious, but the doing impossible.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
43. In software systems, it is often the early bird that makes the worm.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
55. A LISP programmer knows the value of everything, but the cost of nothing.
3. Syntactic sugar causes cancer of the semicolon.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
112. Computer Science is embarrassed by the computer.
22. A good system can't have a weak command language.
98. In computing, the mean time to failure keeps getting shorter.
100. We will never run out of things to program as long as there is a single program around.
66. Making something variable is easy. Controlling duration of constancy is the trick.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
55. A LISP programmer knows the value of everything, but the cost of nothing.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
111. Why did the Roman Empire collapse? What is Latin for office automation?
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
8. A programming language is low level when its programs require attention to the irrelevant.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
12. Recursion is the root of computation since it trades description for time.
21. Optimization hinders evolution.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
17. If a listener nods his head when you're explaining your program, wake him up.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
22. A good system can't have a weak command language.
90. Computation has made the tree flower.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
41. Some programming languages manage to absorb change, but withstand progress.
63. When we write programs that "learn", it turns out that we do and they don't.
22. A good system can't have a weak command language.
23. To understand a program you must become both the machine and the program.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
79. A year spent in artificial intelligence is enough to make one believe in God.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
55. A LISP programmer knows the value of everything, but the cost of nothing.
98. In computing, the mean time to failure keeps getting shorter.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
7. It is easier to write an incorrect program than understand a correct one.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
3. Syntactic sugar causes cancer of the semicolon.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
41. Some programming languages manage to absorb change, but withstand progress.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
95. Don't have good ideas if you aren't willing to be responsible for them.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
110. Editing is a rewording activity.
105. You can't communicate complexity, only an awareness of it.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
102. One can't proceed from the informal to the formal by formal means.
43. In software systems, it is often the early bird that makes the worm.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
105. You can't communicate complexity, only an awareness of it.
22. A good system can't have a weak command language.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
21. Optimization hinders evolution.
61. In programming, as in everything else, to be in error is to be reborn.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
102. One can't proceed from the informal to the formal by formal means.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
55. A LISP programmer knows the value of everything, but the cost of nothing.
18. A program without a loop and a structured variable isn't worth writing.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
3. Syntactic sugar causes cancer of the semicolon.
22. A good system can't have a weak command language.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
110. Editing is a rewording activity.
112. Computer Science is embarrassed by the computer.
63. When we write programs that "learn", it turns out that we do and they don't.
14. In the long run every program becomes rococo - then rubble.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
59. In English every word can be verbed. Would that it were so in our programming languages.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
104. The proof of a system's value is its existence.
1. One man's constant is another man's variable.
55. A LISP programmer knows the value of everything, but the cost of nothing.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
103. Purely applicative languages are poorly applicable.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
41. Some programming languages manage to absorb change, but withstand progress.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
3. Syntactic sugar causes cancer of the semicolon.
119. Programming is an unnatural act.
104. The proof of a system's value is its existence.
115. Most people find the concept of programming obvious, but the doing impossible.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
102. One can't proceed from the informal to the formal by formal means.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
38. Structured Programming supports the law of the excluded middle.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
21. Optimization hinders evolution.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
105. You can't communicate complexity, only an awareness of it.
78. If your computer speaks English, it was probably made in Japan.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
59. In English every word can be verbed. Would that it were so in our programming languages.
31. Simplicity does not precede complexity, but follows it.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
12. Recursion is the root of computation since it trades description for time.
18. A program without a loop and a structured variable isn't worth writing.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
115. Most people find the concept of programming obvious, but the doing impossible.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
41. Some programming languages manage to absorb change, but withstand progress.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
59. In English every word can be verbed. Would that it were so in our programming languages.
27. Once you understand how to write a program get someone else to write it.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
31. Simplicity does not precede complexity, but follows it.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
90. Computation has made the tree flower.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
14. In the long run every program becomes rococo - then rubble.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
1. One man's constant is another man's variable.
12. Recursion is the root of computation since it trades description for time.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
