116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
38. Structured Programming supports the law of the excluded middle.
79. A year spent in artificial intelligence is enough to make one believe in God.
47. As Will Rogers would have said, "There is no such thing as a free variable."
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
15. Everything should be built top-down, except the first time.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
110. Editing is a rewording activity.
46. Like punning, programming is a play on words.
23. To understand a program you must become both the machine and the program.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
66. Making something variable is easy. Controlling duration of constancy is the trick.
100. We will never run out of things to program as long as there is a single program around.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
108. Whenever two programmers meet to criticize their programs, both are silent.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
17. If a listener nods his head when you're explaining your program, wake him up.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
98. In computing, the mean time to failure keeps getting shorter.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
98. In computing, the mean time to failure keeps getting shorter.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
96. Computers don't introduce order anywhere as much as they expose opportunities.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
105. You can't communicate complexity, only an awareness of it.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
72. An adequate bootstrap is a contradiction in terms.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
60. In seeking the unattainable, simplicity only gets in the way.
60. In seeking the unattainable, simplicity only gets in the way.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
115. Most people find the concept of programming obvious, but the doing impossible.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
95. Don't have good ideas if you aren't willing to be responsible for them.
110. Editing is a rewording activity.
114. Within a computer natural language is unnatural.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
11. If you have a procedure with ten parameters, you probably missed some.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
4. Every program is a part of some other program and rarely fits.
111. Why did the Roman Empire collapse? What is Latin for office automation?
55. A LISP programmer knows the value of everything, but the cost of nothing.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
111. Why did the Roman Empire collapse? What is Latin for office automation?
57. It is easier to change the specification to fit the program than vice versa.
41. Some programming languages manage to absorb change, but withstand progress.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
63. When we write programs that "learn", it turns out that we do and they don't.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
98. In computing, the mean time to failure keeps getting shorter.
78. If your computer speaks English, it was probably made in Japan.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
61. In programming, as in everything else, to be in error is to be reborn.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
14. In the long run every program becomes rococo - then rubble.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
47. As Will Rogers would have said, "There is no such thing as a free variable."
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
115. Most people find the concept of programming obvious, but the doing impossible.
119. Programming is an unnatural act.
66. Making something variable is easy. Controlling duration of constancy is the trick.
90. Computation has made the tree flower.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
4. Every program is a part of some other program and rarely fits.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
38. Structured Programming supports the law of the excluded middle.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
100. We will never run out of things to program as long as there is a single program around.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
31. Simplicity does not precede complexity, but follows it.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
114. Within a computer natural language is unnatural.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
110. Editing is a rewording activity.
21. Optimization hinders evolution.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
11. If you have a procedure with ten parameters, you probably missed some.
17. If a listener nods his head when you're explaining your program, wake him up.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
27. Once you understand how to write a program get someone else to write it.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
7. It is easier to write an incorrect program than understand a correct one.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
38. Structured Programming supports the law of the excluded middle.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
103. Purely applicative languages are poorly applicable.
76. It is the user who should parameterize procedures, not their creators.
46. Like punning, programming is a play on words.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
60. In seeking the unattainable, simplicity only gets in the way.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
1. One man's constant is another man's variable.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
8. A programming language is low level when its programs require attention to the irrelevant.
27. Once you understand how to write a program get someone else to write it.
59. In English every word can be verbed. Would that it were so in our programming languages.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
47. As Will Rogers would have said, "There is no such thing as a free variable."
95. Don't have good ideas if you aren't willing to be responsible for them.
55. A LISP programmer knows the value of everything, but the cost of nothing.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
3. Syntactic sugar causes cancer of the semicolon.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
76. It is the user who should parameterize procedures, not their creators.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
79. A year spent in artificial intelligence is enough to make one believe in God.
3. Syntactic sugar causes cancer of the semicolon.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
95. Don't have good ideas if you aren't willing to be responsible for them.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
96. Computers don't introduce order anywhere as much as they expose opportunities.
63. When we write programs that "learn", it turns out that we do and they don't.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
114. Within a computer natural language is unnatural.
17. If a listener nods his head when you're explaining your program, wake him up.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
90. Computation has made the tree flower.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
1. One man's constant is another man's variable.
119. Programming is an unnatural act.
4. Every program is a part of some other program and rarely fits.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
72. An adequate bootstrap is a contradiction in terms.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
31. Simplicity does not precede complexity, but follows it.
61. In programming, as in everything else, to be in error is to be reborn.
23. To understand a program you must become both the machine and the program.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
41. Some programming languages manage to absorb change, but withstand progress.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
57. It is easier to change the specification to fit the program than vice versa.
59. In English every word can be verbed. Would that it were so in our programming languages.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
66. Making something variable is easy. Controlling duration of constancy is the trick.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
62. In computing, invariants are ephemeral.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
11. If you have a procedure with ten parameters, you probably missed some.
18. A program without a loop and a structured variable isn't worth writing.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
78. If your computer speaks English, it was probably made in Japan.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
105. You can't communicate complexity, only an awareness of it.
22. A good system can't have a weak command language.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
55. A LISP programmer knows the value of everything, but the cost of nothing.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
22. A good system can't have a weak command language.
17. If a listener nods his head when you're explaining your program, wake him up.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
112. Computer Science is embarrassed by the computer.
7. It is easier to write an incorrect program than understand a correct one.
23. To understand a program you must become both the machine and the program.
1. One man's constant is another man's variable.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
18. A program without a loop and a structured variable isn't worth writing.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
96. Computers don't introduce order anywhere as much as they expose opportunities.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
62. In computing, invariants are ephemeral.
4. Every program is a part of some other program and rarely fits.
61. In programming, as in everything else, to be in error is to be reborn.
108. Whenever two programmers meet to criticize their programs, both are silent.
102. One can't proceed from the informal to the formal by formal means.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
57. It is easier to change the specification to fit the program than vice versa.
104. The proof of a system's value is its existence.
23. To understand a program you must become both the machine and the program.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
96. Computers don't introduce order anywhere as much as they expose opportunities.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
72. An adequate bootstrap is a contradiction in terms.
11. If you have a procedure with ten parameters, you probably missed some.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
47. As Will Rogers would have said, "There is no such thing as a free variable."
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
60. In seeking the unattainable, simplicity only gets in the way.
12. Recursion is the root of computation since it trades description for time.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
114. Within a computer natural language is unnatural.
11. If you have a procedure with ten parameters, you probably missed some.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
102. One can't proceed from the informal to the formal by formal means.
18. A program without a loop and a structured variable isn't worth writing.
119. Programming is an unnatural act.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
12. Recursion is the root of computation since it trades description for time.
62. In computing, invariants are ephemeral.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
14. In the long run every program becomes rococo - then rubble.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
119. Programming is an unnatural act.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
5. If a program manipulates a large amount of data, it does so in a small number of ways.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
38. Structured Programming supports the law of the excluded middle.
4. Every program is a part of some other program and rarely fits.
55. A LISP programmer knows the value of everything, but the cost of nothing.
108. Whenever two programmers meet to criticize their programs, both are silent.
115. Most people find the concept of programming obvious, but the doing impossible.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
62. In computing, invariants are ephemeral.
114. Within a computer natural language is unnatural.
62. In computing, invariants are ephemeral.
17. If a listener nods his head when you're explaining your program, wake him up.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
14. In the long run every program becomes rococo - then rubble.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
60. In seeking the unattainable, simplicity only gets in the way.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
12. Recursion is the root of computation since it trades description for time.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
72. An adequate bootstrap is a contradiction in terms.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
18. A program without a loop and a structured variable isn't worth writing.
12. Recursion is the root of computation since it trades description for time.
72. An adequate bootstrap is a contradiction in terms.
79. A year spent in artificial intelligence is enough to make one believe in God.
112. Computer Science is embarrassed by the computer.
4. Every program is a part of some other program and rarely fits.
111. Why did the Roman Empire collapse? What is Latin for office automation?
17. If a listener nods his head when you're explaining your program, wake him up.
23. To understand a program you must become both the machine and the program.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
62. In computing, invariants are ephemeral.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
119. Programming is an unnatural act.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
40. There are two ways to write error-free programs; only the third one works.
111. Why did the Roman Empire collapse? What is Latin for office automation?
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
8. A programming language is low level when its programs require attention to the irrelevant.
40. There are two ways to write error-free programs; only the third one works.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
3. Syntactic sugar causes cancer of the semicolon.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
59. In English every word can be verbed. Would that it were so in our programming languages.
22. A good system can't have a weak command language.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
7. It is easier to write an incorrect program than understand a correct one.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
38. Structured Programming supports the law of the excluded middle.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
105. You can't communicate complexity, only an awareness of it.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
22. A good system can't have a weak command language.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
3. Syntactic sugar causes cancer of the semicolon.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
102. One can't proceed from the informal to the formal by formal means.
78. If your computer speaks English, it was probably made in Japan.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
72. An adequate bootstrap is a contradiction in terms.
27. Once you understand how to write a program get someone else to write it.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
90. Computation has made the tree flower.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
57. It is easier to change the specification to fit the program than vice versa.
112. Computer Science is embarrassed by the computer.
96. Computers don't introduce order anywhere as much as they expose opportunities.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
119. Programming is an unnatural act.
96. Computers don't introduce order anywhere as much as they expose opportunities.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
17. If a listener nods his head when you're explaining your program, wake him up.
104. The proof of a system's value is its existence.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
1. One man's constant is another man's variable.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
38. Structured Programming supports the law of the excluded middle.
11. If you have a procedure with ten parameters, you probably missed some.
43. In software systems, it is often the early bird that makes the worm.
43. In software systems, it is often the early bird that makes the worm.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
21. Optimization hinders evolution.
62. In computing, invariants are ephemeral.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
18. A program without a loop and a structured variable isn't worth writing.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
18. A program without a loop and a structured variable isn't worth writing.
108. Whenever two programmers meet to criticize their programs, both are silent.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
1. One man's constant is another man's variable.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
14. In the long run every program becomes rococo - then rubble.
66. Making something variable is easy. Controlling duration of constancy is the trick.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
105. You can't communicate complexity, only an awareness of it.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
111. Why did the Roman Empire collapse? What is Latin for office automation?
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
41. Some programming languages manage to absorb change, but withstand progress.
119. Programming is an unnatural act.
11. If you have a procedure with ten parameters, you probably missed some.
17. If a listener nods his head when you're explaining your program, wake him up.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
100. We will never run out of things to program as long as there is a single program around.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
63. When we write programs that "learn", it turns out that we do and they don't.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
55. A LISP programmer knows the value of everything, but the cost of nothing.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
40. There are two ways to write error-free programs; only the third one works.
114. Within a computer natural language is unnatural.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
41. Some programming languages manage to absorb change, but withstand progress.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
96. Computers don't introduce order anywhere as much as they expose opportunities.
22. A good system can't have a weak command language.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
41. Some programming languages manage to absorb change, but withstand progress.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
78. If your computer speaks English, it was probably made in Japan.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
5. If a program manipulates a large amount of data, it does so in a small number of ways.
112. Computer Science is embarrassed by the computer.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
96. Computers don't introduce order anywhere as much as they expose opportunities.
103. Purely applicative languages are poorly applicable.
60. In seeking the unattainable, simplicity only gets in the way.
112. Computer Science is embarrassed by the computer.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
22. A good system can't have a weak command language.
108. Whenever two programmers meet to criticize their programs, both are silent.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
76. It is the user who should parameterize procedures, not their creators.
90. Computation has made the tree flower.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
79. A year spent in artificial intelligence is enough to make one believe in God.
59. In English every word can be verbed. Would that it were so in our programming languages.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
1. One man's constant is another man's variable.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
90. Computation has made the tree flower.
7. It is easier to write an incorrect program than understand a correct one.
57. It is easier to change the specification to fit the program than vice versa.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
1. One man's constant is another man's variable.
59. In English every word can be verbed. Would that it were so in our programming languages.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
40. There are two ways to write error-free programs; only the third one works.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
57. It is easier to change the specification to fit the program than vice versa.
1. One man's constant is another man's variable.
100. We will never run out of things to program as long as there is a single program around.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
18. A program without a loop and a structured variable isn't worth writing.
8. A programming language is low level when its programs require attention to the irrelevant.
7. It is easier to write an incorrect program than understand a correct one.
72. An adequate bootstrap is a contradiction in terms.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
60. In seeking the unattainable, simplicity only gets in the way.
95. Don't have good ideas if you aren't willing to be responsible for them.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
40. There are two ways to write error-free programs; only the third one works.
27. Once you understand how to write a program get someone else to write it.
112. Computer Science is embarrassed by the computer.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
60. In seeking the unattainable, simplicity only gets in the way.
96. Computers don't introduce order anywhere as much as they expose opportunities.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
112. Computer Science is embarrassed by the computer.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
102. One can't proceed from the informal to the formal by formal means.
3. Syntactic sugar causes cancer of the semicolon.
63. When we write programs that "learn", it turns out that we do and they don't.
78. If your computer speaks English, it was probably made in Japan.
41. Some programming languages manage to absorb change, but withstand progress.
55. A LISP programmer knows the value of everything, but the cost of nothing.
1. One man's constant is another man's variable.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
40. There are two ways to write error-free programs; only the third one works.
22. A good system can't have a weak command language.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
90. Computation has made the tree flower.
55. A LISP programmer knows the value of everything, but the cost of nothing.
95. Don't have good ideas if you aren't willing to be responsible for them.
72. An adequate bootstrap is a contradiction in terms.
1. One man's constant is another man's variable.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
100. We will never run out of things to program as long as there is a single program around.
15. Everything should be built top-down, except the first time.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
79. A year spent in artificial intelligence is enough to make one believe in God.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
72. An adequate bootstrap is a contradiction in terms.
8. A programming language is low level when its programs require attention to the irrelevant.
7. It is easier to write an incorrect program than understand a correct one.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
12. Recursion is the root of computation since it trades description for time.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
38. Structured Programming supports the law of the excluded middle.
66. Making something variable is easy. Controlling duration of constancy is the trick.
61. In programming, as in everything else, to be in error is to be reborn.
38. Structured Programming supports the law of the excluded middle.
17. If a listener nods his head when you're explaining your program, wake him up.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
62. In computing, invariants are ephemeral.
76. It is the user who should parameterize procedures, not their creators.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
41. Some programming languages manage to absorb change, but withstand progress.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
102. One can't proceed from the informal to the formal by formal means.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
57. It is easier to change the specification to fit the program than vice versa.
114. Within a computer natural language is unnatural.
111. Why did the Roman Empire collapse? What is Latin for office automation?
46. Like punning, programming is a play on words.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
38. Structured Programming supports the law of the excluded middle.
8. A programming language is low level when its programs require attention to the irrelevant.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
98. In computing, the mean time to failure keeps getting shorter.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
40. There are two ways to write error-free programs; only the third one works.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
8. A programming language is low level when its programs require attention to the irrelevant.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
98. In computing, the mean time to failure keeps getting shorter.
95. Don't have good ideas if you aren't willing to be responsible for them.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
111. Why did the Roman Empire collapse? What is Latin for office automation?
19. A language that doesn't affect the way you think about programming, is not worth knowing.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
66. Making something variable is easy. Controlling duration of constancy is the trick.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
72. An adequate bootstrap is a contradiction in terms.
100. We will never run out of things to program as long as there is a single program around.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
112. Computer Science is embarrassed by the computer.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
111. Why did the Roman Empire collapse? What is Latin for office automation?
112. Computer Science is embarrassed by the computer.
40. There are two ways to write error-free programs; only the third one works.
62. In computing, invariants are ephemeral.
110. Editing is a rewording activity.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
43. In software systems, it is often the early bird that makes the worm.
112. Computer Science is embarrassed by the computer.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
41. Some programming languages manage to absorb change, but withstand progress.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
1. One man's constant is another man's variable.
96. Computers don't introduce order anywhere as much as they expose opportunities.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
46. Like punning, programming is a play on words.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
55. A LISP programmer knows the value of everything, but the cost of nothing.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
1. One man's constant is another man's variable.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
43. In software systems, it is often the early bird that makes the worm.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
79. A year spent in artificial intelligence is enough to make one believe in God.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
5. If a program manipulates a large amount of data, it does so in a small number of ways.
111. Why did the Roman Empire collapse? What is Latin for office automation?
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
103. Purely applicative languages are poorly applicable.
17. If a listener nods his head when you're explaining your program, wake him up.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
46. Like punning, programming is a play on words.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
78. If your computer speaks English, it was probably made in Japan.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
47. As Will Rogers would have said, "There is no such thing as a free variable."
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
119. Programming is an unnatural act.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
4. Every program is a part of some other program and rarely fits.
100. We will never run out of things to program as long as there is a single program around.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
43. In software systems, it is often the early bird that makes the worm.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
102. One can't proceed from the informal to the formal by formal means.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
46. Like punning, programming is a play on words.
76. It is the user who should parameterize procedures, not their creators.
38. Structured Programming supports the law of the excluded middle.
27. Once you understand how to write a program get someone else to write it.
47. As Will Rogers would have said, "There is no such thing as a free variable."
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
57. It is easier to change the specification to fit the program than vice versa.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
72. An adequate bootstrap is a contradiction in terms.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
12. Recursion is the root of computation since it trades description for time.
90. Computation has made the tree flower.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
3. Syntactic sugar causes cancer of the semicolon.
57. It is easier to change the specification to fit the program than vice versa.
12. Recursion is the root of computation since it trades description for time.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
72. An adequate bootstrap is a contradiction in terms.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
47. As Will Rogers would have said, "There is no such thing as a free variable."
79. A year spent in artificial intelligence is enough to make one believe in God.
59. In English every word can be verbed. Would that it were so in our programming languages.
18. A program without a loop and a structured variable isn't worth writing.
21. Optimization hinders evolution.
78. If your computer speaks English, it was probably made in Japan.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
63. When we write programs that "learn", it turns out that we do and they don't.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
21. Optimization hinders evolution.
21. Optimization hinders evolution.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
4. Every program is a part of some other program and rarely fits.
100. We will never run out of things to program as long as there is a single program around.
102. One can't proceed from the informal to the formal by formal means.
96. Computers don't introduce order anywhere as much as they expose opportunities.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
18. A program without a loop and a structured variable isn't worth writing.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
55. A LISP programmer knows the value of everything, but the cost of nothing.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
22. A good system can't have a weak command language.
59. In English every word can be verbed. Would that it were so in our programming languages.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
104. The proof of a system's value is its existence.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
59. In English every word can be verbed. Would that it were so in our programming languages.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
104. The proof of a system's value is its existence.
63. When we write programs that "learn", it turns out that we do and they don't.
60. In seeking the unattainable, simplicity only gets in the way.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
55. A LISP programmer knows the value of everything, but the cost of nothing.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
60. In seeking the unattainable, simplicity only gets in the way.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
7. It is easier to write an incorrect program than understand a correct one.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
76. It is the user who should parameterize procedures, not their creators.
72. An adequate bootstrap is a contradiction in terms.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
1. One man's constant is another man's variable.
14. In the long run every program becomes rococo - then rubble.
7. It is easier to write an incorrect program than understand a correct one.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
57. It is easier to change the specification to fit the program than vice versa.
61. In programming, as in everything else, to be in error is to be reborn.
112. Computer Science is embarrassed by the computer.
11. If you have a procedure with ten parameters, you probably missed some.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
115. Most people find the concept of programming obvious, but the doing impossible.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
79. A year spent in artificial intelligence is enough to make one believe in God.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
108. Whenever two programmers meet to criticize their programs, both are silent.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
8. A programming language is low level when its programs require attention to the irrelevant.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
59. In English every word can be verbed. Would that it were so in our programming languages.
76. It is the user who should parameterize procedures, not their creators.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
62. In computing, invariants are ephemeral.
72. An adequate bootstrap is a contradiction in terms.
14. In the long run every program becomes rococo - then rubble.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
3. Syntactic sugar causes cancer of the semicolon.
21. Optimization hinders evolution.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
17. If a listener nods his head when you're explaining your program, wake him up.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
90. Computation has made the tree flower.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
7. It is easier to write an incorrect program than understand a correct one.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
60. In seeking the unattainable, simplicity only gets in the way.
31. Simplicity does not precede complexity, but follows it.
4. Every program is a part of some other program and rarely fits.
15. Everything should be built top-down, except the first time.
15. Everything should be built top-down, except the first time.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
47. As Will Rogers would have said, "There is no such thing as a free variable."
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
103. Purely applicative languages are poorly applicable.
98. In computing, the mean time to failure keeps getting shorter.
103. Purely applicative languages are poorly applicable.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
114. Within a computer natural language is unnatural.
7. It is easier to write an incorrect program than understand a correct one.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
22. A good system can't have a weak command language.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
102. One can't proceed from the informal to the formal by formal means.
55. A LISP programmer knows the value of everything, but the cost of nothing.
119. Programming is an unnatural act.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
46. Like punning, programming is a play on words.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
7. It is easier to write an incorrect program than understand a correct one.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
43. In software systems, it is often the early bird that makes the worm.
18. A program without a loop and a structured variable isn't worth writing.
95. Don't have good ideas if you aren't willing to be responsible for them.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
111. Why did the Roman Empire collapse? What is Latin for office automation?
21. Optimization hinders evolution.
57. It is easier to change the specification to fit the program than vice versa.
90. Computation has made the tree flower.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
66. Making something variable is easy. Controlling duration of constancy is the trick.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
100. We will never run out of things to program as long as there is a single program around.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
12. Recursion is the root of computation since it trades description for time.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
95. Don't have good ideas if you aren't willing to be responsible for them.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
11. If you have a procedure with ten parameters, you probably missed some.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
62. In computing, invariants are ephemeral.
98. In computing, the mean time to failure keeps getting shorter.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
110. Editing is a rewording activity.
108. Whenever two programmers meet to criticize their programs, both are silent.
14. In the long run every program becomes rococo - then rubble.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
105. You can't communicate complexity, only an awareness of it.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
104. The proof of a system's value is its existence.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
17. If a listener nods his head when you're explaining your program, wake him up.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
3. Syntactic sugar causes cancer of the semicolon.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
78. If your computer speaks English, it was probably made in Japan.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
63. When we write programs that "learn", it turns out that we do and they don't.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
79. A year spent in artificial intelligence is enough to make one believe in God.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
98. In computing, the mean time to failure keeps getting shorter.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
112. Computer Science is embarrassed by the computer.
63. When we write programs that "learn", it turns out that we do and they don't.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
119. Programming is an unnatural act.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
105. You can't communicate complexity, only an awareness of it.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
38. Structured Programming supports the law of the excluded middle.
27. Once you understand how to write a program get someone else to write it.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
114. Within a computer natural language is unnatural.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
60. In seeking the unattainable, simplicity only gets in the way.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
105. You can't communicate complexity, only an awareness of it.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
8. A programming language is low level when its programs require attention to the irrelevant.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
79. A year spent in artificial intelligence is enough to make one believe in God.
59. In English every word can be verbed. Would that it were so in our programming languages.
18. A program without a loop and a structured variable isn't worth writing.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
40. There are two ways to write error-free programs; only the third one works.
76. It is the user who should parameterize procedures, not their creators.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
102. One can't proceed from the informal to the formal by formal means.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
98. In computing, the mean time to failure keeps getting shorter.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
17. If a listener nods his head when you're explaining your program, wake him up.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
60. In seeking the unattainable, simplicity only gets in the way.
61. In programming, as in everything else, to be in error is to be reborn.
14. In the long run every program becomes rococo - then rubble.
3. Syntactic sugar causes cancer of the semicolon.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
108. Whenever two programmers meet to criticize their programs, both are silent.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
38. Structured Programming supports the law of the excluded middle.
59. In English every word can be verbed. Would that it were so in our programming languages.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
12. Recursion is the root of computation since it trades description for time.
115. Most people find the concept of programming obvious, but the doing impossible.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
59. In English every word can be verbed. Would that it were so in our programming languages.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
103. Purely applicative languages are poorly applicable.
98. In computing, the mean time to failure keeps getting shorter.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
95. Don't have good ideas if you aren't willing to be responsible for them.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
18. A program without a loop and a structured variable isn't worth writing.
90. Computation has made the tree flower.
47. As Will Rogers would have said, "There is no such thing as a free variable."
115. Most people find the concept of programming obvious, but the doing impossible.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
78. If your computer speaks English, it was probably made in Japan.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
1. One man's constant is another man's variable.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
47. As Will Rogers would have said, "There is no such thing as a free variable."
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
31. Simplicity does not precede complexity, but follows it.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
111. Why did the Roman Empire collapse? What is Latin for office automation?
21. Optimization hinders evolution.
62. In computing, invariants are ephemeral.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
62. In computing, invariants are ephemeral.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
98. In computing, the mean time to failure keeps getting shorter.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
60. In seeking the unattainable, simplicity only gets in the way.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
61. In programming, as in everything else, to be in error is to be reborn.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
95. Don't have good ideas if you aren't willing to be responsible for them.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
98. In computing, the mean time to failure keeps getting shorter.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
100. We will never run out of things to program as long as there is a single program around.
119. Programming is an unnatural act.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
43. In software systems, it is often the early bird that makes the worm.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
4. Every program is a part of some other program and rarely fits.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
104. The proof of a system's value is its existence.
76. It is the user who should parameterize procedures, not their creators.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
55. A LISP programmer knows the value of everything, but the cost of nothing.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
98. In computing, the mean time to failure keeps getting shorter.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
11. If you have a procedure with ten parameters, you probably missed some.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
8. A programming language is low level when its programs require attention to the irrelevant.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
110. Editing is a rewording activity.
3. Syntactic sugar causes cancer of the semicolon.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
62. In computing, invariants are ephemeral.
21. Optimization hinders evolution.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
72. An adequate bootstrap is a contradiction in terms.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
17. If a listener nods his head when you're explaining your program, wake him up.
72. An adequate bootstrap is a contradiction in terms.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
102. One can't proceed from the informal to the formal by formal means.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
14. In the long run every program becomes rococo - then rubble.
17. If a listener nods his head when you're explaining your program, wake him up.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
66. Making something variable is easy. Controlling duration of constancy is the trick.
7. It is easier to write an incorrect program than understand a correct one.
1. One man's constant is another man's variable.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
38. Structured Programming supports the law of the excluded middle.
17. If a listener nods his head when you're explaining your program, wake him up.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
21. Optimization hinders evolution.
11. If you have a procedure with ten parameters, you probably missed some.
31. Simplicity does not precede complexity, but follows it.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
96. Computers don't introduce order anywhere as much as they expose opportunities.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
112. Computer Science is embarrassed by the computer.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
3. Syntactic sugar causes cancer of the semicolon.
119. Programming is an unnatural act.
47. As Will Rogers would have said, "There is no such thing as a free variable."
110. Editing is a rewording activity.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
66. Making something variable is easy. Controlling duration of constancy is the trick.
18. A program without a loop and a structured variable isn't worth writing.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
62. In computing, invariants are ephemeral.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
3. Syntactic sugar causes cancer of the semicolon.
59. In English every word can be verbed. Would that it were so in our programming languages.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
57. It is easier to change the specification to fit the program than vice versa.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
23. To understand a program you must become both the machine and the program.
38. Structured Programming supports the law of the excluded middle.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
1. One man's constant is another man's variable.
4. Every program is a part of some other program and rarely fits.
18. A program without a loop and a structured variable isn't worth writing.
105. You can't communicate complexity, only an awareness of it.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
8. A programming language is low level when its programs require attention to the irrelevant.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
90. Computation has made the tree flower.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
7. It is easier to write an incorrect program than understand a correct one.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
17. If a listener nods his head when you're explaining your program, wake him up.
105. You can't communicate complexity, only an awareness of it.
1. One man's constant is another man's variable.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
38. Structured Programming supports the law of the excluded middle.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
23. To understand a program you must become both the machine and the program.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
41. Some programming languages manage to absorb change, but withstand progress.
8. A programming language is low level when its programs require attention to the irrelevant.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
63. When we write programs that "learn", it turns out that we do and they don't.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
21. Optimization hinders evolution.
60. In seeking the unattainable, simplicity only gets in the way.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
3. Syntactic sugar causes cancer of the semicolon.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
23. To understand a program you must become both the machine and the program.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
111. Why did the Roman Empire collapse? What is Latin for office automation?
47. As Will Rogers would have said, "There is no such thing as a free variable."
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
3. Syntactic sugar causes cancer of the semicolon.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
119. Programming is an unnatural act.
15. Everything should be built top-down, except the first time.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
22. A good system can't have a weak command language.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
111. Why did the Roman Empire collapse? What is Latin for office automation?
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
95. Don't have good ideas if you aren't willing to be responsible for them.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
61. In programming, as in everything else, to be in error is to be reborn.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
46. Like punning, programming is a play on words.
57. It is easier to change the specification to fit the program than vice versa.
79. A year spent in artificial intelligence is enough to make one believe in God.
78. If your computer speaks English, it was probably made in Japan.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
104. The proof of a system's value is its existence.
102. One can't proceed from the informal to the formal by formal means.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
110. Editing is a rewording activity.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
38. Structured Programming supports the law of the excluded middle.
119. Programming is an unnatural act.
76. It is the user who should parameterize procedures, not their creators.
112. Computer Science is embarrassed by the computer.
31. Simplicity does not precede complexity, but follows it.
111. Why did the Roman Empire collapse? What is Latin for office automation?
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
66. Making something variable is easy. Controlling duration of constancy is the trick.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
3. Syntactic sugar causes cancer of the semicolon.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
47. As Will Rogers would have said, "There is no such thing as a free variable."
119. Programming is an unnatural act.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
60. In seeking the unattainable, simplicity only gets in the way.
90. Computation has made the tree flower.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
119. Programming is an unnatural act.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
27. Once you understand how to write a program get someone else to write it.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
22. A good system can't have a weak command language.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
1. One man's constant is another man's variable.
62. In computing, invariants are ephemeral.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
63. When we write programs that "learn", it turns out that we do and they don't.
41. Some programming languages manage to absorb change, but withstand progress.
100. We will never run out of things to program as long as there is a single program around.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
23. To understand a program you must become both the machine and the program.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
76. It is the user who should parameterize procedures, not their creators.
105. You can't communicate complexity, only an awareness of it.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
119. Programming is an unnatural act.
17. If a listener nods his head when you're explaining your program, wake him up.
90. Computation has made the tree flower.
119. Programming is an unnatural act.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
41. Some programming languages manage to absorb change, but withstand progress.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
15. Everything should be built top-down, except the first time.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
98. In computing, the mean time to failure keeps getting shorter.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
57. It is easier to change the specification to fit the program than vice versa.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
23. To understand a program you must become both the machine and the program.
79. A year spent in artificial intelligence is enough to make one believe in God.
38. Structured Programming supports the law of the excluded middle.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
23. To understand a program you must become both the machine and the program.
1. One man's constant is another man's variable.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
31. Simplicity does not precede complexity, but follows it.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
115. Most people find the concept of programming obvious, but the doing impossible.
105. You can't communicate complexity, only an awareness of it.
14. In the long run every program becomes rococo - then rubble.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
47. As Will Rogers would have said, "There is no such thing as a free variable."
102. One can't proceed from the informal to the formal by formal means.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
47. As Will Rogers would have said, "There is no such thing as a free variable."
112. Computer Science is embarrassed by the computer.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
112. Computer Science is embarrassed by the computer.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
62. In computing, invariants are ephemeral.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
90. Computation has made the tree flower.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
55. A LISP programmer knows the value of everything, but the cost of nothing.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
111. Why did the Roman Empire collapse? What is Latin for office automation?
19. A language that doesn't affect the way you think about programming, is not worth knowing.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
61. In programming, as in everything else, to be in error is to be reborn.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
17. If a listener nods his head when you're explaining your program, wake him up.
22. A good system can't have a weak command language.
22. A good system can't have a weak command language.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
7. It is easier to write an incorrect program than understand a correct one.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
7. It is easier to write an incorrect program than understand a correct one.
18. A program without a loop and a structured variable isn't worth writing.
112. Computer Science is embarrassed by the computer.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
90. Computation has made the tree flower.
47. As Will Rogers would have said, "There is no such thing as a free variable."
95. Don't have good ideas if you aren't willing to be responsible for them.
110. Editing is a rewording activity.
66. Making something variable is easy. Controlling duration of constancy is the trick.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
8. A programming language is low level when its programs require attention to the irrelevant.
18. A program without a loop and a structured variable isn't worth writing.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
46. Like punning, programming is a play on words.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
8. A programming language is low level when its programs require attention to the irrelevant.
98. In computing, the mean time to failure keeps getting shorter.
40. There are two ways to write error-free programs; only the third one works.
72. An adequate bootstrap is a contradiction in terms.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
115. Most people find the concept of programming obvious, but the doing impossible.
103. Purely applicative languages are poorly applicable.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
46. Like punning, programming is a play on words.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
41. Some programming languages manage to absorb change, but withstand progress.
7. It is easier to write an incorrect program than understand a correct one.
76. It is the user who should parameterize procedures, not their creators.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
108. Whenever two programmers meet to criticize their programs, both are silent.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
11. If you have a procedure with ten parameters, you probably missed some.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
43. In software systems, it is often the early bird that makes the worm.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
96. Computers don't introduce order anywhere as much as they expose opportunities.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
60. In seeking the unattainable, simplicity only gets in the way.
103. Purely applicative languages are poorly applicable.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
61. In programming, as in everything else, to be in error is to be reborn.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
14. In the long run every program becomes rococo - then rubble.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
18. A program without a loop and a structured variable isn't worth writing.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
98. In computing, the mean time to failure keeps getting shorter.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
43. In software systems, it is often the early bird that makes the worm.
66. Making something variable is easy. Controlling duration of constancy is the trick.
110. Editing is a rewording activity.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
112. Computer Science is embarrassed by the computer.
7. It is easier to write an incorrect program than understand a correct one.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
46. Like punning, programming is a play on words.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
104. The proof of a system's value is its existence.
23. To understand a program you must become both the machine and the program.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
79. A year spent in artificial intelligence is enough to make one believe in God.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
62. In computing, invariants are ephemeral.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
119. Programming is an unnatural act.
105. You can't communicate complexity, only an awareness of it.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
59. In English every word can be verbed. Would that it were so in our programming languages.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
31. Simplicity does not precede complexity, but follows it.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
31. Simplicity does not precede complexity, but follows it.
119. Programming is an unnatural act.
103. Purely applicative languages are poorly applicable.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
4. Every program is a part of some other program and rarely fits.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
100. We will never run out of things to program as long as there is a single program around.
112. Computer Science is embarrassed by the computer.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
95. Don't have good ideas if you aren't willing to be responsible for them.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
102. One can't proceed from the informal to the formal by formal means.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
7. It is easier to write an incorrect program than understand a correct one.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
17. If a listener nods his head when you're explaining your program, wake him up.
72. An adequate bootstrap is a contradiction in terms.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
59. In English every word can be verbed. Would that it were so in our programming languages.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
38. Structured Programming supports the law of the excluded middle.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
111. Why did the Roman Empire collapse? What is Latin for office automation?
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
104. The proof of a system's value is its existence.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
14. In the long run every program becomes rococo - then rubble.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
60. In seeking the unattainable, simplicity only gets in the way.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
46. Like punning, programming is a play on words.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
100. We will never run out of things to program as long as there is a single program around.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
107. The debate rages on: is PL/I Bachtrian or Dromedary?
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
90. Computation has made the tree flower.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
46. Like punning, programming is a play on words.
90. Computation has made the tree flower.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
47. As Will Rogers would have said, "There is no such thing as a free variable."
111. Why did the Roman Empire collapse? What is Latin for office automation?
23. To understand a program you must become both the machine and the program.
78. If your computer speaks English, it was probably made in Japan.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
8. A programming language is low level when its programs require attention to the irrelevant.
61. In programming, as in everything else, to be in error is to be reborn.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
7. It is easier to write an incorrect program than understand a correct one.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
112. Computer Science is embarrassed by the computer.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
21. Optimization hinders evolution.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
72. An adequate bootstrap is a contradiction in terms.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
107. The debate rages on: is PL/I Bachtrian or Dromedary?
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
111. Why did the Roman Empire collapse? What is Latin for office automation?
8. A programming language is low level when its programs require attention to the irrelevant.
98. In computing, the mean time to failure keeps getting shorter.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
15. Everything should be built top-down, except the first time.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
27. Once you understand how to write a program get someone else to write it.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
104. The proof of a system's value is its existence.
79. A year spent in artificial intelligence is enough to make one believe in God.
31. Simplicity does not precede complexity, but follows it.
115. Most people find the concept of programming obvious, but the doing impossible.
112. Computer Science is embarrassed by the computer.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
115. Most people find the concept of programming obvious, but the doing impossible.
72. An adequate bootstrap is a contradiction in terms.
105. You can't communicate complexity, only an awareness of it.
23. To understand a program you must become both the machine and the program.
76. It is the user who should parameterize procedures, not their creators.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
55. A LISP programmer knows the value of everything, but the cost of nothing.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
108. Whenever two programmers meet to criticize their programs, both are silent.
90. Computation has made the tree flower.
18. A program without a loop and a structured variable isn't worth writing.
15. Everything should be built top-down, except the first time.
76. It is the user who should parameterize procedures, not their creators.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
90. Computation has made the tree flower.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
46. Like punning, programming is a play on words.
119. Programming is an unnatural act.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
112. Computer Science is embarrassed by the computer.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
108. Whenever two programmers meet to criticize their programs, both are silent.
114. Within a computer natural language is unnatural.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
96. Computers don't introduce order anywhere as much as they expose opportunities.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
23. To understand a program you must become both the machine and the program.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
95. Don't have good ideas if you aren't willing to be responsible for them.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
110. Editing is a rewording activity.
63. When we write programs that "learn", it turns out that we do and they don't.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
78. If your computer speaks English, it was probably made in Japan.
72. An adequate bootstrap is a contradiction in terms.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
43. In software systems, it is often the early bird that makes the worm.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
15. Everything should be built top-down, except the first time.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
59. In English every word can be verbed. Would that it were so in our programming languages.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
100. We will never run out of things to program as long as there is a single program around.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
72. An adequate bootstrap is a contradiction in terms.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
3. Syntactic sugar causes cancer of the semicolon.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
43. In software systems, it is often the early bird that makes the worm.
72. An adequate bootstrap is a contradiction in terms.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
63. When we write programs that "learn", it turns out that we do and they don't.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
4. Every program is a part of some other program and rarely fits.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
8. A programming language is low level when its programs require attention to the irrelevant.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
103. Purely applicative languages are poorly applicable.
21. Optimization hinders evolution.
114. Within a computer natural language is unnatural.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
14. In the long run every program becomes rococo - then rubble.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
31. Simplicity does not precede complexity, but follows it.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
114. Within a computer natural language is unnatural.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
17. If a listener nods his head when you're explaining your program, wake him up.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
46. Like punning, programming is a play on words.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
104. The proof of a system's value is its existence.
22. A good system can't have a weak command language.
31. Simplicity does not precede complexity, but follows it.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
7. It is easier to write an incorrect program than understand a correct one.
103. Purely applicative languages are poorly applicable.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
41. Some programming languages manage to absorb change, but withstand progress.
11. If you have a procedure with ten parameters, you probably missed some.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
102. One can't proceed from the informal to the formal by formal means.
103. Purely applicative languages are poorly applicable.
105. You can't communicate complexity, only an awareness of it.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
112. Computer Science is embarrassed by the computer.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
15. Everything should be built top-down, except the first time.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
62. In computing, invariants are ephemeral.
96. Computers don't introduce order anywhere as much as they expose opportunities.
98. In computing, the mean time to failure keeps getting shorter.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
40. There are two ways to write error-free programs; only the third one works.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
17. If a listener nods his head when you're explaining your program, wake him up.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
17. If a listener nods his head when you're explaining your program, wake him up.
60. In seeking the unattainable, simplicity only gets in the way.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
43. In software systems, it is often the early bird that makes the worm.
111. Why did the Roman Empire collapse? What is Latin for office automation?
107. The debate rages on: is PL/I Bachtrian or Dromedary?
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
98. In computing, the mean time to failure keeps getting shorter.
11. If you have a procedure with ten parameters, you probably missed some.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
98. In computing, the mean time to failure keeps getting shorter.
110. Editing is a rewording activity.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
110. Editing is a rewording activity.
47. As Will Rogers would have said, "There is no such thing as a free variable."
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
8. A programming language is low level when its programs require attention to the irrelevant.
41. Some programming languages manage to absorb change, but withstand progress.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
104. The proof of a system's value is its existence.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
90. Computation has made the tree flower.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
46. Like punning, programming is a play on words.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
40. There are two ways to write error-free programs; only the third one works.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
119. Programming is an unnatural act.
60. In seeking the unattainable, simplicity only gets in the way.
66. Making something variable is easy. Controlling duration of constancy is the trick.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
1. One man's constant is another man's variable.
108. Whenever two programmers meet to criticize their programs, both are silent.
31. Simplicity does not precede complexity, but follows it.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
57. It is easier to change the specification to fit the program than vice versa.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
1. One man's constant is another man's variable.
79. A year spent in artificial intelligence is enough to make one believe in God.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
3. Syntactic sugar causes cancer of the semicolon.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
47. As Will Rogers would have said, "There is no such thing as a free variable."
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
55. A LISP programmer knows the value of everything, but the cost of nothing.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
47. As Will Rogers would have said, "There is no such thing as a free variable."
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
12. Recursion is the root of computation since it trades description for time.
105. You can't communicate complexity, only an awareness of it.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
98. In computing, the mean time to failure keeps getting shorter.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
17. If a listener nods his head when you're explaining your program, wake him up.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
104. The proof of a system's value is its existence.
27. Once you understand how to write a program get someone else to write it.
90. Computation has made the tree flower.
112. Computer Science is embarrassed by the computer.
72. An adequate bootstrap is a contradiction in terms.
111. Why did the Roman Empire collapse? What is Latin for office automation?
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
111. Why did the Roman Empire collapse? What is Latin for office automation?
114. Within a computer natural language is unnatural.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
72. An adequate bootstrap is a contradiction in terms.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
27. Once you understand how to write a program get someone else to write it.
21. Optimization hinders evolution.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
17. If a listener nods his head when you're explaining your program, wake him up.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
18. A program without a loop and a structured variable isn't worth writing.
18. A program without a loop and a structured variable isn't worth writing.
112. Computer Science is embarrassed by the computer.
72. An adequate bootstrap is a contradiction in terms.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
4. Every program is a part of some other program and rarely fits.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
18. A program without a loop and a structured variable isn't worth writing.
31. Simplicity does not precede complexity, but follows it.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
14. In the long run every program becomes rococo - then rubble.
96. Computers don't introduce order anywhere as much as they expose opportunities.
100. We will never run out of things to program as long as there is a single program around.
11. If you have a procedure with ten parameters, you probably missed some.
57. It is easier to change the specification to fit the program than vice versa.
8. A programming language is low level when its programs require attention to the irrelevant.
7. It is easier to write an incorrect program than understand a correct one.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
102. One can't proceed from the informal to the formal by formal means.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
98. In computing, the mean time to failure keeps getting shorter.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
104. The proof of a system's value is its existence.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
114. Within a computer natural language is unnatural.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
27. Once you understand how to write a program get someone else to write it.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
27. Once you understand how to write a program get someone else to write it.
105. You can't communicate complexity, only an awareness of it.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
40. There are two ways to write error-free programs; only the third one works.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
59. In English every word can be verbed. Would that it were so in our programming languages.
111. Why did the Roman Empire collapse? What is Latin for office automation?
55. A LISP programmer knows the value of everything, but the cost of nothing.
96. Computers don't introduce order anywhere as much as they expose opportunities.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
114. Within a computer natural language is unnatural.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
62. In computing, invariants are ephemeral.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
112. Computer Science is embarrassed by the computer.
96. Computers don't introduce order anywhere as much as they expose opportunities.
15. Everything should be built top-down, except the first time.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
62. In computing, invariants are ephemeral.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
114. Within a computer natural language is unnatural.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
114. Within a computer natural language is unnatural.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
1. One man's constant is another man's variable.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
60. In seeking the unattainable, simplicity only gets in the way.
11. If you have a procedure with ten parameters, you probably missed some.
66. Making something variable is easy. Controlling duration of constancy is the trick.
40. There are two ways to write error-free programs; only the third one works.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
59. In English every word can be verbed. Would that it were so in our programming languages.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
23. To understand a program you must become both the machine and the program.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
111. Why did the Roman Empire collapse? What is Latin for office automation?
111. Why did the Roman Empire collapse? What is Latin for office automation?
22. A good system can't have a weak command language.
96. Computers don't introduce order anywhere as much as they expose opportunities.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
22. A good system can't have a weak command language.
66. Making something variable is easy. Controlling duration of constancy is the trick.
41. Some programming languages manage to absorb change, but withstand progress.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
12. Recursion is the root of computation since it trades description for time.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
95. Don't have good ideas if you aren't willing to be responsible for them.
111. Why did the Roman Empire collapse? What is Latin for office automation?
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
4. Every program is a part of some other program and rarely fits.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
115. Most people find the concept of programming obvious, but the doing impossible.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
78. If your computer speaks English, it was probably made in Japan.
76. It is the user who should parameterize procedures, not their creators.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
23. To understand a program you must become both the machine and the program.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
41. Some programming languages manage to absorb change, but withstand progress.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
103. Purely applicative languages are poorly applicable.
17. If a listener nods his head when you're explaining your program, wake him up.
38. Structured Programming supports the law of the excluded middle.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
21. Optimization hinders evolution.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
57. It is easier to change the specification to fit the program than vice versa.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
114. Within a computer natural language is unnatural.
78. If your computer speaks English, it was probably made in Japan.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
60. In seeking the unattainable, simplicity only gets in the way.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
22. A good system can't have a weak command language.
76. It is the user who should parameterize procedures, not their creators.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
111. Why did the Roman Empire collapse? What is Latin for office automation?
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
22. A good system can't have a weak command language.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
110. Editing is a rewording activity.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
79. A year spent in artificial intelligence is enough to make one believe in God.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
79. A year spent in artificial intelligence is enough to make one believe in God.
59. In English every word can be verbed. Would that it were so in our programming languages.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
15. Everything should be built top-down, except the first time.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
59. In English every word can be verbed. Would that it were so in our programming languages.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
55. A LISP programmer knows the value of everything, but the cost of nothing.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
111. Why did the Roman Empire collapse? What is Latin for office automation?
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
108. Whenever two programmers meet to criticize their programs, both are silent.
111. Why did the Roman Empire collapse? What is Latin for office automation?
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
27. Once you understand how to write a program get someone else to write it.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
46. Like punning, programming is a play on words.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
119. Programming is an unnatural act.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
112. Computer Science is embarrassed by the computer.
22. A good system can't have a weak command language.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
17. If a listener nods his head when you're explaining your program, wake him up.
18. A program without a loop and a structured variable isn't worth writing.
41. Some programming languages manage to absorb change, but withstand progress.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
18. A program without a loop and a structured variable isn't worth writing.
27. Once you understand how to write a program get someone else to write it.
1. One man's constant is another man's variable.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
41. Some programming languages manage to absorb change, but withstand progress.
17. If a listener nods his head when you're explaining your program, wake him up.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
95. Don't have good ideas if you aren't willing to be responsible for them.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
55. A LISP programmer knows the value of everything, but the cost of nothing.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
23. To understand a program you must become both the machine and the program.
119. Programming is an unnatural act.
103. Purely applicative languages are poorly applicable.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
112. Computer Science is embarrassed by the computer.
95. Don't have good ideas if you aren't willing to be responsible for them.
78. If your computer speaks English, it was probably made in Japan.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
4. Every program is a part of some other program and rarely fits.
115. Most people find the concept of programming obvious, but the doing impossible.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
12. Recursion is the root of computation since it trades description for time.
14. In the long run every program becomes rococo - then rubble.
55. A LISP programmer knows the value of everything, but the cost of nothing.
57. It is easier to change the specification to fit the program than vice versa.
57. It is easier to change the specification to fit the program than vice versa.
18. A program without a loop and a structured variable isn't worth writing.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
98. In computing, the mean time to failure keeps getting shorter.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
103. Purely applicative languages are poorly applicable.
90. Computation has made the tree flower.
18. A program without a loop and a structured variable isn't worth writing.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
114. Within a computer natural language is unnatural.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
38. Structured Programming supports the law of the excluded middle.
15. Everything should be built top-down, except the first time.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
17. If a listener nods his head when you're explaining your program, wake him up.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
60. In seeking the unattainable, simplicity only gets in the way.
103. Purely applicative languages are poorly applicable.
38. Structured Programming supports the law of the excluded middle.
79. A year spent in artificial intelligence is enough to make one believe in God.
3. Syntactic sugar causes cancer of the semicolon.
111. Why did the Roman Empire collapse? What is Latin for office automation?
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
55. A LISP programmer knows the value of everything, but the cost of nothing.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
31. Simplicity does not precede complexity, but follows it.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
57. It is easier to change the specification to fit the program than vice versa.
57. It is easier to change the specification to fit the program than vice versa.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
119. Programming is an unnatural act.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
105. You can't communicate complexity, only an awareness of it.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
63. When we write programs that "learn", it turns out that we do and they don't.
3. Syntactic sugar causes cancer of the semicolon.
27. Once you understand how to write a program get someone else to write it.
60. In seeking the unattainable, simplicity only gets in the way.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
96. Computers don't introduce order anywhere as much as they expose opportunities.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
61. In programming, as in everything else, to be in error is to be reborn.
72. An adequate bootstrap is a contradiction in terms.
100. We will never run out of things to program as long as there is a single program around.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
72. An adequate bootstrap is a contradiction in terms.
62. In computing, invariants are ephemeral.
102. One can't proceed from the informal to the formal by formal means.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
78. If your computer speaks English, it was probably made in Japan.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
98. In computing, the mean time to failure keeps getting shorter.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
3. Syntactic sugar causes cancer of the semicolon.
108. Whenever two programmers meet to criticize their programs, both are silent.
23. To understand a program you must become both the machine and the program.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
23. To understand a program you must become both the machine and the program.
38. Structured Programming supports the law of the excluded middle.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
76. It is the user who should parameterize procedures, not their creators.
72. An adequate bootstrap is a contradiction in terms.
12. Recursion is the root of computation since it trades description for time.
7. It is easier to write an incorrect program than understand a correct one.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
55. A LISP programmer knows the value of everything, but the cost of nothing.
105. You can't communicate complexity, only an awareness of it.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
66. Making something variable is easy. Controlling duration of constancy is the trick.
76. It is the user who should parameterize procedures, not their creators.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
96. Computers don't introduce order anywhere as much as they expose opportunities.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
104. The proof of a system's value is its existence.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
111. Why did the Roman Empire collapse? What is Latin for office automation?
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
100. We will never run out of things to program as long as there is a single program around.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
114. Within a computer natural language is unnatural.
40. There are two ways to write error-free programs; only the third one works.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
46. Like punning, programming is a play on words.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
12. Recursion is the root of computation since it trades description for time.
21. Optimization hinders evolution.
3. Syntactic sugar causes cancer of the semicolon.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
105. You can't communicate complexity, only an awareness of it.
8. A programming language is low level when its programs require attention to the irrelevant.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
111. Why did the Roman Empire collapse? What is Latin for office automation?
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
4. Every program is a part of some other program and rarely fits.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
119. Programming is an unnatural act.
114. Within a computer natural language is unnatural.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
119. Programming is an unnatural act.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
47. As Will Rogers would have said, "There is no such thing as a free variable."
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
8. A programming language is low level when its programs require attention to the irrelevant.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
105. You can't communicate complexity, only an awareness of it.
90. Computation has made the tree flower.
15. Everything should be built top-down, except the first time.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
108. Whenever two programmers meet to criticize their programs, both are silent.
72. An adequate bootstrap is a contradiction in terms.
4. Every program is a part of some other program and rarely fits.
110. Editing is a rewording activity.
7. It is easier to write an incorrect program than understand a correct one.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
43. In software systems, it is often the early bird that makes the worm.
14. In the long run every program becomes rococo - then rubble.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
46. Like punning, programming is a play on words.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
115. Most people find the concept of programming obvious, but the doing impossible.
105. You can't communicate complexity, only an awareness of it.
62. In computing, invariants are ephemeral.
111. Why did the Roman Empire collapse? What is Latin for office automation?
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
119. Programming is an unnatural act.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
17. If a listener nods his head when you're explaining your program, wake him up.
27. Once you understand how to write a program get someone else to write it.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
66. Making something variable is easy. Controlling duration of constancy is the trick.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
40. There are two ways to write error-free programs; only the third one works.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
98. In computing, the mean time to failure keeps getting shorter.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
63. When we write programs that "learn", it turns out that we do and they don't.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
61. In programming, as in everything else, to be in error is to be reborn.
72. An adequate bootstrap is a contradiction in terms.
27. Once you understand how to write a program get someone else to write it.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
112. Computer Science is embarrassed by the computer.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
63. When we write programs that "learn", it turns out that we do and they don't.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
62. In computing, invariants are ephemeral.
55. A LISP programmer knows the value of everything, but the cost of nothing.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
63. When we write programs that "learn", it turns out that we do and they don't.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
15. Everything should be built top-down, except the first time.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
78. If your computer speaks English, it was probably made in Japan.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
1. One man's constant is another man's variable.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
119. Programming is an unnatural act.
4. Every program is a part of some other program and rarely fits.
38. Structured Programming supports the law of the excluded middle.
27. Once you understand how to write a program get someone else to write it.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
38. Structured Programming supports the law of the excluded middle.
104. The proof of a system's value is its existence.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
100. We will never run out of things to program as long as there is a single program around.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
115. Most people find the concept of programming obvious, but the doing impossible.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
4. Every program is a part of some other program and rarely fits.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
114. Within a computer natural language is unnatural.
98. In computing, the mean time to failure keeps getting shorter.
104. The proof of a system's value is its existence.
21. Optimization hinders evolution.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
114. Within a computer natural language is unnatural.
90. Computation has made the tree flower.
98. In computing, the mean time to failure keeps getting shorter.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
7. It is easier to write an incorrect program than understand a correct one.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
47. As Will Rogers would have said, "There is no such thing as a free variable."
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
4. Every program is a part of some other program and rarely fits.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
90. Computation has made the tree flower.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
115. Most people find the concept of programming obvious, but the doing impossible.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
110. Editing is a rewording activity.
22. A good system can't have a weak command language.
22. A good system can't have a weak command language.
59. In English every word can be verbed. Would that it were so in our programming languages.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
104. The proof of a system's value is its existence.
27. Once you understand how to write a program get someone else to write it.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
78. If your computer speaks English, it was probably made in Japan.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
90. Computation has made the tree flower.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
4. Every program is a part of some other program and rarely fits.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
110. Editing is a rewording activity.
66. Making something variable is easy. Controlling duration of constancy is the trick.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
105. You can't communicate complexity, only an awareness of it.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
41. Some programming languages manage to absorb change, but withstand progress.
63. When we write programs that "learn", it turns out that we do and they don't.
79. A year spent in artificial intelligence is enough to make one believe in God.
66. Making something variable is easy. Controlling duration of constancy is the trick.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
103. Purely applicative languages are poorly applicable.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
1. One man's constant is another man's variable.
23. To understand a program you must become both the machine and the program.
12. Recursion is the root of computation since it trades description for time.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
43. In software systems, it is often the early bird that makes the worm.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
3. Syntactic sugar causes cancer of the semicolon.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
108. Whenever two programmers meet to criticize their programs, both are silent.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
111. Why did the Roman Empire collapse? What is Latin for office automation?
47. As Will Rogers would have said, "There is no such thing as a free variable."
7. It is easier to write an incorrect program than understand a correct one.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
38. Structured Programming supports the law of the excluded middle.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
90. Computation has made the tree flower.
15. Everything should be built top-down, except the first time.
57. It is easier to change the specification to fit the program than vice versa.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
78. If your computer speaks English, it was probably made in Japan.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
46. Like punning, programming is a play on words.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
41. Some programming languages manage to absorb change, but withstand progress.
41. Some programming languages manage to absorb change, but withstand progress.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
40. There are two ways to write error-free programs; only the third one works.
55. A LISP programmer knows the value of everything, but the cost of nothing.
55. A LISP programmer knows the value of everything, but the cost of nothing.
57. It is easier to change the specification to fit the program than vice versa.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
95. Don't have good ideas if you aren't willing to be responsible for them.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
78. If your computer speaks English, it was probably made in Japan.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
43. In software systems, it is often the early bird that makes the worm.
14. In the long run every program becomes rococo - then rubble.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
98. In computing, the mean time to failure keeps getting shorter.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
1. One man's constant is another man's variable.
110. Editing is a rewording activity.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
55. A LISP programmer knows the value of everything, but the cost of nothing.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
119. Programming is an unnatural act.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
57. It is easier to change the specification to fit the program than vice versa.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
22. A good system can't have a weak command language.
112. Computer Science is embarrassed by the computer.
4. Every program is a part of some other program and rarely fits.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
103. Purely applicative languages are poorly applicable.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
79. A year spent in artificial intelligence is enough to make one believe in God.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
27. Once you understand how to write a program get someone else to write it.
31. Simplicity does not precede complexity, but follows it.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
17. If a listener nods his head when you're explaining your program, wake him up.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
40. There are two ways to write error-free programs; only the third one works.
11. If you have a procedure with ten parameters, you probably missed some.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
22. A good system can't have a weak command language.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
21. Optimization hinders evolution.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
114. Within a computer natural language is unnatural.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
72. An adequate bootstrap is a contradiction in terms.
12. Recursion is the root of computation since it trades description for time.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
46. Like punning, programming is a play on words.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
110. Editing is a rewording activity.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
105. You can't communicate complexity, only an awareness of it.
40. There are two ways to write error-free programs; only the third one works.
104. The proof of a system's value is its existence.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
100. We will never run out of things to program as long as there is a single program around.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
17. If a listener nods his head when you're explaining your program, wake him up.
79. A year spent in artificial intelligence is enough to make one believe in God.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
43. In software systems, it is often the early bird that makes the worm.
21. Optimization hinders evolution.
15. Everything should be built top-down, except the first time.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
5. If a program manipulates a large amount of data, it does so in a small number of ways.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
38. Structured Programming supports the law of the excluded middle.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
21. Optimization hinders evolution.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
23. To understand a program you must become both the machine and the program.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
60. In seeking the unattainable, simplicity only gets in the way.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
96. Computers don't introduce order anywhere as much as they expose opportunities.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
119. Programming is an unnatural act.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
112. Computer Science is embarrassed by the computer.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
104. The proof of a system's value is its existence.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
21. Optimization hinders evolution.
96. Computers don't introduce order anywhere as much as they expose opportunities.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
4. Every program is a part of some other program and rarely fits.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
15. Everything should be built top-down, except the first time.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
63. When we write programs that "learn", it turns out that we do and they don't.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
17. If a listener nods his head when you're explaining your program, wake him up.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
22. A good system can't have a weak command language.
14. In the long run every program becomes rococo - then rubble.
41. Some programming languages manage to absorb change, but withstand progress.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
55. A LISP programmer knows the value of everything, but the cost of nothing.
72. An adequate bootstrap is a contradiction in terms.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
96. Computers don't introduce order anywhere as much as they expose opportunities.
105. You can't communicate complexity, only an awareness of it.
66. Making something variable is easy. Controlling duration of constancy is the trick.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
14. In the long run every program becomes rococo - then rubble.
102. One can't proceed from the informal to the formal by formal means.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
21. Optimization hinders evolution.
61. In programming, as in everything else, to be in error is to be reborn.
43. In software systems, it is often the early bird that makes the worm.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
46. Like punning, programming is a play on words.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
95. Don't have good ideas if you aren't willing to be responsible for them.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
103. Purely applicative languages are poorly applicable.
46. Like punning, programming is a play on words.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
110. Editing is a rewording activity.
100. We will never run out of things to program as long as there is a single program around.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
31. Simplicity does not precede complexity, but follows it.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
47. As Will Rogers would have said, "There is no such thing as a free variable."
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
111. Why did the Roman Empire collapse? What is Latin for office automation?
23. To understand a program you must become both the machine and the program.
55. A LISP programmer knows the value of everything, but the cost of nothing.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
76. It is the user who should parameterize procedures, not their creators.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
59. In English every word can be verbed. Would that it were so in our programming languages.
96. Computers don't introduce order anywhere as much as they expose opportunities.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
61. In programming, as in everything else, to be in error is to be reborn.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
15. Everything should be built top-down, except the first time.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
46. Like punning, programming is a play on words.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
7. It is easier to write an incorrect program than understand a correct one.
7. It is easier to write an incorrect program than understand a correct one.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
66. Making something variable is easy. Controlling duration of constancy is the trick.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
21. Optimization hinders evolution.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
61. In programming, as in everything else, to be in error is to be reborn.
112. Computer Science is embarrassed by the computer.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
72. An adequate bootstrap is a contradiction in terms.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
102. One can't proceed from the informal to the formal by formal means.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
119. Programming is an unnatural act.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
11. If you have a procedure with ten parameters, you probably missed some.
40. There are two ways to write error-free programs; only the third one works.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
90. Computation has made the tree flower.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
38. Structured Programming supports the law of the excluded middle.
40. There are two ways to write error-free programs; only the third one works.
112. Computer Science is embarrassed by the computer.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
112. Computer Science is embarrassed by the computer.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
31. Simplicity does not precede complexity, but follows it.
112. Computer Science is embarrassed by the computer.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
40. There are two ways to write error-free programs; only the third one works.
115. Most people find the concept of programming obvious, but the doing impossible.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
17. If a listener nods his head when you're explaining your program, wake him up.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
38. Structured Programming supports the law of the excluded middle.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
38. Structured Programming supports the law of the excluded middle.
103. Purely applicative languages are poorly applicable.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
112. Computer Science is embarrassed by the computer.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
57. It is easier to change the specification to fit the program than vice versa.
17. If a listener nods his head when you're explaining your program, wake him up.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
27. Once you understand how to write a program get someone else to write it.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
90. Computation has made the tree flower.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
115. Most people find the concept of programming obvious, but the doing impossible.
108. Whenever two programmers meet to criticize their programs, both are silent.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
63. When we write programs that "learn", it turns out that we do and they don't.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
15. Everything should be built top-down, except the first time.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
11. If you have a procedure with ten parameters, you probably missed some.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
115. Most people find the concept of programming obvious, but the doing impossible.
98. In computing, the mean time to failure keeps getting shorter.
76. It is the user who should parameterize procedures, not their creators.
4. Every program is a part of some other program and rarely fits.
96. Computers don't introduce order anywhere as much as they expose opportunities.
17. If a listener nods his head when you're explaining your program, wake him up.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
63. When we write programs that "learn", it turns out that we do and they don't.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
104. The proof of a system's value is its existence.
96. Computers don't introduce order anywhere as much as they expose opportunities.
95. Don't have good ideas if you aren't willing to be responsible for them.
102. One can't proceed from the informal to the formal by formal means.
11. If you have a procedure with ten parameters, you probably missed some.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
40. There are two ways to write error-free programs; only the third one works.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
43. In software systems, it is often the early bird that makes the worm.
76. It is the user who should parameterize procedures, not their creators.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
110. Editing is a rewording activity.
102. One can't proceed from the informal to the formal by formal means.
104. The proof of a system's value is its existence.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
110. Editing is a rewording activity.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
66. Making something variable is easy. Controlling duration of constancy is the trick.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
112. Computer Science is embarrassed by the computer.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
100. We will never run out of things to program as long as there is a single program around.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
18. A program without a loop and a structured variable isn't worth writing.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
18. A program without a loop and a structured variable isn't worth writing.
95. Don't have good ideas if you aren't willing to be responsible for them.
8. A programming language is low level when its programs require attention to the irrelevant.
47. As Will Rogers would have said, "There is no such thing as a free variable."
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
104. The proof of a system's value is its existence.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
7. It is easier to write an incorrect program than understand a correct one.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
95. Don't have good ideas if you aren't willing to be responsible for them.
108. Whenever two programmers meet to criticize their programs, both are silent.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
11. If you have a procedure with ten parameters, you probably missed some.
7. It is easier to write an incorrect program than understand a correct one.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
110. Editing is a rewording activity.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
22. A good system can't have a weak command language.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
96. Computers don't introduce order anywhere as much as they expose opportunities.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
27. Once you understand how to write a program get someone else to write it.
59. In English every word can be verbed. Would that it were so in our programming languages.
31. Simplicity does not precede complexity, but follows it.
100. We will never run out of things to program as long as there is a single program around.
38. Structured Programming supports the law of the excluded middle.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
4. Every program is a part of some other program and rarely fits.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
46. Like punning, programming is a play on words.
47. As Will Rogers would have said, "There is no such thing as a free variable."
62. In computing, invariants are ephemeral.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
43. In software systems, it is often the early bird that makes the worm.
40. There are two ways to write error-free programs; only the third one works.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
22. A good system can't have a weak command language.
108. Whenever two programmers meet to criticize their programs, both are silent.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
23. To understand a program you must become both the machine and the program.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
62. In computing, invariants are ephemeral.
41. Some programming languages manage to absorb change, but withstand progress.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
90. Computation has made the tree flower.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
43. In software systems, it is often the early bird that makes the worm.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
11. If you have a procedure with ten parameters, you probably missed some.
22. A good system can't have a weak command language.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
38. Structured Programming supports the law of the excluded middle.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
12. Recursion is the root of computation since it trades description for time.
63. When we write programs that "learn", it turns out that we do and they don't.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
111. Why did the Roman Empire collapse? What is Latin for office automation?
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
100. We will never run out of things to program as long as there is a single program around.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
119. Programming is an unnatural act.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
103. Purely applicative languages are poorly applicable.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
55. A LISP programmer knows the value of everything, but the cost of nothing.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
61. In programming, as in everything else, to be in error is to be reborn.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
61. In programming, as in everything else, to be in error is to be reborn.
110. Editing is a rewording activity.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
11. If you have a procedure with ten parameters, you probably missed some.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
96. Computers don't introduce order anywhere as much as they expose opportunities.
78. If your computer speaks English, it was probably made in Japan.
12. Recursion is the root of computation since it trades description for time.
111. Why did the Roman Empire collapse? What is Latin for office automation?
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
63. When we write programs that "learn", it turns out that we do and they don't.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
40. There are two ways to write error-free programs; only the third one works.
40. There are two ways to write error-free programs; only the third one works.
43. In software systems, it is often the early bird that makes the worm.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
61. In programming, as in everything else, to be in error is to be reborn.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
23. To understand a program you must become both the machine and the program.
41. Some programming languages manage to absorb change, but withstand progress.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
1. One man's constant is another man's variable.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
114. Within a computer natural language is unnatural.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
17. If a listener nods his head when you're explaining your program, wake him up.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
119. Programming is an unnatural act.
46. Like punning, programming is a play on words.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
104. The proof of a system's value is its existence.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
105. You can't communicate complexity, only an awareness of it.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
62. In computing, invariants are ephemeral.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
22. A good system can't have a weak command language.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
110. Editing is a rewording activity.
12. Recursion is the root of computation since it trades description for time.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
40. There are two ways to write error-free programs; only the third one works.
46. Like punning, programming is a play on words.
1. One man's constant is another man's variable.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
17. If a listener nods his head when you're explaining your program, wake him up.
111. Why did the Roman Empire collapse? What is Latin for office automation?
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
100. We will never run out of things to program as long as there is a single program around.
62. In computing, invariants are ephemeral.
59. In English every word can be verbed. Would that it were so in our programming languages.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
18. A program without a loop and a structured variable isn't worth writing.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
11. If you have a procedure with ten parameters, you probably missed some.
96. Computers don't introduce order anywhere as much as they expose opportunities.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
96. Computers don't introduce order anywhere as much as they expose opportunities.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
111. Why did the Roman Empire collapse? What is Latin for office automation?
104. The proof of a system's value is its existence.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
95. Don't have good ideas if you aren't willing to be responsible for them.
7. It is easier to write an incorrect program than understand a correct one.
8. A programming language is low level when its programs require attention to the irrelevant.
60. In seeking the unattainable, simplicity only gets in the way.
105. You can't communicate complexity, only an awareness of it.
96. Computers don't introduce order anywhere as much as they expose opportunities.
62. In computing, invariants are ephemeral.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
79. A year spent in artificial intelligence is enough to make one believe in God.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
119. Programming is an unnatural act.
8. A programming language is low level when its programs require attention to the irrelevant.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
21. Optimization hinders evolution.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
38. Structured Programming supports the law of the excluded middle.
102. One can't proceed from the informal to the formal by formal means.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
23. To understand a program you must become both the machine and the program.
4. Every program is a part of some other program and rarely fits.
66. Making something variable is easy. Controlling duration of constancy is the trick.
31. Simplicity does not precede complexity, but follows it.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
112. Computer Science is embarrassed by the computer.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
103. Purely applicative languages are poorly applicable.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
119. Programming is an unnatural act.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
41. Some programming languages manage to absorb change, but withstand progress.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
103. Purely applicative languages are poorly applicable.
23. To understand a program you must become both the machine and the program.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
72. An adequate bootstrap is a contradiction in terms.
22. A good system can't have a weak command language.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
95. Don't have good ideas if you aren't willing to be responsible for them.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
115. Most people find the concept of programming obvious, but the doing impossible.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
23. To understand a program you must become both the machine and the program.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
47. As Will Rogers would have said, "There is no such thing as a free variable."
63. When we write programs that "learn", it turns out that we do and they don't.
12. Recursion is the root of computation since it trades description for time.
63. When we write programs that "learn", it turns out that we do and they don't.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
4. Every program is a part of some other program and rarely fits.
95. Don't have good ideas if you aren't willing to be responsible for them.
104. The proof of a system's value is its existence.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
61. In programming, as in everything else, to be in error is to be reborn.
79. A year spent in artificial intelligence is enough to make one believe in God.
104. The proof of a system's value is its existence.
14. In the long run every program becomes rococo - then rubble.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
100. We will never run out of things to program as long as there is a single program around.
18. A program without a loop and a structured variable isn't worth writing.
43. In software systems, it is often the early bird that makes the worm.
105. You can't communicate complexity, only an awareness of it.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
43. In software systems, it is often the early bird that makes the worm.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
76. It is the user who should parameterize procedures, not their creators.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
43. In software systems, it is often the early bird that makes the worm.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
14. In the long run every program becomes rococo - then rubble.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
21. Optimization hinders evolution.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
60. In seeking the unattainable, simplicity only gets in the way.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
57. It is easier to change the specification to fit the program than vice versa.
38. Structured Programming supports the law of the excluded middle.
22. A good system can't have a weak command language.
17. If a listener nods his head when you're explaining your program, wake him up.
46. Like punning, programming is a play on words.
15. Everything should be built top-down, except the first time.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
112. Computer Science is embarrassed by the computer.
3. Syntactic sugar causes cancer of the semicolon.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
114. Within a computer natural language is unnatural.
46. Like punning, programming is a play on words.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
60. In seeking the unattainable, simplicity only gets in the way.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
76. It is the user who should parameterize procedures, not their creators.
108. Whenever two programmers meet to criticize their programs, both are silent.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
11. If you have a procedure with ten parameters, you probably missed some.
60. In seeking the unattainable, simplicity only gets in the way.
40. There are two ways to write error-free programs; only the third one works.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
103. Purely applicative languages are poorly applicable.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
102. One can't proceed from the informal to the formal by formal means.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
66. Making something variable is easy. Controlling duration of constancy is the trick.
22. A good system can't have a weak command language.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
72. An adequate bootstrap is a contradiction in terms.
59. In English every word can be verbed. Would that it were so in our programming languages.
4. Every program is a part of some other program and rarely fits.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
114. Within a computer natural language is unnatural.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
104. The proof of a system's value is its existence.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
59. In English every word can be verbed. Would that it were so in our programming languages.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
3. Syntactic sugar causes cancer of the semicolon.
78. If your computer speaks English, it was probably made in Japan.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
21. Optimization hinders evolution.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
104. The proof of a system's value is its existence.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
119. Programming is an unnatural act.
95. Don't have good ideas if you aren't willing to be responsible for them.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
60. In seeking the unattainable, simplicity only gets in the way.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
7. It is easier to write an incorrect program than understand a correct one.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
110. Editing is a rewording activity.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
17. If a listener nods his head when you're explaining your program, wake him up.
11. If you have a procedure with ten parameters, you probably missed some.
112. Computer Science is embarrassed by the computer.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
111. Why did the Roman Empire collapse? What is Latin for office automation?
38. Structured Programming supports the law of the excluded middle.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
21. Optimization hinders evolution.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
22. A good system can't have a weak command language.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
12. Recursion is the root of computation since it trades description for time.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
98. In computing, the mean time to failure keeps getting shorter.
78. If your computer speaks English, it was probably made in Japan.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
3. Syntactic sugar causes cancer of the semicolon.
47. As Will Rogers would have said, "There is no such thing as a free variable."
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
21. Optimization hinders evolution.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
110. Editing is a rewording activity.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
119. Programming is an unnatural act.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
95. Don't have good ideas if you aren't willing to be responsible for them.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
105. You can't communicate complexity, only an awareness of it.
41. Some programming languages manage to absorb change, but withstand progress.
104. The proof of a system's value is its existence.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
1. One man's constant is another man's variable.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
46. Like punning, programming is a play on words.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
59. In English every word can be verbed. Would that it were so in our programming languages.
115. Most people find the concept of programming obvious, but the doing impossible.
119. Programming is an unnatural act.
96. Computers don't introduce order anywhere as much as they expose opportunities.
115. Most people find the concept of programming obvious, but the doing impossible.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
90. Computation has made the tree flower.
96. Computers don't introduce order anywhere as much as they expose opportunities.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
4. Every program is a part of some other program and rarely fits.
63. When we write programs that "learn", it turns out that we do and they don't.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
103. Purely applicative languages are poorly applicable.
15. Everything should be built top-down, except the first time.
15. Everything should be built top-down, except the first time.
90. Computation has made the tree flower.
96. Computers don't introduce order anywhere as much as they expose opportunities.
78. If your computer speaks English, it was probably made in Japan.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
59. In English every word can be verbed. Would that it were so in our programming languages.
11. If you have a procedure with ten parameters, you probably missed some.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
22. A good system can't have a weak command language.
60. In seeking the unattainable, simplicity only gets in the way.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
59. In English every word can be verbed. Would that it were so in our programming languages.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
18. A program without a loop and a structured variable isn't worth writing.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
57. It is easier to change the specification to fit the program than vice versa.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
7. It is easier to write an incorrect program than understand a correct one.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
46. Like punning, programming is a play on words.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
23. To understand a program you must become both the machine and the program.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
41. Some programming languages manage to absorb change, but withstand progress.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
21. Optimization hinders evolution.
21. Optimization hinders evolution.
22. A good system can't have a weak command language.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
107. The debate rages on: is PL/I Bachtrian or Dromedary?
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
11. If you have a procedure with ten parameters, you probably missed some.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
102. One can't proceed from the informal to the formal by formal means.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
110. Editing is a rewording activity.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
23. To understand a program you must become both the machine and the program.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
31. Simplicity does not precede complexity, but follows it.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
43. In software systems, it is often the early bird that makes the worm.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
47. As Will Rogers would have said, "There is no such thing as a free variable."
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
63. When we write programs that "learn", it turns out that we do and they don't.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
103. Purely applicative languages are poorly applicable.
55. A LISP programmer knows the value of everything, but the cost of nothing.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
107. The debate rages on: is PL/I Bachtrian or Dromedary?
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
60. In seeking the unattainable, simplicity only gets in the way.
105. You can't communicate complexity, only an awareness of it.
40. There are two ways to write error-free programs; only the third one works.
17. If a listener nods his head when you're explaining your program, wake him up.
63. When we write programs that "learn", it turns out that we do and they don't.
4. Every program is a part of some other program and rarely fits.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
115. Most people find the concept of programming obvious, but the doing impossible.
46. Like punning, programming is a play on words.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
111. Why did the Roman Empire collapse? What is Latin for office automation?
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
12. Recursion is the root of computation since it trades description for time.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
41. Some programming languages manage to absorb change, but withstand progress.
78. If your computer speaks English, it was probably made in Japan.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
90. Computation has made the tree flower.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
110. Editing is a rewording activity.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
38. Structured Programming supports the law of the excluded middle.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
108. Whenever two programmers meet to criticize their programs, both are silent.
79. A year spent in artificial intelligence is enough to make one believe in God.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
102. One can't proceed from the informal to the formal by formal means.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
1. One man's constant is another man's variable.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
23. To understand a program you must become both the machine and the program.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
112. Computer Science is embarrassed by the computer.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
108. Whenever two programmers meet to criticize their programs, both are silent.
66. Making something variable is easy. Controlling duration of constancy is the trick.
111. Why did the Roman Empire collapse? What is Latin for office automation?
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
102. One can't proceed from the informal to the formal by formal means.
78. If your computer speaks English, it was probably made in Japan.
3. Syntactic sugar causes cancer of the semicolon.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
61. In programming, as in everything else, to be in error is to be reborn.
47. As Will Rogers would have said, "There is no such thing as a free variable."
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
90. Computation has made the tree flower.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
90. Computation has made the tree flower.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
21. Optimization hinders evolution.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
31. Simplicity does not precede complexity, but follows it.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
59. In English every word can be verbed. Would that it were so in our programming languages.
78. If your computer speaks English, it was probably made in Japan.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
4. Every program is a part of some other program and rarely fits.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
47. As Will Rogers would have said, "There is no such thing as a free variable."
23. To understand a program you must become both the machine and the program.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
72. An adequate bootstrap is a contradiction in terms.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
114. Within a computer natural language is unnatural.
12. Recursion is the root of computation since it trades description for time.
59. In English every word can be verbed. Would that it were so in our programming languages.
110. Editing is a rewording activity.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
90. Computation has made the tree flower.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
63. When we write programs that "learn", it turns out that we do and they don't.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
17. If a listener nods his head when you're explaining your program, wake him up.
55. A LISP programmer knows the value of everything, but the cost of nothing.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
108. Whenever two programmers meet to criticize their programs, both are silent.
40. There are two ways to write error-free programs; only the third one works.
78. If your computer speaks English, it was probably made in Japan.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
12. Recursion is the root of computation since it trades description for time.
62. In computing, invariants are ephemeral.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
23. To understand a program you must become both the machine and the program.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
66. Making something variable is easy. Controlling duration of constancy is the trick.
66. Making something variable is easy. Controlling duration of constancy is the trick.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
12. Recursion is the root of computation since it trades description for time.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
43. In software systems, it is often the early bird that makes the worm.
111. Why did the Roman Empire collapse? What is Latin for office automation?
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
90. Computation has made the tree flower.
41. Some programming languages manage to absorb change, but withstand progress.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
108. Whenever two programmers meet to criticize their programs, both are silent.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
55. A LISP programmer knows the value of everything, but the cost of nothing.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
41. Some programming languages manage to absorb change, but withstand progress.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
63. When we write programs that "learn", it turns out that we do and they don't.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
12. Recursion is the root of computation since it trades description for time.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
76. It is the user who should parameterize procedures, not their creators.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
96. Computers don't introduce order anywhere as much as they expose opportunities.
114. Within a computer natural language is unnatural.
15. Everything should be built top-down, except the first time.
95. Don't have good ideas if you aren't willing to be responsible for them.
12. Recursion is the root of computation since it trades description for time.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
100. We will never run out of things to program as long as there is a single program around.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
110. Editing is a rewording activity.
7. It is easier to write an incorrect program than understand a correct one.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
90. Computation has made the tree flower.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
63. When we write programs that "learn", it turns out that we do and they don't.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
38. Structured Programming supports the law of the excluded middle.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
98. In computing, the mean time to failure keeps getting shorter.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
98. In computing, the mean time to failure keeps getting shorter.
104. The proof of a system's value is its existence.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
103. Purely applicative languages are poorly applicable.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
98. In computing, the mean time to failure keeps getting shorter.
78. If your computer speaks English, it was probably made in Japan.
114. Within a computer natural language is unnatural.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
43. In software systems, it is often the early bird that makes the worm.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
47. As Will Rogers would have said, "There is no such thing as a free variable."
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
119. Programming is an unnatural act.
102. One can't proceed from the informal to the formal by formal means.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
41. Some programming languages manage to absorb change, but withstand progress.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
11. If you have a procedure with ten parameters, you probably missed some.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
76. It is the user who should parameterize procedures, not their creators.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
98. In computing, the mean time to failure keeps getting shorter.
90. Computation has made the tree flower.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
21. Optimization hinders evolution.
55. A LISP programmer knows the value of everything, but the cost of nothing.
100. We will never run out of things to program as long as there is a single program around.
115. Most people find the concept of programming obvious, but the doing impossible.
59. In English every word can be verbed. Would that it were so in our programming languages.
62. In computing, invariants are ephemeral.
3. Syntactic sugar causes cancer of the semicolon.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
100. We will never run out of things to program as long as there is a single program around.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
17. If a listener nods his head when you're explaining your program, wake him up.
111. Why did the Roman Empire collapse? What is Latin for office automation?
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
114. Within a computer natural language is unnatural.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
41. Some programming languages manage to absorb change, but withstand progress.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
18. A program without a loop and a structured variable isn't worth writing.
102. One can't proceed from the informal to the formal by formal means.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
108. Whenever two programmers meet to criticize their programs, both are silent.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
21. Optimization hinders evolution.
22. A good system can't have a weak command language.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
90. Computation has made the tree flower.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
12. Recursion is the root of computation since it trades description for time.
21. Optimization hinders evolution.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
38. Structured Programming supports the law of the excluded middle.
46. Like punning, programming is a play on words.
119. Programming is an unnatural act.
105. You can't communicate complexity, only an awareness of it.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
95. Don't have good ideas if you aren't willing to be responsible for them.
41. Some programming languages manage to absorb change, but withstand progress.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
31. Simplicity does not precede complexity, but follows it.
57. It is easier to change the specification to fit the program than vice versa.
105. You can't communicate complexity, only an awareness of it.
112. Computer Science is embarrassed by the computer.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
114. Within a computer natural language is unnatural.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
78. If your computer speaks English, it was probably made in Japan.
15. Everything should be built top-down, except the first time.
4. Every program is a part of some other program and rarely fits.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
95. Don't have good ideas if you aren't willing to be responsible for them.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
108. Whenever two programmers meet to criticize their programs, both are silent.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
66. Making something variable is easy. Controlling duration of constancy is the trick.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
19. A language that doesn't affect the way you think about programming, is not worth knowing.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
72. An adequate bootstrap is a contradiction in terms.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
4. Every program is a part of some other program and rarely fits.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
79. A year spent in artificial intelligence is enough to make one believe in God.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
31. Simplicity does not precede complexity, but follows it.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
3. Syntactic sugar causes cancer of the semicolon.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
119. Programming is an unnatural act.
115. Most people find the concept of programming obvious, but the doing impossible.
31. Simplicity does not precede complexity, but follows it.
41. Some programming languages manage to absorb change, but withstand progress.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
8. A programming language is low level when its programs require attention to the irrelevant.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
112. Computer Science is embarrassed by the computer.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
100. We will never run out of things to program as long as there is a single program around.
59. In English every word can be verbed. Would that it were so in our programming languages.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
104. The proof of a system's value is its existence.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
72. An adequate bootstrap is a contradiction in terms.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
90. Computation has made the tree flower.
78. If your computer speaks English, it was probably made in Japan.
96. Computers don't introduce order anywhere as much as they expose opportunities.
21. Optimization hinders evolution.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
8. A programming language is low level when its programs require attention to the irrelevant.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
103. Purely applicative languages are poorly applicable.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
8. A programming language is low level when its programs require attention to the irrelevant.
1. One man's constant is another man's variable.
115. Most people find the concept of programming obvious, but the doing impossible.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
111. Why did the Roman Empire collapse? What is Latin for office automation?
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
27. Once you understand how to write a program get someone else to write it.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
98. In computing, the mean time to failure keeps getting shorter.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
76. It is the user who should parameterize procedures, not their creators.
1. One man's constant is another man's variable.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
46. Like punning, programming is a play on words.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
22. A good system can't have a weak command language.
112. Computer Science is embarrassed by the computer.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
112. Computer Science is embarrassed by the computer.
21. Optimization hinders evolution.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
31. Simplicity does not precede complexity, but follows it.
55. A LISP programmer knows the value of everything, but the cost of nothing.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
96. Computers don't introduce order anywhere as much as they expose opportunities.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
18. A program without a loop and a structured variable isn't worth writing.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
21. Optimization hinders evolution.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
103. Purely applicative languages are poorly applicable.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
22. A good system can't have a weak command language.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
90. Computation has made the tree flower.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
11. If you have a procedure with ten parameters, you probably missed some.
59. In English every word can be verbed. Would that it were so in our programming languages.
111. Why did the Roman Empire collapse? What is Latin for office automation?
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
105. You can't communicate complexity, only an awareness of it.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
100. We will never run out of things to program as long as there is a single program around.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
111. Why did the Roman Empire collapse? What is Latin for office automation?
119. Programming is an unnatural act.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
4. Every program is a part of some other program and rarely fits.
103. Purely applicative languages are poorly applicable.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
55. A LISP programmer knows the value of everything, but the cost of nothing.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
23. To understand a program you must become both the machine and the program.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
96. Computers don't introduce order anywhere as much as they expose opportunities.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
98. In computing, the mean time to failure keeps getting shorter.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
57. It is easier to change the specification to fit the program than vice versa.
61. In programming, as in everything else, to be in error is to be reborn.
14. In the long run every program becomes rococo - then rubble.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
18. A program without a loop and a structured variable isn't worth writing.
103. Purely applicative languages are poorly applicable.
119. Programming is an unnatural act.
17. If a listener nods his head when you're explaining your program, wake him up.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
103. Purely applicative languages are poorly applicable.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
76. It is the user who should parameterize procedures, not their creators.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
63. When we write programs that "learn", it turns out that we do and they don't.
100. We will never run out of things to program as long as there is a single program around.
14. In the long run every program becomes rococo - then rubble.
55. A LISP programmer knows the value of everything, but the cost of nothing.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
41. Some programming languages manage to absorb change, but withstand progress.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
55. A LISP programmer knows the value of everything, but the cost of nothing.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
22. A good system can't have a weak command language.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
111. Why did the Roman Empire collapse? What is Latin for office automation?
40. There are two ways to write error-free programs; only the third one works.
38. Structured Programming supports the law of the excluded middle.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
46. Like punning, programming is a play on words.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
17. If a listener nods his head when you're explaining your program, wake him up.
100. We will never run out of things to program as long as there is a single program around.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
66. Making something variable is easy. Controlling duration of constancy is the trick.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
104. The proof of a system's value is its existence.
78. If your computer speaks English, it was probably made in Japan.
22. A good system can't have a weak command language.
78. If your computer speaks English, it was probably made in Japan.
96. Computers don't introduce order anywhere as much as they expose opportunities.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
23. To understand a program you must become both the machine and the program.
8. A programming language is low level when its programs require attention to the irrelevant.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
4. Every program is a part of some other program and rarely fits.
4. Every program is a part of some other program and rarely fits.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
59. In English every word can be verbed. Would that it were so in our programming languages.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
23. To understand a program you must become both the machine and the program.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
100. We will never run out of things to program as long as there is a single program around.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
1. One man's constant is another man's variable.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
108. Whenever two programmers meet to criticize their programs, both are silent.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
15. Everything should be built top-down, except the first time.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
12. Recursion is the root of computation since it trades description for time.
41. Some programming languages manage to absorb change, but withstand progress.
4. Every program is a part of some other program and rarely fits.
96. Computers don't introduce order anywhere as much as they expose opportunities.
55. A LISP programmer knows the value of everything, but the cost of nothing.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
46. Like punning, programming is a play on words.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
119. Programming is an unnatural act.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
43. In software systems, it is often the early bird that makes the worm.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
23. To understand a program you must become both the machine and the program.
17. If a listener nods his head when you're explaining your program, wake him up.
119. Programming is an unnatural act.
110. Editing is a rewording activity.
41. Some programming languages manage to absorb change, but withstand progress.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
27. Once you understand how to write a program get someone else to write it.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
112. Computer Science is embarrassed by the computer.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
27. Once you understand how to write a program get someone else to write it.
119. Programming is an unnatural act.
22. A good system can't have a weak command language.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
11. If you have a procedure with ten parameters, you probably missed some.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
38. Structured Programming supports the law of the excluded middle.
96. Computers don't introduce order anywhere as much as they expose opportunities.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
98. In computing, the mean time to failure keeps getting shorter.
14. In the long run every program becomes rococo - then rubble.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
18. A program without a loop and a structured variable isn't worth writing.
15. Everything should be built top-down, except the first time.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
55. A LISP programmer knows the value of everything, but the cost of nothing.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
23. To understand a program you must become both the machine and the program.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
111. Why did the Roman Empire collapse? What is Latin for office automation?
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
72. An adequate bootstrap is a contradiction in terms.
76. It is the user who should parameterize procedures, not their creators.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
66. Making something variable is easy. Controlling duration of constancy is the trick.
72. An adequate bootstrap is a contradiction in terms.
108. Whenever two programmers meet to criticize their programs, both are silent.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
100. We will never run out of things to program as long as there is a single program around.
62. In computing, invariants are ephemeral.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
46. Like punning, programming is a play on words.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
43. In software systems, it is often the early bird that makes the worm.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
78. If your computer speaks English, it was probably made in Japan.
76. It is the user who should parameterize procedures, not their creators.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
114. Within a computer natural language is unnatural.
21. Optimization hinders evolution.
100. We will never run out of things to program as long as there is a single program around.
78. If your computer speaks English, it was probably made in Japan.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
23. To understand a program you must become both the machine and the program.
43. In software systems, it is often the early bird that makes the worm.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
22. A good system can't have a weak command language.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
8. A programming language is low level when its programs require attention to the irrelevant.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
111. Why did the Roman Empire collapse? What is Latin for office automation?
105. You can't communicate complexity, only an awareness of it.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
112. Computer Science is embarrassed by the computer.
40. There are two ways to write error-free programs; only the third one works.
41. Some programming languages manage to absorb change, but withstand progress.
60. In seeking the unattainable, simplicity only gets in the way.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
102. One can't proceed from the informal to the formal by formal means.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
103. Purely applicative languages are poorly applicable.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
7. It is easier to write an incorrect program than understand a correct one.
119. Programming is an unnatural act.
1. One man's constant is another man's variable.
61. In programming, as in everything else, to be in error is to be reborn.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
108. Whenever two programmers meet to criticize their programs, both are silent.
4. Every program is a part of some other program and rarely fits.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
1. One man's constant is another man's variable.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
55. A LISP programmer knows the value of everything, but the cost of nothing.
95. Don't have good ideas if you aren't willing to be responsible for them.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
47. As Will Rogers would have said, "There is no such thing as a free variable."
43. In software systems, it is often the early bird that makes the worm.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
100. We will never run out of things to program as long as there is a single program around.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
105. You can't communicate complexity, only an awareness of it.
3. Syntactic sugar causes cancer of the semicolon.
11. If you have a procedure with ten parameters, you probably missed some.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
14. In the long run every program becomes rococo - then rubble.
17. If a listener nods his head when you're explaining your program, wake him up.
40. There are two ways to write error-free programs; only the third one works.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
62. In computing, invariants are ephemeral.
90. Computation has made the tree flower.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
72. An adequate bootstrap is a contradiction in terms.
79. A year spent in artificial intelligence is enough to make one believe in God.
21. Optimization hinders evolution.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
95. Don't have good ideas if you aren't willing to be responsible for them.
11. If you have a procedure with ten parameters, you probably missed some.
21. Optimization hinders evolution.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
47. As Will Rogers would have said, "There is no such thing as a free variable."
47. As Will Rogers would have said, "There is no such thing as a free variable."
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
14. In the long run every program becomes rococo - then rubble.
114. Within a computer natural language is unnatural.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
114. Within a computer natural language is unnatural.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
18. A program without a loop and a structured variable isn't worth writing.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
21. Optimization hinders evolution.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
103. Purely applicative languages are poorly applicable.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
72. An adequate bootstrap is a contradiction in terms.
18. A program without a loop and a structured variable isn't worth writing.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
76. It is the user who should parameterize procedures, not their creators.
79. A year spent in artificial intelligence is enough to make one believe in God.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
21. Optimization hinders evolution.
119. Programming is an unnatural act.
4. Every program is a part of some other program and rarely fits.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
60. In seeking the unattainable, simplicity only gets in the way.
21. Optimization hinders evolution.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
5. If a program manipulates a large amount of data, it does so in a small number of ways.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
62. In computing, invariants are ephemeral.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
47. As Will Rogers would have said, "There is no such thing as a free variable."
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
79. A year spent in artificial intelligence is enough to make one believe in God.
4. Every program is a part of some other program and rarely fits.
100. We will never run out of things to program as long as there is a single program around.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
76. It is the user who should parameterize procedures, not their creators.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
66. Making something variable is easy. Controlling duration of constancy is the trick.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
115. Most people find the concept of programming obvious, but the doing impossible.
55. A LISP programmer knows the value of everything, but the cost of nothing.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
18. A program without a loop and a structured variable isn't worth writing.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
90. Computation has made the tree flower.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
11. If you have a procedure with ten parameters, you probably missed some.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
17. If a listener nods his head when you're explaining your program, wake him up.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
98. In computing, the mean time to failure keeps getting shorter.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
40. There are two ways to write error-free programs; only the third one works.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
111. Why did the Roman Empire collapse? What is Latin for office automation?
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
21. Optimization hinders evolution.
57. It is easier to change the specification to fit the program than vice versa.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
41. Some programming languages manage to absorb change, but withstand progress.
66. Making something variable is easy. Controlling duration of constancy is the trick.
15. Everything should be built top-down, except the first time.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
111. Why did the Roman Empire collapse? What is Latin for office automation?
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
14. In the long run every program becomes rococo - then rubble.
110. Editing is a rewording activity.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
105. You can't communicate complexity, only an awareness of it.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
95. Don't have good ideas if you aren't willing to be responsible for them.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
63. When we write programs that "learn", it turns out that we do and they don't.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
4. Every program is a part of some other program and rarely fits.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
12. Recursion is the root of computation since it trades description for time.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
114. Within a computer natural language is unnatural.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
27. Once you understand how to write a program get someone else to write it.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
23. To understand a program you must become both the machine and the program.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
63. When we write programs that "learn", it turns out that we do and they don't.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
104. The proof of a system's value is its existence.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
22. A good system can't have a weak command language.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
55. A LISP programmer knows the value of everything, but the cost of nothing.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
41. Some programming languages manage to absorb change, but withstand progress.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
119. Programming is an unnatural act.
40. There are two ways to write error-free programs; only the third one works.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
3. Syntactic sugar causes cancer of the semicolon.
61. In programming, as in everything else, to be in error is to be reborn.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
17. If a listener nods his head when you're explaining your program, wake him up.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
11. If you have a procedure with ten parameters, you probably missed some.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
15. Everything should be built top-down, except the first time.
27. Once you understand how to write a program get someone else to write it.
43. In software systems, it is often the early bird that makes the worm.
41. Some programming languages manage to absorb change, but withstand progress.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
105. You can't communicate complexity, only an awareness of it.
40. There are two ways to write error-free programs; only the third one works.
78. If your computer speaks English, it was probably made in Japan.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
119. Programming is an unnatural act.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
95. Don't have good ideas if you aren't willing to be responsible for them.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
31. Simplicity does not precede complexity, but follows it.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
12. Recursion is the root of computation since it trades description for time.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
8. A programming language is low level when its programs require attention to the irrelevant.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
12. Recursion is the root of computation since it trades description for time.
63. When we write programs that "learn", it turns out that we do and they don't.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
104. The proof of a system's value is its existence.
38. Structured Programming supports the law of the excluded middle.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
119. Programming is an unnatural act.
115. Most people find the concept of programming obvious, but the doing impossible.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
110. Editing is a rewording activity.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
4. Every program is a part of some other program and rarely fits.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
18. A program without a loop and a structured variable isn't worth writing.
4. Every program is a part of some other program and rarely fits.
96. Computers don't introduce order anywhere as much as they expose opportunities.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
59. In English every word can be verbed. Would that it were so in our programming languages.
47. As Will Rogers would have said, "There is no such thing as a free variable."
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
43. In software systems, it is often the early bird that makes the worm.
22. A good system can't have a weak command language.
100. We will never run out of things to program as long as there is a single program around.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
63. When we write programs that "learn", it turns out that we do and they don't.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
59. In English every word can be verbed. Would that it were so in our programming languages.
11. If you have a procedure with ten parameters, you probably missed some.
43. In software systems, it is often the early bird that makes the worm.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
17. If a listener nods his head when you're explaining your program, wake him up.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
110. Editing is a rewording activity.
98. In computing, the mean time to failure keeps getting shorter.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
108. Whenever two programmers meet to criticize their programs, both are silent.
72. An adequate bootstrap is a contradiction in terms.
79. A year spent in artificial intelligence is enough to make one believe in God.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
15. Everything should be built top-down, except the first time.
60. In seeking the unattainable, simplicity only gets in the way.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
1. One man's constant is another man's variable.
12. Recursion is the root of computation since it trades description for time.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
114. Within a computer natural language is unnatural.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
23. To understand a program you must become both the machine and the program.
27. Once you understand how to write a program get someone else to write it.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
18. A program without a loop and a structured variable isn't worth writing.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
102. One can't proceed from the informal to the formal by formal means.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
61. In programming, as in everything else, to be in error is to be reborn.
114. Within a computer natural language is unnatural.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
60. In seeking the unattainable, simplicity only gets in the way.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
66. Making something variable is easy. Controlling duration of constancy is the trick.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
63. When we write programs that "learn", it turns out that we do and they don't.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
79. A year spent in artificial intelligence is enough to make one believe in God.
111. Why did the Roman Empire collapse? What is Latin for office automation?
114. Within a computer natural language is unnatural.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
3. Syntactic sugar causes cancer of the semicolon.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
72. An adequate bootstrap is a contradiction in terms.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
104. The proof of a system's value is its existence.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
72. An adequate bootstrap is a contradiction in terms.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
27. Once you understand how to write a program get someone else to write it.
110. Editing is a rewording activity.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
55. A LISP programmer knows the value of everything, but the cost of nothing.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
31. Simplicity does not precede complexity, but follows it.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
119. Programming is an unnatural act.
108. Whenever two programmers meet to criticize their programs, both are silent.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
22. A good system can't have a weak command language.
22. A good system can't have a weak command language.
3. Syntactic sugar causes cancer of the semicolon.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
63. When we write programs that "learn", it turns out that we do and they don't.
98. In computing, the mean time to failure keeps getting shorter.
115. Most people find the concept of programming obvious, but the doing impossible.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
12. Recursion is the root of computation since it trades description for time.
98. In computing, the mean time to failure keeps getting shorter.
21. Optimization hinders evolution.
43. In software systems, it is often the early bird that makes the worm.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
31. Simplicity does not precede complexity, but follows it.
63. When we write programs that "learn", it turns out that we do and they don't.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
114. Within a computer natural language is unnatural.
66. Making something variable is easy. Controlling duration of constancy is the trick.
4. Every program is a part of some other program and rarely fits.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
12. Recursion is the root of computation since it trades description for time.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
78. If your computer speaks English, it was probably made in Japan.
38. Structured Programming supports the law of the excluded middle.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
19. A language that doesn't affect the way you think about programming, is not worth knowing.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
112. Computer Science is embarrassed by the computer.
59. In English every word can be verbed. Would that it were so in our programming languages.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
43. In software systems, it is often the early bird that makes the worm.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
104. The proof of a system's value is its existence.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
22. A good system can't have a weak command language.
18. A program without a loop and a structured variable isn't worth writing.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
57. It is easier to change the specification to fit the program than vice versa.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
22. A good system can't have a weak command language.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
31. Simplicity does not precede complexity, but follows it.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
12. Recursion is the root of computation since it trades description for time.
96. Computers don't introduce order anywhere as much as they expose opportunities.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
79. A year spent in artificial intelligence is enough to make one believe in God.
114. Within a computer natural language is unnatural.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
76. It is the user who should parameterize procedures, not their creators.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
79. A year spent in artificial intelligence is enough to make one believe in God.
41. Some programming languages manage to absorb change, but withstand progress.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
4. Every program is a part of some other program and rarely fits.
21. Optimization hinders evolution.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
18. A program without a loop and a structured variable isn't worth writing.
79. A year spent in artificial intelligence is enough to make one believe in God.
31. Simplicity does not precede complexity, but follows it.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
100. We will never run out of things to program as long as there is a single program around.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
66. Making something variable is easy. Controlling duration of constancy is the trick.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
27. Once you understand how to write a program get someone else to write it.
72. An adequate bootstrap is a contradiction in terms.
95. Don't have good ideas if you aren't willing to be responsible for them.
66. Making something variable is easy. Controlling duration of constancy is the trick.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
98. In computing, the mean time to failure keeps getting shorter.
60. In seeking the unattainable, simplicity only gets in the way.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
21. Optimization hinders evolution.
23. To understand a program you must become both the machine and the program.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
21. Optimization hinders evolution.
31. Simplicity does not precede complexity, but follows it.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
3. Syntactic sugar causes cancer of the semicolon.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
78. If your computer speaks English, it was probably made in Japan.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
31. Simplicity does not precede complexity, but follows it.
1. One man's constant is another man's variable.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
3. Syntactic sugar causes cancer of the semicolon.
108. Whenever two programmers meet to criticize their programs, both are silent.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
78. If your computer speaks English, it was probably made in Japan.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
100. We will never run out of things to program as long as there is a single program around.
4. Every program is a part of some other program and rarely fits.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
8. A programming language is low level when its programs require attention to the irrelevant.
43. In software systems, it is often the early bird that makes the worm.
76. It is the user who should parameterize procedures, not their creators.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
27. Once you understand how to write a program get someone else to write it.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
90. Computation has made the tree flower.
57. It is easier to change the specification to fit the program than vice versa.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
107. The debate rages on: is PL/I Bachtrian or Dromedary?
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
62. In computing, invariants are ephemeral.
100. We will never run out of things to program as long as there is a single program around.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
22. A good system can't have a weak command language.
47. As Will Rogers would have said, "There is no such thing as a free variable."
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
15. Everything should be built top-down, except the first time.
63. When we write programs that "learn", it turns out that we do and they don't.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
31. Simplicity does not precede complexity, but follows it.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
18. A program without a loop and a structured variable isn't worth writing.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
102. One can't proceed from the informal to the formal by formal means.
95. Don't have good ideas if you aren't willing to be responsible for them.
90. Computation has made the tree flower.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
78. If your computer speaks English, it was probably made in Japan.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
100. We will never run out of things to program as long as there is a single program around.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
47. As Will Rogers would have said, "There is no such thing as a free variable."
38. Structured Programming supports the law of the excluded middle.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
15. Everything should be built top-down, except the first time.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
43. In software systems, it is often the early bird that makes the worm.
61. In programming, as in everything else, to be in error is to be reborn.
66. Making something variable is easy. Controlling duration of constancy is the trick.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
98. In computing, the mean time to failure keeps getting shorter.
79. A year spent in artificial intelligence is enough to make one believe in God.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
62. In computing, invariants are ephemeral.
41. Some programming languages manage to absorb change, but withstand progress.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
72. An adequate bootstrap is a contradiction in terms.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
105. You can't communicate complexity, only an awareness of it.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
112. Computer Science is embarrassed by the computer.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
60. In seeking the unattainable, simplicity only gets in the way.
100. We will never run out of things to program as long as there is a single program around.
57. It is easier to change the specification to fit the program than vice versa.
104. The proof of a system's value is its existence.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
98. In computing, the mean time to failure keeps getting shorter.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
102. One can't proceed from the informal to the formal by formal means.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
43. In software systems, it is often the early bird that makes the worm.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
63. When we write programs that "learn", it turns out that we do and they don't.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
1. One man's constant is another man's variable.
46. Like punning, programming is a play on words.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
76. It is the user who should parameterize procedures, not their creators.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
14. In the long run every program becomes rococo - then rubble.
1. One man's constant is another man's variable.
1. One man's constant is another man's variable.
15. Everything should be built top-down, except the first time.
17. If a listener nods his head when you're explaining your program, wake him up.
108. Whenever two programmers meet to criticize their programs, both are silent.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
12. Recursion is the root of computation since it trades description for time.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
40. There are two ways to write error-free programs; only the third one works.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
66. Making something variable is easy. Controlling duration of constancy is the trick.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
66. Making something variable is easy. Controlling duration of constancy is the trick.
3. Syntactic sugar causes cancer of the semicolon.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
115. Most people find the concept of programming obvious, but the doing impossible.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
40. There are two ways to write error-free programs; only the third one works.
22. A good system can't have a weak command language.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
46. Like punning, programming is a play on words.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
14. In the long run every program becomes rococo - then rubble.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
31. Simplicity does not precede complexity, but follows it.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
15. Everything should be built top-down, except the first time.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
43. In software systems, it is often the early bird that makes the worm.
12. Recursion is the root of computation since it trades description for time.
96. Computers don't introduce order anywhere as much as they expose opportunities.
103. Purely applicative languages are poorly applicable.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
108. Whenever two programmers meet to criticize their programs, both are silent.
108. Whenever two programmers meet to criticize their programs, both are silent.
22. A good system can't have a weak command language.
66. Making something variable is easy. Controlling duration of constancy is the trick.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
105. You can't communicate complexity, only an awareness of it.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
15. Everything should be built top-down, except the first time.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
55. A LISP programmer knows the value of everything, but the cost of nothing.
60. In seeking the unattainable, simplicity only gets in the way.
38. Structured Programming supports the law of the excluded middle.
105. You can't communicate complexity, only an awareness of it.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
72. An adequate bootstrap is a contradiction in terms.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
103. Purely applicative languages are poorly applicable.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
90. Computation has made the tree flower.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
14. In the long run every program becomes rococo - then rubble.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
96. Computers don't introduce order anywhere as much as they expose opportunities.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
111. Why did the Roman Empire collapse? What is Latin for office automation?
115. Most people find the concept of programming obvious, but the doing impossible.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
63. When we write programs that "learn", it turns out that we do and they don't.
57. It is easier to change the specification to fit the program than vice versa.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
8. A programming language is low level when its programs require attention to the irrelevant.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
31. Simplicity does not precede complexity, but follows it.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
27. Once you understand how to write a program get someone else to write it.
22. A good system can't have a weak command language.
110. Editing is a rewording activity.
4. Every program is a part of some other program and rarely fits.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
8. A programming language is low level when its programs require attention to the irrelevant.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
100. We will never run out of things to program as long as there is a single program around.
60. In seeking the unattainable, simplicity only gets in the way.
22. A good system can't have a weak command language.
60. In seeking the unattainable, simplicity only gets in the way.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
115. Most people find the concept of programming obvious, but the doing impossible.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
112. Computer Science is embarrassed by the computer.
76. It is the user who should parameterize procedures, not their creators.
63. When we write programs that "learn", it turns out that we do and they don't.
3. Syntactic sugar causes cancer of the semicolon.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
63. When we write programs that "learn", it turns out that we do and they don't.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
27. Once you understand how to write a program get someone else to write it.
78. If your computer speaks English, it was probably made in Japan.
47. As Will Rogers would have said, "There is no such thing as a free variable."
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
12. Recursion is the root of computation since it trades description for time.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
40. There are two ways to write error-free programs; only the third one works.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
63. When we write programs that "learn", it turns out that we do and they don't.
114. Within a computer natural language is unnatural.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
11. If you have a procedure with ten parameters, you probably missed some.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
40. There are two ways to write error-free programs; only the third one works.
102. One can't proceed from the informal to the formal by formal means.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
4. Every program is a part of some other program and rarely fits.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
15. Everything should be built top-down, except the first time.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
105. You can't communicate complexity, only an awareness of it.
11. If you have a procedure with ten parameters, you probably missed some.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
66. Making something variable is easy. Controlling duration of constancy is the trick.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
98. In computing, the mean time to failure keeps getting shorter.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
104. The proof of a system's value is its existence.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
98. In computing, the mean time to failure keeps getting shorter.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
90. Computation has made the tree flower.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
79. A year spent in artificial intelligence is enough to make one believe in God.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
22. A good system can't have a weak command language.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
3. Syntactic sugar causes cancer of the semicolon.
7. It is easier to write an incorrect program than understand a correct one.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
114. Within a computer natural language is unnatural.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
110. Editing is a rewording activity.
31. Simplicity does not precede complexity, but follows it.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
31. Simplicity does not precede complexity, but follows it.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
98. In computing, the mean time to failure keeps getting shorter.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
27. Once you understand how to write a program get someone else to write it.
119. Programming is an unnatural act.
96. Computers don't introduce order anywhere as much as they expose opportunities.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
3. Syntactic sugar causes cancer of the semicolon.
102. One can't proceed from the informal to the formal by formal means.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
27. Once you understand how to write a program get someone else to write it.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
61. In programming, as in everything else, to be in error is to be reborn.
105. You can't communicate complexity, only an awareness of it.
105. You can't communicate complexity, only an awareness of it.
46. Like punning, programming is a play on words.
102. One can't proceed from the informal to the formal by formal means.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
8. A programming language is low level when its programs require attention to the irrelevant.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
43. In software systems, it is often the early bird that makes the worm.
23. To understand a program you must become both the machine and the program.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
14. In the long run every program becomes rococo - then rubble.
7. It is easier to write an incorrect program than understand a correct one.
98. In computing, the mean time to failure keeps getting shorter.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
55. A LISP programmer knows the value of everything, but the cost of nothing.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
76. It is the user who should parameterize procedures, not their creators.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
98. In computing, the mean time to failure keeps getting shorter.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
104. The proof of a system's value is its existence.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
112. Computer Science is embarrassed by the computer.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
4. Every program is a part of some other program and rarely fits.
110. Editing is a rewording activity.
63. When we write programs that "learn", it turns out that we do and they don't.
108. Whenever two programmers meet to criticize their programs, both are silent.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
1. One man's constant is another man's variable.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
112. Computer Science is embarrassed by the computer.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
7. It is easier to write an incorrect program than understand a correct one.
115. Most people find the concept of programming obvious, but the doing impossible.
31. Simplicity does not precede complexity, but follows it.
111. Why did the Roman Empire collapse? What is Latin for office automation?
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
47. As Will Rogers would have said, "There is no such thing as a free variable."
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
46. Like punning, programming is a play on words.
119. Programming is an unnatural act.
4. Every program is a part of some other program and rarely fits.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
14. In the long run every program becomes rococo - then rubble.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
57. It is easier to change the specification to fit the program than vice versa.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
60. In seeking the unattainable, simplicity only gets in the way.
108. Whenever two programmers meet to criticize their programs, both are silent.
111. Why did the Roman Empire collapse? What is Latin for office automation?
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
111. Why did the Roman Empire collapse? What is Latin for office automation?
14. In the long run every program becomes rococo - then rubble.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
79. A year spent in artificial intelligence is enough to make one believe in God.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
15. Everything should be built top-down, except the first time.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
114. Within a computer natural language is unnatural.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
4. Every program is a part of some other program and rarely fits.
1. One man's constant is another man's variable.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
105. You can't communicate complexity, only an awareness of it.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
63. When we write programs that "learn", it turns out that we do and they don't.
11. If you have a procedure with ten parameters, you probably missed some.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
60. In seeking the unattainable, simplicity only gets in the way.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
110. Editing is a rewording activity.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
66. Making something variable is easy. Controlling duration of constancy is the trick.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
43. In software systems, it is often the early bird that makes the worm.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
55. A LISP programmer knows the value of everything, but the cost of nothing.
27. Once you understand how to write a program get someone else to write it.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
112. Computer Science is embarrassed by the computer.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
15. Everything should be built top-down, except the first time.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
1. One man's constant is another man's variable.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
96. Computers don't introduce order anywhere as much as they expose opportunities.
105. You can't communicate complexity, only an awareness of it.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
60. In seeking the unattainable, simplicity only gets in the way.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
40. There are two ways to write error-free programs; only the third one works.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
100. We will never run out of things to program as long as there is a single program around.
90. Computation has made the tree flower.
23. To understand a program you must become both the machine and the program.
76. It is the user who should parameterize procedures, not their creators.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
41. Some programming languages manage to absorb change, but withstand progress.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
1. One man's constant is another man's variable.
115. Most people find the concept of programming obvious, but the doing impossible.
47. As Will Rogers would have said, "There is no such thing as a free variable."
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
4. Every program is a part of some other program and rarely fits.
17. If a listener nods his head when you're explaining your program, wake him up.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
96. Computers don't introduce order anywhere as much as they expose opportunities.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
62. In computing, invariants are ephemeral.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
62. In computing, invariants are ephemeral.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
105. You can't communicate complexity, only an awareness of it.
66. Making something variable is easy. Controlling duration of constancy is the trick.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
55. A LISP programmer knows the value of everything, but the cost of nothing.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
17. If a listener nods his head when you're explaining your program, wake him up.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
62. In computing, invariants are ephemeral.
40. There are two ways to write error-free programs; only the third one works.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
27. Once you understand how to write a program get someone else to write it.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
102. One can't proceed from the informal to the formal by formal means.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
59. In English every word can be verbed. Would that it were so in our programming languages.
62. In computing, invariants are ephemeral.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
96. Computers don't introduce order anywhere as much as they expose opportunities.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
104. The proof of a system's value is its existence.
96. Computers don't introduce order anywhere as much as they expose opportunities.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
8. A programming language is low level when its programs require attention to the irrelevant.
38. Structured Programming supports the law of the excluded middle.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
43. In software systems, it is often the early bird that makes the worm.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
40. There are two ways to write error-free programs; only the third one works.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
63. When we write programs that "learn", it turns out that we do and they don't.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
23. To understand a program you must become both the machine and the program.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
1. One man's constant is another man's variable.
62. In computing, invariants are ephemeral.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
96. Computers don't introduce order anywhere as much as they expose opportunities.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
4. Every program is a part of some other program and rarely fits.
90. Computation has made the tree flower.
57. It is easier to change the specification to fit the program than vice versa.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
31. Simplicity does not precede complexity, but follows it.
15. Everything should be built top-down, except the first time.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
3. Syntactic sugar causes cancer of the semicolon.
41. Some programming languages manage to absorb change, but withstand progress.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
17. If a listener nods his head when you're explaining your program, wake him up.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
102. One can't proceed from the informal to the formal by formal means.
59. In English every word can be verbed. Would that it were so in our programming languages.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
23. To understand a program you must become both the machine and the program.
66. Making something variable is easy. Controlling duration of constancy is the trick.
111. Why did the Roman Empire collapse? What is Latin for office automation?
17. If a listener nods his head when you're explaining your program, wake him up.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
111. Why did the Roman Empire collapse? What is Latin for office automation?
7. It is easier to write an incorrect program than understand a correct one.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
102. One can't proceed from the informal to the formal by formal means.
31. Simplicity does not precede complexity, but follows it.
104. The proof of a system's value is its existence.
3. Syntactic sugar causes cancer of the semicolon.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
59. In English every word can be verbed. Would that it were so in our programming languages.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
27. Once you understand how to write a program get someone else to write it.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
76. It is the user who should parameterize procedures, not their creators.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
7. It is easier to write an incorrect program than understand a correct one.
119. Programming is an unnatural act.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
90. Computation has made the tree flower.
23. To understand a program you must become both the machine and the program.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
119. Programming is an unnatural act.
63. When we write programs that "learn", it turns out that we do and they don't.
66. Making something variable is easy. Controlling duration of constancy is the trick.
12. Recursion is the root of computation since it trades description for time.
114. Within a computer natural language is unnatural.
55. A LISP programmer knows the value of everything, but the cost of nothing.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
63. When we write programs that "learn", it turns out that we do and they don't.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
102. One can't proceed from the informal to the formal by formal means.
40. There are two ways to write error-free programs; only the third one works.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
79. A year spent in artificial intelligence is enough to make one believe in God.
14. In the long run every program becomes rococo - then rubble.
57. It is easier to change the specification to fit the program than vice versa.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
60. In seeking the unattainable, simplicity only gets in the way.
76. It is the user who should parameterize procedures, not their creators.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
7. It is easier to write an incorrect program than understand a correct one.
60. In seeking the unattainable, simplicity only gets in the way.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
98. In computing, the mean time to failure keeps getting shorter.
72. An adequate bootstrap is a contradiction in terms.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
119. Programming is an unnatural act.
114. Within a computer natural language is unnatural.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
110. Editing is a rewording activity.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
47. As Will Rogers would have said, "There is no such thing as a free variable."
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
8. A programming language is low level when its programs require attention to the irrelevant.
78. If your computer speaks English, it was probably made in Japan.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
115. Most people find the concept of programming obvious, but the doing impossible.
18. A program without a loop and a structured variable isn't worth writing.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
57. It is easier to change the specification to fit the program than vice versa.
72. An adequate bootstrap is a contradiction in terms.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
103. Purely applicative languages are poorly applicable.
21. Optimization hinders evolution.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
100. We will never run out of things to program as long as there is a single program around.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
27. Once you understand how to write a program get someone else to write it.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
21. Optimization hinders evolution.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
12. Recursion is the root of computation since it trades description for time.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
119. Programming is an unnatural act.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
111. Why did the Roman Empire collapse? What is Latin for office automation?
27. Once you understand how to write a program get someone else to write it.
115. Most people find the concept of programming obvious, but the doing impossible.
95. Don't have good ideas if you aren't willing to be responsible for them.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
60. In seeking the unattainable, simplicity only gets in the way.
102. One can't proceed from the informal to the formal by formal means.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
72. An adequate bootstrap is a contradiction in terms.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
3. Syntactic sugar causes cancer of the semicolon.
111. Why did the Roman Empire collapse? What is Latin for office automation?
17. If a listener nods his head when you're explaining your program, wake him up.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
22. A good system can't have a weak command language.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
100. We will never run out of things to program as long as there is a single program around.
17. If a listener nods his head when you're explaining your program, wake him up.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
41. Some programming languages manage to absorb change, but withstand progress.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
72. An adequate bootstrap is a contradiction in terms.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
63. When we write programs that "learn", it turns out that we do and they don't.
76. It is the user who should parameterize procedures, not their creators.
119. Programming is an unnatural act.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
103. Purely applicative languages are poorly applicable.
95. Don't have good ideas if you aren't willing to be responsible for them.
1. One man's constant is another man's variable.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
3. Syntactic sugar causes cancer of the semicolon.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
119. Programming is an unnatural act.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
111. Why did the Roman Empire collapse? What is Latin for office automation?
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
79. A year spent in artificial intelligence is enough to make one believe in God.
114. Within a computer natural language is unnatural.
4. Every program is a part of some other program and rarely fits.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
90. Computation has made the tree flower.
66. Making something variable is easy. Controlling duration of constancy is the trick.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
112. Computer Science is embarrassed by the computer.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
11. If you have a procedure with ten parameters, you probably missed some.
102. One can't proceed from the informal to the formal by formal means.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
7. It is easier to write an incorrect program than understand a correct one.
105. You can't communicate complexity, only an awareness of it.
102. One can't proceed from the informal to the formal by formal means.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
95. Don't have good ideas if you aren't willing to be responsible for them.
47. As Will Rogers would have said, "There is no such thing as a free variable."
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
105. You can't communicate complexity, only an awareness of it.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
110. Editing is a rewording activity.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
14. In the long run every program becomes rococo - then rubble.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
76. It is the user who should parameterize procedures, not their creators.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
38. Structured Programming supports the law of the excluded middle.
66. Making something variable is easy. Controlling duration of constancy is the trick.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
4. Every program is a part of some other program and rarely fits.
17. If a listener nods his head when you're explaining your program, wake him up.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
60. In seeking the unattainable, simplicity only gets in the way.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
66. Making something variable is easy. Controlling duration of constancy is the trick.
18. A program without a loop and a structured variable isn't worth writing.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
104. The proof of a system's value is its existence.
14. In the long run every program becomes rococo - then rubble.
18. A program without a loop and a structured variable isn't worth writing.
100. We will never run out of things to program as long as there is a single program around.
23. To understand a program you must become both the machine and the program.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
59. In English every word can be verbed. Would that it were so in our programming languages.
47. As Will Rogers would have said, "There is no such thing as a free variable."
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
76. It is the user who should parameterize procedures, not their creators.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
47. As Will Rogers would have said, "There is no such thing as a free variable."
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
115. Most people find the concept of programming obvious, but the doing impossible.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
47. As Will Rogers would have said, "There is no such thing as a free variable."
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
11. If you have a procedure with ten parameters, you probably missed some.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
95. Don't have good ideas if you aren't willing to be responsible for them.
104. The proof of a system's value is its existence.
119. Programming is an unnatural act.
59. In English every word can be verbed. Would that it were so in our programming languages.
108. Whenever two programmers meet to criticize their programs, both are silent.
119. Programming is an unnatural act.
96. Computers don't introduce order anywhere as much as they expose opportunities.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
12. Recursion is the root of computation since it trades description for time.
110. Editing is a rewording activity.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
119. Programming is an unnatural act.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
11. If you have a procedure with ten parameters, you probably missed some.
31. Simplicity does not precede complexity, but follows it.
55. A LISP programmer knows the value of everything, but the cost of nothing.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
46. Like punning, programming is a play on words.
72. An adequate bootstrap is a contradiction in terms.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
40. There are two ways to write error-free programs; only the third one works.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
108. Whenever two programmers meet to criticize their programs, both are silent.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
60. In seeking the unattainable, simplicity only gets in the way.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
4. Every program is a part of some other program and rarely fits.
90. Computation has made the tree flower.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
90. Computation has made the tree flower.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
18. A program without a loop and a structured variable isn't worth writing.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
1. One man's constant is another man's variable.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
66. Making something variable is easy. Controlling duration of constancy is the trick.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
21. Optimization hinders evolution.
40. There are two ways to write error-free programs; only the third one works.
76. It is the user who should parameterize procedures, not their creators.
66. Making something variable is easy. Controlling duration of constancy is the trick.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
90. Computation has made the tree flower.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
66. Making something variable is easy. Controlling duration of constancy is the trick.
21. Optimization hinders evolution.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
27. Once you understand how to write a program get someone else to write it.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
115. Most people find the concept of programming obvious, but the doing impossible.
103. Purely applicative languages are poorly applicable.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
47. As Will Rogers would have said, "There is no such thing as a free variable."
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
46. Like punning, programming is a play on words.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
8. A programming language is low level when its programs require attention to the irrelevant.
108. Whenever two programmers meet to criticize their programs, both are silent.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
15. Everything should be built top-down, except the first time.
55. A LISP programmer knows the value of everything, but the cost of nothing.
115. Most people find the concept of programming obvious, but the doing impossible.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
40. There are two ways to write error-free programs; only the third one works.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
79. A year spent in artificial intelligence is enough to make one believe in God.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
18. A program without a loop and a structured variable isn't worth writing.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
7. It is easier to write an incorrect program than understand a correct one.
59. In English every word can be verbed. Would that it were so in our programming languages.
62. In computing, invariants are ephemeral.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
55. A LISP programmer knows the value of everything, but the cost of nothing.
21. Optimization hinders evolution.
108. Whenever two programmers meet to criticize their programs, both are silent.
78. If your computer speaks English, it was probably made in Japan.
63. When we write programs that "learn", it turns out that we do and they don't.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
59. In English every word can be verbed. Would that it were so in our programming languages.
3. Syntactic sugar causes cancer of the semicolon.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
111. Why did the Roman Empire collapse? What is Latin for office automation?
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
95. Don't have good ideas if you aren't willing to be responsible for them.
90. Computation has made the tree flower.
31. Simplicity does not precede complexity, but follows it.
63. When we write programs that "learn", it turns out that we do and they don't.
3. Syntactic sugar causes cancer of the semicolon.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
90. Computation has made the tree flower.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
102. One can't proceed from the informal to the formal by formal means.
15. Everything should be built top-down, except the first time.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
111. Why did the Roman Empire collapse? What is Latin for office automation?
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
62. In computing, invariants are ephemeral.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
112. Computer Science is embarrassed by the computer.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
15. Everything should be built top-down, except the first time.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
43. In software systems, it is often the early bird that makes the worm.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
55. A LISP programmer knows the value of everything, but the cost of nothing.
110. Editing is a rewording activity.
4. Every program is a part of some other program and rarely fits.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
11. If you have a procedure with ten parameters, you probably missed some.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
23. To understand a program you must become both the machine and the program.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
11. If you have a procedure with ten parameters, you probably missed some.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
105. You can't communicate complexity, only an awareness of it.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
66. Making something variable is easy. Controlling duration of constancy is the trick.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
43. In software systems, it is often the early bird that makes the worm.
18. A program without a loop and a structured variable isn't worth writing.
108. Whenever two programmers meet to criticize their programs, both are silent.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
8. A programming language is low level when its programs require attention to the irrelevant.
90. Computation has made the tree flower.
57. It is easier to change the specification to fit the program than vice versa.
108. Whenever two programmers meet to criticize their programs, both are silent.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
60. In seeking the unattainable, simplicity only gets in the way.
95. Don't have good ideas if you aren't willing to be responsible for them.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
12. Recursion is the root of computation since it trades description for time.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
95. Don't have good ideas if you aren't willing to be responsible for them.
12. Recursion is the root of computation since it trades description for time.
47. As Will Rogers would have said, "There is no such thing as a free variable."
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
57. It is easier to change the specification to fit the program than vice versa.
66. Making something variable is easy. Controlling duration of constancy is the trick.
79. A year spent in artificial intelligence is enough to make one believe in God.
14. In the long run every program becomes rococo - then rubble.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
14. In the long run every program becomes rococo - then rubble.
60. In seeking the unattainable, simplicity only gets in the way.
38. Structured Programming supports the law of the excluded middle.
72. An adequate bootstrap is a contradiction in terms.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
43. In software systems, it is often the early bird that makes the worm.
79. A year spent in artificial intelligence is enough to make one believe in God.
96. Computers don't introduce order anywhere as much as they expose opportunities.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
114. Within a computer natural language is unnatural.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
119. Programming is an unnatural act.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
14. In the long run every program becomes rococo - then rubble.
108. Whenever two programmers meet to criticize their programs, both are silent.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
78. If your computer speaks English, it was probably made in Japan.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
8. A programming language is low level when its programs require attention to the irrelevant.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
115. Most people find the concept of programming obvious, but the doing impossible.
38. Structured Programming supports the law of the excluded middle.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
57. It is easier to change the specification to fit the program than vice versa.
111. Why did the Roman Empire collapse? What is Latin for office automation?
59. In English every word can be verbed. Would that it were so in our programming languages.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
90. Computation has made the tree flower.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
11. If you have a procedure with ten parameters, you probably missed some.
76. It is the user who should parameterize procedures, not their creators.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
111. Why did the Roman Empire collapse? What is Latin for office automation?
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
47. As Will Rogers would have said, "There is no such thing as a free variable."
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
1. One man's constant is another man's variable.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
102. One can't proceed from the informal to the formal by formal means.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
98. In computing, the mean time to failure keeps getting shorter.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
21. Optimization hinders evolution.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
63. When we write programs that "learn", it turns out that we do and they don't.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
60. In seeking the unattainable, simplicity only gets in the way.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
102. One can't proceed from the informal to the formal by formal means.
76. It is the user who should parameterize procedures, not their creators.
8. A programming language is low level when its programs require attention to the irrelevant.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
114. Within a computer natural language is unnatural.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
27. Once you understand how to write a program get someone else to write it.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
72. An adequate bootstrap is a contradiction in terms.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
60. In seeking the unattainable, simplicity only gets in the way.
63. When we write programs that "learn", it turns out that we do and they don't.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
62. In computing, invariants are ephemeral.
79. A year spent in artificial intelligence is enough to make one believe in God.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
22. A good system can't have a weak command language.
47. As Will Rogers would have said, "There is no such thing as a free variable."
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
112. Computer Science is embarrassed by the computer.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
60. In seeking the unattainable, simplicity only gets in the way.
61. In programming, as in everything else, to be in error is to be reborn.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
105. You can't communicate complexity, only an awareness of it.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
111. Why did the Roman Empire collapse? What is Latin for office automation?
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
60. In seeking the unattainable, simplicity only gets in the way.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
1. One man's constant is another man's variable.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
110. Editing is a rewording activity.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
103. Purely applicative languages are poorly applicable.
100. We will never run out of things to program as long as there is a single program around.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
115. Most people find the concept of programming obvious, but the doing impossible.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
78. If your computer speaks English, it was probably made in Japan.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
47. As Will Rogers would have said, "There is no such thing as a free variable."
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
96. Computers don't introduce order anywhere as much as they expose opportunities.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
78. If your computer speaks English, it was probably made in Japan.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
112. Computer Science is embarrassed by the computer.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
105. You can't communicate complexity, only an awareness of it.
3. Syntactic sugar causes cancer of the semicolon.
96. Computers don't introduce order anywhere as much as they expose opportunities.
103. Purely applicative languages are poorly applicable.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
31. Simplicity does not precede complexity, but follows it.
62. In computing, invariants are ephemeral.
78. If your computer speaks English, it was probably made in Japan.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
112. Computer Science is embarrassed by the computer.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
12. Recursion is the root of computation since it trades description for time.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
38. Structured Programming supports the law of the excluded middle.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
15. Everything should be built top-down, except the first time.
78. If your computer speaks English, it was probably made in Japan.
104. The proof of a system's value is its existence.
40. There are two ways to write error-free programs; only the third one works.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
59. In English every word can be verbed. Would that it were so in our programming languages.
18. A program without a loop and a structured variable isn't worth writing.
12. Recursion is the root of computation since it trades description for time.
18. A program without a loop and a structured variable isn't worth writing.
72. An adequate bootstrap is a contradiction in terms.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
114. Within a computer natural language is unnatural.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
57. It is easier to change the specification to fit the program than vice versa.
102. One can't proceed from the informal to the formal by formal means.
31. Simplicity does not precede complexity, but follows it.
11. If you have a procedure with ten parameters, you probably missed some.
8. A programming language is low level when its programs require attention to the irrelevant.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
59. In English every word can be verbed. Would that it were so in our programming languages.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
17. If a listener nods his head when you're explaining your program, wake him up.
55. A LISP programmer knows the value of everything, but the cost of nothing.
90. Computation has made the tree flower.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
110. Editing is a rewording activity.
17. If a listener nods his head when you're explaining your program, wake him up.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
1. One man's constant is another man's variable.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
90. Computation has made the tree flower.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
105. You can't communicate complexity, only an awareness of it.
63. When we write programs that "learn", it turns out that we do and they don't.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
96. Computers don't introduce order anywhere as much as they expose opportunities.
38. Structured Programming supports the law of the excluded middle.
104. The proof of a system's value is its existence.
18. A program without a loop and a structured variable isn't worth writing.
23. To understand a program you must become both the machine and the program.
60. In seeking the unattainable, simplicity only gets in the way.
21. Optimization hinders evolution.
27. Once you understand how to write a program get someone else to write it.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
76. It is the user who should parameterize procedures, not their creators.
115. Most people find the concept of programming obvious, but the doing impossible.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
63. When we write programs that "learn", it turns out that we do and they don't.
8. A programming language is low level when its programs require attention to the irrelevant.
111. Why did the Roman Empire collapse? What is Latin for office automation?
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
110. Editing is a rewording activity.
40. There are two ways to write error-free programs; only the third one works.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
72. An adequate bootstrap is a contradiction in terms.
47. As Will Rogers would have said, "There is no such thing as a free variable."
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
7. It is easier to write an incorrect program than understand a correct one.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
27. Once you understand how to write a program get someone else to write it.
72. An adequate bootstrap is a contradiction in terms.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
63. When we write programs that "learn", it turns out that we do and they don't.
1. One man's constant is another man's variable.
96. Computers don't introduce order anywhere as much as they expose opportunities.
72. An adequate bootstrap is a contradiction in terms.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
1. One man's constant is another man's variable.
90. Computation has made the tree flower.
18. A program without a loop and a structured variable isn't worth writing.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
114. Within a computer natural language is unnatural.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
79. A year spent in artificial intelligence is enough to make one believe in God.
119. Programming is an unnatural act.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
115. Most people find the concept of programming obvious, but the doing impossible.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
47. As Will Rogers would have said, "There is no such thing as a free variable."
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
43. In software systems, it is often the early bird that makes the worm.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
18. A program without a loop and a structured variable isn't worth writing.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
7. It is easier to write an incorrect program than understand a correct one.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
111. Why did the Roman Empire collapse? What is Latin for office automation?
103. Purely applicative languages are poorly applicable.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
17. If a listener nods his head when you're explaining your program, wake him up.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
96. Computers don't introduce order anywhere as much as they expose opportunities.
12. Recursion is the root of computation since it trades description for time.
61. In programming, as in everything else, to be in error is to be reborn.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
47. As Will Rogers would have said, "There is no such thing as a free variable."
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
23. To understand a program you must become both the machine and the program.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
95. Don't have good ideas if you aren't willing to be responsible for them.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
78. If your computer speaks English, it was probably made in Japan.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
12. Recursion is the root of computation since it trades description for time.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
40. There are two ways to write error-free programs; only the third one works.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
61. In programming, as in everything else, to be in error is to be reborn.
59. In English every word can be verbed. Would that it were so in our programming languages.
3. Syntactic sugar causes cancer of the semicolon.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
72. An adequate bootstrap is a contradiction in terms.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
79. A year spent in artificial intelligence is enough to make one believe in God.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
57. It is easier to change the specification to fit the program than vice versa.
1. One man's constant is another man's variable.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
102. One can't proceed from the informal to the formal by formal means.
7. It is easier to write an incorrect program than understand a correct one.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
100. We will never run out of things to program as long as there is a single program around.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
17. If a listener nods his head when you're explaining your program, wake him up.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
90. Computation has made the tree flower.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
8. A programming language is low level when its programs require attention to the irrelevant.
63. When we write programs that "learn", it turns out that we do and they don't.
27. Once you understand how to write a program get someone else to write it.
31. Simplicity does not precede complexity, but follows it.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
12. Recursion is the root of computation since it trades description for time.
104. The proof of a system's value is its existence.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
23. To understand a program you must become both the machine and the program.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
3. Syntactic sugar causes cancer of the semicolon.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
111. Why did the Roman Empire collapse? What is Latin for office automation?
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
43. In software systems, it is often the early bird that makes the worm.
100. We will never run out of things to program as long as there is a single program around.
14. In the long run every program becomes rococo - then rubble.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
119. Programming is an unnatural act.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
3. Syntactic sugar causes cancer of the semicolon.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
43. In software systems, it is often the early bird that makes the worm.
60. In seeking the unattainable, simplicity only gets in the way.
4. Every program is a part of some other program and rarely fits.
96. Computers don't introduce order anywhere as much as they expose opportunities.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
95. Don't have good ideas if you aren't willing to be responsible for them.
3. Syntactic sugar causes cancer of the semicolon.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
23. To understand a program you must become both the machine and the program.
100. We will never run out of things to program as long as there is a single program around.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
111. Why did the Roman Empire collapse? What is Latin for office automation?
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
95. Don't have good ideas if you aren't willing to be responsible for them.
23. To understand a program you must become both the machine and the program.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
23. To understand a program you must become both the machine and the program.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
63. When we write programs that "learn", it turns out that we do and they don't.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
119. Programming is an unnatural act.
66. Making something variable is easy. Controlling duration of constancy is the trick.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
114. Within a computer natural language is unnatural.
115. Most people find the concept of programming obvious, but the doing impossible.
57. It is easier to change the specification to fit the program than vice versa.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
47. As Will Rogers would have said, "There is no such thing as a free variable."
23. To understand a program you must become both the machine and the program.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
76. It is the user who should parameterize procedures, not their creators.
95. Don't have good ideas if you aren't willing to be responsible for them.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
11. If you have a procedure with ten parameters, you probably missed some.
17. If a listener nods his head when you're explaining your program, wake him up.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
46. Like punning, programming is a play on words.
104. The proof of a system's value is its existence.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
114. Within a computer natural language is unnatural.
7. It is easier to write an incorrect program than understand a correct one.
76. It is the user who should parameterize procedures, not their creators.
108. Whenever two programmers meet to criticize their programs, both are silent.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
78. If your computer speaks English, it was probably made in Japan.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
17. If a listener nods his head when you're explaining your program, wake him up.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
63. When we write programs that "learn", it turns out that we do and they don't.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
62. In computing, invariants are ephemeral.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
15. Everything should be built top-down, except the first time.
112. Computer Science is embarrassed by the computer.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
46. Like punning, programming is a play on words.
57. It is easier to change the specification to fit the program than vice versa.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
103. Purely applicative languages are poorly applicable.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
72. An adequate bootstrap is a contradiction in terms.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
1. One man's constant is another man's variable.
102. One can't proceed from the informal to the formal by formal means.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
27. Once you understand how to write a program get someone else to write it.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
72. An adequate bootstrap is a contradiction in terms.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
3. Syntactic sugar causes cancer of the semicolon.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
112. Computer Science is embarrassed by the computer.
100. We will never run out of things to program as long as there is a single program around.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
104. The proof of a system's value is its existence.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
90. Computation has made the tree flower.
108. Whenever two programmers meet to criticize their programs, both are silent.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
104. The proof of a system's value is its existence.
105. You can't communicate complexity, only an awareness of it.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
100. We will never run out of things to program as long as there is a single program around.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
27. Once you understand how to write a program get someone else to write it.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
61. In programming, as in everything else, to be in error is to be reborn.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
98. In computing, the mean time to failure keeps getting shorter.
96. Computers don't introduce order anywhere as much as they expose opportunities.
15. Everything should be built top-down, except the first time.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
17. If a listener nods his head when you're explaining your program, wake him up.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
41. Some programming languages manage to absorb change, but withstand progress.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
105. You can't communicate complexity, only an awareness of it.
8. A programming language is low level when its programs require attention to the irrelevant.
27. Once you understand how to write a program get someone else to write it.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
111. Why did the Roman Empire collapse? What is Latin for office automation?
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
102. One can't proceed from the informal to the formal by formal means.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
108. Whenever two programmers meet to criticize their programs, both are silent.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
114. Within a computer natural language is unnatural.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
111. Why did the Roman Empire collapse? What is Latin for office automation?
98. In computing, the mean time to failure keeps getting shorter.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
110. Editing is a rewording activity.
43. In software systems, it is often the early bird that makes the worm.
27. Once you understand how to write a program get someone else to write it.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
1. One man's constant is another man's variable.
90. Computation has made the tree flower.
119. Programming is an unnatural act.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
61. In programming, as in everything else, to be in error is to be reborn.
43. In software systems, it is often the early bird that makes the worm.
90. Computation has made the tree flower.
96. Computers don't introduce order anywhere as much as they expose opportunities.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
103. Purely applicative languages are poorly applicable.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
63. When we write programs that "learn", it turns out that we do and they don't.
59. In English every word can be verbed. Would that it were so in our programming languages.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
62. In computing, invariants are ephemeral.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
63. When we write programs that "learn", it turns out that we do and they don't.
21. Optimization hinders evolution.
46. Like punning, programming is a play on words.
114. Within a computer natural language is unnatural.
15. Everything should be built top-down, except the first time.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
38. Structured Programming supports the law of the excluded middle.
40. There are two ways to write error-free programs; only the third one works.
115. Most people find the concept of programming obvious, but the doing impossible.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
90. Computation has made the tree flower.
59. In English every word can be verbed. Would that it were so in our programming languages.
14. In the long run every program becomes rococo - then rubble.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
100. We will never run out of things to program as long as there is a single program around.
40. There are two ways to write error-free programs; only the third one works.
59. In English every word can be verbed. Would that it were so in our programming languages.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
55. A LISP programmer knows the value of everything, but the cost of nothing.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
79. A year spent in artificial intelligence is enough to make one believe in God.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
95. Don't have good ideas if you aren't willing to be responsible for them.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
72. An adequate bootstrap is a contradiction in terms.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
4. Every program is a part of some other program and rarely fits.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
61. In programming, as in everything else, to be in error is to be reborn.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
17. If a listener nods his head when you're explaining your program, wake him up.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
76. It is the user who should parameterize procedures, not their creators.
41. Some programming languages manage to absorb change, but withstand progress.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
63. When we write programs that "learn", it turns out that we do and they don't.
43. In software systems, it is often the early bird that makes the worm.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
63. When we write programs that "learn", it turns out that we do and they don't.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
59. In English every word can be verbed. Would that it were so in our programming languages.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
111. Why did the Roman Empire collapse? What is Latin for office automation?
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
47. As Will Rogers would have said, "There is no such thing as a free variable."
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
62. In computing, invariants are ephemeral.
76. It is the user who should parameterize procedures, not their creators.
12. Recursion is the root of computation since it trades description for time.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
7. It is easier to write an incorrect program than understand a correct one.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
119. Programming is an unnatural act.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
38. Structured Programming supports the law of the excluded middle.
66. Making something variable is easy. Controlling duration of constancy is the trick.
104. The proof of a system's value is its existence.
66. Making something variable is easy. Controlling duration of constancy is the trick.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
22. A good system can't have a weak command language.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
63. When we write programs that "learn", it turns out that we do and they don't.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
11. If you have a procedure with ten parameters, you probably missed some.
21. Optimization hinders evolution.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
3. Syntactic sugar causes cancer of the semicolon.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
105. You can't communicate complexity, only an awareness of it.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
59. In English every word can be verbed. Would that it were so in our programming languages.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
79. A year spent in artificial intelligence is enough to make one believe in God.
14. In the long run every program becomes rococo - then rubble.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
76. It is the user who should parameterize procedures, not their creators.
4. Every program is a part of some other program and rarely fits.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
14. In the long run every program becomes rococo - then rubble.
72. An adequate bootstrap is a contradiction in terms.
105. You can't communicate complexity, only an awareness of it.
61. In programming, as in everything else, to be in error is to be reborn.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
47. As Will Rogers would have said, "There is no such thing as a free variable."
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
95. Don't have good ideas if you aren't willing to be responsible for them.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
1. One man's constant is another man's variable.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
119. Programming is an unnatural act.
4. Every program is a part of some other program and rarely fits.
76. It is the user who should parameterize procedures, not their creators.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
60. In seeking the unattainable, simplicity only gets in the way.
7. It is easier to write an incorrect program than understand a correct one.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
40. There are two ways to write error-free programs; only the third one works.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
104. The proof of a system's value is its existence.
119. Programming is an unnatural act.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
1. One man's constant is another man's variable.
119. Programming is an unnatural act.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
40. There are two ways to write error-free programs; only the third one works.
95. Don't have good ideas if you aren't willing to be responsible for them.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
110. Editing is a rewording activity.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
60. In seeking the unattainable, simplicity only gets in the way.
78. If your computer speaks English, it was probably made in Japan.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
47. As Will Rogers would have said, "There is no such thing as a free variable."
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
18. A program without a loop and a structured variable isn't worth writing.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
119. Programming is an unnatural act.
110. Editing is a rewording activity.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
61. In programming, as in everything else, to be in error is to be reborn.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
61. In programming, as in everything else, to be in error is to be reborn.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
12. Recursion is the root of computation since it trades description for time.
103. Purely applicative languages are poorly applicable.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
112. Computer Science is embarrassed by the computer.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
100. We will never run out of things to program as long as there is a single program around.
17. If a listener nods his head when you're explaining your program, wake him up.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
19. A language that doesn't affect the way you think about programming, is not worth knowing.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
40. There are two ways to write error-free programs; only the third one works.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
90. Computation has made the tree flower.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
22. A good system can't have a weak command language.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
119. Programming is an unnatural act.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
104. The proof of a system's value is its existence.
43. In software systems, it is often the early bird that makes the worm.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
11. If you have a procedure with ten parameters, you probably missed some.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
14. In the long run every program becomes rococo - then rubble.
95. Don't have good ideas if you aren't willing to be responsible for them.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
41. Some programming languages manage to absorb change, but withstand progress.
14. In the long run every program becomes rococo - then rubble.
17. If a listener nods his head when you're explaining your program, wake him up.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
96. Computers don't introduce order anywhere as much as they expose opportunities.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
31. Simplicity does not precede complexity, but follows it.
103. Purely applicative languages are poorly applicable.
1. One man's constant is another man's variable.
108. Whenever two programmers meet to criticize their programs, both are silent.
108. Whenever two programmers meet to criticize their programs, both are silent.
60. In seeking the unattainable, simplicity only gets in the way.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
15. Everything should be built top-down, except the first time.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
47. As Will Rogers would have said, "There is no such thing as a free variable."
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
114. Within a computer natural language is unnatural.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
110. Editing is a rewording activity.
103. Purely applicative languages are poorly applicable.
105. You can't communicate complexity, only an awareness of it.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
17. If a listener nods his head when you're explaining your program, wake him up.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
103. Purely applicative languages are poorly applicable.
79. A year spent in artificial intelligence is enough to make one believe in God.
4. Every program is a part of some other program and rarely fits.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
62. In computing, invariants are ephemeral.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
78. If your computer speaks English, it was probably made in Japan.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
40. There are two ways to write error-free programs; only the third one works.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
55. A LISP programmer knows the value of everything, but the cost of nothing.
18. A program without a loop and a structured variable isn't worth writing.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
38. Structured Programming supports the law of the excluded middle.
102. One can't proceed from the informal to the formal by formal means.
79. A year spent in artificial intelligence is enough to make one believe in God.
114. Within a computer natural language is unnatural.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
112. Computer Science is embarrassed by the computer.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
1. One man's constant is another man's variable.
110. Editing is a rewording activity.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
23. To understand a program you must become both the machine and the program.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
104. The proof of a system's value is its existence.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
12. Recursion is the root of computation since it trades description for time.
40. There are two ways to write error-free programs; only the third one works.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
60. In seeking the unattainable, simplicity only gets in the way.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
107. The debate rages on: is PL/I Bachtrian or Dromedary?
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
7. It is easier to write an incorrect program than understand a correct one.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
17. If a listener nods his head when you're explaining your program, wake him up.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
98. In computing, the mean time to failure keeps getting shorter.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
14. In the long run every program becomes rococo - then rubble.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
7. It is easier to write an incorrect program than understand a correct one.
114. Within a computer natural language is unnatural.
23. To understand a program you must become both the machine and the program.
57. It is easier to change the specification to fit the program than vice versa.
18. A program without a loop and a structured variable isn't worth writing.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
72. An adequate bootstrap is a contradiction in terms.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
47. As Will Rogers would have said, "There is no such thing as a free variable."
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
12. Recursion is the root of computation since it trades description for time.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
55. A LISP programmer knows the value of everything, but the cost of nothing.
103. Purely applicative languages are poorly applicable.
119. Programming is an unnatural act.
78. If your computer speaks English, it was probably made in Japan.
4. Every program is a part of some other program and rarely fits.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
104. The proof of a system's value is its existence.
14. In the long run every program becomes rococo - then rubble.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
8. A programming language is low level when its programs require attention to the irrelevant.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
17. If a listener nods his head when you're explaining your program, wake him up.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
78. If your computer speaks English, it was probably made in Japan.
98. In computing, the mean time to failure keeps getting shorter.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
102. One can't proceed from the informal to the formal by formal means.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
55. A LISP programmer knows the value of everything, but the cost of nothing.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
60. In seeking the unattainable, simplicity only gets in the way.
59. In English every word can be verbed. Would that it were so in our programming languages.
114. Within a computer natural language is unnatural.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
47. As Will Rogers would have said, "There is no such thing as a free variable."
107. The debate rages on: is PL/I Bachtrian or Dromedary?
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
8. A programming language is low level when its programs require attention to the irrelevant.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
76. It is the user who should parameterize procedures, not their creators.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
62. In computing, invariants are ephemeral.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
21. Optimization hinders evolution.
17. If a listener nods his head when you're explaining your program, wake him up.
90. Computation has made the tree flower.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
41. Some programming languages manage to absorb change, but withstand progress.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
104. The proof of a system's value is its existence.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
95. Don't have good ideas if you aren't willing to be responsible for them.
110. Editing is a rewording activity.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
38. Structured Programming supports the law of the excluded middle.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
111. Why did the Roman Empire collapse? What is Latin for office automation?
76. It is the user who should parameterize procedures, not their creators.
7. It is easier to write an incorrect program than understand a correct one.
98. In computing, the mean time to failure keeps getting shorter.
55. A LISP programmer knows the value of everything, but the cost of nothing.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
102. One can't proceed from the informal to the formal by formal means.
112. Computer Science is embarrassed by the computer.
112. Computer Science is embarrassed by the computer.
112. Computer Science is embarrassed by the computer.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
105. You can't communicate complexity, only an awareness of it.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
1. One man's constant is another man's variable.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
72. An adequate bootstrap is a contradiction in terms.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
4. Every program is a part of some other program and rarely fits.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
31. Simplicity does not precede complexity, but follows it.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
79. A year spent in artificial intelligence is enough to make one believe in God.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
66. Making something variable is easy. Controlling duration of constancy is the trick.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
72. An adequate bootstrap is a contradiction in terms.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
59. In English every word can be verbed. Would that it were so in our programming languages.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
4. Every program is a part of some other program and rarely fits.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
66. Making something variable is easy. Controlling duration of constancy is the trick.
72. An adequate bootstrap is a contradiction in terms.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
57. It is easier to change the specification to fit the program than vice versa.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
18. A program without a loop and a structured variable isn't worth writing.
103. Purely applicative languages are poorly applicable.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
95. Don't have good ideas if you aren't willing to be responsible for them.
76. It is the user who should parameterize procedures, not their creators.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
21. Optimization hinders evolution.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
62. In computing, invariants are ephemeral.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
98. In computing, the mean time to failure keeps getting shorter.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
72. An adequate bootstrap is a contradiction in terms.
17. If a listener nods his head when you're explaining your program, wake him up.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
102. One can't proceed from the informal to the formal by formal means.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
100. We will never run out of things to program as long as there is a single program around.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
96. Computers don't introduce order anywhere as much as they expose opportunities.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
114. Within a computer natural language is unnatural.
22. A good system can't have a weak command language.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
4. Every program is a part of some other program and rarely fits.
112. Computer Science is embarrassed by the computer.
11. If you have a procedure with ten parameters, you probably missed some.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
100. We will never run out of things to program as long as there is a single program around.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
59. In English every word can be verbed. Would that it were so in our programming languages.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
63. When we write programs that "learn", it turns out that we do and they don't.
102. One can't proceed from the informal to the formal by formal means.
47. As Will Rogers would have said, "There is no such thing as a free variable."
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
55. A LISP programmer knows the value of everything, but the cost of nothing.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
59. In English every word can be verbed. Would that it were so in our programming languages.
79. A year spent in artificial intelligence is enough to make one believe in God.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
55. A LISP programmer knows the value of everything, but the cost of nothing.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
23. To understand a program you must become both the machine and the program.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
8. A programming language is low level when its programs require attention to the irrelevant.
79. A year spent in artificial intelligence is enough to make one believe in God.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
43. In software systems, it is often the early bird that makes the worm.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
61. In programming, as in everything else, to be in error is to be reborn.
60. In seeking the unattainable, simplicity only gets in the way.
105. You can't communicate complexity, only an awareness of it.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
104. The proof of a system's value is its existence.
18. A program without a loop and a structured variable isn't worth writing.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
63. When we write programs that "learn", it turns out that we do and they don't.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
105. You can't communicate complexity, only an awareness of it.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
47. As Will Rogers would have said, "There is no such thing as a free variable."
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
8. A programming language is low level when its programs require attention to the irrelevant.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
103. Purely applicative languages are poorly applicable.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
90. Computation has made the tree flower.
105. You can't communicate complexity, only an awareness of it.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
22. A good system can't have a weak command language.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
102. One can't proceed from the informal to the formal by formal means.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
3. Syntactic sugar causes cancer of the semicolon.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
46. Like punning, programming is a play on words.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
22. A good system can't have a weak command language.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
41. Some programming languages manage to absorb change, but withstand progress.
60. In seeking the unattainable, simplicity only gets in the way.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
43. In software systems, it is often the early bird that makes the worm.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
41. Some programming languages manage to absorb change, but withstand progress.
102. One can't proceed from the informal to the formal by formal means.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
1. One man's constant is another man's variable.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
27. Once you understand how to write a program get someone else to write it.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
21. Optimization hinders evolution.
98. In computing, the mean time to failure keeps getting shorter.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
43. In software systems, it is often the early bird that makes the worm.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
95. Don't have good ideas if you aren't willing to be responsible for them.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
63. When we write programs that "learn", it turns out that we do and they don't.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
111. Why did the Roman Empire collapse? What is Latin for office automation?
100. We will never run out of things to program as long as there is a single program around.
1. One man's constant is another man's variable.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
90. Computation has made the tree flower.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
15. Everything should be built top-down, except the first time.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
8. A programming language is low level when its programs require attention to the irrelevant.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
7. It is easier to write an incorrect program than understand a correct one.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
12. Recursion is the root of computation since it trades description for time.
110. Editing is a rewording activity.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
55. A LISP programmer knows the value of everything, but the cost of nothing.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
108. Whenever two programmers meet to criticize their programs, both are silent.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
95. Don't have good ideas if you aren't willing to be responsible for them.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
23. To understand a program you must become both the machine and the program.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
5. If a program manipulates a large amount of data, it does so in a small number of ways.
111. Why did the Roman Empire collapse? What is Latin for office automation?
105. You can't communicate complexity, only an awareness of it.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
40. There are two ways to write error-free programs; only the third one works.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
7. It is easier to write an incorrect program than understand a correct one.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
108. Whenever two programmers meet to criticize their programs, both are silent.
15. Everything should be built top-down, except the first time.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
14. In the long run every program becomes rococo - then rubble.
115. Most people find the concept of programming obvious, but the doing impossible.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
110. Editing is a rewording activity.
18. A program without a loop and a structured variable isn't worth writing.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
79. A year spent in artificial intelligence is enough to make one believe in God.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
76. It is the user who should parameterize procedures, not their creators.
115. Most people find the concept of programming obvious, but the doing impossible.
18. A program without a loop and a structured variable isn't worth writing.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
4. Every program is a part of some other program and rarely fits.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
114. Within a computer natural language is unnatural.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
59. In English every word can be verbed. Would that it were so in our programming languages.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
66. Making something variable is easy. Controlling duration of constancy is the trick.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
23. To understand a program you must become both the machine and the program.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
103. Purely applicative languages are poorly applicable.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
110. Editing is a rewording activity.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
40. There are two ways to write error-free programs; only the third one works.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
40. There are two ways to write error-free programs; only the third one works.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
11. If you have a procedure with ten parameters, you probably missed some.
95. Don't have good ideas if you aren't willing to be responsible for them.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
1. One man's constant is another man's variable.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
18. A program without a loop and a structured variable isn't worth writing.
22. A good system can't have a weak command language.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
100. We will never run out of things to program as long as there is a single program around.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
8. A programming language is low level when its programs require attention to the irrelevant.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
57. It is easier to change the specification to fit the program than vice versa.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
15. Everything should be built top-down, except the first time.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
17. If a listener nods his head when you're explaining your program, wake him up.
112. Computer Science is embarrassed by the computer.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
55. A LISP programmer knows the value of everything, but the cost of nothing.
104. The proof of a system's value is its existence.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
119. Programming is an unnatural act.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
40. There are two ways to write error-free programs; only the third one works.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
111. Why did the Roman Empire collapse? What is Latin for office automation?
15. Everything should be built top-down, except the first time.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
22. A good system can't have a weak command language.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
12. Recursion is the root of computation since it trades description for time.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
4. Every program is a part of some other program and rarely fits.
72. An adequate bootstrap is a contradiction in terms.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
72. An adequate bootstrap is a contradiction in terms.
18. A program without a loop and a structured variable isn't worth writing.
76. It is the user who should parameterize procedures, not their creators.
21. Optimization hinders evolution.
72. An adequate bootstrap is a contradiction in terms.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
63. When we write programs that "learn", it turns out that we do and they don't.
27. Once you understand how to write a program get someone else to write it.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
15. Everything should be built top-down, except the first time.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
105. You can't communicate complexity, only an awareness of it.
31. Simplicity does not precede complexity, but follows it.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
61. In programming, as in everything else, to be in error is to be reborn.
15. Everything should be built top-down, except the first time.
62. In computing, invariants are ephemeral.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
114. Within a computer natural language is unnatural.
110. Editing is a rewording activity.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
4. Every program is a part of some other program and rarely fits.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
79. A year spent in artificial intelligence is enough to make one believe in God.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
43. In software systems, it is often the early bird that makes the worm.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
79. A year spent in artificial intelligence is enough to make one believe in God.
3. Syntactic sugar causes cancer of the semicolon.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
22. A good system can't have a weak command language.
8. A programming language is low level when its programs require attention to the irrelevant.
61. In programming, as in everything else, to be in error is to be reborn.
55. A LISP programmer knows the value of everything, but the cost of nothing.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
66. Making something variable is easy. Controlling duration of constancy is the trick.
18. A program without a loop and a structured variable isn't worth writing.
31. Simplicity does not precede complexity, but follows it.
102. One can't proceed from the informal to the formal by formal means.
4. Every program is a part of some other program and rarely fits.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
31. Simplicity does not precede complexity, but follows it.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
43. In software systems, it is often the early bird that makes the worm.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
107. The debate rages on: is PL/I Bachtrian or Dromedary?
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
79. A year spent in artificial intelligence is enough to make one believe in God.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
41. Some programming languages manage to absorb change, but withstand progress.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
41. Some programming languages manage to absorb change, but withstand progress.
7. It is easier to write an incorrect program than understand a correct one.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
17. If a listener nods his head when you're explaining your program, wake him up.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
72. An adequate bootstrap is a contradiction in terms.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing  thoughts,  devoting attention to detail and learning to be self-critical?
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
105. You can't communicate complexity, only an awareness of it.
18. A program without a loop and a structured variable isn't worth writing.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
18. A program without a loop and a structured variable isn't worth writing.
7. It is easier to write an incorrect program than understand a correct one.
96. Computers don't introduce order anywhere as much as they expose opportunities.
79. A year spent in artificial intelligence is enough to make one believe in God.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
23. To understand a program you must become both the machine and the program.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
52. Systems have sub-systems and sub-systems have sub-systems and so on ad infinitum - which is why we're always starting over.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
98. In computing, the mean time to failure keeps getting shorter.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
15. Everything should be built top-down, except the first time.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
63. When we write programs that "learn", it turns out that we do and they don't.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
1. One man's constant is another man's variable.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
22. A good system can't have a weak command language.
21. Optimization hinders evolution.
1. One man's constant is another man's variable.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
59. In English every word can be verbed. Would that it were so in our programming languages.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
18. A program without a loop and a structured variable isn't worth writing.
8. A programming language is low level when its programs require attention to the irrelevant.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
76. It is the user who should parameterize procedures, not their creators.
55. A LISP programmer knows the value of everything, but the cost of nothing.
105. You can't communicate complexity, only an awareness of it.
66. Making something variable is easy. Controlling duration of constancy is the trick.
7. It is easier to write an incorrect program than understand a correct one.
43. In software systems, it is often the early bird that makes the worm.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
114. Within a computer natural language is unnatural.
60. In seeking the unattainable, simplicity only gets in the way.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
119. Programming is an unnatural act.
95. Don't have good ideas if you aren't willing to be responsible for them.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
23. To understand a program you must become both the machine and the program.
22. A good system can't have a weak command language.
4. Every program is a part of some other program and rarely fits.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
98. In computing, the mean time to failure keeps getting shorter.
38. Structured Programming supports the law of the excluded middle.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
66. Making something variable is easy. Controlling duration of constancy is the trick.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
105. You can't communicate complexity, only an awareness of it.
76. It is the user who should parameterize procedures, not their creators.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
46. Like punning, programming is a play on words.
63. When we write programs that "learn", it turns out that we do and they don't.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
7. It is easier to write an incorrect program than understand a correct one.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
27. Once you understand how to write a program get someone else to write it.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
31. Simplicity does not precede complexity, but follows it.
105. You can't communicate complexity, only an awareness of it.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
3. Syntactic sugar causes cancer of the semicolon.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
3. Syntactic sugar causes cancer of the semicolon.
3. Syntactic sugar causes cancer of the semicolon.
90. Computation has made the tree flower.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
55. A LISP programmer knows the value of everything, but the cost of nothing.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
102. One can't proceed from the informal to the formal by formal means.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
76. It is the user who should parameterize procedures, not their creators.
62. In computing, invariants are ephemeral.
60. In seeking the unattainable, simplicity only gets in the way.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
105. You can't communicate complexity, only an awareness of it.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
104. The proof of a system's value is its existence.
21. Optimization hinders evolution.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
15. Everything should be built top-down, except the first time.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
55. A LISP programmer knows the value of everything, but the cost of nothing.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
60. In seeking the unattainable, simplicity only gets in the way.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
90. Computation has made the tree flower.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
46. Like punning, programming is a play on words.
47. As Will Rogers would have said, "There is no such thing as a free variable."
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
22. A good system can't have a weak command language.
103. Purely applicative languages are poorly applicable.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
8. A programming language is low level when its programs require attention to the irrelevant.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
112. Computer Science is embarrassed by the computer.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
17. If a listener nods his head when you're explaining your program, wake him up.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
60. In seeking the unattainable, simplicity only gets in the way.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
104. The proof of a system's value is its existence.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
3. Syntactic sugar causes cancer of the semicolon.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
55. A LISP programmer knows the value of everything, but the cost of nothing.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
78. If your computer speaks English, it was probably made in Japan.
3. Syntactic sugar causes cancer of the semicolon.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
43. In software systems, it is often the early bird that makes the worm.
95. Don't have good ideas if you aren't willing to be responsible for them.
27. Once you understand how to write a program get someone else to write it.
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
21. Optimization hinders evolution.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
55. A LISP programmer knows the value of everything, but the cost of nothing.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
15. Everything should be built top-down, except the first time.
4. Every program is a part of some other program and rarely fits.
15. Everything should be built top-down, except the first time.
100. We will never run out of things to program as long as there is a single program around.
31. Simplicity does not precede complexity, but follows it.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
92. The computer is the ultimate polluter: its feces are indistinguishable from the food it produces.
102. One can't proceed from the informal to the formal by formal means.
102. One can't proceed from the informal to the formal by formal means.
27. Once you understand how to write a program get someone else to write it.
22. A good system can't have a weak command language.
31. Simplicity does not precede complexity, but follows it.
17. If a listener nods his head when you're explaining your program, wake him up.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
83. What is the difference between a Turing machine and the modern computer?  It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
17. If a listener nods his head when you're explaining your program, wake him up.
79. A year spent in artificial intelligence is enough to make one believe in God.
15. Everything should be built top-down, except the first time.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
78. If your computer speaks English, it was probably made in Japan.
21. Optimization hinders evolution.
15. Everything should be built top-down, except the first time.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
111. Why did the Roman Empire collapse? What is Latin for office automation?
41. Some programming languages manage to absorb change, but withstand progress.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
76. It is the user who should parameterize procedures, not their creators.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
119. Programming is an unnatural act.
40. There are two ways to write error-free programs; only the third one works.
27. Once you understand how to write a program get someone else to write it.
79. A year spent in artificial intelligence is enough to make one believe in God.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
98. In computing, the mean time to failure keeps getting shorter.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
59. In English every word can be verbed. Would that it were so in our programming languages.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
108. Whenever two programmers meet to criticize their programs, both are silent.
38. Structured Programming supports the law of the excluded middle.
3. Syntactic sugar causes cancer of the semicolon.
12. Recursion is the root of computation since it trades description for time.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
60. In seeking the unattainable, simplicity only gets in the way.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
103. Purely applicative languages are poorly applicable.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
118. If you can imagine a society in which the computer-robot is the only menial, you can imagine anything.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
78. If your computer speaks English, it was probably made in Japan.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
86. We kid ourselves if we think that the ratio of procedure to  data  in an active data-base system can be made arbitrarily small or even kept small.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
47. As Will Rogers would have said, "There is no such thing as a free variable."
3. Syntactic sugar causes cancer of the semicolon.
44.Sometimes I think the only universal in the computing field is the fetch-execute cycle.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
96. Computers don't introduce order anywhere as much as they expose opportunities.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
59. In English every word can be verbed. Would that it were so in our programming languages.
110. Editing is a rewording activity.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
46. Like punning, programming is a play on words.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
105. You can't communicate complexity, only an awareness of it.
18. A program without a loop and a structured variable isn't worth writing.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
21. Optimization hinders evolution.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
46. Like punning, programming is a play on words.
72. An adequate bootstrap is a contradiction in terms.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from
98. In computing, the mean time to failure keeps getting shorter.
